<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>nssh.driver.network_driver API documentation</title>
<meta name="description" content="nssh.driver.network_driver" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nssh.driver.network_driver</code></h1>
</header>
<section id="section-intro">
<p>nssh.driver.network_driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;nssh.driver.network_driver&#34;&#34;&#34;
import logging
import re
from dataclasses import dataclass
from io import TextIOWrapper
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

from nssh.driver.driver import NSSH
from nssh.exceptions import CouldNotAcquirePrivLevel, UnknownPrivLevel
from nssh.helper import _textfsm_get_template, get_prompt_pattern, textfsm_parse
from nssh.response import Response
from nssh.transport import (
    MIKO_TRANSPORT_ARGS,
    SSH2_TRANSPORT_ARGS,
    SYSTEM_SSH_TRANSPORT_ARGS,
    MikoTransport,
    SSH2Transport,
    SystemSSHTransport,
    Transport,
)

TRANSPORT_CLASS: Dict[str, Callable[..., Transport]] = {
    &#34;system&#34;: SystemSSHTransport,
    &#34;ssh2&#34;: SSH2Transport,
    &#34;paramiko&#34;: MikoTransport,
}
TRANSPORT_ARGS: Dict[str, Tuple[str, ...]] = {
    &#34;system&#34;: SYSTEM_SSH_TRANSPORT_ARGS,
    &#34;ssh2&#34;: SSH2_TRANSPORT_ARGS,
    &#34;paramiko&#34;: MIKO_TRANSPORT_ARGS,
}


@dataclass
class PrivilegeLevel:
    &#34;&#34;&#34;
    Dataclass representing privilege levels of a device

    PrivilegeLevel contains the following fields:

    pattern:
    name:
    deescalate_priv:
    deescalate:
    escalate_priv:
    escalate:
    escalate_auth:
    escalate_prompt:
    requestable:
    level:

    &#34;&#34;&#34;

    __slots__ = (
        &#34;pattern&#34;,
        &#34;name&#34;,
        &#34;deescalate_priv&#34;,
        &#34;deescalate&#34;,
        &#34;escalate_priv&#34;,
        &#34;escalate&#34;,
        &#34;escalate_auth&#34;,
        &#34;escalate_prompt&#34;,
        &#34;requestable&#34;,
        &#34;level&#34;,
    )
    pattern: str
    name: str
    deescalate_priv: str
    deescalate: str
    escalate_priv: str
    escalate: str
    escalate_auth: bool
    escalate_prompt: str
    requestable: bool
    level: int


PRIVS: Dict[str, PrivilegeLevel] = {}

LOG = logging.getLogger(&#34;nssh_base&#34;)


class NetworkDriver(NSSH):
    def __init__(self, auth_secondary: str = &#34;&#34;, **kwargs: Any):
        &#34;&#34;&#34;
        BaseNetworkDriver Object

        Args:
            auth_secondary: password to use for secondary authentication (enable)
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.auth_secondary = auth_secondary
        self.privs = PRIVS
        self.default_desired_priv: Optional[str] = None
        self.textfsm_platform: str = &#34;&#34;
        self.exit_command: str = &#34;exit&#34;

    def _determine_current_priv(self, current_prompt: str) -&gt; PrivilegeLevel:
        &#34;&#34;&#34;
        Determine current privilege level from prompt string

        Args:
            current_prompt: string of current prompt

        Returns:
            PrivilegeLevel: NamedTuple of current privilege level

        Raises:
            UnknownPrivLevel: if privilege level cannot be determined

        &#34;&#34;&#34;
        for priv_level in self.privs.values():
            prompt_pattern = get_prompt_pattern(&#34;&#34;, priv_level.pattern)
            if re.search(prompt_pattern, current_prompt.encode()):
                return priv_level
        raise UnknownPrivLevel

    def _escalate(self) -&gt; None:
        &#34;&#34;&#34;
        Escalate to the next privilege level up

        Args:
            N/A  # noqa

        Returns:
            N/A  # noqa

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv.escalate:
            next_priv = self.privs.get(current_priv.escalate_priv, None)
            if next_priv is None:
                raise UnknownPrivLevel(
                    f&#34;Could not get next priv level, current priv is {current_priv.name}&#34;
                )
            next_prompt = next_priv.pattern
            if current_priv.escalate_auth:
                escalate_cmd: str = current_priv.escalate
                escalate_prompt: str = current_priv.escalate_prompt
                escalate_auth = self.auth_secondary
                if not isinstance(next_prompt, str):
                    raise TypeError(
                        f&#34;got {type(next_prompt)} for {current_priv.name} escalate priv, &#34;
                        &#34;expected str&#34;
                    )
                self.channel.send_inputs_interact(
                    (escalate_cmd, escalate_prompt, escalate_auth, next_prompt),
                    hidden_response=True,
                )
                self.channel.comms_prompt_pattern = next_priv.pattern
            else:
                self.channel.comms_prompt_pattern = next_priv.pattern
                self.channel.send_inputs(current_priv.escalate)

    def _deescalate(self) -&gt; None:
        &#34;&#34;&#34;
        Deescalate to the next privilege level down

        Args:
            N/A  # noqa

        Returns:
            N/A  # noqa

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv.deescalate:
            next_priv = self.privs.get(current_priv.deescalate_priv, None)
            if not next_priv:
                raise UnknownPrivLevel(
                    &#34;NetworkDriver has no default priv levels, set them or use a network driver&#34;
                )
            self.channel.comms_prompt_pattern = next_priv.pattern
            self.channel.send_inputs(current_priv.deescalate)

    def acquire_priv(self, desired_priv: str) -&gt; None:
        &#34;&#34;&#34;
        Acquire desired priv level

        Args:
            desired_priv: string name of desired privilege level
                (see nssh.driver.&lt;driver_category.device_type&gt;.driver for levels)

        Returns:
            N/A  # noqa

        Raises:
            CouldNotAcquirePrivLevel: if requested priv level not attained

        &#34;&#34;&#34;
        priv_attempt_counter = 0
        while True:
            current_priv = self._determine_current_priv(self.channel.get_prompt())
            if current_priv == self.privs[desired_priv]:
                return
            if priv_attempt_counter &gt; len(self.privs):
                raise CouldNotAcquirePrivLevel(
                    f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
                )
            if current_priv.level &gt; self.privs[desired_priv].level:
                self._deescalate()
            else:
                self._escalate()
            priv_attempt_counter += 1

    def send_commands(
        self, commands: Union[str, List[str]], strip_prompt: bool = True, textfsm: bool = False,
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send command(s)

        Args:
            commands: string or list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            textfsm: True/False try to parse each command with textfsm

        Returns:
            responses: list of NSSH Response objects

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        self.acquire_priv(str(self.default_desired_priv))
        responses = self.channel.send_inputs(commands, strip_prompt)
        if not textfsm:
            return responses
        for response in responses:
            response.structured_result = self.textfsm_parse_output(
                response.channel_input, response.result
            )
        return responses

    def send_interactive(
        self, inputs: Union[List[str], Tuple[str, str, str, str]], hidden_response: bool = False,
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send inputs in an interactive fashion; used to handle prompts

        accepts inputs and looks for expected prompt;
        sends the appropriate response, then waits for the &#34;finale&#34;
        returns the results of the interaction

        could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

        Args:
            inputs: list or tuple containing strings representing:
                initial input
                expectation (what should nssh expect after input)
                channel_response: string what to respond to the &#34;expectation&#34;, or empty string to
                    send return character only
                finale (what should nssh expect when &#34;done&#34;)
            hidden_response: True/False response is hidden (i.e. password input)

        Returns:
            responses: List of NSSH Response objects

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        self.acquire_priv(str(self.default_desired_priv))
        responses = self.channel.send_inputs_interact(inputs, hidden_response)
        return responses

    def send_configs(
        self, configs: Union[str, List[str]], strip_prompt: bool = True
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            configs: string or list of strings to send to device in config mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            responses: List of NSSH Response objects

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        self.acquire_priv(&#34;configuration&#34;)
        responses = self.channel.send_inputs(configs, strip_prompt)
        self.acquire_priv(str(self.default_desired_priv))
        return responses

    def textfsm_parse_output(
        self, command: str, output: str
    ) -&gt; Union[List[Union[List[Any], Dict[str, Any]]], Dict[str, Any]]:
        &#34;&#34;&#34;
        Parse output with TextFSM and ntc-templates

        Always return a non-string value -- if parsing fails to produce list/dict, return empty dict

        Args:
            command: command used to get output
            output: output from command

        Returns:
            output: parsed output

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        template = _textfsm_get_template(self.textfsm_platform, command)
        if isinstance(template, TextIOWrapper):
            structured_output = textfsm_parse(template, output)
            if isinstance(structured_output, (dict, list)):
                return structured_output
        return {}

    def get_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Convenience method to get device prompt from Channel

        Args:
            N/A  # noqa

        Returns:
            prompt: prompt received from channel.get_prompt

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        prompt: str = self.channel.get_prompt()
        return prompt

    def open(self) -&gt; None:
        super().open()
        if self.session_pre_login_handler:
            self.session_pre_login_handler(self)
        # send disable paging if needed
        if self.session_disable_paging:
            if callable(self.session_disable_paging):
                self.session_disable_paging(self)
            else:
                self.channel.send_inputs(self.session_disable_paging)

    def close(self) -&gt; None:
        self.transport.write(f&#34;{self.exit_command}{self.comms_return_char}&#34;)
        super().close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nssh.driver.network_driver.NetworkDriver"><code class="flex name class">
<span>class <span class="ident">NetworkDriver</span></span>
<span>(</span><span>auth_secondary='', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>BaseNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkDriver(NSSH):
    def __init__(self, auth_secondary: str = &#34;&#34;, **kwargs: Any):
        &#34;&#34;&#34;
        BaseNetworkDriver Object

        Args:
            auth_secondary: password to use for secondary authentication (enable)
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.auth_secondary = auth_secondary
        self.privs = PRIVS
        self.default_desired_priv: Optional[str] = None
        self.textfsm_platform: str = &#34;&#34;
        self.exit_command: str = &#34;exit&#34;

    def _determine_current_priv(self, current_prompt: str) -&gt; PrivilegeLevel:
        &#34;&#34;&#34;
        Determine current privilege level from prompt string

        Args:
            current_prompt: string of current prompt

        Returns:
            PrivilegeLevel: NamedTuple of current privilege level

        Raises:
            UnknownPrivLevel: if privilege level cannot be determined

        &#34;&#34;&#34;
        for priv_level in self.privs.values():
            prompt_pattern = get_prompt_pattern(&#34;&#34;, priv_level.pattern)
            if re.search(prompt_pattern, current_prompt.encode()):
                return priv_level
        raise UnknownPrivLevel

    def _escalate(self) -&gt; None:
        &#34;&#34;&#34;
        Escalate to the next privilege level up

        Args:
            N/A  # noqa

        Returns:
            N/A  # noqa

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv.escalate:
            next_priv = self.privs.get(current_priv.escalate_priv, None)
            if next_priv is None:
                raise UnknownPrivLevel(
                    f&#34;Could not get next priv level, current priv is {current_priv.name}&#34;
                )
            next_prompt = next_priv.pattern
            if current_priv.escalate_auth:
                escalate_cmd: str = current_priv.escalate
                escalate_prompt: str = current_priv.escalate_prompt
                escalate_auth = self.auth_secondary
                if not isinstance(next_prompt, str):
                    raise TypeError(
                        f&#34;got {type(next_prompt)} for {current_priv.name} escalate priv, &#34;
                        &#34;expected str&#34;
                    )
                self.channel.send_inputs_interact(
                    (escalate_cmd, escalate_prompt, escalate_auth, next_prompt),
                    hidden_response=True,
                )
                self.channel.comms_prompt_pattern = next_priv.pattern
            else:
                self.channel.comms_prompt_pattern = next_priv.pattern
                self.channel.send_inputs(current_priv.escalate)

    def _deescalate(self) -&gt; None:
        &#34;&#34;&#34;
        Deescalate to the next privilege level down

        Args:
            N/A  # noqa

        Returns:
            N/A  # noqa

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv.deescalate:
            next_priv = self.privs.get(current_priv.deescalate_priv, None)
            if not next_priv:
                raise UnknownPrivLevel(
                    &#34;NetworkDriver has no default priv levels, set them or use a network driver&#34;
                )
            self.channel.comms_prompt_pattern = next_priv.pattern
            self.channel.send_inputs(current_priv.deescalate)

    def acquire_priv(self, desired_priv: str) -&gt; None:
        &#34;&#34;&#34;
        Acquire desired priv level

        Args:
            desired_priv: string name of desired privilege level
                (see nssh.driver.&lt;driver_category.device_type&gt;.driver for levels)

        Returns:
            N/A  # noqa

        Raises:
            CouldNotAcquirePrivLevel: if requested priv level not attained

        &#34;&#34;&#34;
        priv_attempt_counter = 0
        while True:
            current_priv = self._determine_current_priv(self.channel.get_prompt())
            if current_priv == self.privs[desired_priv]:
                return
            if priv_attempt_counter &gt; len(self.privs):
                raise CouldNotAcquirePrivLevel(
                    f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
                )
            if current_priv.level &gt; self.privs[desired_priv].level:
                self._deescalate()
            else:
                self._escalate()
            priv_attempt_counter += 1

    def send_commands(
        self, commands: Union[str, List[str]], strip_prompt: bool = True, textfsm: bool = False,
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send command(s)

        Args:
            commands: string or list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            textfsm: True/False try to parse each command with textfsm

        Returns:
            responses: list of NSSH Response objects

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        self.acquire_priv(str(self.default_desired_priv))
        responses = self.channel.send_inputs(commands, strip_prompt)
        if not textfsm:
            return responses
        for response in responses:
            response.structured_result = self.textfsm_parse_output(
                response.channel_input, response.result
            )
        return responses

    def send_interactive(
        self, inputs: Union[List[str], Tuple[str, str, str, str]], hidden_response: bool = False,
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send inputs in an interactive fashion; used to handle prompts

        accepts inputs and looks for expected prompt;
        sends the appropriate response, then waits for the &#34;finale&#34;
        returns the results of the interaction

        could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

        Args:
            inputs: list or tuple containing strings representing:
                initial input
                expectation (what should nssh expect after input)
                channel_response: string what to respond to the &#34;expectation&#34;, or empty string to
                    send return character only
                finale (what should nssh expect when &#34;done&#34;)
            hidden_response: True/False response is hidden (i.e. password input)

        Returns:
            responses: List of NSSH Response objects

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        self.acquire_priv(str(self.default_desired_priv))
        responses = self.channel.send_inputs_interact(inputs, hidden_response)
        return responses

    def send_configs(
        self, configs: Union[str, List[str]], strip_prompt: bool = True
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            configs: string or list of strings to send to device in config mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            responses: List of NSSH Response objects

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        self.acquire_priv(&#34;configuration&#34;)
        responses = self.channel.send_inputs(configs, strip_prompt)
        self.acquire_priv(str(self.default_desired_priv))
        return responses

    def textfsm_parse_output(
        self, command: str, output: str
    ) -&gt; Union[List[Union[List[Any], Dict[str, Any]]], Dict[str, Any]]:
        &#34;&#34;&#34;
        Parse output with TextFSM and ntc-templates

        Always return a non-string value -- if parsing fails to produce list/dict, return empty dict

        Args:
            command: command used to get output
            output: output from command

        Returns:
            output: parsed output

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        template = _textfsm_get_template(self.textfsm_platform, command)
        if isinstance(template, TextIOWrapper):
            structured_output = textfsm_parse(template, output)
            if isinstance(structured_output, (dict, list)):
                return structured_output
        return {}

    def get_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Convenience method to get device prompt from Channel

        Args:
            N/A  # noqa

        Returns:
            prompt: prompt received from channel.get_prompt

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        prompt: str = self.channel.get_prompt()
        return prompt

    def open(self) -&gt; None:
        super().open()
        if self.session_pre_login_handler:
            self.session_pre_login_handler(self)
        # send disable paging if needed
        if self.session_disable_paging:
            if callable(self.session_disable_paging):
                self.session_disable_paging(self)
            else:
                self.channel.send_inputs(self.session_disable_paging)

    def close(self) -&gt; None:
        self.transport.write(f&#34;{self.exit_command}{self.comms_return_char}&#34;)
        super().close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nssh.driver.driver.NSSH" href="driver.html#nssh.driver.driver.NSSH">NSSH</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nssh.driver.core.arista_eos.driver.EOSDriver" href="core/arista_eos/driver.html#nssh.driver.core.arista_eos.driver.EOSDriver">EOSDriver</a></li>
<li><a title="nssh.driver.core.cisco_iosxe.driver.IOSXEDriver" href="core/cisco_iosxe/driver.html#nssh.driver.core.cisco_iosxe.driver.IOSXEDriver">IOSXEDriver</a></li>
<li><a title="nssh.driver.core.cisco_iosxr.driver.IOSXRDriver" href="core/cisco_iosxr/driver.html#nssh.driver.core.cisco_iosxr.driver.IOSXRDriver">IOSXRDriver</a></li>
<li><a title="nssh.driver.core.cisco_nxos.driver.NXOSDriver" href="core/cisco_nxos/driver.html#nssh.driver.core.cisco_nxos.driver.NXOSDriver">NXOSDriver</a></li>
<li><a title="nssh.driver.core.juniper_junos.driver.JunosDriver" href="core/juniper_junos/driver.html#nssh.driver.core.juniper_junos.driver.JunosDriver">JunosDriver</a></li>
<li><a title="nssh.netmiko_compatability.NetmikoNetworkDriver" href="../netmiko_compatability.html#nssh.netmiko_compatability.NetmikoNetworkDriver">NetmikoNetworkDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="nssh.driver.network_driver.NetworkDriver.acquire_priv"><code class="name flex">
<span>def <span class="ident">acquire_priv</span></span>(<span>self, desired_priv)</span>
</code></dt>
<dd>
<section class="desc"><p>Acquire desired priv level</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>desired_priv</code></strong></dt>
<dd>string name of desired privilege level
(see nssh.driver.<driver_category.device_type>.driver for levels)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>CouldNotAcquirePrivLevel</code></strong></dt>
<dd>if requested priv level not attained</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_priv(self, desired_priv: str) -&gt; None:
    &#34;&#34;&#34;
    Acquire desired priv level

    Args:
        desired_priv: string name of desired privilege level
            (see nssh.driver.&lt;driver_category.device_type&gt;.driver for levels)

    Returns:
        N/A  # noqa

    Raises:
        CouldNotAcquirePrivLevel: if requested priv level not attained

    &#34;&#34;&#34;
    priv_attempt_counter = 0
    while True:
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv == self.privs[desired_priv]:
            return
        if priv_attempt_counter &gt; len(self.privs):
            raise CouldNotAcquirePrivLevel(
                f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
            )
        if current_priv.level &gt; self.privs[desired_priv].level:
            self._deescalate()
        else:
            self._escalate()
        priv_attempt_counter += 1</code></pre>
</details>
</dd>
<dt id="nssh.driver.network_driver.NetworkDriver.get_prompt"><code class="name flex">
<span>def <span class="ident">get_prompt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convenience method to get device prompt from Channel</p>
<h2 id="args">Args</h2>
<p>N/A
# noqa</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>prompt</code></strong></dt>
<dd>prompt received from channel.get_prompt</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prompt(self) -&gt; str:
    &#34;&#34;&#34;
    Convenience method to get device prompt from Channel

    Args:
        N/A  # noqa

    Returns:
        prompt: prompt received from channel.get_prompt

    Raises:
        N/A  # noqa

    &#34;&#34;&#34;
    prompt: str = self.channel.get_prompt()
    return prompt</code></pre>
</details>
</dd>
<dt id="nssh.driver.network_driver.NetworkDriver.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>self, commands, strip_prompt=True, textfsm=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send command(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>string or list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>textfsm</code></strong></dt>
<dd>True/False try to parse each command with textfsm</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>list of NSSH Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(
    self, commands: Union[str, List[str]], strip_prompt: bool = True, textfsm: bool = False,
) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send command(s)

    Args:
        commands: string or list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        textfsm: True/False try to parse each command with textfsm

    Returns:
        responses: list of NSSH Response objects

    Raises:
        N/A  # noqa

    &#34;&#34;&#34;
    self.acquire_priv(str(self.default_desired_priv))
    responses = self.channel.send_inputs(commands, strip_prompt)
    if not textfsm:
        return responses
    for response in responses:
        response.structured_result = self.textfsm_parse_output(
            response.channel_input, response.result
        )
    return responses</code></pre>
</details>
</dd>
<dt id="nssh.driver.network_driver.NetworkDriver.send_configs"><code class="name flex">
<span>def <span class="ident">send_configs</span></span>(<span>self, configs, strip_prompt=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Send configuration(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>configs</code></strong></dt>
<dd>string or list of strings to send to device in config mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>List of NSSH Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_configs(
    self, configs: Union[str, List[str]], strip_prompt: bool = True
) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send configuration(s)

    Args:
        configs: string or list of strings to send to device in config mode
        strip_prompt: True/False strip prompt from returned output

    Returns:
        responses: List of NSSH Response objects

    Raises:
        N/A  # noqa

    &#34;&#34;&#34;
    self.acquire_priv(&#34;configuration&#34;)
    responses = self.channel.send_inputs(configs, strip_prompt)
    self.acquire_priv(str(self.default_desired_priv))
    return responses</code></pre>
</details>
</dd>
<dt id="nssh.driver.network_driver.NetworkDriver.send_interactive"><code class="name flex">
<span>def <span class="ident">send_interactive</span></span>(<span>self, inputs, hidden_response=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send inputs in an interactive fashion; used to handle prompts</p>
<p>accepts inputs and looks for expected prompt;
sends the appropriate response, then waits for the "finale"
returns the results of the interaction</p>
<p>could be "chained" together to respond to more than a "single" staged prompt</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>list or tuple containing strings representing:
initial input
expectation (what should nssh expect after input)
channel_response: string what to respond to the "expectation", or empty string to
send return character only
finale (what should nssh expect when "done")</dd>
<dt><strong><code>hidden_response</code></strong></dt>
<dd>True/False response is hidden (i.e. password input)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>List of NSSH Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_interactive(
    self, inputs: Union[List[str], Tuple[str, str, str, str]], hidden_response: bool = False,
) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send inputs in an interactive fashion; used to handle prompts

    accepts inputs and looks for expected prompt;
    sends the appropriate response, then waits for the &#34;finale&#34;
    returns the results of the interaction

    could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

    Args:
        inputs: list or tuple containing strings representing:
            initial input
            expectation (what should nssh expect after input)
            channel_response: string what to respond to the &#34;expectation&#34;, or empty string to
                send return character only
            finale (what should nssh expect when &#34;done&#34;)
        hidden_response: True/False response is hidden (i.e. password input)

    Returns:
        responses: List of NSSH Response objects

    Raises:
        N/A  # noqa

    &#34;&#34;&#34;
    self.acquire_priv(str(self.default_desired_priv))
    responses = self.channel.send_inputs_interact(inputs, hidden_response)
    return responses</code></pre>
</details>
</dd>
<dt id="nssh.driver.network_driver.NetworkDriver.textfsm_parse_output"><code class="name flex">
<span>def <span class="ident">textfsm_parse_output</span></span>(<span>self, command, output)</span>
</code></dt>
<dd>
<section class="desc"><p>Parse output with TextFSM and ntc-templates</p>
<p>Always return a non-string value &ndash; if parsing fails to produce list/dict, return empty dict</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>command used to get output</dd>
<dt><strong><code>output</code></strong></dt>
<dd>output from command</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong></dt>
<dd>parsed output</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def textfsm_parse_output(
    self, command: str, output: str
) -&gt; Union[List[Union[List[Any], Dict[str, Any]]], Dict[str, Any]]:
    &#34;&#34;&#34;
    Parse output with TextFSM and ntc-templates

    Always return a non-string value -- if parsing fails to produce list/dict, return empty dict

    Args:
        command: command used to get output
        output: output from command

    Returns:
        output: parsed output

    Raises:
        N/A  # noqa

    &#34;&#34;&#34;
    template = _textfsm_get_template(self.textfsm_platform, command)
    if isinstance(template, TextIOWrapper):
        structured_output = textfsm_parse(template, output)
        if isinstance(structured_output, (dict, list)):
            return structured_output
    return {}</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nssh.driver.driver.NSSH" href="driver.html#nssh.driver.driver.NSSH">NSSH</a></b></code>:
<ul class="hlist">
<li><code><a title="nssh.driver.driver.NSSH.close" href="driver.html#nssh.driver.driver.NSSH.close">close</a></code></li>
<li><code><a title="nssh.driver.driver.NSSH.isalive" href="driver.html#nssh.driver.driver.NSSH.isalive">isalive</a></code></li>
<li><code><a title="nssh.driver.driver.NSSH.open" href="driver.html#nssh.driver.driver.NSSH.open">open</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel"><code class="flex name class">
<span>class <span class="ident">PrivilegeLevel</span></span>
<span>(</span><span>pattern, name, deescalate_priv, deescalate, escalate_priv, escalate, escalate_auth, escalate_prompt, requestable, level)</span>
</code></dt>
<dd>
<section class="desc"><p>Dataclass representing privilege levels of a device</p>
<p>PrivilegeLevel contains the following fields:</p>
<p>pattern:
name:
deescalate_priv:
deescalate:
escalate_priv:
escalate:
escalate_auth:
escalate_prompt:
requestable:
level:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrivilegeLevel:
    &#34;&#34;&#34;
    Dataclass representing privilege levels of a device

    PrivilegeLevel contains the following fields:

    pattern:
    name:
    deescalate_priv:
    deescalate:
    escalate_priv:
    escalate:
    escalate_auth:
    escalate_prompt:
    requestable:
    level:

    &#34;&#34;&#34;

    __slots__ = (
        &#34;pattern&#34;,
        &#34;name&#34;,
        &#34;deescalate_priv&#34;,
        &#34;deescalate&#34;,
        &#34;escalate_priv&#34;,
        &#34;escalate&#34;,
        &#34;escalate_auth&#34;,
        &#34;escalate_prompt&#34;,
        &#34;requestable&#34;,
        &#34;level&#34;,
    )
    pattern: str
    name: str
    deescalate_priv: str
    deescalate: str
    escalate_priv: str
    escalate: str
    escalate_auth: bool
    escalate_prompt: str
    requestable: bool
    level: int</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="nssh.driver.network_driver.PrivilegeLevel.deescalate"><code class="name">var <span class="ident">deescalate</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.deescalate_priv"><code class="name">var <span class="ident">deescalate_priv</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.escalate"><code class="name">var <span class="ident">escalate</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.escalate_auth"><code class="name">var <span class="ident">escalate_auth</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.escalate_priv"><code class="name">var <span class="ident">escalate_priv</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.escalate_prompt"><code class="name">var <span class="ident">escalate_prompt</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.pattern"><code class="name">var <span class="ident">pattern</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="nssh.driver.network_driver.PrivilegeLevel.requestable"><code class="name">var <span class="ident">requestable</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nssh.driver" href="index.html">nssh.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nssh.driver.network_driver.NetworkDriver" href="#nssh.driver.network_driver.NetworkDriver">NetworkDriver</a></code></h4>
<ul class="">
<li><code><a title="nssh.driver.network_driver.NetworkDriver.acquire_priv" href="#nssh.driver.network_driver.NetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="nssh.driver.network_driver.NetworkDriver.get_prompt" href="#nssh.driver.network_driver.NetworkDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="nssh.driver.network_driver.NetworkDriver.send_commands" href="#nssh.driver.network_driver.NetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="nssh.driver.network_driver.NetworkDriver.send_configs" href="#nssh.driver.network_driver.NetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="nssh.driver.network_driver.NetworkDriver.send_interactive" href="#nssh.driver.network_driver.NetworkDriver.send_interactive">send_interactive</a></code></li>
<li><code><a title="nssh.driver.network_driver.NetworkDriver.textfsm_parse_output" href="#nssh.driver.network_driver.NetworkDriver.textfsm_parse_output">textfsm_parse_output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nssh.driver.network_driver.PrivilegeLevel" href="#nssh.driver.network_driver.PrivilegeLevel">PrivilegeLevel</a></code></h4>
<ul class="two-column">
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.deescalate" href="#nssh.driver.network_driver.PrivilegeLevel.deescalate">deescalate</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.deescalate_priv" href="#nssh.driver.network_driver.PrivilegeLevel.deescalate_priv">deescalate_priv</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.escalate" href="#nssh.driver.network_driver.PrivilegeLevel.escalate">escalate</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.escalate_auth" href="#nssh.driver.network_driver.PrivilegeLevel.escalate_auth">escalate_auth</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.escalate_priv" href="#nssh.driver.network_driver.PrivilegeLevel.escalate_priv">escalate_priv</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.escalate_prompt" href="#nssh.driver.network_driver.PrivilegeLevel.escalate_prompt">escalate_prompt</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.level" href="#nssh.driver.network_driver.PrivilegeLevel.level">level</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.name" href="#nssh.driver.network_driver.PrivilegeLevel.name">name</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.pattern" href="#nssh.driver.network_driver.PrivilegeLevel.pattern">pattern</a></code></li>
<li><code><a title="nssh.driver.network_driver.PrivilegeLevel.requestable" href="#nssh.driver.network_driver.PrivilegeLevel.requestable">requestable</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>