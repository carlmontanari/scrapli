<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>scrapli.driver API documentation</title>
<meta name="description" content="scrapli.driver" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli.driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.driver&#34;&#34;&#34;
from scrapli.driver.driver import Scrape
from scrapli.driver.generic_driver import GenericDriver
from scrapli.driver.network_driver import NetworkDriver

__all__ = (&#34;Scrape&#34;, &#34;GenericDriver&#34;, &#34;NetworkDriver&#34;)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli.driver.community" href="community/index.html">scrapli.driver.community</a></code></dt>
<dd>
<section class="desc"><p>scrapli.driver.community</p></section>
</dd>
<dt><code class="name"><a title="scrapli.driver.core" href="core/index.html">scrapli.driver.core</a></code></dt>
<dd>
<section class="desc"><p>scrapli.driver.core</p></section>
</dd>
<dt><code class="name"><a title="scrapli.driver.driver" href="driver.html">scrapli.driver.driver</a></code></dt>
<dd>
<section class="desc"><p>scrapli.driver.driver</p></section>
</dd>
<dt><code class="name"><a title="scrapli.driver.generic_driver" href="generic_driver.html">scrapli.driver.generic_driver</a></code></dt>
<dd>
<section class="desc"><p>scrapli.driver.generic_driver</p></section>
</dd>
<dt><code class="name"><a title="scrapli.driver.network_driver" href="network_driver.html">scrapli.driver.network_driver</a></code></dt>
<dd>
<section class="desc"><p>scrapli.driver.network_driver</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.driver.GenericDriver"><code class="flex name class">
<span>class <span class="ident">GenericDriver</span></span>
<span>(</span><span>comms_prompt_pattern=&#x27;^\\S{0,32}[#&gt;$~@:\\]]\\s*$&#x27;, comms_ansi=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>GenericDriver Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <a title="scrapli.driver.Scrape" href="#scrapli.driver.Scrape"><code>Scrape</code></a> object from that perspective.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
For this GenericDriver the prompt pattern matches a really wide range of things&hellip;
the general pattern is start of line, match any character 0-32 times, then match a
prompt termination character from the following character set: <code>#</code>, <code>&gt;</code>, <code>$</code>, <code>~</code>,
<code>@</code>, <code>:</code>, <code>]</code>, finally match any or no whitespace till the end of the line. This
pattern works on all of the "core" platforms and should work on a wide range of
other devices, however because it is so broad it may also accidentally match too
many things and cause issues, so be careful!</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; in the case of the
GenericDriver, always strip ansi; this may slow things down but will hopefully help
prevent issues! Obviously can be overridden if desired.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericDriver(Scrape):
    def __init__(
        self,
        comms_prompt_pattern: str = r&#34;^\S{0,32}[#&gt;$~@:\]]\s*$&#34;,
        comms_ansi: bool = True,
        **kwargs: Any,
    ):
        &#34;&#34;&#34;
        GenericDriver Object

        A generic network driver that will *hopefully* work for a broad variety of devices with
        minimal to no modifications and provide a normal NetworkDriver type experience with
        `send_command(s)`, `get_prompt` and `send_interactive` methods instead of forcing users to
        call Channel methods directly.

        This driver doesn&#39;t know anything about privilege levels (or any type of &#34;config modes&#34;,
        disabling paging, gracefully exiting, or anything like that, and as such should be treated
        similar to the base `Scrape` object from that perspective.

        Args:
            comms_prompt_pattern: raw string regex pattern -- preferably use `^` and `$` anchors!
                this is the single most important attribute here! if this does not match a prompt,
                scrapli will not work!
                For this GenericDriver the prompt pattern matches a really wide range of things...
                the general pattern is start of line, match any character 0-32 times, then match a
                prompt termination character from the following character set: `#`, `&gt;`, `$`, `~`,
                `@`, `:`, `]`, finally match any or no whitespace till the end of the line. This
                pattern works on all of the &#34;core&#34; platforms and should work on a wide range of
                other devices, however because it is so broad it may also accidentally match too
                many things and cause issues, so be careful!
            comms_ansi: True/False strip comms_ansi characters from output; in the case of the
                GenericDriver, always strip ansi; this may slow things down but will hopefully help
                prevent issues! Obviously can be overridden if desired.
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A
        &#34;&#34;&#34;
        super().__init__(comms_prompt_pattern=comms_prompt_pattern, comms_ansi=comms_ansi, **kwargs)

    def send_command(
        self,
        command: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            TypeError: if command is anything but a string

        &#34;&#34;&#34;
        if not isinstance(command, str):
            raise TypeError(
                f&#34;`send_command` expects a single string, got {type(command)}. &#34;
                &#34;to send a list of commands use the `send_commands` method instead.&#34;
            )

        response = Response(
            self.transport.host, channel_input=command, failed_when_contains=failed_when_contains
        )
        raw_response, processed_response = self.channel.send_input(command, strip_prompt)
        response.record_response(processed_response)
        response.raw_result = raw_response

        return response

    def send_commands(
        self,
        commands: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send multiple commands

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            responses: list of Scrapli Response objects

        Raises:
            TypeError: if commands is anything but a list

        &#34;&#34;&#34;
        if not isinstance(commands, list):
            raise TypeError(
                f&#34;`send_commands` expects a list of strings, got {type(commands)}. &#34;
                &#34;to send a single command use the `send_command` method instead.&#34;
            )

        responses = []
        for command in commands:
            responses.append(
                self.send_command(
                    command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
                )
            )

        return responses

    def send_interactive(self, interact: List[str], hidden_response: bool = False) -&gt; Response:
        &#34;&#34;&#34;
        Send inputs in an interactive fashion; used to handle prompts

        accepts inputs and looks for expected prompt;
        sends the appropriate response, then waits for the &#34;finale&#34;
        returns the results of the interaction

        could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

        Args:
            interact: list of four string elements representing...
                channel_input - initial input to send
                expected_prompt - prompt to expect after initial input
                response - response to prompt
                final_prompt - final prompt to expect
            hidden_response: True/False response is hidden (i.e. password input)

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self.channel.send_inputs_interact(interact, hidden_response)
        return response

    def get_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Convenience method to get device prompt from Channel

        Args:
            N/A

        Returns:
            str: prompt received from channel.get_prompt

        Raises:
            N/A

        &#34;&#34;&#34;
        prompt: str = self.channel.get_prompt()
        return prompt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.network_driver.NetworkDriver" href="network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.GenericDriver.get_prompt"><code class="name flex">
<span>def <span class="ident">get_prompt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convenience method to get device prompt from Channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>prompt received from channel.get_prompt</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prompt(self) -&gt; str:
    &#34;&#34;&#34;
    Convenience method to get device prompt from Channel

    Args:
        N/A

    Returns:
        str: prompt received from channel.get_prompt

    Raises:
        N/A

    &#34;&#34;&#34;
    prompt: str = self.channel.get_prompt()
    return prompt</code></pre>
</details>
</dd>
<dt id="scrapli.driver.GenericDriver.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command, strip_prompt=True, failed_when_contains=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a command</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Response</code></strong></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>if command is anything but a string</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(
    self,
    command: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; Response:
    &#34;&#34;&#34;
    Send a command

    Args:
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        Response: Scrapli Response object

    Raises:
        TypeError: if command is anything but a string

    &#34;&#34;&#34;
    if not isinstance(command, str):
        raise TypeError(
            f&#34;`send_command` expects a single string, got {type(command)}. &#34;
            &#34;to send a list of commands use the `send_commands` method instead.&#34;
        )

    response = Response(
        self.transport.host, channel_input=command, failed_when_contains=failed_when_contains
    )
    raw_response, processed_response = self.channel.send_input(command, strip_prompt)
    response.record_response(processed_response)
    response.raw_result = raw_response

    return response</code></pre>
</details>
</dd>
<dt id="scrapli.driver.GenericDriver.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>self, commands, strip_prompt=True, failed_when_contains=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Send multiple commands</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>list of Scrapli Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>if commands is anything but a list</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(
    self,
    commands: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send multiple commands

    Args:
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        responses: list of Scrapli Response objects

    Raises:
        TypeError: if commands is anything but a list

    &#34;&#34;&#34;
    if not isinstance(commands, list):
        raise TypeError(
            f&#34;`send_commands` expects a list of strings, got {type(commands)}. &#34;
            &#34;to send a single command use the `send_command` method instead.&#34;
        )

    responses = []
    for command in commands:
        responses.append(
            self.send_command(
                command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
            )
        )

    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.GenericDriver.send_interactive"><code class="name flex">
<span>def <span class="ident">send_interactive</span></span>(<span>self, interact, hidden_response=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send inputs in an interactive fashion; used to handle prompts</p>
<p>accepts inputs and looks for expected prompt;
sends the appropriate response, then waits for the "finale"
returns the results of the interaction</p>
<p>could be "chained" together to respond to more than a "single" staged prompt</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interact</code></strong></dt>
<dd>list of four string elements representing&hellip;
channel_input - initial input to send
expected_prompt - prompt to expect after initial input
response - response to prompt
final_prompt - final prompt to expect</dd>
<dt><strong><code>hidden_response</code></strong></dt>
<dd>True/False response is hidden (i.e. password input)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Response</code></strong></dt>
<dd>scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_interactive(self, interact: List[str], hidden_response: bool = False) -&gt; Response:
    &#34;&#34;&#34;
    Send inputs in an interactive fashion; used to handle prompts

    accepts inputs and looks for expected prompt;
    sends the appropriate response, then waits for the &#34;finale&#34;
    returns the results of the interaction

    could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

    Args:
        interact: list of four string elements representing...
            channel_input - initial input to send
            expected_prompt - prompt to expect after initial input
            response - response to prompt
            final_prompt - final prompt to expect
        hidden_response: True/False response is hidden (i.e. password input)

    Returns:
        Response: scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self.channel.send_inputs_interact(interact, hidden_response)
    return response</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.driver.Scrape.close" href="driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.driver.Scrape.isalive" href="driver.html#scrapli.driver.driver.Scrape.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.driver.Scrape.open" href="driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.NetworkDriver"><code class="flex name class">
<span>class <span class="ident">NetworkDriver</span></span>
<span>(</span><span>auth_secondary='', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>BaseNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkDriver(GenericDriver, ABC):
    @abstractmethod
    def __init__(
        self, auth_secondary: str = &#34;&#34;, **kwargs: Any,
    ):
        &#34;&#34;&#34;
        BaseNetworkDriver Object

        Args:
            auth_secondary: password to use for secondary authentication (enable)
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(**kwargs)

        self.auth_secondary = auth_secondary
        self.privs = PRIVS
        self.default_desired_priv: str = &#34;&#34;
        self._current_priv_level = NoPrivLevel

        self.textfsm_platform: str = &#34;&#34;
        self.genie_platform: str = &#34;&#34;
        self.failed_when_contains: List[str] = []

    def _determine_current_priv(self, current_prompt: str) -&gt; PrivilegeLevel:
        &#34;&#34;&#34;
        Determine current privilege level from prompt string

        Args:
            current_prompt: string of current prompt

        Returns:
            PrivilegeLevel: NamedTuple of current privilege level

        Raises:
            UnknownPrivLevel: if privilege level cannot be determined

        &#34;&#34;&#34;
        for priv_level in self.privs.values():
            prompt_pattern = get_prompt_pattern(&#34;&#34;, priv_level.pattern)
            if re.search(prompt_pattern, current_prompt.encode()):
                return priv_level
        raise UnknownPrivLevel

    def _escalate(self) -&gt; None:
        &#34;&#34;&#34;
        Escalate to the next privilege level up

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            UnknownPrivLevel: if priv level cant be attained
            TypeError: if invalid next prompt value

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if not current_priv.escalate:
            return

        next_priv = self.privs.get(current_priv.escalate_priv, None)
        if next_priv is None:
            raise UnknownPrivLevel(
                f&#34;Could not get next priv level, current priv is {current_priv.name}&#34;
            )
        next_prompt = next_priv.pattern
        if current_priv.escalate_auth:
            if not self.auth_secondary:
                err = (
                    &#34;Privilege escalation generally requires an `auth_secondary` password, &#34;
                    &#34;but none is set!&#34;
                )
                msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
                fix = (
                    &#34;scrapli will try to escalate privilege without entering a password but may &#34;
                    &#34;fail.\nSet an `auth_secondary` password if your device requires a password to &#34;
                    &#34;increase privilege, otherwise ignore this message.&#34;
                )
                warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
                warnings.warn(warning)
            else:
                escalate_cmd: str = current_priv.escalate
                escalate_prompt: str = current_priv.escalate_prompt
                escalate_auth = self.auth_secondary
                if not isinstance(next_prompt, str):
                    raise TypeError(
                        f&#34;got {type(next_prompt)} for {current_priv.name} escalate priv, &#34;
                        &#34;expected str&#34;
                    )
                self.channel.send_inputs_interact(
                    [escalate_cmd, escalate_prompt, escalate_auth, next_prompt],
                    hidden_response=True,
                )
                self.channel.comms_prompt_pattern = next_priv.pattern
                return
        self.channel.comms_prompt_pattern = next_priv.pattern
        self.channel.send_input(current_priv.escalate)

    def _deescalate(self) -&gt; None:
        &#34;&#34;&#34;
        Deescalate to the next privilege level down

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            UnknownPrivLevel: if no default priv level set to deescalate to

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv.deescalate:
            next_priv = self.privs.get(current_priv.deescalate_priv, None)
            if not next_priv:
                raise UnknownPrivLevel(
                    &#34;NetworkDriver has no default priv levels, set them or use a network driver&#34;
                )
            self.channel.comms_prompt_pattern = next_priv.pattern
            self.channel.send_input(current_priv.deescalate)

    def acquire_priv(self, desired_priv: str) -&gt; None:
        &#34;&#34;&#34;
        Acquire desired priv level

        Args:
            desired_priv: string name of desired privilege level
                (see scrapli.driver.&lt;driver_category.device_type&gt;.driver for levels)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            CouldNotAcquirePrivLevel: if requested priv level not attained

        &#34;&#34;&#34;
        priv_attempt_counter = 0
        while True:
            current_priv = self._determine_current_priv(self.channel.get_prompt())
            if current_priv == self.privs[desired_priv]:
                self._current_priv_level = current_priv
                return
            if priv_attempt_counter &gt; len(self.privs):
                raise CouldNotAcquirePrivLevel(
                    f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
                )
            if current_priv.level &gt; self.privs[desired_priv].level:
                self._deescalate()
            else:
                self._escalate()
            priv_attempt_counter += 1

    def _update_response(self, response: Response) -&gt; None:
        &#34;&#34;&#34;
        Update response with network driver specific data

        This happens here as the underlying channel provides a response object but is unaware of any
        of the network/platform specific attributes that may need to get updated

        Args:
            response: response to update

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        response.textfsm_platform = self.textfsm_platform
        response.genie_platform = self.genie_platform

    def send_command(
        self,
        command: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Super method will raise TypeError if anything but a string is passed here!

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        response = super().send_command(
            command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
        )

        self._update_response(response)

        return response

    def send_commands(
        self,
        commands: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send multiple commands

        Super method will raise TypeError if anything but a list of strings is passed here!

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            responses: list of Scrapli Response objects

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        responses = super().send_commands(
            commands, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
        )

        for response in responses:
            self._update_response(response)

        return responses

    def send_interactive(self, interact: List[str], hidden_response: bool = False) -&gt; Response:
        &#34;&#34;&#34;
        Send inputs in an interactive fashion; used to handle prompts

        accepts inputs and looks for expected prompt;
        sends the appropriate response, then waits for the &#34;finale&#34;
        returns the results of the interaction

        could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

        Args:
            interact: list of four string elements representing...
                channel_input - initial input to send
                expected_prompt - prompt to expect after initial input
                response - response to prompt
                final_prompt - final prompt to expect
            hidden_response: True/False response is hidden (i.e. password input)

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)
        response = self.channel.send_inputs_interact(interact, hidden_response)
        return response

    def send_configs(
        self,
        configs: Union[str, List[str]],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            configs: string or list of strings to send to device in config mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            responses: List of Scrape Response objects

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(configs, str):
            configs = [configs]

        self.acquire_priv(&#34;configuration&#34;)

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        responses = []
        for config in configs:
            responses.append(
                super().send_command(
                    config, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
                )
            )

        for response in responses:
            self._update_response(response)

        self.acquire_priv(self.default_desired_priv)
        return responses</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
<li><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.core.arista_eos.driver.EOSDriver" href="core/arista_eos/driver.html#scrapli.driver.core.arista_eos.driver.EOSDriver">EOSDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxe.driver.IOSXEDriver" href="core/cisco_iosxe/driver.html#scrapli.driver.core.cisco_iosxe.driver.IOSXEDriver">IOSXEDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxr.driver.IOSXRDriver" href="core/cisco_iosxr/driver.html#scrapli.driver.core.cisco_iosxr.driver.IOSXRDriver">IOSXRDriver</a></li>
<li><a title="scrapli.driver.core.cisco_nxos.driver.NXOSDriver" href="core/cisco_nxos/driver.html#scrapli.driver.core.cisco_nxos.driver.NXOSDriver">NXOSDriver</a></li>
<li><a title="scrapli.driver.core.juniper_junos.driver.JunosDriver" href="core/juniper_junos/driver.html#scrapli.driver.core.juniper_junos.driver.JunosDriver">JunosDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.NetworkDriver.acquire_priv"><code class="name flex">
<span>def <span class="ident">acquire_priv</span></span>(<span>self, desired_priv)</span>
</code></dt>
<dd>
<section class="desc"><p>Acquire desired priv level</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>desired_priv</code></strong></dt>
<dd>string name of desired privilege level
(see scrapli.driver.<driver_category.device_type>.driver for levels)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>CouldNotAcquirePrivLevel</code></strong></dt>
<dd>if requested priv level not attained</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_priv(self, desired_priv: str) -&gt; None:
    &#34;&#34;&#34;
    Acquire desired priv level

    Args:
        desired_priv: string name of desired privilege level
            (see scrapli.driver.&lt;driver_category.device_type&gt;.driver for levels)

    Returns:
        N/A  # noqa: DAR202

    Raises:
        CouldNotAcquirePrivLevel: if requested priv level not attained

    &#34;&#34;&#34;
    priv_attempt_counter = 0
    while True:
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv == self.privs[desired_priv]:
            self._current_priv_level = current_priv
            return
        if priv_attempt_counter &gt; len(self.privs):
            raise CouldNotAcquirePrivLevel(
                f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
            )
        if current_priv.level &gt; self.privs[desired_priv].level:
            self._deescalate()
        else:
            self._escalate()
        priv_attempt_counter += 1</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command, strip_prompt=True, failed_when_contains=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a command</p>
<p>Super method will raise TypeError if anything but a string is passed here!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Response</code></strong></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(
    self,
    command: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; Response:
    &#34;&#34;&#34;
    Send a command

    Super method will raise TypeError if anything but a string is passed here!

    Args:
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        Response: Scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._current_priv_level.name != self.default_desired_priv:
        self.acquire_priv(self.default_desired_priv)

    if failed_when_contains is None:
        failed_when_contains = self.failed_when_contains

    response = super().send_command(
        command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
    )

    self._update_response(response)

    return response</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>self, commands, strip_prompt=True, failed_when_contains=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Send multiple commands</p>
<p>Super method will raise TypeError if anything but a list of strings is passed here!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>list of Scrapli Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(
    self,
    commands: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send multiple commands

    Super method will raise TypeError if anything but a list of strings is passed here!

    Args:
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        responses: list of Scrapli Response objects

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._current_priv_level.name != self.default_desired_priv:
        self.acquire_priv(self.default_desired_priv)

    if failed_when_contains is None:
        failed_when_contains = self.failed_when_contains

    responses = super().send_commands(
        commands, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
    )

    for response in responses:
        self._update_response(response)

    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_configs"><code class="name flex">
<span>def <span class="ident">send_configs</span></span>(<span>self, configs, strip_prompt=True, failed_when_contains=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Send configuration(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>configs</code></strong></dt>
<dd>string or list of strings to send to device in config mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>List of Scrape Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_configs(
    self,
    configs: Union[str, List[str]],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send configuration(s)

    Args:
        configs: string or list of strings to send to device in config mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        responses: List of Scrape Response objects

    Raises:
        N/A

    &#34;&#34;&#34;
    if isinstance(configs, str):
        configs = [configs]

    self.acquire_priv(&#34;configuration&#34;)

    if failed_when_contains is None:
        failed_when_contains = self.failed_when_contains

    responses = []
    for config in configs:
        responses.append(
            super().send_command(
                config, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
            )
        )

    for response in responses:
        self._update_response(response)

    self.acquire_priv(self.default_desired_priv)
    return responses</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.generic_driver.GenericDriver" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.close" href="driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.get_prompt" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.isalive" href="driver.html#scrapli.driver.driver.Scrape.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.open" href="driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.send_interactive" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver.send_interactive">send_interactive</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.Scrape"><code class="flex name class">
<span>class <span class="ident">Scrape</span></span>
<span>(</span><span>host='', port=22, auth_username='', auth_password='', auth_private_key='', auth_strict_key=True, timeout_socket=5, timeout_transport=5, timeout_ops=10, timeout_exit=True, keepalive=False, keepalive_interval=30, keepalive_type='network', keepalive_pattern='\x05', comms_prompt_pattern=&#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]\\s*$&#x27;, comms_return_char='\n', comms_ansi=False, ssh_config_file=False, ssh_known_hosts_file=False, on_open=None, on_close=None, transport='system')</span>
</code></dt>
<dd>
<section class="desc"><p>Scrape Object</p>
<p>Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
that it doesn't know or care about privilege levels, platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_private_key</code></strong></dt>
<dd>path to private key for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>strict host checking or not &ndash; applicable for system ssh driver only</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for ssh channel operations</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' attempts to use whatever 'standard'
keepalive mechanisms are available in the selected transport mechanism. Check the
transport documentation for details on what is supported and/or how it is
implemented for any given transport driver</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows
for highly reliably matching for prompts however we do NOT strip trailing whitespace
for each line, so be sure to add '\s?' or similar if your device needs that. This
should be mostly sorted for you if using network drivers (i.e. <code>IOSXEDriver</code>).
Lastly, the case insensitive is just a convenience factor so i can be lazy.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>character to use to send returns to host</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file, True to use default ssh config file
or False to ignore default ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file, True to use default known
file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</dd>
<dt><strong><code>on_open</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately after authentication is completed. Common use
cases for this callable would be to disable paging or accept any kind of banner
message that prompts a user upon connection</dd>
<dt><strong><code>on_close</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately prior to closing the underlying transport.
Common use cases for this callable would be to save configurations prior to exiting,
or to logout properly to free up vtys or similar.</dd>
<dt><strong><code>transport</code></strong></dt>
<dd>system|ssh2|paramiko|telnet &ndash; type of transport to use for connection
system uses system available ssh (/usr/bin/ssh)
ssh2 uses ssh2-python
paramiko uses&hellip; paramiko
telnet uses telnetlib
choice of driver depends on the features you need. in general system is easiest as
it will just 'auto-magically' use your ssh config file ('~/.ssh/config' or
'/etc/ssh/config_file'). ssh2 is very very fast as it is a thin wrapper around
libssh2 however it is slightly feature limited. paramiko is slower than ssh2, but
has more features built in (though scrapli does not expose/support them all).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>if transport value is invalid</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scrape:
    def __init__(
        self,
        host: str = &#34;&#34;,
        port: int = 22,
        auth_username: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_private_key: str = &#34;&#34;,
        auth_strict_key: bool = True,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_ops: int = 10,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;network&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]\s*$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
        ssh_config_file: Union[str, bool] = False,
        ssh_known_hosts_file: Union[str, bool] = False,
        on_open: Optional[Callable[..., Any]] = None,
        on_close: Optional[Callable[..., Any]] = None,
        transport: str = &#34;system&#34;,
    ):
        &#34;&#34;&#34;
        Scrape Object

        Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
        IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
        that it doesn&#39;t know or care about privilege levels, platform types, and things like that.

        *Note* most arguments passed to Scrape do not actually get assigned to the scrape object
        itself, but instead are used to construct the Transport and Channel classes that Scrape
        relies on, see Transport and Channel docs for details.

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_private_key: path to private key for authentication
            auth_password: password for authentication
            auth_strict_key: strict host checking or not -- applicable for system ssh driver only
            timeout_socket: timeout for establishing socket in seconds
            timeout_transport: timeout for ssh|telnet transport in seconds
            timeout_ops: timeout for ssh channel operations
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; attempts to use whatever &#39;standard&#39;
                keepalive mechanisms are available in the selected transport mechanism. Check the
                transport documentation for details on what is supported and/or how it is
                implemented for any given transport driver
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            comms_prompt_pattern: raw string regex pattern -- preferably use `^` and `$` anchors!
                this is the single most important attribute here! if this does not match a prompt,
                scrapli will not work!
                IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows
                for highly reliably matching for prompts however we do NOT strip trailing whitespace
                for each line, so be sure to add &#39;\\s?&#39; or similar if your device needs that. This
                should be mostly sorted for you if using network drivers (i.e. `IOSXEDriver`).
                Lastly, the case insensitive is just a convenience factor so i can be lazy.
            comms_return_char: character to use to send returns to host
            comms_ansi: True/False strip comms_ansi characters from output
            ssh_config_file: string to path for ssh config file, True to use default ssh config file
                or False to ignore default ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known
                file locations. Only applicable/needed if `auth_strict_key` is set to True
            on_open: callable that accepts the class instance as its only argument. this callable,
                if provided, is executed immediately after authentication is completed. Common use
                cases for this callable would be to disable paging or accept any kind of banner
                message that prompts a user upon connection
            on_close: callable that accepts the class instance as its only argument. this callable,
                if provided, is executed immediately prior to closing the underlying transport.
                Common use cases for this callable would be to save configurations prior to exiting,
                or to logout properly to free up vtys or similar.
            transport: system|ssh2|paramiko|telnet -- type of transport to use for connection
                system uses system available ssh (/usr/bin/ssh)
                ssh2 uses ssh2-python
                paramiko uses... paramiko
                telnet uses telnetlib
                choice of driver depends on the features you need. in general system is easiest as
                it will just &#39;auto-magically&#39; use your ssh config file (&#39;~/.ssh/config&#39; or
                &#39;/etc/ssh/config_file&#39;). ssh2 is very very fast as it is a thin wrapper around
                libssh2 however it is slightly feature limited. paramiko is slower than ssh2, but
                has more features built in (though scrapli does not expose/support them all).

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if transport value is invalid

        &#34;&#34;&#34;
        # create a dict of all &#34;initialization&#34; args for posterity and for passing to Transport
        # and Channel objects
        self._initialization_args: Dict[str, Any] = {}

        self._setup_host(host, port)
        self._setup_auth(auth_username, auth_password, auth_private_key, auth_strict_key)
        self._setup_timeouts(timeout_socket, timeout_transport, timeout_ops, timeout_exit)
        self._setup_keepalive(keepalive, keepalive_type, keepalive_interval, keepalive_pattern)
        self._setup_comms(comms_prompt_pattern, comms_return_char, comms_ansi)
        self._setup_callables(on_open, on_close)

        if transport not in (&#34;ssh2&#34;, &#34;paramiko&#34;, &#34;system&#34;, &#34;telnet&#34;):
            raise ValueError(
                f&#34;`transport` should be one of ssh2|paramiko|system|telnet, got `{transport}`&#34;
            )
        self._transport = transport

        if transport != &#34;telnet&#34;:
            self._setup_ssh_args(ssh_config_file, ssh_known_hosts_file)

        self.transport_class, self.transport_args = self._transport_factory(transport)
        self.transport = self.transport_class(**self.transport_args)

        self.channel_args: Dict[str, Any] = {}
        for arg in CHANNEL_ARGS:
            if arg == &#34;transport&#34;:
                continue
            self.channel_args[arg] = self._initialization_args.get(arg)
        self.channel = Channel(self.transport, **self.channel_args)

    def __enter__(self) -&gt; &#34;Scrape&#34;:
        &#34;&#34;&#34;
        Enter method for context manager

        Args:
            N/A

        Returns:
            self: instance of self

        Raises:
            N/A

        &#34;&#34;&#34;
        self.open()
        return self

    def __exit__(
        self,
        exception_type: Optional[Type[BaseException]],
        exception_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        &#34;&#34;&#34;
        Exit method to cleanup for context manager

        Args:
            exception_type: exception type being raised
            exception_value: message from exception being raised
            traceback: traceback from exception being raised

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.close()

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Magic str method for Scrape

        Args:
            N/A

        Returns:
            str: str representation of object

        Raises:
            N/A

        &#34;&#34;&#34;
        return f&#34;Scrape Object for host {self._host}&#34;

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Magic repr method for Scrape

        Args:
            N/A

        Returns:
            str: repr for class object

        Raises:
            N/A

        &#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}(&#34;
            f&#34;host={self._initialization_args[&#39;host&#39;]!r}, &#34;
            f&#34;port={self._initialization_args[&#39;port&#39;]!r}, &#34;
            f&#34;auth_username={self._initialization_args[&#39;auth_username&#39;]!r}, &#34;
            f&#34;auth_password={self._initialization_args[&#39;auth_password&#39;]!r}, &#34;
            f&#34;auth_private_key={self._initialization_args[&#39;auth_private_key&#39;]!r}, &#34;
            f&#34;auth_strict_key={self._initialization_args[&#39;auth_strict_key&#39;]!r}, &#34;
            f&#34;timeout_socket={self._initialization_args[&#39;timeout_socket&#39;]!r}, &#34;
            f&#34;timeout_transport={self._initialization_args[&#39;timeout_transport&#39;]!r}, &#34;
            f&#34;timeout_ops={self._initialization_args[&#39;timeout_ops&#39;]!r}, &#34;
            f&#34;timeout_exit={self._initialization_args[&#39;timeout_exit&#39;]!r}, &#34;
            f&#34;keepalive={self._initialization_args[&#39;keepalive&#39;]!r}, &#34;
            f&#34;keepalive_interval={self._initialization_args[&#39;keepalive_interval&#39;]!r}, &#34;
            f&#34;keepalive_type={self._initialization_args[&#39;keepalive_type&#39;]!r}, &#34;
            f&#34;keepalive_pattern={self._initialization_args[&#39;keepalive_pattern&#39;]!r}, &#34;
            f&#34;comms_prompt_pattern={self._initialization_args[&#39;comms_prompt_pattern&#39;]!r}, &#34;
            f&#34;comms_return_char={self._initialization_args[&#39;comms_return_char&#39;]!r}, &#34;
            f&#34;comms_ansi={self._initialization_args[&#39;comms_ansi&#39;]!r}, &#34;
            f&#34;ssh_config_file={self._initialization_args.get(&#39;ssh_config_file&#39;)!r}, &#34;
            f&#34;ssh_known_hosts_file={self._initialization_args.get(&#39;ssh_known_hosts_file&#39;)!r}, &#34;
            f&#34;on_open={self.on_open!r}, &#34;
            f&#34;on_close={self.on_close!r}, &#34;
            f&#34;transport={self._transport!r})&#34;
        )

    def _setup_host(self, host: str, port: int) -&gt; None:
        &#34;&#34;&#34;
        Parse and setup host attributes

        Args:
            host: host to parse/set
            port: port to parse/set

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if host is not provided
            TypeError: if port is not an integer

        &#34;&#34;&#34;
        if not host:
            raise ValueError(&#34;`host` should be a hostname/ip address, got nothing!&#34;)
        if not isinstance(port, int):
            raise TypeError(f&#34;`port` should be int, got {type(port)}&#34;)
        self._host = host.strip()
        self._initialization_args[&#34;host&#34;] = host.strip()
        self._initialization_args[&#34;port&#34;] = port

    def _setup_auth(
        self, auth_username: str, auth_password: str, auth_private_key: str, auth_strict_key: bool
    ) -&gt; None:
        &#34;&#34;&#34;
        Parse and setup auth attributes

        Args:
            auth_username: username to parse/set
            auth_password: password to parse/set
            auth_private_key: public key to parse/set
            auth_strict_key: strict key to parse/set

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TypeError: if auth_strict_key is not a bool
            ValueError: if auth_private_key is not a valid file

        &#34;&#34;&#34;
        if not isinstance(auth_strict_key, bool):
            raise TypeError(f&#34;`auth_strict_key` should be bool, got {type(auth_strict_key)}&#34;)

        self._initialization_args[&#34;auth_strict_key&#34;] = auth_strict_key
        self._initialization_args[&#34;auth_username&#34;] = auth_username.strip()
        self._initialization_args[&#34;auth_password&#34;] = auth_password.strip()

        if auth_private_key:
            public_key_path = Path.expanduser(Path(auth_private_key.strip()))
            if not public_key_path.is_file():
                raise ValueError(f&#34;Provided public key `{auth_private_key}` is not a file&#34;)
            self._initialization_args[&#34;auth_private_key&#34;] = os.path.expanduser(
                auth_private_key.strip().encode()
            )
        else:
            self._initialization_args[&#34;auth_private_key&#34;] = auth_private_key.encode()

    def _setup_timeouts(
        self, timeout_socket: int, timeout_transport: int, timeout_ops: int, timeout_exit: bool
    ) -&gt; None:
        &#34;&#34;&#34;
        Parse and setup timeout attributes

        Args:
            timeout_socket: socket timeout to parse/set
            timeout_transport: transport timeout to parse/set
            timeout_ops: ops timeout to parse/set
            timeout_exit: timeout exit bool to parse/set

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TypeError: if invalid type args provided

        &#34;&#34;&#34;
        if not isinstance(timeout_exit, bool):
            raise TypeError(f&#34;`timeout_exit` should be bool, got {type(timeout_exit)}&#34;)

        self._initialization_args[&#34;timeout_socket&#34;] = int(timeout_socket)
        self._initialization_args[&#34;timeout_transport&#34;] = int(timeout_transport)
        self._initialization_args[&#34;timeout_ops&#34;] = int(timeout_ops)
        self._initialization_args[&#34;timeout_exit&#34;] = timeout_exit

    def _setup_keepalive(
        self, keepalive: bool, keepalive_type: str, keepalive_interval: int, keepalive_pattern: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Parse and setup keepalive attributes

        Args:
            keepalive: keepalive to parse/set
            keepalive_type: keepalive_type to parse/set
            keepalive_interval: keepalive_interval to parse/set
            keepalive_pattern: keepalive_pattern to parse/set

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TypeError: if keepalive is not a bool
            ValueError: if keepalive_type is not valid

        &#34;&#34;&#34;
        if not isinstance(keepalive, bool):
            raise TypeError(f&#34;`keepalive` should be bool, got {type(keepalive)}&#34;)
        if keepalive_type not in [&#34;network&#34;, &#34;standard&#34;]:
            raise ValueError(
                f&#34;`{keepalive_type}` is an invalid keepalive_type; must be &#39;network&#39; or &#39;standard&#39;&#34;
            )
        self._initialization_args[&#34;keepalive&#34;] = keepalive
        self._initialization_args[&#34;keepalive_interval&#34;] = int(keepalive_interval)
        self._initialization_args[&#34;keepalive_type&#34;] = keepalive_type
        self._initialization_args[&#34;keepalive_pattern&#34;] = keepalive_pattern

    def _setup_comms(
        self, comms_prompt_pattern: str, comms_return_char: str, comms_ansi: bool
    ) -&gt; None:
        &#34;&#34;&#34;
        Parse and setup auth attributes

        Args:
            comms_prompt_pattern: prompt pattern to parse/set
            comms_return_char: return char to parse/set
            comms_ansi: ansi val to parse/set

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TypeError: if invalid type args provided

        &#34;&#34;&#34;
        # try to compile prompt to raise TypeError before opening any connections
        re.compile(comms_prompt_pattern, flags=re.M | re.I)

        if not isinstance(comms_return_char, str):
            raise TypeError(f&#34;`comms_return_char` should be str, got {type(comms_return_char)}&#34;)
        if not isinstance(comms_ansi, bool):
            raise TypeError(f&#34;`comms_ansi` should be bool, got {type(comms_ansi)}&#34;)

        self._initialization_args[&#34;comms_prompt_pattern&#34;] = comms_prompt_pattern
        self._initialization_args[&#34;comms_return_char&#34;] = comms_return_char
        self._initialization_args[&#34;comms_ansi&#34;] = comms_ansi

    def _setup_callables(
        self, on_open: Optional[Callable[..., Any]], on_close: Optional[Callable[..., Any]]
    ) -&gt; None:
        &#34;&#34;&#34;
        Parse and setup callables (on_open/on_close)

        Args:
            on_open: on_open to parse/set
            on_close: on_close to parse/set

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TypeError: if port is not an integer

        &#34;&#34;&#34;
        if on_open is not None and not callable(on_open):
            raise TypeError(f&#34;`on_open` must be a callable, got {type(on_open)}&#34;)
        if on_close is not None and not callable(on_close):
            raise TypeError(f&#34;`on_close` must be a callable, got {type(on_close)}&#34;)
        self.on_open = on_open
        self.on_close = on_close
        self._initialization_args[&#34;on_open&#34;] = on_open
        self._initialization_args[&#34;on_close&#34;] = on_close

    def _setup_ssh_args(
        self, ssh_config_file: Union[str, bool], ssh_known_hosts_file: Union[str, bool]
    ) -&gt; None:
        &#34;&#34;&#34;
        Parse and setup ssh related arguments

        Args:
            ssh_config_file: string to path for ssh config file, True to use default ssh config file
                or False to ignore default ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known
                file locations. Only applicable/needed if `auth_strict_key` is set to True

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TypeError: if invalid config file or known hosts file value provided

        &#34;&#34;&#34;
        if not isinstance(ssh_config_file, (str, bool)):
            raise TypeError(f&#34;`ssh_config_file` must be str or bool, got {type(ssh_config_file)}&#34;)
        if not isinstance(ssh_known_hosts_file, (str, bool)):
            raise TypeError(
                &#34;`ssh_known_hosts_file` must be str or bool, got &#34; f&#34;{type(ssh_known_hosts_file)}&#34;
            )

        if ssh_config_file is not False:
            if isinstance(ssh_config_file, bool):
                cfg = &#34;&#34;
            else:
                cfg = ssh_config_file
            self._initialization_args[&#34;ssh_config_file&#34;] = resolve_ssh_config(cfg)
        else:
            self._initialization_args[&#34;ssh_config_file&#34;] = &#34;&#34;

        if ssh_known_hosts_file is not False:
            if isinstance(ssh_known_hosts_file, bool):
                known_hosts = &#34;&#34;
            else:
                known_hosts = ssh_known_hosts_file
            self._initialization_args[&#34;ssh_known_hosts_file&#34;] = resolve_ssh_known_hosts(known_hosts)
        else:
            self._initialization_args[&#34;ssh_known_hosts_file&#34;] = &#34;&#34;

    def _transport_factory(self, transport: str) -&gt; Tuple[Callable[..., Any], Dict[str, Any]]:
        &#34;&#34;&#34;
        Private factory method to produce transport class

        Args:
            transport: string name of transport class to use

        Returns:
            Transport: initialized Transport class

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        transport_class = TRANSPORT_CLASS[transport]
        required_transport_args = TRANSPORT_ARGS[transport]

        transport_args = {}
        for arg in TRANSPORT_BASE_ARGS:
            transport_args[arg] = self._initialization_args.get(arg)
        for arg in required_transport_args:
            transport_args[arg] = self._initialization_args.get(arg)
        return transport_class, transport_args

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open Transport (socket/session) and establish channel

        If on_open callable provided, execute that callable after opening connection

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.transport.open()
        if self.on_open:
            self.on_open(self)

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close Transport (socket/session)

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.on_close:
            self.on_close(self)
        self.transport.close()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if underlying socket/channel is alive

        Args:
            N/A

        Returns:
            bool: True/False if socket/channel is alive

        Raises:
            N/A

        &#34;&#34;&#34;
        alive = False
        try:
            alive = self.transport.isalive()
        except AttributeError:
            pass
        return alive</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.Scrape.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Close Transport (socket/session)</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;
    Close Transport (socket/session)

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    if self.on_close:
        self.on_close(self)
    self.transport.close()</code></pre>
</details>
</dd>
<dt id="scrapli.driver.Scrape.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if underlying socket/channel is alive</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True/False if socket/channel is alive</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if underlying socket/channel is alive

    Args:
        N/A

    Returns:
        bool: True/False if socket/channel is alive

    Raises:
        N/A

    &#34;&#34;&#34;
    alive = False
    try:
        alive = self.transport.isalive()
    except AttributeError:
        pass
    return alive</code></pre>
</details>
</dd>
<dt id="scrapli.driver.Scrape.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Open Transport (socket/session) and establish channel</p>
<p>If on_open callable provided, execute that callable after opening connection</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open Transport (socket/session) and establish channel

    If on_open callable provided, execute that callable after opening connection

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.transport.open()
    if self.on_open:
        self.on_open(self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli" href="../index.html">scrapli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli.driver.community" href="community/index.html">scrapli.driver.community</a></code></li>
<li><code><a title="scrapli.driver.core" href="core/index.html">scrapli.driver.core</a></code></li>
<li><code><a title="scrapli.driver.driver" href="driver.html">scrapli.driver.driver</a></code></li>
<li><code><a title="scrapli.driver.generic_driver" href="generic_driver.html">scrapli.driver.generic_driver</a></code></li>
<li><code><a title="scrapli.driver.network_driver" href="network_driver.html">scrapli.driver.network_driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.driver.GenericDriver" href="#scrapli.driver.GenericDriver">GenericDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.GenericDriver.get_prompt" href="#scrapli.driver.GenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.GenericDriver.send_command" href="#scrapli.driver.GenericDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.GenericDriver.send_commands" href="#scrapli.driver.GenericDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.GenericDriver.send_interactive" href="#scrapli.driver.GenericDriver.send_interactive">send_interactive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.NetworkDriver" href="#scrapli.driver.NetworkDriver">NetworkDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.NetworkDriver.acquire_priv" href="#scrapli.driver.NetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_command" href="#scrapli.driver.NetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_commands" href="#scrapli.driver.NetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_configs" href="#scrapli.driver.NetworkDriver.send_configs">send_configs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.Scrape" href="#scrapli.driver.Scrape">Scrape</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.Scrape.close" href="#scrapli.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.Scrape.isalive" href="#scrapli.driver.Scrape.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.Scrape.open" href="#scrapli.driver.Scrape.open">open</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>