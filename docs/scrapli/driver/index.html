<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>scrapli.driver API documentation</title>
<meta name="description" content="scrapli.driver" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli.driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.driver&#34;&#34;&#34;
from scrapli.driver.async_driver import AsyncScrape
from scrapli.driver.async_generic_driver import AsyncGenericDriver
from scrapli.driver.async_network_driver import AsyncNetworkDriver
from scrapli.driver.driver import Scrape
from scrapli.driver.generic_driver import GenericDriver
from scrapli.driver.network_driver import NetworkDriver

__all__ = (
    &#34;AsyncScrape&#34;,
    &#34;Scrape&#34;,
    &#34;AsyncGenericDriver&#34;,
    &#34;GenericDriver&#34;,
    &#34;AsyncNetworkDriver&#34;,
    &#34;NetworkDriver&#34;,
)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli.driver.async_driver" href="async_driver.html">scrapli.driver.async_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.async_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.async_generic_driver" href="async_generic_driver.html">scrapli.driver.async_generic_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.async_generic_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.async_network_driver" href="async_network_driver.html">scrapli.driver.async_network_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.async_network_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.base_driver" href="base_driver.html">scrapli.driver.base_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.base_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.base_generic_driver" href="base_generic_driver.html">scrapli.driver.base_generic_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.base_generic_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.base_network_driver" href="base_network_driver.html">scrapli.driver.base_network_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.base_network_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.core" href="core/index.html">scrapli.driver.core</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.core</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.driver" href="driver.html">scrapli.driver.driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.generic_driver" href="generic_driver.html">scrapli.driver.generic_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.generic_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.network_driver" href="network_driver.html">scrapli.driver.network_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.network_driver</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.driver.AsyncGenericDriver"><code class="flex name class">
<span>class <span class="ident">AsyncGenericDriver</span></span>
<span>(</span><span>comms_prompt_pattern: str = &#x27;^\\S{0,48}[#&gt;$~@:\\]]\\s*$&#x27;, comms_ansi: bool = True, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code><a title="scrapli.driver.Scrape" href="#scrapli.driver.Scrape">Scrape</a></code> object from that perspective.</p>
<p>AsyncGenericDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
For this GenericDriver the prompt pattern matches a really wide range of things&hellip;
the general pattern is start of line, match any character 0-32 times, then match a
prompt termination character from the following character set: <code>#</code>, <code>&gt;</code>, <code>$</code>, <code>~</code>,
<code>@</code>, <code>:</code>, <code>]</code>, finally match any or no whitespace till the end of the line. This
pattern works on all of the "core" platforms and should work on a wide range of
other devices, however because it is so broad it may also accidentally match too
many things and cause issues, so be careful!</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; in the case of the
GenericDriver, always strip ansi; this may slow things down but will hopefully help
prevent issues! Obviously can be overridden if desired.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncGenericDriver(AsyncScrape, GenericDriverBase):
    def __init__(
        self,
        comms_prompt_pattern: str = r&#34;^\S{0,48}[#&gt;$~@:\]]\s*$&#34;,
        comms_ansi: bool = True,
        **kwargs: Any,
    ):
        &#34;&#34;&#34;
        AsyncGenericDriver Object

        Args:
            comms_prompt_pattern: raw string regex pattern -- preferably use `^` and `$` anchors!
                this is the single most important attribute here! if this does not match a prompt,
                scrapli will not work!
                For this GenericDriver the prompt pattern matches a really wide range of things...
                the general pattern is start of line, match any character 0-32 times, then match a
                prompt termination character from the following character set: `#`, `&gt;`, `$`, `~`,
                `@`, `:`, `]`, finally match any or no whitespace till the end of the line. This
                pattern works on all of the &#34;core&#34; platforms and should work on a wide range of
                other devices, however because it is so broad it may also accidentally match too
                many things and cause issues, so be careful!
            comms_ansi: True/False strip comms_ansi characters from output; in the case of the
                GenericDriver, always strip ansi; this may slow things down but will hopefully help
                prevent issues! Obviously can be overridden if desired.
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A
        &#34;&#34;&#34;
        super().__init__(comms_prompt_pattern=comms_prompt_pattern, comms_ansi=comms_ansi, **kwargs)
        self.channel: AsyncChannel

    async def send_command(
        self,
        command: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_send_command(
            host=self.transport.host, command=command, failed_when_contains=failed_when_contains
        )
        raw_response, processed_response = await self.channel.send_input(
            channel_input=command, strip_prompt=strip_prompt
        )
        return self._post_send_command(
            raw_response=raw_response, processed_response=processed_response, response=response
        )

    async def send_commands(
        self,
        commands: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send multiple commands

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        responses = self._pre_send_commands(commands=commands)
        for command in commands:
            response = await self.send_command(
                command=command,
                strip_prompt=strip_prompt,
                failed_when_contains=failed_when_contains,
            )
            responses.append(response)
            if stop_on_failed is True and response.failed is True:
                return responses

        return responses

    async def send_commands_from_file(
        self,
        file: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send command(s) from file

        Args:
            file: string path to file
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        commands = self._pre_send_commands_from_file(file=file)

        return await self.send_commands(
            commands=commands,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
        )

    async def send_interactive(
        self,
        interact_events: List[Tuple[str, str, Optional[bool]]],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Interact with a device with changing prompts per input.

        Used to interact with devices where prompts change per input, and where inputs may be hidden
        such as in the case of a password input. This can be used to respond to challenges from
        devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
        example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
        element of that list should be a tuple of two or three elements. The first element is always
        the input to send as a string, the second should be the expected response as a string, and
        the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

        An example where we need this sort of capability:

        ```
        3560CX#copy flash: scp:
        Source filename []? test1.txt
        Address or name of remote host []? 172.31.254.100
        Destination username [carl]?
        Writing test1.txt
        Password:

        Password:
         Sink: C0644 639 test1.txt
        !
        639 bytes copied in 12.066 secs (53 bytes/sec)
        3560CX#
        ```

        To accomplish this we can use the following:

        ```
        interact = conn.channel.send_inputs_interact(
            [
                (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
                (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
                (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
                (&#34;carl&#34;, &#34;Password:&#34;, False),
                (&#34;super_secure_password&#34;, prompt, True),
            ]
        )
        ```

        If we needed to deal with more prompts we could simply continue adding tuples to the list of
        interact &#34;events&#34;.

        Args:
            interact_events: list of tuples containing the &#34;interactions&#34; with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
                not provided it is assumed the input is &#34;normal&#34; (not hidden)
            failed_when_contains: list of strings that, if present in final output, represent a
                failed command/interaction
            privilege_level: ignored in this base class; for LSP reasons for subclasses

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        _ = privilege_level

        response = self._pre_send_interactive(
            host=self.transport.host,
            interact_events=interact_events,
            failed_when_contains=failed_when_contains,
        )
        raw_response, processed_response = await self.channel.send_inputs_interact(
            interact_events=interact_events
        )
        return self._post_send_command(
            raw_response=raw_response, processed_response=processed_response, response=response
        )

    async def get_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Convenience method to get device prompt from Channel

        Args:
            N/A

        Returns:
            str: prompt received from channel.get_prompt

        Raises:
            N/A

        &#34;&#34;&#34;
        prompt: str = await self.channel.get_prompt()
        return prompt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_driver.AsyncScrape" href="async_driver.html#scrapli.driver.async_driver.AsyncScrape">AsyncScrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.AsyncGenericDriver.get_prompt"><code class="name flex">
<span>async def <span class="ident">get_prompt</span></span>(<span>self) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method to get device prompt from Channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>prompt received from channel.get_prompt</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_prompt(self) -&gt; str:
    &#34;&#34;&#34;
    Convenience method to get device prompt from Channel

    Args:
        N/A

    Returns:
        str: prompt received from channel.get_prompt

    Raises:
        N/A

    &#34;&#34;&#34;
    prompt: str = await self.channel.get_prompt()
    return prompt</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncGenericDriver.send_command"><code class="name flex">
<span>async def <span class="ident">send_command</span></span>(<span>self, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None) -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send a command</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_command(
    self,
    command: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; Response:
    &#34;&#34;&#34;
    Send a command

    Args:
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        Response: Scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_send_command(
        host=self.transport.host, command=command, failed_when_contains=failed_when_contains
    )
    raw_response, processed_response = await self.channel.send_input(
        channel_input=command, strip_prompt=strip_prompt
    )
    return self._post_send_command(
        raw_response=raw_response, processed_response=processed_response, response=response
    )</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncGenericDriver.send_commands"><code class="name flex">
<span>async def <span class="ident">send_commands</span></span>(<span>self, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False) -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send multiple commands</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_commands(
    self,
    commands: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send multiple commands

    Args:
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    responses = self._pre_send_commands(commands=commands)
    for command in commands:
        response = await self.send_command(
            command=command,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
        )
        responses.append(response)
        if stop_on_failed is True and response.failed is True:
            return responses

    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncGenericDriver.send_commands_from_file"><code class="name flex">
<span>async def <span class="ident">send_commands_from_file</span></span>(<span>self, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False) -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send command(s) from file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>string path to file</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_commands_from_file(
    self,
    file: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send command(s) from file

    Args:
        file: string path to file
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    commands = self._pre_send_commands_from_file(file=file)

    return await self.send_commands(
        commands=commands,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
    )</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncGenericDriver.send_interactive"><code class="name flex">
<span>async def <span class="ident">send_interactive</span></span>(<span>self, interact_events: List[Tuple[str, str, Union[bool, NoneType]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '') -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Interact with a device with changing prompts per input.</p>
<p>Used to interact with devices where prompts change per input, and where inputs may be hidden
such as in the case of a password input. This can be used to respond to challenges from
devices such as the confirmation for the command "clear logging" on IOSXE devices for
example. You may have as many elements in the "interact_events" list as needed, and each
element of that list should be a tuple of two or three elements. The first element is always
the input to send as a string, the second should be the expected response as a string, and
the optional third a bool for whether or not the input is "hidden" (i.e. password input)</p>
<p>An example where we need this sort of capability:</p>
<pre><code>3560CX#copy flash: scp:
Source filename []? test1.txt
Address or name of remote host []? 172.31.254.100
Destination username [carl]?
Writing test1.txt
Password:

Password:
 Sink: C0644 639 test1.txt
!
639 bytes copied in 12.066 secs (53 bytes/sec)
3560CX#
</code></pre>
<p>To accomplish this we can use the following:</p>
<pre><code>interact = conn.channel.send_inputs_interact(
    [
        (&quot;copy flash: scp:&quot;, &quot;Source filename []?&quot;, False),
        (&quot;test1.txt&quot;, &quot;Address or name of remote host []?&quot;, False),
        (&quot;172.31.254.100&quot;, &quot;Destination username [carl]?&quot;, False),
        (&quot;carl&quot;, &quot;Password:&quot;, False),
        (&quot;super_secure_password&quot;, prompt, True),
    ]
)
</code></pre>
<p>If we needed to deal with more prompts we could simply continue adding tuples to the list of
interact "events".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interact_events</code></strong></dt>
<dd>list of tuples containing the "interactions" with the device
each list element must have an input and an expected response, and may have an
optional bool for the third and final element &ndash; the optional bool specifies if the
input that is sent to the device is "hidden" (ex: password), if the hidden param is
not provided it is assumed the input is "normal" (not hidden)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that, if present in final output, represent a
failed command/interaction</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>ignored in this base class; for LSP reasons for subclasses</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_interactive(
    self,
    interact_events: List[Tuple[str, str, Optional[bool]]],
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    privilege_level: str = &#34;&#34;,
) -&gt; Response:
    &#34;&#34;&#34;
    Interact with a device with changing prompts per input.

    Used to interact with devices where prompts change per input, and where inputs may be hidden
    such as in the case of a password input. This can be used to respond to challenges from
    devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
    example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
    element of that list should be a tuple of two or three elements. The first element is always
    the input to send as a string, the second should be the expected response as a string, and
    the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

    An example where we need this sort of capability:

    ```
    3560CX#copy flash: scp:
    Source filename []? test1.txt
    Address or name of remote host []? 172.31.254.100
    Destination username [carl]?
    Writing test1.txt
    Password:

    Password:
     Sink: C0644 639 test1.txt
    !
    639 bytes copied in 12.066 secs (53 bytes/sec)
    3560CX#
    ```

    To accomplish this we can use the following:

    ```
    interact = conn.channel.send_inputs_interact(
        [
            (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
            (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
            (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
            (&#34;carl&#34;, &#34;Password:&#34;, False),
            (&#34;super_secure_password&#34;, prompt, True),
        ]
    )
    ```

    If we needed to deal with more prompts we could simply continue adding tuples to the list of
    interact &#34;events&#34;.

    Args:
        interact_events: list of tuples containing the &#34;interactions&#34; with the device
            each list element must have an input and an expected response, and may have an
            optional bool for the third and final element -- the optional bool specifies if the
            input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
            not provided it is assumed the input is &#34;normal&#34; (not hidden)
        failed_when_contains: list of strings that, if present in final output, represent a
            failed command/interaction
        privilege_level: ignored in this base class; for LSP reasons for subclasses

    Returns:
        Response: scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    _ = privilege_level

    response = self._pre_send_interactive(
        host=self.transport.host,
        interact_events=interact_events,
        failed_when_contains=failed_when_contains,
    )
    raw_response, processed_response = await self.channel.send_inputs_interact(
        interact_events=interact_events
    )
    return self._post_send_command(
        raw_response=raw_response, processed_response=processed_response, response=response
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.async_driver.AsyncScrape" href="async_driver.html#scrapli.driver.async_driver.AsyncScrape">AsyncScrape</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.async_driver.AsyncScrape.close" href="async_driver.html#scrapli.driver.async_driver.AsyncScrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.async_driver.AsyncScrape.isalive" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.async_driver.AsyncScrape.open" href="async_driver.html#scrapli.driver.async_driver.AsyncScrape.open">open</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.AsyncNetworkDriver"><code class="flex name class">
<span>class <span class="ident">AsyncNetworkDriver</span></span>
<span>(</span><span>privilege_levels: Dict[str, scrapli.driver.base_network_driver.PrivilegeLevel], default_desired_privilege_level: str, auth_secondary: str = '', failed_when_contains: Union[List[str], NoneType] = None, textfsm_platform: str = '', genie_platform: str = '', **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code><a title="scrapli.driver.Scrape" href="#scrapli.driver.Scrape">Scrape</a></code> object from that perspective.</p>
<p>AsyncNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>Dict of privilege levels for a given platform</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that indicate a command/configuration has failed</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of platform to use for textfsm parsing</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of platform to use for genie parsing</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncNetworkDriver(AsyncGenericDriver, NetworkDriverBase):
    def __init__(
        self,
        privilege_levels: Dict[str, PrivilegeLevel],
        default_desired_privilege_level: str,
        auth_secondary: str = &#34;&#34;,
        failed_when_contains: Optional[List[str]] = None,
        textfsm_platform: str = &#34;&#34;,
        genie_platform: str = &#34;&#34;,
        **kwargs: Any,
    ):
        &#34;&#34;&#34;
        AsyncNetworkDriver Object

        Args:
            privilege_levels: Dict of privilege levels for a given platform
            default_desired_privilege_level: string of name of default desired priv, this is the
                priv level that is generally used to disable paging/set terminal width and things
                like that upon first login, and is also the priv level scrapli will try to acquire
                for normal &#34;command&#34; operations (`send_command`, `send_commands`)
            auth_secondary: password to use for secondary authentication (enable)
            failed_when_contains: list of strings that indicate a command/configuration has failed
            textfsm_platform: string name of platform to use for textfsm parsing
            genie_platform: string name of platform to use for genie parsing
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._check_kwargs_comms_prompt_pattern(kwargs=kwargs)

        self.auth_secondary = auth_secondary
        self.privilege_levels = privilege_levels
        self._priv_map = {}
        self.default_desired_privilege_level = default_desired_privilege_level
        self.update_privilege_levels(update_channel=False)

        self.textfsm_platform = textfsm_platform
        self.genie_platform = genie_platform
        self.failed_when_contains = failed_when_contains or []

        super().__init__(comms_prompt_pattern=self.comms_prompt_pattern, **kwargs)

    async def _escalate(self, escalate_priv: PrivilegeLevel) -&gt; None:
        &#34;&#34;&#34;
        Escalate to the next privilege level up

        Args:
            escalate_priv: privilege level to escalate to

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._pre_escalate(escalate_priv=escalate_priv)

        if escalate_priv.escalate_auth is True:
            await super().send_interactive(
                interact_events=[
                    (escalate_priv.escalate, escalate_priv.escalate_prompt, False),
                    (self.auth_secondary, escalate_priv.pattern, True),
                ],
            )
        else:
            await self.channel.send_input(channel_input=escalate_priv.escalate)

    async def _deescalate(self, current_priv: PrivilegeLevel) -&gt; None:
        &#34;&#34;&#34;
        Deescalate to the next privilege level down

        Args:
            current_priv: current privilege level

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        await self.channel.send_input(channel_input=current_priv.deescalate)

    async def acquire_priv(self, desired_priv: str) -&gt; None:
        &#34;&#34;&#34;
        Acquire desired priv level

        Args:
            desired_priv: string name of desired privilege level
                (see scrapli.driver.&lt;driver_category.device_type&gt;.driver for levels)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            CouldNotAcquirePrivLevel: if scrapli cannot get to the requested privilege level

        &#34;&#34;&#34;
        resolved_priv, map_to_desired_priv = self._pre_acquire_priv(desired_priv=desired_priv)

        privilege_change_count = 0
        while True:
            current_prompt = await self.channel.get_prompt()
            privilege_action, target_priv = self._process_acquire_priv(
                resolved_priv=resolved_priv,
                map_to_desired_priv=map_to_desired_priv,
                current_prompt=current_prompt,
            )

            if privilege_action == PrivilegeAction.NO_ACTION:
                self._current_priv_level = target_priv
                return
            if privilege_action == PrivilegeAction.DEESCALATE:
                await self._deescalate(current_priv=target_priv)
            if privilege_action == PrivilegeAction.ESCALATE:
                await self._escalate(escalate_priv=target_priv)

            privilege_change_count += 1
            if privilege_change_count &gt; len(self.privilege_levels) * 2:
                msg = f&#34;Failed to acquire requested privilege level {resolved_priv}&#34;
                raise CouldNotAcquirePrivLevel(msg)

    async def send_command(
        self,
        command: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Super method will raise TypeError if anything but a string is passed here!

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_privilege_level:
            await self.acquire_priv(desired_priv=self.default_desired_privilege_level)

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        response = await super().send_command(
            command=command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
        )

        self._update_response(response)

        return response

    async def send_commands(
        self,
        commands: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send multiple commands

        Super method will raise TypeError if anything but a list of strings is passed here!

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_privilege_level:
            await self.acquire_priv(desired_priv=self.default_desired_privilege_level)

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        responses = await super().send_commands(
            commands=commands,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
        )

        for response in responses:
            self._update_response(response=response)

        return responses

    async def send_commands_from_file(
        self,
        file: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send command(s) from file

        Args:
            file: string path to file
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        commands = self._pre_send_commands_from_file(file=file)

        return await self.send_commands(
            commands=commands,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
        )

    async def send_interactive(
        self,
        interact_events: List[Tuple[str, str, Optional[bool]]],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Interact with a device with changing prompts per input.

        Used to interact with devices where prompts change per input, and where inputs may be hidden
        such as in the case of a password input. This can be used to respond to challenges from
        devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
        example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
        element of that list should be a tuple of two or three elements. The first element is always
        the input to send as a string, the second should be the expected response as a string, and
        the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

        An example where we need this sort of capability:

        ```
        3560CX#copy flash: scp:
        Source filename []? test1.txt
        Address or name of remote host []? 172.31.254.100
        Destination username [carl]?
        Writing test1.txt
        Password:

        Password:
         Sink: C0644 639 test1.txt
        !
        639 bytes copied in 12.066 secs (53 bytes/sec)
        3560CX#
        ```

        To accomplish this we can use the following:

        ```
        interact = conn.channel.send_inputs_interact(
            [
                (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
                (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
                (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
                (&#34;carl&#34;, &#34;Password:&#34;, False),
                (&#34;super_secure_password&#34;, prompt, True),
            ]
        )
        ```

        If we needed to deal with more prompts we could simply continue adding tuples to the list of
        interact &#34;events&#34;.

        Args:
            interact_events: list of tuples containing the &#34;interactions&#34; with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
                not provided it is assumed the input is &#34;normal&#34; (not hidden)
            failed_when_contains: list of strings that, if present in final output, represent a
                failed command/interaction
            privilege_level: name of the privilege level to operate in

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if privilege_level:
            resolved_privilege_level = self._get_privilege_level_name(
                requested_priv=privilege_level
            )
        else:
            resolved_privilege_level = self.default_desired_privilege_level

        if self._current_priv_level.name != resolved_privilege_level:
            await self.acquire_priv(desired_priv=resolved_privilege_level)
        response = await super().send_interactive(
            interact_events=interact_events, failed_when_contains=failed_when_contains
        )
        self._update_response(response=response)

        return response

    async def _abort_config(self) -&gt; None:
        &#34;&#34;&#34;
        Abort a configuration operation/session if applicable (for config sessions like junos/iosxr)

        Args:
            N/A

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    async def send_config(
        self,
        config: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            config: string configuration to send to the device, supports sending multi-line strings
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution; aborts configuration session if applicable (iosxr/junos or
                eos/nxos if using a configuration session)
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
                JunosDriver. You can also pass in a name of a configuration session such as
                &#34;my-config-session&#34; if you have registered a session using the
                &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        split_config = self._pre_send_config(config=config)

        # now that we have a list of configs, just use send_configs to actually execute them
        multi_response = await self.send_configs(
            configs=split_config,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
            privilege_level=privilege_level,
        )
        return self._post_send_config(config=config, multi_response=multi_response)

    async def send_configs(
        self,
        configs: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
        privilege_level: str = &#34;&#34;,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            configs: list of strings to send to device in config mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution; aborts configuration session if applicable (iosxr/junos or
                eos/nxos if using a configuration session)
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
                JunosDriver. You can also pass in a name of a configuration session such as
                &#34;my-config-session&#34; if you have registered a session using the
                &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        resolved_privilege_level, failed_when_contains = self._pre_send_configs(
            configs=configs,
            failed_when_contains=failed_when_contains,
            privilege_level=privilege_level,
        )

        if self._current_priv_level.name != resolved_privilege_level:
            await self.acquire_priv(desired_priv=resolved_privilege_level)

        responses = MultiResponse()
        _failed_during_execution = False
        for config in configs:
            response = await super().send_command(
                command=config,
                strip_prompt=strip_prompt,
                failed_when_contains=failed_when_contains,
            )
            responses.append(response)
            if response.failed is True:
                _failed_during_execution = True
                if stop_on_failed is True:
                    break

        if _failed_during_execution is True:
            await self._abort_config()

        return self._post_send_configs(responses=responses)

    async def send_configs_from_file(
        self,
        file: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
        privilege_level: str = &#34;&#34;,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send configuration(s) from a file

        Args:
            file: string path to file
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution; aborts configuration session if applicable (iosxr/junos or
                eos/nxos if using a configuration session)
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;exclusive&#34; for IOSXRDriver, &#34;private&#34; for JunosDriver. You can also pass
                in a name of a configuration session such as &#34;session_mysession&#34; if you have
                registered a session using the &#34;register_config_session&#34; method of the EOSDriver or
                NXOSDriver.

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        configs = self._pre_send_configs_from_file(file=file)

        return await self.send_configs(
            configs=configs,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
            privilege_level=privilege_level,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></li>
<li><a title="scrapli.driver.async_driver.AsyncScrape" href="async_driver.html#scrapli.driver.async_driver.AsyncScrape">AsyncScrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.core.arista_eos.async_driver.AsyncEOSDriver" href="core/arista_eos/async_driver.html#scrapli.driver.core.arista_eos.async_driver.AsyncEOSDriver">AsyncEOSDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxe.async_driver.AsyncIOSXEDriver" href="core/cisco_iosxe/async_driver.html#scrapli.driver.core.cisco_iosxe.async_driver.AsyncIOSXEDriver">AsyncIOSXEDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxr.async_driver.AsyncIOSXRDriver" href="core/cisco_iosxr/async_driver.html#scrapli.driver.core.cisco_iosxr.async_driver.AsyncIOSXRDriver">AsyncIOSXRDriver</a></li>
<li><a title="scrapli.driver.core.cisco_nxos.async_driver.AsyncNXOSDriver" href="core/cisco_nxos/async_driver.html#scrapli.driver.core.cisco_nxos.async_driver.AsyncNXOSDriver">AsyncNXOSDriver</a></li>
<li><a title="scrapli.driver.core.juniper_junos.async_driver.AsyncJunosDriver" href="core/juniper_junos/async_driver.html#scrapli.driver.core.juniper_junos.async_driver.AsyncJunosDriver">AsyncJunosDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.AsyncNetworkDriver.acquire_priv"><code class="name flex">
<span>async def <span class="ident">acquire_priv</span></span>(<span>self, desired_priv: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Acquire desired priv level</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>desired_priv</code></strong></dt>
<dd>string name of desired privilege level
(see scrapli.driver.<driver_category.device_type>.driver for levels)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CouldNotAcquirePrivLevel</code></dt>
<dd>if scrapli cannot get to the requested privilege level</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def acquire_priv(self, desired_priv: str) -&gt; None:
    &#34;&#34;&#34;
    Acquire desired priv level

    Args:
        desired_priv: string name of desired privilege level
            (see scrapli.driver.&lt;driver_category.device_type&gt;.driver for levels)

    Returns:
        N/A  # noqa: DAR202

    Raises:
        CouldNotAcquirePrivLevel: if scrapli cannot get to the requested privilege level

    &#34;&#34;&#34;
    resolved_priv, map_to_desired_priv = self._pre_acquire_priv(desired_priv=desired_priv)

    privilege_change_count = 0
    while True:
        current_prompt = await self.channel.get_prompt()
        privilege_action, target_priv = self._process_acquire_priv(
            resolved_priv=resolved_priv,
            map_to_desired_priv=map_to_desired_priv,
            current_prompt=current_prompt,
        )

        if privilege_action == PrivilegeAction.NO_ACTION:
            self._current_priv_level = target_priv
            return
        if privilege_action == PrivilegeAction.DEESCALATE:
            await self._deescalate(current_priv=target_priv)
        if privilege_action == PrivilegeAction.ESCALATE:
            await self._escalate(escalate_priv=target_priv)

        privilege_change_count += 1
        if privilege_change_count &gt; len(self.privilege_levels) * 2:
            msg = f&#34;Failed to acquire requested privilege level {resolved_priv}&#34;
            raise CouldNotAcquirePrivLevel(msg)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncNetworkDriver.send_command"><code class="name flex">
<span>async def <span class="ident">send_command</span></span>(<span>self, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None) -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send a command</p>
<p>Super method will raise TypeError if anything but a string is passed here!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_command(
    self,
    command: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; Response:
    &#34;&#34;&#34;
    Send a command

    Super method will raise TypeError if anything but a string is passed here!

    Args:
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        Response: Scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._current_priv_level.name != self.default_desired_privilege_level:
        await self.acquire_priv(desired_priv=self.default_desired_privilege_level)

    if failed_when_contains is None:
        failed_when_contains = self.failed_when_contains

    response = await super().send_command(
        command=command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
    )

    self._update_response(response)

    return response</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncNetworkDriver.send_commands"><code class="name flex">
<span>async def <span class="ident">send_commands</span></span>(<span>self, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False) -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send multiple commands</p>
<p>Super method will raise TypeError if anything but a list of strings is passed here!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_commands(
    self,
    commands: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send multiple commands

    Super method will raise TypeError if anything but a list of strings is passed here!

    Args:
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._current_priv_level.name != self.default_desired_privilege_level:
        await self.acquire_priv(desired_priv=self.default_desired_privilege_level)

    if failed_when_contains is None:
        failed_when_contains = self.failed_when_contains

    responses = await super().send_commands(
        commands=commands,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
    )

    for response in responses:
        self._update_response(response=response)

    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncNetworkDriver.send_config"><code class="name flex">
<span>async def <span class="ident">send_config</span></span>(<span>self, config: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '') -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>string configuration to send to the device, supports sending multi-line strings</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution; aborts configuration session if applicable (iosxr/junos or
eos/nxos if using a configuration session)</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "configuration_exclusive" for IOSXRDriver, or "configuration_private" for
JunosDriver. You can also pass in a name of a configuration session such as
"my-config-session" if you have registered a session using the
"register_config_session" method of the EOSDriver or NXOSDriver.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_config(
    self,
    config: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
) -&gt; Response:
    &#34;&#34;&#34;
    Send configuration(s)

    Args:
        config: string configuration to send to the device, supports sending multi-line strings
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution; aborts configuration session if applicable (iosxr/junos or
            eos/nxos if using a configuration session)
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
            JunosDriver. You can also pass in a name of a configuration session such as
            &#34;my-config-session&#34; if you have registered a session using the
            &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

    Returns:
        Response: Scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    split_config = self._pre_send_config(config=config)

    # now that we have a list of configs, just use send_configs to actually execute them
    multi_response = await self.send_configs(
        configs=split_config,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        privilege_level=privilege_level,
    )
    return self._post_send_config(config=config, multi_response=multi_response)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncNetworkDriver.send_configs"><code class="name flex">
<span>async def <span class="ident">send_configs</span></span>(<span>self, configs: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '') -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>configs</code></strong></dt>
<dd>list of strings to send to device in config mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution; aborts configuration session if applicable (iosxr/junos or
eos/nxos if using a configuration session)</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "configuration_exclusive" for IOSXRDriver, or "configuration_private" for
JunosDriver. You can also pass in a name of a configuration session such as
"my-config-session" if you have registered a session using the
"register_config_session" method of the EOSDriver or NXOSDriver.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_configs(
    self,
    configs: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send configuration(s)

    Args:
        configs: list of strings to send to device in config mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution; aborts configuration session if applicable (iosxr/junos or
            eos/nxos if using a configuration session)
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
            JunosDriver. You can also pass in a name of a configuration session such as
            &#34;my-config-session&#34; if you have registered a session using the
            &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    resolved_privilege_level, failed_when_contains = self._pre_send_configs(
        configs=configs,
        failed_when_contains=failed_when_contains,
        privilege_level=privilege_level,
    )

    if self._current_priv_level.name != resolved_privilege_level:
        await self.acquire_priv(desired_priv=resolved_privilege_level)

    responses = MultiResponse()
    _failed_during_execution = False
    for config in configs:
        response = await super().send_command(
            command=config,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
        )
        responses.append(response)
        if response.failed is True:
            _failed_during_execution = True
            if stop_on_failed is True:
                break

    if _failed_during_execution is True:
        await self._abort_config()

    return self._post_send_configs(responses=responses)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncNetworkDriver.send_configs_from_file"><code class="name flex">
<span>async def <span class="ident">send_configs_from_file</span></span>(<span>self, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '') -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration(s) from a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>string path to file</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution; aborts configuration session if applicable (iosxr/junos or
eos/nxos if using a configuration session)</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "exclusive" for IOSXRDriver, "private" for JunosDriver. You can also pass
in a name of a configuration session such as "session_mysession" if you have
registered a session using the "register_config_session" method of the EOSDriver or
NXOSDriver.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_configs_from_file(
    self,
    file: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send configuration(s) from a file

    Args:
        file: string path to file
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution; aborts configuration session if applicable (iosxr/junos or
            eos/nxos if using a configuration session)
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;exclusive&#34; for IOSXRDriver, &#34;private&#34; for JunosDriver. You can also pass
            in a name of a configuration session such as &#34;session_mysession&#34; if you have
            registered a session using the &#34;register_config_session&#34; method of the EOSDriver or
            NXOSDriver.

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    configs = self._pre_send_configs_from_file(file=file)

    return await self.send_configs(
        configs=configs,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        privilege_level=privilege_level,
    )</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncNetworkDriver.send_interactive"><code class="name flex">
<span>async def <span class="ident">send_interactive</span></span>(<span>self, interact_events: List[Tuple[str, str, Union[bool, NoneType]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '') -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Interact with a device with changing prompts per input.</p>
<p>Used to interact with devices where prompts change per input, and where inputs may be hidden
such as in the case of a password input. This can be used to respond to challenges from
devices such as the confirmation for the command "clear logging" on IOSXE devices for
example. You may have as many elements in the "interact_events" list as needed, and each
element of that list should be a tuple of two or three elements. The first element is always
the input to send as a string, the second should be the expected response as a string, and
the optional third a bool for whether or not the input is "hidden" (i.e. password input)</p>
<p>An example where we need this sort of capability:</p>
<pre><code>3560CX#copy flash: scp:
Source filename []? test1.txt
Address or name of remote host []? 172.31.254.100
Destination username [carl]?
Writing test1.txt
Password:

Password:
 Sink: C0644 639 test1.txt
!
639 bytes copied in 12.066 secs (53 bytes/sec)
3560CX#
</code></pre>
<p>To accomplish this we can use the following:</p>
<pre><code>interact = conn.channel.send_inputs_interact(
    [
        (&quot;copy flash: scp:&quot;, &quot;Source filename []?&quot;, False),
        (&quot;test1.txt&quot;, &quot;Address or name of remote host []?&quot;, False),
        (&quot;172.31.254.100&quot;, &quot;Destination username [carl]?&quot;, False),
        (&quot;carl&quot;, &quot;Password:&quot;, False),
        (&quot;super_secure_password&quot;, prompt, True),
    ]
)
</code></pre>
<p>If we needed to deal with more prompts we could simply continue adding tuples to the list of
interact "events".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interact_events</code></strong></dt>
<dd>list of tuples containing the "interactions" with the device
each list element must have an input and an expected response, and may have an
optional bool for the third and final element &ndash; the optional bool specifies if the
input that is sent to the device is "hidden" (ex: password), if the hidden param is
not provided it is assumed the input is "normal" (not hidden)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that, if present in final output, represent a
failed command/interaction</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of the privilege level to operate in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_interactive(
    self,
    interact_events: List[Tuple[str, str, Optional[bool]]],
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    privilege_level: str = &#34;&#34;,
) -&gt; Response:
    &#34;&#34;&#34;
    Interact with a device with changing prompts per input.

    Used to interact with devices where prompts change per input, and where inputs may be hidden
    such as in the case of a password input. This can be used to respond to challenges from
    devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
    example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
    element of that list should be a tuple of two or three elements. The first element is always
    the input to send as a string, the second should be the expected response as a string, and
    the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

    An example where we need this sort of capability:

    ```
    3560CX#copy flash: scp:
    Source filename []? test1.txt
    Address or name of remote host []? 172.31.254.100
    Destination username [carl]?
    Writing test1.txt
    Password:

    Password:
     Sink: C0644 639 test1.txt
    !
    639 bytes copied in 12.066 secs (53 bytes/sec)
    3560CX#
    ```

    To accomplish this we can use the following:

    ```
    interact = conn.channel.send_inputs_interact(
        [
            (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
            (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
            (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
            (&#34;carl&#34;, &#34;Password:&#34;, False),
            (&#34;super_secure_password&#34;, prompt, True),
        ]
    )
    ```

    If we needed to deal with more prompts we could simply continue adding tuples to the list of
    interact &#34;events&#34;.

    Args:
        interact_events: list of tuples containing the &#34;interactions&#34; with the device
            each list element must have an input and an expected response, and may have an
            optional bool for the third and final element -- the optional bool specifies if the
            input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
            not provided it is assumed the input is &#34;normal&#34; (not hidden)
        failed_when_contains: list of strings that, if present in final output, represent a
            failed command/interaction
        privilege_level: name of the privilege level to operate in

    Returns:
        Response: scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    if privilege_level:
        resolved_privilege_level = self._get_privilege_level_name(
            requested_priv=privilege_level
        )
    else:
        resolved_privilege_level = self.default_desired_privilege_level

    if self._current_priv_level.name != resolved_privilege_level:
        await self.acquire_priv(desired_priv=resolved_privilege_level)
    response = await super().send_interactive(
        interact_events=interact_events, failed_when_contains=failed_when_contains
    )
    self._update_response(response=response)

    return response</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver.close" href="async_driver.html#scrapli.driver.async_driver.AsyncScrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver.get_prompt" href="async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver.isalive" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver.open" href="async_driver.html#scrapli.driver.async_driver.AsyncScrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver.send_commands_from_file" href="async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
</ul>
</li>
<li><code><b><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session">register_configuration_session</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.AsyncScrape"><code class="flex name class">
<span>class <span class="ident">AsyncScrape</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>AsyncScrape Object</p>
<p>AsyncScrape is the base class for AsyncNetworkDriver, and subsequent async platform specific
drivers (i.e. AsyncIOSXEDriver). AsyncScrape can be used on its own and offers a
semi-pexpect like experience in that it doesn't know or care about privilege levels,
platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments to pass to <code>ScrapeBase</code> &ndash; see <code>ScrapeBase</code> for available args</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncScrape(ScrapeBase):
    def __init__(self, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;
        AsyncScrape Object

        AsyncScrape is the base class for AsyncNetworkDriver, and subsequent async platform specific
        drivers (i.e. AsyncIOSXEDriver). AsyncScrape can be used on its own and offers a
        semi-pexpect like experience in that it doesn&#39;t know or care about privilege levels,
        platform types, and things like that.

        *Note* most arguments passed to Scrape do not actually get assigned to the scrape object
        itself, but instead are used to construct the Transport and Channel classes that Scrape
        relies on, see Transport and Channel docs for details.

        Args:
            kwargs: Keyword arguments to pass to `ScrapeBase` -- see `ScrapeBase` for available args

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.channel = AsyncChannel(transport=self.transport, **self.channel_args)

    async def __aenter__(self) -&gt; &#34;AsyncScrape&#34;:
        &#34;&#34;&#34;
        Enter method for context manager

        Args:
            N/A

        Returns:
            self: instance of self

        Raises:
            N/A

        &#34;&#34;&#34;
        await self.open()
        return self

    async def __aexit__(
        self,
        exception_type: Optional[Type[BaseException]],
        exception_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        &#34;&#34;&#34;
        Exit method to cleanup for context manager

        Args:
            exception_type: exception type being raised
            exception_value: message from exception being raised
            traceback: traceback from exception being raised

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        await self.close()

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open Transport (socket/session) and establish channel

        If on_open callable provided, execute that callable after opening connection

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        await self.transport.open()
        if self.on_open:
            await self.on_open(self)
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    async def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close Transport (socket/session)

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        if self.on_close:
            await self.on_close(self)
        self.transport.close()
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.AsyncScrape.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close Transport (socket/session)</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;
    Close Transport (socket/session)

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    if self.on_close:
        await self.on_close(self)
    self.transport.close()
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.AsyncScrape.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open Transport (socket/session) and establish channel</p>
<p>If on_open callable provided, execute that callable after opening connection</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open Transport (socket/session) and establish channel

    If on_open callable provided, execute that callable after opening connection

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    await self.transport.open()
    if self.on_open:
        await self.on_open(self)
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.base_driver.ScrapeBase.isalive" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.GenericDriver"><code class="flex name class">
<span>class <span class="ident">GenericDriver</span></span>
<span>(</span><span>comms_prompt_pattern: str = &#x27;^\\S{0,48}[#&gt;$~@:\\]]\\s*$&#x27;, comms_ansi: bool = True, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code><a title="scrapli.driver.Scrape" href="#scrapli.driver.Scrape">Scrape</a></code> object from that perspective.</p>
<p>GenericDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
For this GenericDriver the prompt pattern matches a really wide range of things&hellip;
the general pattern is start of line, match any character 0-32 times, then match a
prompt termination character from the following character set: <code>#</code>, <code>&gt;</code>, <code>$</code>, <code>~</code>,
<code>@</code>, <code>:</code>, <code>]</code>, finally match any or no whitespace till the end of the line. This
pattern works on all of the "core" platforms and should work on a wide range of
other devices, however because it is so broad it may also accidentally match too
many things and cause issues, so be careful!</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; in the case of the
GenericDriver, always strip ansi; this may slow things down but will hopefully help
prevent issues! Obviously can be overridden if desired.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericDriver(Scrape, GenericDriverBase):
    def __init__(
        self,
        comms_prompt_pattern: str = r&#34;^\S{0,48}[#&gt;$~@:\]]\s*$&#34;,
        comms_ansi: bool = True,
        **kwargs: Any,
    ):
        &#34;&#34;&#34;
        GenericDriver Object

        Args:
            comms_prompt_pattern: raw string regex pattern -- preferably use `^` and `$` anchors!
                this is the single most important attribute here! if this does not match a prompt,
                scrapli will not work!
                For this GenericDriver the prompt pattern matches a really wide range of things...
                the general pattern is start of line, match any character 0-32 times, then match a
                prompt termination character from the following character set: `#`, `&gt;`, `$`, `~`,
                `@`, `:`, `]`, finally match any or no whitespace till the end of the line. This
                pattern works on all of the &#34;core&#34; platforms and should work on a wide range of
                other devices, however because it is so broad it may also accidentally match too
                many things and cause issues, so be careful!
            comms_ansi: True/False strip comms_ansi characters from output; in the case of the
                GenericDriver, always strip ansi; this may slow things down but will hopefully help
                prevent issues! Obviously can be overridden if desired.
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A
        &#34;&#34;&#34;
        super().__init__(comms_prompt_pattern=comms_prompt_pattern, comms_ansi=comms_ansi, **kwargs)
        self.channel: Channel

    def send_command(
        self,
        command: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_send_command(
            host=self.transport.host, command=command, failed_when_contains=failed_when_contains
        )
        raw_response, processed_response = self.channel.send_input(
            channel_input=command, strip_prompt=strip_prompt
        )
        return self._post_send_command(
            raw_response=raw_response, processed_response=processed_response, response=response
        )

    def send_commands(
        self,
        commands: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send multiple commands

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        responses = self._pre_send_commands(commands=commands)
        for command in commands:
            response = self.send_command(
                command=command,
                strip_prompt=strip_prompt,
                failed_when_contains=failed_when_contains,
            )
            responses.append(response)
            if stop_on_failed is True and response.failed is True:
                return responses

        return responses

    def send_commands_from_file(
        self,
        file: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send command(s) from file

        Args:
            file: string path to file
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        commands = self._pre_send_commands_from_file(file=file)

        return self.send_commands(
            commands=commands,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
        )

    def send_interactive(
        self,
        interact_events: List[Tuple[str, str, Optional[bool]]],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Interact with a device with changing prompts per input.

        Used to interact with devices where prompts change per input, and where inputs may be hidden
        such as in the case of a password input. This can be used to respond to challenges from
        devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
        example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
        element of that list should be a tuple of two or three elements. The first element is always
        the input to send as a string, the second should be the expected response as a string, and
        the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

        An example where we need this sort of capability:

        ```
        3560CX#copy flash: scp:
        Source filename []? test1.txt
        Address or name of remote host []? 172.31.254.100
        Destination username [carl]?
        Writing test1.txt
        Password:

        Password:
         Sink: C0644 639 test1.txt
        !
        639 bytes copied in 12.066 secs (53 bytes/sec)
        3560CX#
        ```

        To accomplish this we can use the following:

        ```
        interact = conn.channel.send_inputs_interact(
            [
                (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
                (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
                (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
                (&#34;carl&#34;, &#34;Password:&#34;, False),
                (&#34;super_secure_password&#34;, prompt, True),
            ]
        )
        ```

        If we needed to deal with more prompts we could simply continue adding tuples to the list of
        interact &#34;events&#34;.

        Args:
            interact_events: list of tuples containing the &#34;interactions&#34; with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
                not provided it is assumed the input is &#34;normal&#34; (not hidden)
            failed_when_contains: list of strings that, if present in final output, represent a
                failed command/interaction
            privilege_level: ignored in this base class; for LSP reasons for subclasses

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        _ = privilege_level

        response = self._pre_send_interactive(
            host=self.transport.host,
            interact_events=interact_events,
            failed_when_contains=failed_when_contains,
        )
        raw_response, processed_response = self.channel.send_inputs_interact(
            interact_events=interact_events
        )
        return self._post_send_command(
            raw_response=raw_response, processed_response=processed_response, response=response
        )

    def get_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Convenience method to get device prompt from Channel

        Args:
            N/A

        Returns:
            str: prompt received from channel.get_prompt

        Raises:
            N/A

        &#34;&#34;&#34;
        prompt: str = self.channel.get_prompt()
        return prompt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.network_driver.NetworkDriver" href="network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.GenericDriver.get_prompt"><code class="name flex">
<span>def <span class="ident">get_prompt</span></span>(<span>self) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method to get device prompt from Channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>prompt received from channel.get_prompt</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prompt(self) -&gt; str:
    &#34;&#34;&#34;
    Convenience method to get device prompt from Channel

    Args:
        N/A

    Returns:
        str: prompt received from channel.get_prompt

    Raises:
        N/A

    &#34;&#34;&#34;
    prompt: str = self.channel.get_prompt()
    return prompt</code></pre>
</details>
</dd>
<dt id="scrapli.driver.GenericDriver.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None) -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send a command</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(
    self,
    command: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; Response:
    &#34;&#34;&#34;
    Send a command

    Args:
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        Response: Scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_send_command(
        host=self.transport.host, command=command, failed_when_contains=failed_when_contains
    )
    raw_response, processed_response = self.channel.send_input(
        channel_input=command, strip_prompt=strip_prompt
    )
    return self._post_send_command(
        raw_response=raw_response, processed_response=processed_response, response=response
    )</code></pre>
</details>
</dd>
<dt id="scrapli.driver.GenericDriver.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>self, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False) -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send multiple commands</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(
    self,
    commands: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send multiple commands

    Args:
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    responses = self._pre_send_commands(commands=commands)
    for command in commands:
        response = self.send_command(
            command=command,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
        )
        responses.append(response)
        if stop_on_failed is True and response.failed is True:
            return responses

    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.GenericDriver.send_commands_from_file"><code class="name flex">
<span>def <span class="ident">send_commands_from_file</span></span>(<span>self, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False) -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send command(s) from file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>string path to file</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands_from_file(
    self,
    file: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send command(s) from file

    Args:
        file: string path to file
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    commands = self._pre_send_commands_from_file(file=file)

    return self.send_commands(
        commands=commands,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
    )</code></pre>
</details>
</dd>
<dt id="scrapli.driver.GenericDriver.send_interactive"><code class="name flex">
<span>def <span class="ident">send_interactive</span></span>(<span>self, interact_events: List[Tuple[str, str, Union[bool, NoneType]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '') -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Interact with a device with changing prompts per input.</p>
<p>Used to interact with devices where prompts change per input, and where inputs may be hidden
such as in the case of a password input. This can be used to respond to challenges from
devices such as the confirmation for the command "clear logging" on IOSXE devices for
example. You may have as many elements in the "interact_events" list as needed, and each
element of that list should be a tuple of two or three elements. The first element is always
the input to send as a string, the second should be the expected response as a string, and
the optional third a bool for whether or not the input is "hidden" (i.e. password input)</p>
<p>An example where we need this sort of capability:</p>
<pre><code>3560CX#copy flash: scp:
Source filename []? test1.txt
Address or name of remote host []? 172.31.254.100
Destination username [carl]?
Writing test1.txt
Password:

Password:
 Sink: C0644 639 test1.txt
!
639 bytes copied in 12.066 secs (53 bytes/sec)
3560CX#
</code></pre>
<p>To accomplish this we can use the following:</p>
<pre><code>interact = conn.channel.send_inputs_interact(
    [
        (&quot;copy flash: scp:&quot;, &quot;Source filename []?&quot;, False),
        (&quot;test1.txt&quot;, &quot;Address or name of remote host []?&quot;, False),
        (&quot;172.31.254.100&quot;, &quot;Destination username [carl]?&quot;, False),
        (&quot;carl&quot;, &quot;Password:&quot;, False),
        (&quot;super_secure_password&quot;, prompt, True),
    ]
)
</code></pre>
<p>If we needed to deal with more prompts we could simply continue adding tuples to the list of
interact "events".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interact_events</code></strong></dt>
<dd>list of tuples containing the "interactions" with the device
each list element must have an input and an expected response, and may have an
optional bool for the third and final element &ndash; the optional bool specifies if the
input that is sent to the device is "hidden" (ex: password), if the hidden param is
not provided it is assumed the input is "normal" (not hidden)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that, if present in final output, represent a
failed command/interaction</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>ignored in this base class; for LSP reasons for subclasses</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_interactive(
    self,
    interact_events: List[Tuple[str, str, Optional[bool]]],
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    privilege_level: str = &#34;&#34;,
) -&gt; Response:
    &#34;&#34;&#34;
    Interact with a device with changing prompts per input.

    Used to interact with devices where prompts change per input, and where inputs may be hidden
    such as in the case of a password input. This can be used to respond to challenges from
    devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
    example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
    element of that list should be a tuple of two or three elements. The first element is always
    the input to send as a string, the second should be the expected response as a string, and
    the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

    An example where we need this sort of capability:

    ```
    3560CX#copy flash: scp:
    Source filename []? test1.txt
    Address or name of remote host []? 172.31.254.100
    Destination username [carl]?
    Writing test1.txt
    Password:

    Password:
     Sink: C0644 639 test1.txt
    !
    639 bytes copied in 12.066 secs (53 bytes/sec)
    3560CX#
    ```

    To accomplish this we can use the following:

    ```
    interact = conn.channel.send_inputs_interact(
        [
            (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
            (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
            (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
            (&#34;carl&#34;, &#34;Password:&#34;, False),
            (&#34;super_secure_password&#34;, prompt, True),
        ]
    )
    ```

    If we needed to deal with more prompts we could simply continue adding tuples to the list of
    interact &#34;events&#34;.

    Args:
        interact_events: list of tuples containing the &#34;interactions&#34; with the device
            each list element must have an input and an expected response, and may have an
            optional bool for the third and final element -- the optional bool specifies if the
            input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
            not provided it is assumed the input is &#34;normal&#34; (not hidden)
        failed_when_contains: list of strings that, if present in final output, represent a
            failed command/interaction
        privilege_level: ignored in this base class; for LSP reasons for subclasses

    Returns:
        Response: scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    _ = privilege_level

    response = self._pre_send_interactive(
        host=self.transport.host,
        interact_events=interact_events,
        failed_when_contains=failed_when_contains,
    )
    raw_response, processed_response = self.channel.send_inputs_interact(
        interact_events=interact_events
    )
    return self._post_send_command(
        raw_response=raw_response, processed_response=processed_response, response=response
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.driver.Scrape.close" href="driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.driver.Scrape.isalive" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.driver.Scrape.open" href="driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.NetworkDriver"><code class="flex name class">
<span>class <span class="ident">NetworkDriver</span></span>
<span>(</span><span>privilege_levels: Dict[str, scrapli.driver.base_network_driver.PrivilegeLevel], default_desired_privilege_level: str, auth_secondary: str = '', failed_when_contains: Union[List[str], NoneType] = None, textfsm_platform: str = '', genie_platform: str = '', **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code><a title="scrapli.driver.Scrape" href="#scrapli.driver.Scrape">Scrape</a></code> object from that perspective.</p>
<p>BaseNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>Dict of privilege levels for a given platform</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that indicate a command/configuration has failed</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of platform to use for textfsm parsing</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of platform to use for genie parsing</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkDriver(GenericDriver, NetworkDriverBase):
    def __init__(
        self,
        privilege_levels: Dict[str, PrivilegeLevel],
        default_desired_privilege_level: str,
        auth_secondary: str = &#34;&#34;,
        failed_when_contains: Optional[List[str]] = None,
        textfsm_platform: str = &#34;&#34;,
        genie_platform: str = &#34;&#34;,
        **kwargs: Any,
    ):
        &#34;&#34;&#34;
        BaseNetworkDriver Object

        Args:
            privilege_levels: Dict of privilege levels for a given platform
            default_desired_privilege_level: string of name of default desired priv, this is the
                priv level that is generally used to disable paging/set terminal width and things
                like that upon first login, and is also the priv level scrapli will try to acquire
                for normal &#34;command&#34; operations (`send_command`, `send_commands`)
            auth_secondary: password to use for secondary authentication (enable)
            failed_when_contains: list of strings that indicate a command/configuration has failed
            textfsm_platform: string name of platform to use for textfsm parsing
            genie_platform: string name of platform to use for genie parsing
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._check_kwargs_comms_prompt_pattern(kwargs=kwargs)

        self.auth_secondary = auth_secondary
        self.privilege_levels = privilege_levels
        self._priv_map = {}
        self.default_desired_privilege_level = default_desired_privilege_level
        self.update_privilege_levels(update_channel=False)

        self.textfsm_platform = textfsm_platform
        self.genie_platform = genie_platform
        self.failed_when_contains = failed_when_contains or []

        super().__init__(comms_prompt_pattern=self.comms_prompt_pattern, **kwargs)

    def _escalate(self, escalate_priv: PrivilegeLevel) -&gt; None:
        &#34;&#34;&#34;
        Escalate to the next privilege level up

        Args:
            escalate_priv: privilege level to escalate to

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._pre_escalate(escalate_priv=escalate_priv)

        if escalate_priv.escalate_auth is True:
            super().send_interactive(
                interact_events=[
                    (escalate_priv.escalate, escalate_priv.escalate_prompt, False),
                    (self.auth_secondary, escalate_priv.pattern, True),
                ],
            )
        else:
            self.channel.send_input(channel_input=escalate_priv.escalate)

    def _deescalate(self, current_priv: PrivilegeLevel) -&gt; None:
        &#34;&#34;&#34;
        Deescalate to the next privilege level down

        Args:
            current_priv: current privilege level

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.channel.send_input(channel_input=current_priv.deescalate)

    def acquire_priv(self, desired_priv: str) -&gt; None:
        &#34;&#34;&#34;
        Acquire desired priv level

        Args:
            desired_priv: string name of desired privilege level see
                `scrapli.driver.&lt;driver_category.device_type&gt;.driver` for levels

        Returns:
            N/A  # noqa: DAR202

        Raises:
            CouldNotAcquirePrivLevel: if desired_priv cannot be attained

        &#34;&#34;&#34;
        resolved_priv, map_to_desired_priv = self._pre_acquire_priv(desired_priv=desired_priv)

        privilege_change_count = 0
        while True:
            current_prompt = self.channel.get_prompt()
            privilege_action, target_priv = self._process_acquire_priv(
                resolved_priv=resolved_priv,
                map_to_desired_priv=map_to_desired_priv,
                current_prompt=current_prompt,
            )

            if privilege_action == PrivilegeAction.NO_ACTION:
                self._current_priv_level = target_priv
                return
            if privilege_action == PrivilegeAction.DEESCALATE:
                self._deescalate(current_priv=target_priv)
            if privilege_action == PrivilegeAction.ESCALATE:
                self._escalate(escalate_priv=target_priv)

            privilege_change_count += 1
            if privilege_change_count &gt; len(self.privilege_levels) * 2:
                msg = f&#34;Failed to acquire requested privilege level {resolved_priv}&#34;
                raise CouldNotAcquirePrivLevel(msg)

    def send_command(
        self,
        command: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Super method will raise TypeError if anything but a string is passed here!

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_privilege_level:
            self.acquire_priv(desired_priv=self.default_desired_privilege_level)

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        response = super().send_command(
            command=command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
        )

        self._update_response(response)

        return response

    def send_commands(
        self,
        commands: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send multiple commands

        Super method will raise TypeError if anything but a list of strings is passed here!

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_privilege_level:
            self.acquire_priv(desired_priv=self.default_desired_privilege_level)

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        responses = super().send_commands(
            commands=commands,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
        )

        for response in responses:
            self._update_response(response=response)

        return responses

    def send_commands_from_file(
        self,
        file: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send command(s) from file

        Args:
            file: string path to file
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        commands = self._pre_send_commands_from_file(file=file)

        return self.send_commands(
            commands=commands,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
        )

    def send_interactive(
        self,
        interact_events: List[Tuple[str, str, Optional[bool]]],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Interact with a device with changing prompts per input.

        Used to interact with devices where prompts change per input, and where inputs may be hidden
        such as in the case of a password input. This can be used to respond to challenges from
        devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
        example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
        element of that list should be a tuple of two or three elements. The first element is always
        the input to send as a string, the second should be the expected response as a string, and
        the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

        An example where we need this sort of capability:

        ```
        3560CX#copy flash: scp:
        Source filename []? test1.txt
        Address or name of remote host []? 172.31.254.100
        Destination username [carl]?
        Writing test1.txt
        Password:

        Password:
         Sink: C0644 639 test1.txt
        !
        639 bytes copied in 12.066 secs (53 bytes/sec)
        3560CX#
        ```

        To accomplish this we can use the following:

        ```
        interact = conn.channel.send_inputs_interact(
            [
                (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
                (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
                (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
                (&#34;carl&#34;, &#34;Password:&#34;, False),
                (&#34;super_secure_password&#34;, prompt, True),
            ]
        )
        ```

        If we needed to deal with more prompts we could simply continue adding tuples to the list of
        interact &#34;events&#34;.

        Args:
            interact_events: list of tuples containing the &#34;interactions&#34; with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
                not provided it is assumed the input is &#34;normal&#34; (not hidden)
            failed_when_contains: list of strings that, if present in final output, represent a
                failed command/interaction
            privilege_level: name of the privilege level to operate in

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if privilege_level:
            resolved_privilege_level = self._get_privilege_level_name(
                requested_priv=privilege_level
            )
        else:
            resolved_privilege_level = self.default_desired_privilege_level

        if self._current_priv_level.name != resolved_privilege_level:
            self.acquire_priv(desired_priv=resolved_privilege_level)
        response = super().send_interactive(
            interact_events=interact_events, failed_when_contains=failed_when_contains
        )
        self._update_response(response=response)

        return response

    def _abort_config(self) -&gt; None:
        &#34;&#34;&#34;
        Abort a configuration operation/session if applicable (for config sessions like junos/iosxr)

        Args:
            N/A

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def send_config(
        self,
        config: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            config: string configuration to send to the device, supports sending multi-line strings
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution; aborts configuration session if applicable (iosxr/junos or
                eos/nxos if using a configuration session)
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
                JunosDriver. You can also pass in a name of a configuration session such as
                &#34;my-config-session&#34; if you have registered a session using the
                &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        split_config = self._pre_send_config(config=config)

        # now that we have a list of configs, just use send_configs to actually execute them
        multi_response = self.send_configs(
            configs=split_config,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
            privilege_level=privilege_level,
        )
        return self._post_send_config(config=config, multi_response=multi_response)

    def send_configs(
        self,
        configs: List[str],
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
        privilege_level: str = &#34;&#34;,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            configs: list of strings to send to device in config mode
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution; aborts configuration session if applicable (iosxr/junos or
                eos/nxos if using a configuration session)
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
                JunosDriver. You can also pass in a name of a configuration session such as
                &#34;my-config-session&#34; if you have registered a session using the
                &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        resolved_privilege_level, failed_when_contains = self._pre_send_configs(
            configs=configs,
            failed_when_contains=failed_when_contains,
            privilege_level=privilege_level,
        )

        if self._current_priv_level.name != resolved_privilege_level:
            self.acquire_priv(desired_priv=resolved_privilege_level)

        responses = MultiResponse()
        _failed_during_execution = False
        for config in configs:
            response = super().send_command(
                command=config,
                strip_prompt=strip_prompt,
                failed_when_contains=failed_when_contains,
            )
            responses.append(response)
            if response.failed is True:
                _failed_during_execution = True
                if stop_on_failed is True:
                    break

        if _failed_during_execution is True:
            self._abort_config()

        return self._post_send_configs(responses=responses)

    def send_configs_from_file(
        self,
        file: str,
        strip_prompt: bool = True,
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        stop_on_failed: bool = False,
        privilege_level: str = &#34;&#34;,
    ) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Send configuration(s) from a file

        Args:
            file: string path to file
            strip_prompt: True/False strip prompt from returned output
            failed_when_contains: string or list of strings indicating failure if found in response
            stop_on_failed: True/False stop executing commands if a command fails, returns results
                as of current execution; aborts configuration session if applicable (iosxr/junos or
                eos/nxos if using a configuration session)
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;exclusive&#34; for IOSXRDriver, &#34;private&#34; for JunosDriver. You can also pass
                in a name of a configuration session such as &#34;session_mysession&#34; if you have
                registered a session using the &#34;register_config_session&#34; method of the EOSDriver or
                NXOSDriver.

        Returns:
            ScrapliMultiResponse: Scrapli MultiResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        configs = self._pre_send_configs_from_file(file=file)

        return self.send_configs(
            configs=configs,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
            stop_on_failed=stop_on_failed,
            privilege_level=privilege_level,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
<li><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.core.arista_eos.driver.EOSDriver" href="core/arista_eos/driver.html#scrapli.driver.core.arista_eos.driver.EOSDriver">EOSDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxe.driver.IOSXEDriver" href="core/cisco_iosxe/driver.html#scrapli.driver.core.cisco_iosxe.driver.IOSXEDriver">IOSXEDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxr.driver.IOSXRDriver" href="core/cisco_iosxr/driver.html#scrapli.driver.core.cisco_iosxr.driver.IOSXRDriver">IOSXRDriver</a></li>
<li><a title="scrapli.driver.core.cisco_nxos.driver.NXOSDriver" href="core/cisco_nxos/driver.html#scrapli.driver.core.cisco_nxos.driver.NXOSDriver">NXOSDriver</a></li>
<li><a title="scrapli.driver.core.juniper_junos.driver.JunosDriver" href="core/juniper_junos/driver.html#scrapli.driver.core.juniper_junos.driver.JunosDriver">JunosDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.NetworkDriver.acquire_priv"><code class="name flex">
<span>def <span class="ident">acquire_priv</span></span>(<span>self, desired_priv: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Acquire desired priv level</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>desired_priv</code></strong></dt>
<dd>string name of desired privilege level see
<code>scrapli.driver.&lt;driver_category.device_type&gt;.driver</code> for levels</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CouldNotAcquirePrivLevel</code></dt>
<dd>if desired_priv cannot be attained</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_priv(self, desired_priv: str) -&gt; None:
    &#34;&#34;&#34;
    Acquire desired priv level

    Args:
        desired_priv: string name of desired privilege level see
            `scrapli.driver.&lt;driver_category.device_type&gt;.driver` for levels

    Returns:
        N/A  # noqa: DAR202

    Raises:
        CouldNotAcquirePrivLevel: if desired_priv cannot be attained

    &#34;&#34;&#34;
    resolved_priv, map_to_desired_priv = self._pre_acquire_priv(desired_priv=desired_priv)

    privilege_change_count = 0
    while True:
        current_prompt = self.channel.get_prompt()
        privilege_action, target_priv = self._process_acquire_priv(
            resolved_priv=resolved_priv,
            map_to_desired_priv=map_to_desired_priv,
            current_prompt=current_prompt,
        )

        if privilege_action == PrivilegeAction.NO_ACTION:
            self._current_priv_level = target_priv
            return
        if privilege_action == PrivilegeAction.DEESCALATE:
            self._deescalate(current_priv=target_priv)
        if privilege_action == PrivilegeAction.ESCALATE:
            self._escalate(escalate_priv=target_priv)

        privilege_change_count += 1
        if privilege_change_count &gt; len(self.privilege_levels) * 2:
            msg = f&#34;Failed to acquire requested privilege level {resolved_priv}&#34;
            raise CouldNotAcquirePrivLevel(msg)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None) -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send a command</p>
<p>Super method will raise TypeError if anything but a string is passed here!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(
    self,
    command: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
) -&gt; Response:
    &#34;&#34;&#34;
    Send a command

    Super method will raise TypeError if anything but a string is passed here!

    Args:
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response

    Returns:
        Response: Scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._current_priv_level.name != self.default_desired_privilege_level:
        self.acquire_priv(desired_priv=self.default_desired_privilege_level)

    if failed_when_contains is None:
        failed_when_contains = self.failed_when_contains

    response = super().send_command(
        command=command, strip_prompt=strip_prompt, failed_when_contains=failed_when_contains
    )

    self._update_response(response)

    return response</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>self, commands: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False) -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send multiple commands</p>
<p>Super method will raise TypeError if anything but a list of strings is passed here!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(
    self,
    commands: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send multiple commands

    Super method will raise TypeError if anything but a list of strings is passed here!

    Args:
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._current_priv_level.name != self.default_desired_privilege_level:
        self.acquire_priv(desired_priv=self.default_desired_privilege_level)

    if failed_when_contains is None:
        failed_when_contains = self.failed_when_contains

    responses = super().send_commands(
        commands=commands,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
    )

    for response in responses:
        self._update_response(response=response)

    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_config"><code class="name flex">
<span>def <span class="ident">send_config</span></span>(<span>self, config: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '') -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>string configuration to send to the device, supports sending multi-line strings</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution; aborts configuration session if applicable (iosxr/junos or
eos/nxos if using a configuration session)</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "configuration_exclusive" for IOSXRDriver, or "configuration_private" for
JunosDriver. You can also pass in a name of a configuration session such as
"my-config-session" if you have registered a session using the
"register_config_session" method of the EOSDriver or NXOSDriver.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_config(
    self,
    config: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
) -&gt; Response:
    &#34;&#34;&#34;
    Send configuration(s)

    Args:
        config: string configuration to send to the device, supports sending multi-line strings
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution; aborts configuration session if applicable (iosxr/junos or
            eos/nxos if using a configuration session)
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
            JunosDriver. You can also pass in a name of a configuration session such as
            &#34;my-config-session&#34; if you have registered a session using the
            &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

    Returns:
        Response: Scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    split_config = self._pre_send_config(config=config)

    # now that we have a list of configs, just use send_configs to actually execute them
    multi_response = self.send_configs(
        configs=split_config,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        privilege_level=privilege_level,
    )
    return self._post_send_config(config=config, multi_response=multi_response)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_configs"><code class="name flex">
<span>def <span class="ident">send_configs</span></span>(<span>self, configs: List[str], strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '') -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>configs</code></strong></dt>
<dd>list of strings to send to device in config mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution; aborts configuration session if applicable (iosxr/junos or
eos/nxos if using a configuration session)</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "configuration_exclusive" for IOSXRDriver, or "configuration_private" for
JunosDriver. You can also pass in a name of a configuration session such as
"my-config-session" if you have registered a session using the
"register_config_session" method of the EOSDriver or NXOSDriver.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_configs(
    self,
    configs: List[str],
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send configuration(s)

    Args:
        configs: list of strings to send to device in config mode
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution; aborts configuration session if applicable (iosxr/junos or
            eos/nxos if using a configuration session)
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
            JunosDriver. You can also pass in a name of a configuration session such as
            &#34;my-config-session&#34; if you have registered a session using the
            &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    resolved_privilege_level, failed_when_contains = self._pre_send_configs(
        configs=configs,
        failed_when_contains=failed_when_contains,
        privilege_level=privilege_level,
    )

    if self._current_priv_level.name != resolved_privilege_level:
        self.acquire_priv(desired_priv=resolved_privilege_level)

    responses = MultiResponse()
    _failed_during_execution = False
    for config in configs:
        response = super().send_command(
            command=config,
            strip_prompt=strip_prompt,
            failed_when_contains=failed_when_contains,
        )
        responses.append(response)
        if response.failed is True:
            _failed_during_execution = True
            if stop_on_failed is True:
                break

    if _failed_during_execution is True:
        self._abort_config()

    return self._post_send_configs(responses=responses)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_configs_from_file"><code class="name flex">
<span>def <span class="ident">send_configs_from_file</span></span>(<span>self, file: str, strip_prompt: bool = True, failed_when_contains: Union[str, List[str], NoneType] = None, stop_on_failed: bool = False, privilege_level: str = '') -> collections.UserList</span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration(s) from a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>string path to file</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>string or list of strings indicating failure if found in response</dd>
<dt><strong><code>stop_on_failed</code></strong></dt>
<dd>True/False stop executing commands if a command fails, returns results
as of current execution; aborts configuration session if applicable (iosxr/junos or
eos/nxos if using a configuration session)</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of configuration privilege level/type to acquire; this is platform
dependent, so check the device driver for specifics. Examples of privilege_name
would be "exclusive" for IOSXRDriver, "private" for JunosDriver. You can also pass
in a name of a configuration session such as "session_mysession" if you have
registered a session using the "register_config_session" method of the EOSDriver or
NXOSDriver.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScrapliMultiResponse</code></dt>
<dd>Scrapli MultiResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_configs_from_file(
    self,
    file: str,
    strip_prompt: bool = True,
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    stop_on_failed: bool = False,
    privilege_level: str = &#34;&#34;,
) -&gt; ScrapliMultiResponse:
    &#34;&#34;&#34;
    Send configuration(s) from a file

    Args:
        file: string path to file
        strip_prompt: True/False strip prompt from returned output
        failed_when_contains: string or list of strings indicating failure if found in response
        stop_on_failed: True/False stop executing commands if a command fails, returns results
            as of current execution; aborts configuration session if applicable (iosxr/junos or
            eos/nxos if using a configuration session)
        privilege_level: name of configuration privilege level/type to acquire; this is platform
            dependent, so check the device driver for specifics. Examples of privilege_name
            would be &#34;exclusive&#34; for IOSXRDriver, &#34;private&#34; for JunosDriver. You can also pass
            in a name of a configuration session such as &#34;session_mysession&#34; if you have
            registered a session using the &#34;register_config_session&#34; method of the EOSDriver or
            NXOSDriver.

    Returns:
        ScrapliMultiResponse: Scrapli MultiResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    configs = self._pre_send_configs_from_file(file=file)

    return self.send_configs(
        configs=configs,
        strip_prompt=strip_prompt,
        failed_when_contains=failed_when_contains,
        stop_on_failed=stop_on_failed,
        privilege_level=privilege_level,
    )</code></pre>
</details>
</dd>
<dt id="scrapli.driver.NetworkDriver.send_interactive"><code class="name flex">
<span>def <span class="ident">send_interactive</span></span>(<span>self, interact_events: List[Tuple[str, str, Union[bool, NoneType]]], failed_when_contains: Union[str, List[str], NoneType] = None, privilege_level: str = '') -> <a title="scrapli.response.Response" href="../response.html#scrapli.response.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Interact with a device with changing prompts per input.</p>
<p>Used to interact with devices where prompts change per input, and where inputs may be hidden
such as in the case of a password input. This can be used to respond to challenges from
devices such as the confirmation for the command "clear logging" on IOSXE devices for
example. You may have as many elements in the "interact_events" list as needed, and each
element of that list should be a tuple of two or three elements. The first element is always
the input to send as a string, the second should be the expected response as a string, and
the optional third a bool for whether or not the input is "hidden" (i.e. password input)</p>
<p>An example where we need this sort of capability:</p>
<pre><code>3560CX#copy flash: scp:
Source filename []? test1.txt
Address or name of remote host []? 172.31.254.100
Destination username [carl]?
Writing test1.txt
Password:

Password:
 Sink: C0644 639 test1.txt
!
639 bytes copied in 12.066 secs (53 bytes/sec)
3560CX#
</code></pre>
<p>To accomplish this we can use the following:</p>
<pre><code>interact = conn.channel.send_inputs_interact(
    [
        (&quot;copy flash: scp:&quot;, &quot;Source filename []?&quot;, False),
        (&quot;test1.txt&quot;, &quot;Address or name of remote host []?&quot;, False),
        (&quot;172.31.254.100&quot;, &quot;Destination username [carl]?&quot;, False),
        (&quot;carl&quot;, &quot;Password:&quot;, False),
        (&quot;super_secure_password&quot;, prompt, True),
    ]
)
</code></pre>
<p>If we needed to deal with more prompts we could simply continue adding tuples to the list of
interact "events".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interact_events</code></strong></dt>
<dd>list of tuples containing the "interactions" with the device
each list element must have an input and an expected response, and may have an
optional bool for the third and final element &ndash; the optional bool specifies if the
input that is sent to the device is "hidden" (ex: password), if the hidden param is
not provided it is assumed the input is "normal" (not hidden)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that, if present in final output, represent a
failed command/interaction</dd>
<dt><strong><code>privilege_level</code></strong></dt>
<dd>name of the privilege level to operate in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_interactive(
    self,
    interact_events: List[Tuple[str, str, Optional[bool]]],
    failed_when_contains: Optional[Union[str, List[str]]] = None,
    privilege_level: str = &#34;&#34;,
) -&gt; Response:
    &#34;&#34;&#34;
    Interact with a device with changing prompts per input.

    Used to interact with devices where prompts change per input, and where inputs may be hidden
    such as in the case of a password input. This can be used to respond to challenges from
    devices such as the confirmation for the command &#34;clear logging&#34; on IOSXE devices for
    example. You may have as many elements in the &#34;interact_events&#34; list as needed, and each
    element of that list should be a tuple of two or three elements. The first element is always
    the input to send as a string, the second should be the expected response as a string, and
    the optional third a bool for whether or not the input is &#34;hidden&#34; (i.e. password input)

    An example where we need this sort of capability:

    ```
    3560CX#copy flash: scp:
    Source filename []? test1.txt
    Address or name of remote host []? 172.31.254.100
    Destination username [carl]?
    Writing test1.txt
    Password:

    Password:
     Sink: C0644 639 test1.txt
    !
    639 bytes copied in 12.066 secs (53 bytes/sec)
    3560CX#
    ```

    To accomplish this we can use the following:

    ```
    interact = conn.channel.send_inputs_interact(
        [
            (&#34;copy flash: scp:&#34;, &#34;Source filename []?&#34;, False),
            (&#34;test1.txt&#34;, &#34;Address or name of remote host []?&#34;, False),
            (&#34;172.31.254.100&#34;, &#34;Destination username [carl]?&#34;, False),
            (&#34;carl&#34;, &#34;Password:&#34;, False),
            (&#34;super_secure_password&#34;, prompt, True),
        ]
    )
    ```

    If we needed to deal with more prompts we could simply continue adding tuples to the list of
    interact &#34;events&#34;.

    Args:
        interact_events: list of tuples containing the &#34;interactions&#34; with the device
            each list element must have an input and an expected response, and may have an
            optional bool for the third and final element -- the optional bool specifies if the
            input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
            not provided it is assumed the input is &#34;normal&#34; (not hidden)
        failed_when_contains: list of strings that, if present in final output, represent a
            failed command/interaction
        privilege_level: name of the privilege level to operate in

    Returns:
        Response: scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    if privilege_level:
        resolved_privilege_level = self._get_privilege_level_name(
            requested_priv=privilege_level
        )
    else:
        resolved_privilege_level = self.default_desired_privilege_level

    if self._current_priv_level.name != resolved_privilege_level:
        self.acquire_priv(desired_priv=resolved_privilege_level)
    response = super().send_interactive(
        interact_events=interact_events, failed_when_contains=failed_when_contains
    )
    self._update_response(response=response)

    return response</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.generic_driver.GenericDriver" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.close" href="driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.get_prompt" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.isalive" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.open" href="driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.generic_driver.GenericDriver.send_commands_from_file" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
</ul>
</li>
<li><code><b><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session">register_configuration_session</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels" href="base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.Scrape"><code class="flex name class">
<span>class <span class="ident">Scrape</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Scrape Object</p>
<p>Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
that it doesn't know or care about privilege levels, platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments to pass to <code>ScrapeBase</code> &ndash; see <code>ScrapeBase</code> for available args</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scrape(ScrapeBase):
    def __init__(self, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;
        Scrape Object

        Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
        IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
        that it doesn&#39;t know or care about privilege levels, platform types, and things like that.

        *Note* most arguments passed to Scrape do not actually get assigned to the scrape object
        itself, but instead are used to construct the Transport and Channel classes that Scrape
        relies on, see Transport and Channel docs for details.

        Args:
            kwargs: Keyword arguments to pass to `ScrapeBase` -- see `ScrapeBase` for available args

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.channel = Channel(transport=self.transport, **self.channel_args)

    def __enter__(self) -&gt; &#34;Scrape&#34;:
        &#34;&#34;&#34;
        Enter method for context manager

        Args:
            N/A

        Returns:
            self: instance of self

        Raises:
            N/A

        &#34;&#34;&#34;
        self.open()
        return self

    def __exit__(
        self,
        exception_type: Optional[Type[BaseException]],
        exception_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        &#34;&#34;&#34;
        Exit method to cleanup for context manager

        Args:
            exception_type: exception type being raised
            exception_value: message from exception being raised
            traceback: traceback from exception being raised

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.close()

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open Transport (socket/session) and establish channel

        If on_open callable provided, execute that callable after opening connection

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        self.transport.open()
        if self.on_open:
            self.on_open(self)
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close Transport (socket/session)

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        if self.on_close:
            self.on_close(self)
        self.transport.close()
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.Scrape.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close Transport (socket/session)</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;
    Close Transport (socket/session)

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    if self.on_close:
        self.on_close(self)
    self.transport.close()
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)</code></pre>
</details>
</dd>
<dt id="scrapli.driver.Scrape.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open Transport (socket/session) and establish channel</p>
<p>If on_open callable provided, execute that callable after opening connection</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open Transport (socket/session) and establish channel

    If on_open callable provided, execute that callable after opening connection

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    self.transport.open()
    if self.on_open:
        self.on_open(self)
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.base_driver.ScrapeBase" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.base_driver.ScrapeBase.isalive" href="base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli" href="../index.html">scrapli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli.driver.async_driver" href="async_driver.html">scrapli.driver.async_driver</a></code></li>
<li><code><a title="scrapli.driver.async_generic_driver" href="async_generic_driver.html">scrapli.driver.async_generic_driver</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver" href="async_network_driver.html">scrapli.driver.async_network_driver</a></code></li>
<li><code><a title="scrapli.driver.base_driver" href="base_driver.html">scrapli.driver.base_driver</a></code></li>
<li><code><a title="scrapli.driver.base_generic_driver" href="base_generic_driver.html">scrapli.driver.base_generic_driver</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver" href="base_network_driver.html">scrapli.driver.base_network_driver</a></code></li>
<li><code><a title="scrapli.driver.core" href="core/index.html">scrapli.driver.core</a></code></li>
<li><code><a title="scrapli.driver.driver" href="driver.html">scrapli.driver.driver</a></code></li>
<li><code><a title="scrapli.driver.generic_driver" href="generic_driver.html">scrapli.driver.generic_driver</a></code></li>
<li><code><a title="scrapli.driver.network_driver" href="network_driver.html">scrapli.driver.network_driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.driver.AsyncGenericDriver" href="#scrapli.driver.AsyncGenericDriver">AsyncGenericDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.AsyncGenericDriver.get_prompt" href="#scrapli.driver.AsyncGenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.AsyncGenericDriver.send_command" href="#scrapli.driver.AsyncGenericDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.AsyncGenericDriver.send_commands" href="#scrapli.driver.AsyncGenericDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.AsyncGenericDriver.send_commands_from_file" href="#scrapli.driver.AsyncGenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.AsyncGenericDriver.send_interactive" href="#scrapli.driver.AsyncGenericDriver.send_interactive">send_interactive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.AsyncNetworkDriver" href="#scrapli.driver.AsyncNetworkDriver">AsyncNetworkDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.AsyncNetworkDriver.acquire_priv" href="#scrapli.driver.AsyncNetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.AsyncNetworkDriver.send_command" href="#scrapli.driver.AsyncNetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.AsyncNetworkDriver.send_commands" href="#scrapli.driver.AsyncNetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.AsyncNetworkDriver.send_config" href="#scrapli.driver.AsyncNetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.AsyncNetworkDriver.send_configs" href="#scrapli.driver.AsyncNetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.AsyncNetworkDriver.send_configs_from_file" href="#scrapli.driver.AsyncNetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.AsyncNetworkDriver.send_interactive" href="#scrapli.driver.AsyncNetworkDriver.send_interactive">send_interactive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.AsyncScrape" href="#scrapli.driver.AsyncScrape">AsyncScrape</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.AsyncScrape.close" href="#scrapli.driver.AsyncScrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.AsyncScrape.open" href="#scrapli.driver.AsyncScrape.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.GenericDriver" href="#scrapli.driver.GenericDriver">GenericDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.GenericDriver.get_prompt" href="#scrapli.driver.GenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.GenericDriver.send_command" href="#scrapli.driver.GenericDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.GenericDriver.send_commands" href="#scrapli.driver.GenericDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.GenericDriver.send_commands_from_file" href="#scrapli.driver.GenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.GenericDriver.send_interactive" href="#scrapli.driver.GenericDriver.send_interactive">send_interactive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.NetworkDriver" href="#scrapli.driver.NetworkDriver">NetworkDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.NetworkDriver.acquire_priv" href="#scrapli.driver.NetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_command" href="#scrapli.driver.NetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_commands" href="#scrapli.driver.NetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_config" href="#scrapli.driver.NetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_configs" href="#scrapli.driver.NetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_configs_from_file" href="#scrapli.driver.NetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.NetworkDriver.send_interactive" href="#scrapli.driver.NetworkDriver.send_interactive">send_interactive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.Scrape" href="#scrapli.driver.Scrape">Scrape</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.Scrape.close" href="#scrapli.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.Scrape.open" href="#scrapli.driver.Scrape.open">open</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>