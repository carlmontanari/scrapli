<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>scrapli.driver.base_generic_driver API documentation</title>
<meta name="description" content="scrapli.driver.base_generic_driver" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.driver.base_generic_driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli.driver.base_generic_driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.driver.base_generic_driver&#34;&#34;&#34;
from typing import List, Optional, Tuple, Union

from scrapli.helper import resolve_file
from scrapli.response import MultiResponse, Response


class GenericDriverBase:
    &#34;&#34;&#34;
    GenericDriverBase Object

    A generic network driver that will *hopefully* work for a broad variety of devices with
    minimal to no modifications and provide a normal NetworkDriver type experience with
    `send_command(s)`, `get_prompt` and `send_interactive` methods instead of forcing users to
    call Channel methods directly.

    This driver doesn&#39;t know anything about privilege levels (or any type of &#34;config modes&#34;,
    disabling paging, gracefully exiting, or anything like that, and as such should be treated
    similar to the base `Scrape` object from that perspective.

    &#34;&#34;&#34;

    @staticmethod
    def _pre_send_command(
        host: str, command: str, failed_when_contains: Optional[Union[str, List[str]]] = None
    ) -&gt; Response:
        &#34;&#34;&#34;
        Handle pre &#34;send_command&#34; tasks for consistency between sync/async versions

        Args:
            host: string name of the host
            command: string to send to device in privilege exec mode
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            TypeError: if command is anything but a string

        &#34;&#34;&#34;
        if not isinstance(command, str):
            raise TypeError(
                f&#34;`send_command` expects a single string, got {type(command)}, &#34;
                &#34;to send a list of commands use the `send_commands` method instead.&#34;
            )

        response = Response(
            host=host, channel_input=command, failed_when_contains=failed_when_contains,
        )

        return response

    @staticmethod
    def _post_send_command(
        raw_response: str, processed_response: str, response: Response
    ) -&gt; Response:
        &#34;&#34;&#34;
        Handle post &#34;send_command&#34; tasks for consistency between sync/async versions

        Args:
            raw_response: raw response returned from the channel
            processed_response: processed response returned from the channel
            response: response object to update with channel results

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        response._record_response(result=processed_response)  # pylint: disable=W0212
        response.raw_result = raw_response
        return response

    @staticmethod
    def _pre_send_commands(commands: List[str]) -&gt; MultiResponse:
        &#34;&#34;&#34;
        Handle pre &#34;send_command&#34; tasks for consistency between sync/async versions

        Args:
            commands: list of strings to send to device in privilege exec mode

        Returns:
            MultiResponse: Scrapli MultiResponse object

        Raises:
            TypeError: if command is anything but a string

        &#34;&#34;&#34;
        if not isinstance(commands, list):
            raise TypeError(
                f&#34;`send_commands` expects a list of strings, got {type(commands)}, &#34;
                &#34;to send a single command use the `send_command` method instead.&#34;
            )

        responses = MultiResponse()

        return responses

    @staticmethod
    def _pre_send_commands_from_file(file: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Handle pre &#34;send_commands_from_file&#34; tasks for consistency between sync/async versions

        Args:
            file: string path to file

        Returns:
            commands: list of commands read from file

        Raises:
            TypeError: if anything but a string is provided for `file`

        &#34;&#34;&#34;
        if not isinstance(file, str):
            raise TypeError(
                f&#34;`send_commands_from_file` expects a string path to a file, got {type(file)}&#34;
            )
        resolved_file = resolve_file(file)

        with open(resolved_file, &#34;r&#34;) as f:
            commands = f.read().splitlines()

        return commands

    @classmethod
    def _pre_send_interactive(
        cls,
        host: str,
        interact_events: List[Tuple[str, str, Optional[bool]]],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Handle pre &#34;send_interactive&#34; tasks for consistency between sync/async versions

        Args:
            host: string name of the host
            interact_events: list of tuples containing the &#34;interactions&#34; with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
                not provided it is assumed the input is &#34;normal&#34; (not hidden)
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        joined_input = &#34;, &#34;.join([event[0] for event in interact_events])
        return cls._pre_send_command(
            host=host, command=joined_input, failed_when_contains=failed_when_contains
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.driver.base_generic_driver.GenericDriverBase"><code class="flex name class">
<span>class <span class="ident">GenericDriverBase</span></span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code>Scrape</code> object from that perspective.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericDriverBase:
    &#34;&#34;&#34;
    GenericDriverBase Object

    A generic network driver that will *hopefully* work for a broad variety of devices with
    minimal to no modifications and provide a normal NetworkDriver type experience with
    `send_command(s)`, `get_prompt` and `send_interactive` methods instead of forcing users to
    call Channel methods directly.

    This driver doesn&#39;t know anything about privilege levels (or any type of &#34;config modes&#34;,
    disabling paging, gracefully exiting, or anything like that, and as such should be treated
    similar to the base `Scrape` object from that perspective.

    &#34;&#34;&#34;

    @staticmethod
    def _pre_send_command(
        host: str, command: str, failed_when_contains: Optional[Union[str, List[str]]] = None
    ) -&gt; Response:
        &#34;&#34;&#34;
        Handle pre &#34;send_command&#34; tasks for consistency between sync/async versions

        Args:
            host: string name of the host
            command: string to send to device in privilege exec mode
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            TypeError: if command is anything but a string

        &#34;&#34;&#34;
        if not isinstance(command, str):
            raise TypeError(
                f&#34;`send_command` expects a single string, got {type(command)}, &#34;
                &#34;to send a list of commands use the `send_commands` method instead.&#34;
            )

        response = Response(
            host=host, channel_input=command, failed_when_contains=failed_when_contains,
        )

        return response

    @staticmethod
    def _post_send_command(
        raw_response: str, processed_response: str, response: Response
    ) -&gt; Response:
        &#34;&#34;&#34;
        Handle post &#34;send_command&#34; tasks for consistency between sync/async versions

        Args:
            raw_response: raw response returned from the channel
            processed_response: processed response returned from the channel
            response: response object to update with channel results

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        response._record_response(result=processed_response)  # pylint: disable=W0212
        response.raw_result = raw_response
        return response

    @staticmethod
    def _pre_send_commands(commands: List[str]) -&gt; MultiResponse:
        &#34;&#34;&#34;
        Handle pre &#34;send_command&#34; tasks for consistency between sync/async versions

        Args:
            commands: list of strings to send to device in privilege exec mode

        Returns:
            MultiResponse: Scrapli MultiResponse object

        Raises:
            TypeError: if command is anything but a string

        &#34;&#34;&#34;
        if not isinstance(commands, list):
            raise TypeError(
                f&#34;`send_commands` expects a list of strings, got {type(commands)}, &#34;
                &#34;to send a single command use the `send_command` method instead.&#34;
            )

        responses = MultiResponse()

        return responses

    @staticmethod
    def _pre_send_commands_from_file(file: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Handle pre &#34;send_commands_from_file&#34; tasks for consistency between sync/async versions

        Args:
            file: string path to file

        Returns:
            commands: list of commands read from file

        Raises:
            TypeError: if anything but a string is provided for `file`

        &#34;&#34;&#34;
        if not isinstance(file, str):
            raise TypeError(
                f&#34;`send_commands_from_file` expects a string path to a file, got {type(file)}&#34;
            )
        resolved_file = resolve_file(file)

        with open(resolved_file, &#34;r&#34;) as f:
            commands = f.read().splitlines()

        return commands

    @classmethod
    def _pre_send_interactive(
        cls,
        host: str,
        interact_events: List[Tuple[str, str, Optional[bool]]],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Handle pre &#34;send_interactive&#34; tasks for consistency between sync/async versions

        Args:
            host: string name of the host
            interact_events: list of tuples containing the &#34;interactions&#34; with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is &#34;hidden&#34; (ex: password), if the hidden param is
                not provided it is assumed the input is &#34;normal&#34; (not hidden)
            failed_when_contains: string or list of strings indicating failure if found in response

        Returns:
            Response: Scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        joined_input = &#34;, &#34;.join([event[0] for event in interact_events])
        return cls._pre_send_command(
            host=host, command=joined_input, failed_when_contains=failed_when_contains
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></li>
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.driver" href="index.html">scrapli.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>