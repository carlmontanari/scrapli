<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>scrapli.driver.network_driver API documentation</title>
<meta name="description" content="scrapli.driver.network_driver" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.driver.network_driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli.driver.network_driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.driver.network_driver&#34;&#34;&#34;
import logging
import re
from abc import ABC, abstractmethod
from collections import namedtuple
from typing import Any, Callable, Dict, List, Tuple, Union

from scrapli.driver.driver import Scrape
from scrapli.exceptions import CouldNotAcquirePrivLevel, UnknownPrivLevel
from scrapli.helper import get_prompt_pattern
from scrapli.response import Response
from scrapli.transport import (
    MIKO_TRANSPORT_ARGS,
    SSH2_TRANSPORT_ARGS,
    SYSTEM_SSH_TRANSPORT_ARGS,
    MikoTransport,
    SSH2Transport,
    SystemSSHTransport,
    Transport,
)

TRANSPORT_CLASS: Dict[str, Callable[..., Transport]] = {
    &#34;system&#34;: SystemSSHTransport,
    &#34;ssh2&#34;: SSH2Transport,
    &#34;paramiko&#34;: MikoTransport,
}
TRANSPORT_ARGS: Dict[str, Tuple[str, ...]] = {
    &#34;system&#34;: SYSTEM_SSH_TRANSPORT_ARGS,
    &#34;ssh2&#34;: SSH2_TRANSPORT_ARGS,
    &#34;paramiko&#34;: MIKO_TRANSPORT_ARGS,
}


PrivilegeLevel = namedtuple(
    &#34;PrivilegeLevel&#34;,
    &#34;pattern &#34;
    &#34;name &#34;
    &#34;deescalate_priv &#34;
    &#34;deescalate &#34;
    &#34;escalate_priv &#34;
    &#34;escalate &#34;
    &#34;escalate_auth &#34;
    &#34;escalate_prompt &#34;
    &#34;requestable &#34;
    &#34;level&#34;,
)

NoPrivLevel = PrivilegeLevel(&#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;)


PRIVS: Dict[str, PrivilegeLevel] = {}

LOG = logging.getLogger(&#34;scrapli_base&#34;)


class NetworkDriver(Scrape, ABC):
    @abstractmethod
    def __init__(
        self, auth_secondary: str = &#34;&#34;, **kwargs: Any,
    ):
        &#34;&#34;&#34;
        BaseNetworkDriver Object

        Args:
            auth_secondary: password to use for secondary authentication (enable)
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(**kwargs)

        self.textfsm_platform: str = &#34;&#34;
        self.auth_secondary = auth_secondary
        self.privs = PRIVS
        self.default_desired_priv: str = &#34;&#34;
        self._current_priv_level = NoPrivLevel

    def _determine_current_priv(self, current_prompt: str) -&gt; PrivilegeLevel:
        &#34;&#34;&#34;
        Determine current privilege level from prompt string

        Args:
            current_prompt: string of current prompt

        Returns:
            PrivilegeLevel: NamedTuple of current privilege level

        Raises:
            UnknownPrivLevel: if privilege level cannot be determined

        &#34;&#34;&#34;
        for priv_level in self.privs.values():
            prompt_pattern = get_prompt_pattern(&#34;&#34;, priv_level.pattern)
            if re.search(prompt_pattern, current_prompt.encode()):
                return priv_level
        raise UnknownPrivLevel

    def _escalate(self) -&gt; None:
        &#34;&#34;&#34;
        Escalate to the next privilege level up

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            UnknownPrivLevel: if priv level cant be attained
            TypeError: if invalid next prompt value

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if not current_priv.escalate:
            return

        next_priv = self.privs.get(current_priv.escalate_priv, None)
        if next_priv is None:
            raise UnknownPrivLevel(
                f&#34;Could not get next priv level, current priv is {current_priv.name}&#34;
            )
        next_prompt = next_priv.pattern
        if current_priv.escalate_auth:
            escalate_cmd: str = current_priv.escalate
            escalate_prompt: str = current_priv.escalate_prompt
            escalate_auth = self.auth_secondary
            if not isinstance(next_prompt, str):
                raise TypeError(
                    f&#34;got {type(next_prompt)} for {current_priv.name} escalate priv, &#34;
                    &#34;expected str&#34;
                )
            self.channel.send_inputs_interact(
                [escalate_cmd, escalate_prompt, escalate_auth, next_prompt], hidden_response=True,
            )
            self.channel.comms_prompt_pattern = next_priv.pattern
        else:
            self.channel.comms_prompt_pattern = next_priv.pattern
            self.channel.send_input(current_priv.escalate)

    def _deescalate(self) -&gt; None:
        &#34;&#34;&#34;
        Deescalate to the next privilege level down

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            UnknownPrivLevel: if no default priv level set to deescalate to

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv.deescalate:
            next_priv = self.privs.get(current_priv.deescalate_priv, None)
            if not next_priv:
                raise UnknownPrivLevel(
                    &#34;NetworkDriver has no default priv levels, set them or use a network driver&#34;
                )
            self.channel.comms_prompt_pattern = next_priv.pattern
            self.channel.send_input(current_priv.deescalate)

    def acquire_priv(self, desired_priv: str) -&gt; None:
        &#34;&#34;&#34;
        Acquire desired priv level

        Args:
            desired_priv: string name of desired privilege level
                (see scrapli.driver.&lt;driver_category.device_type&gt;.driver for levels)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            CouldNotAcquirePrivLevel: if requested priv level not attained

        &#34;&#34;&#34;
        priv_attempt_counter = 0
        while True:
            current_priv = self._determine_current_priv(self.channel.get_prompt())
            if current_priv == self.privs[desired_priv]:
                self._current_priv_level = current_priv
                return
            if priv_attempt_counter &gt; len(self.privs):
                raise CouldNotAcquirePrivLevel(
                    f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
                )
            if current_priv.level &gt; self.privs[desired_priv].level:
                self._deescalate()
            else:
                self._escalate()
            priv_attempt_counter += 1

    def send_command(self, command: str, strip_prompt: bool = True) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            Response: Scrapli Response object

        Raises:
            TypeError: if command is anything but a string

        &#34;&#34;&#34;
        if not isinstance(command, str):
            raise TypeError(
                f&#34;`send_command` expects a single string, got {type(command)}. &#34;
                &#34;to send a list of commands use the `send_commands` method instead.&#34;
            )

        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)
        response = self.channel.send_input(command, strip_prompt)

        # update the response objects with textfsm platform; we do this here because the underlying
        #  channel doesn&#39;t know or care about platforms
        response.textfsm_platform = self.textfsm_platform

        return response

    def send_commands(self, commands: List[str], strip_prompt: bool = True) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send multiple commands

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            responses: list of Scrapli Response objects

        Raises:
            TypeError: if commands is anything but a list

        &#34;&#34;&#34;
        if not isinstance(commands, list):
            raise TypeError(
                f&#34;`send_commands` expects a list of strings, got {type(commands)}. &#34;
                &#34;to send a single command use the `send_command` method instead.&#34;
            )

        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)
        responses = self.channel.send_inputs(commands, strip_prompt)

        # update the response objects with textfsm platform; we do this here because the underlying
        #  channel doesn&#39;t know or care about platforms
        for response in responses:
            response.textfsm_platform = self.textfsm_platform

        return responses

    def send_interactive(self, inputs: List[str], hidden_response: bool = False) -&gt; Response:
        &#34;&#34;&#34;
        Send inputs in an interactive fashion; used to handle prompts

        accepts inputs and looks for expected prompt;
        sends the appropriate response, then waits for the &#34;finale&#34;
        returns the results of the interaction

        could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

        Args:
            inputs: list of four string elements representing...
                channel_input - initial input to send
                expected_prompt - prompt to expect after initial input
                response - response to prompt
                final_prompt - final prompt to expect
            hidden_response: True/False response is hidden (i.e. password input)

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)
        response = self.channel.send_inputs_interact(inputs, hidden_response)
        return response

    def send_configs(
        self, configs: Union[str, List[str]], strip_prompt: bool = True
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            configs: string or list of strings to send to device in config mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            responses: List of Scrape Response objects

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(configs, str):
            configs = [configs]

        self.acquire_priv(&#34;configuration&#34;)
        responses = self.channel.send_inputs(configs, strip_prompt)
        self.acquire_priv(self.default_desired_priv)
        return responses

    def get_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Convenience method to get device prompt from Channel

        Args:
            N/A

        Returns:
            str: prompt received from channel.get_prompt

        Raises:
            N/A

        &#34;&#34;&#34;
        prompt: str = self.channel.get_prompt()
        return prompt</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.driver.network_driver.NetworkDriver"><code class="flex name class">
<span>class <span class="ident">NetworkDriver</span></span>
<span>(</span><span>auth_secondary='', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>BaseNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkDriver(Scrape, ABC):
    @abstractmethod
    def __init__(
        self, auth_secondary: str = &#34;&#34;, **kwargs: Any,
    ):
        &#34;&#34;&#34;
        BaseNetworkDriver Object

        Args:
            auth_secondary: password to use for secondary authentication (enable)
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(**kwargs)

        self.textfsm_platform: str = &#34;&#34;
        self.auth_secondary = auth_secondary
        self.privs = PRIVS
        self.default_desired_priv: str = &#34;&#34;
        self._current_priv_level = NoPrivLevel

    def _determine_current_priv(self, current_prompt: str) -&gt; PrivilegeLevel:
        &#34;&#34;&#34;
        Determine current privilege level from prompt string

        Args:
            current_prompt: string of current prompt

        Returns:
            PrivilegeLevel: NamedTuple of current privilege level

        Raises:
            UnknownPrivLevel: if privilege level cannot be determined

        &#34;&#34;&#34;
        for priv_level in self.privs.values():
            prompt_pattern = get_prompt_pattern(&#34;&#34;, priv_level.pattern)
            if re.search(prompt_pattern, current_prompt.encode()):
                return priv_level
        raise UnknownPrivLevel

    def _escalate(self) -&gt; None:
        &#34;&#34;&#34;
        Escalate to the next privilege level up

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            UnknownPrivLevel: if priv level cant be attained
            TypeError: if invalid next prompt value

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if not current_priv.escalate:
            return

        next_priv = self.privs.get(current_priv.escalate_priv, None)
        if next_priv is None:
            raise UnknownPrivLevel(
                f&#34;Could not get next priv level, current priv is {current_priv.name}&#34;
            )
        next_prompt = next_priv.pattern
        if current_priv.escalate_auth:
            escalate_cmd: str = current_priv.escalate
            escalate_prompt: str = current_priv.escalate_prompt
            escalate_auth = self.auth_secondary
            if not isinstance(next_prompt, str):
                raise TypeError(
                    f&#34;got {type(next_prompt)} for {current_priv.name} escalate priv, &#34;
                    &#34;expected str&#34;
                )
            self.channel.send_inputs_interact(
                [escalate_cmd, escalate_prompt, escalate_auth, next_prompt], hidden_response=True,
            )
            self.channel.comms_prompt_pattern = next_priv.pattern
        else:
            self.channel.comms_prompt_pattern = next_priv.pattern
            self.channel.send_input(current_priv.escalate)

    def _deescalate(self) -&gt; None:
        &#34;&#34;&#34;
        Deescalate to the next privilege level down

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            UnknownPrivLevel: if no default priv level set to deescalate to

        &#34;&#34;&#34;
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv.deescalate:
            next_priv = self.privs.get(current_priv.deescalate_priv, None)
            if not next_priv:
                raise UnknownPrivLevel(
                    &#34;NetworkDriver has no default priv levels, set them or use a network driver&#34;
                )
            self.channel.comms_prompt_pattern = next_priv.pattern
            self.channel.send_input(current_priv.deescalate)

    def acquire_priv(self, desired_priv: str) -&gt; None:
        &#34;&#34;&#34;
        Acquire desired priv level

        Args:
            desired_priv: string name of desired privilege level
                (see scrapli.driver.&lt;driver_category.device_type&gt;.driver for levels)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            CouldNotAcquirePrivLevel: if requested priv level not attained

        &#34;&#34;&#34;
        priv_attempt_counter = 0
        while True:
            current_priv = self._determine_current_priv(self.channel.get_prompt())
            if current_priv == self.privs[desired_priv]:
                self._current_priv_level = current_priv
                return
            if priv_attempt_counter &gt; len(self.privs):
                raise CouldNotAcquirePrivLevel(
                    f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
                )
            if current_priv.level &gt; self.privs[desired_priv].level:
                self._deescalate()
            else:
                self._escalate()
            priv_attempt_counter += 1

    def send_command(self, command: str, strip_prompt: bool = True) -&gt; Response:
        &#34;&#34;&#34;
        Send a command

        Args:
            command: string to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            Response: Scrapli Response object

        Raises:
            TypeError: if command is anything but a string

        &#34;&#34;&#34;
        if not isinstance(command, str):
            raise TypeError(
                f&#34;`send_command` expects a single string, got {type(command)}. &#34;
                &#34;to send a list of commands use the `send_commands` method instead.&#34;
            )

        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)
        response = self.channel.send_input(command, strip_prompt)

        # update the response objects with textfsm platform; we do this here because the underlying
        #  channel doesn&#39;t know or care about platforms
        response.textfsm_platform = self.textfsm_platform

        return response

    def send_commands(self, commands: List[str], strip_prompt: bool = True) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send multiple commands

        Args:
            commands: list of strings to send to device in privilege exec mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            responses: list of Scrapli Response objects

        Raises:
            TypeError: if commands is anything but a list

        &#34;&#34;&#34;
        if not isinstance(commands, list):
            raise TypeError(
                f&#34;`send_commands` expects a list of strings, got {type(commands)}. &#34;
                &#34;to send a single command use the `send_command` method instead.&#34;
            )

        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)
        responses = self.channel.send_inputs(commands, strip_prompt)

        # update the response objects with textfsm platform; we do this here because the underlying
        #  channel doesn&#39;t know or care about platforms
        for response in responses:
            response.textfsm_platform = self.textfsm_platform

        return responses

    def send_interactive(self, inputs: List[str], hidden_response: bool = False) -&gt; Response:
        &#34;&#34;&#34;
        Send inputs in an interactive fashion; used to handle prompts

        accepts inputs and looks for expected prompt;
        sends the appropriate response, then waits for the &#34;finale&#34;
        returns the results of the interaction

        could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

        Args:
            inputs: list of four string elements representing...
                channel_input - initial input to send
                expected_prompt - prompt to expect after initial input
                response - response to prompt
                final_prompt - final prompt to expect
            hidden_response: True/False response is hidden (i.e. password input)

        Returns:
            Response: scrapli Response object

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._current_priv_level.name != self.default_desired_priv:
            self.acquire_priv(self.default_desired_priv)
        response = self.channel.send_inputs_interact(inputs, hidden_response)
        return response

    def send_configs(
        self, configs: Union[str, List[str]], strip_prompt: bool = True
    ) -&gt; List[Response]:
        &#34;&#34;&#34;
        Send configuration(s)

        Args:
            configs: string or list of strings to send to device in config mode
            strip_prompt: True/False strip prompt from returned output

        Returns:
            responses: List of Scrape Response objects

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(configs, str):
            configs = [configs]

        self.acquire_priv(&#34;configuration&#34;)
        responses = self.channel.send_inputs(configs, strip_prompt)
        self.acquire_priv(self.default_desired_priv)
        return responses

    def get_prompt(self) -&gt; str:
        &#34;&#34;&#34;
        Convenience method to get device prompt from Channel

        Args:
            N/A

        Returns:
            str: prompt received from channel.get_prompt

        Raises:
            N/A

        &#34;&#34;&#34;
        prompt: str = self.channel.get_prompt()
        return prompt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.core.arista_eos.driver.EOSDriver" href="core/arista_eos/driver.html#scrapli.driver.core.arista_eos.driver.EOSDriver">EOSDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxe.driver.IOSXEDriver" href="core/cisco_iosxe/driver.html#scrapli.driver.core.cisco_iosxe.driver.IOSXEDriver">IOSXEDriver</a></li>
<li><a title="scrapli.driver.core.cisco_iosxr.driver.IOSXRDriver" href="core/cisco_iosxr/driver.html#scrapli.driver.core.cisco_iosxr.driver.IOSXRDriver">IOSXRDriver</a></li>
<li><a title="scrapli.driver.core.cisco_nxos.driver.NXOSDriver" href="core/cisco_nxos/driver.html#scrapli.driver.core.cisco_nxos.driver.NXOSDriver">NXOSDriver</a></li>
<li><a title="scrapli.driver.core.juniper_junos.driver.JunosDriver" href="core/juniper_junos/driver.html#scrapli.driver.core.juniper_junos.driver.JunosDriver">JunosDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.network_driver.NetworkDriver.acquire_priv"><code class="name flex">
<span>def <span class="ident">acquire_priv</span></span>(<span>self, desired_priv)</span>
</code></dt>
<dd>
<section class="desc"><p>Acquire desired priv level</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>desired_priv</code></strong></dt>
<dd>string name of desired privilege level
(see scrapli.driver.<driver_category.device_type>.driver for levels)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>CouldNotAcquirePrivLevel</code></strong></dt>
<dd>if requested priv level not attained</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_priv(self, desired_priv: str) -&gt; None:
    &#34;&#34;&#34;
    Acquire desired priv level

    Args:
        desired_priv: string name of desired privilege level
            (see scrapli.driver.&lt;driver_category.device_type&gt;.driver for levels)

    Returns:
        N/A  # noqa: DAR202

    Raises:
        CouldNotAcquirePrivLevel: if requested priv level not attained

    &#34;&#34;&#34;
    priv_attempt_counter = 0
    while True:
        current_priv = self._determine_current_priv(self.channel.get_prompt())
        if current_priv == self.privs[desired_priv]:
            self._current_priv_level = current_priv
            return
        if priv_attempt_counter &gt; len(self.privs):
            raise CouldNotAcquirePrivLevel(
                f&#34;Could not get to &#39;{desired_priv}&#39; privilege level.&#34;
            )
        if current_priv.level &gt; self.privs[desired_priv].level:
            self._deescalate()
        else:
            self._escalate()
        priv_attempt_counter += 1</code></pre>
</details>
</dd>
<dt id="scrapli.driver.network_driver.NetworkDriver.get_prompt"><code class="name flex">
<span>def <span class="ident">get_prompt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convenience method to get device prompt from Channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>prompt received from channel.get_prompt</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prompt(self) -&gt; str:
    &#34;&#34;&#34;
    Convenience method to get device prompt from Channel

    Args:
        N/A

    Returns:
        str: prompt received from channel.get_prompt

    Raises:
        N/A

    &#34;&#34;&#34;
    prompt: str = self.channel.get_prompt()
    return prompt</code></pre>
</details>
</dd>
<dt id="scrapli.driver.network_driver.NetworkDriver.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command, strip_prompt=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a command</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>string to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Response</code></strong></dt>
<dd>Scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>if command is anything but a string</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(self, command: str, strip_prompt: bool = True) -&gt; Response:
    &#34;&#34;&#34;
    Send a command

    Args:
        command: string to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output

    Returns:
        Response: Scrapli Response object

    Raises:
        TypeError: if command is anything but a string

    &#34;&#34;&#34;
    if not isinstance(command, str):
        raise TypeError(
            f&#34;`send_command` expects a single string, got {type(command)}. &#34;
            &#34;to send a list of commands use the `send_commands` method instead.&#34;
        )

    if self._current_priv_level.name != self.default_desired_priv:
        self.acquire_priv(self.default_desired_priv)
    response = self.channel.send_input(command, strip_prompt)

    # update the response objects with textfsm platform; we do this here because the underlying
    #  channel doesn&#39;t know or care about platforms
    response.textfsm_platform = self.textfsm_platform

    return response</code></pre>
</details>
</dd>
<dt id="scrapli.driver.network_driver.NetworkDriver.send_commands"><code class="name flex">
<span>def <span class="ident">send_commands</span></span>(<span>self, commands, strip_prompt=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Send multiple commands</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>list of strings to send to device in privilege exec mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>list of Scrapli Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>if commands is anything but a list</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_commands(self, commands: List[str], strip_prompt: bool = True) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send multiple commands

    Args:
        commands: list of strings to send to device in privilege exec mode
        strip_prompt: True/False strip prompt from returned output

    Returns:
        responses: list of Scrapli Response objects

    Raises:
        TypeError: if commands is anything but a list

    &#34;&#34;&#34;
    if not isinstance(commands, list):
        raise TypeError(
            f&#34;`send_commands` expects a list of strings, got {type(commands)}. &#34;
            &#34;to send a single command use the `send_command` method instead.&#34;
        )

    if self._current_priv_level.name != self.default_desired_priv:
        self.acquire_priv(self.default_desired_priv)
    responses = self.channel.send_inputs(commands, strip_prompt)

    # update the response objects with textfsm platform; we do this here because the underlying
    #  channel doesn&#39;t know or care about platforms
    for response in responses:
        response.textfsm_platform = self.textfsm_platform

    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.network_driver.NetworkDriver.send_configs"><code class="name flex">
<span>def <span class="ident">send_configs</span></span>(<span>self, configs, strip_prompt=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Send configuration(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>configs</code></strong></dt>
<dd>string or list of strings to send to device in config mode</dd>
<dt><strong><code>strip_prompt</code></strong></dt>
<dd>True/False strip prompt from returned output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>responses</code></strong></dt>
<dd>List of Scrape Response objects</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_configs(
    self, configs: Union[str, List[str]], strip_prompt: bool = True
) -&gt; List[Response]:
    &#34;&#34;&#34;
    Send configuration(s)

    Args:
        configs: string or list of strings to send to device in config mode
        strip_prompt: True/False strip prompt from returned output

    Returns:
        responses: List of Scrape Response objects

    Raises:
        N/A

    &#34;&#34;&#34;
    if isinstance(configs, str):
        configs = [configs]

    self.acquire_priv(&#34;configuration&#34;)
    responses = self.channel.send_inputs(configs, strip_prompt)
    self.acquire_priv(self.default_desired_priv)
    return responses</code></pre>
</details>
</dd>
<dt id="scrapli.driver.network_driver.NetworkDriver.send_interactive"><code class="name flex">
<span>def <span class="ident">send_interactive</span></span>(<span>self, inputs, hidden_response=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send inputs in an interactive fashion; used to handle prompts</p>
<p>accepts inputs and looks for expected prompt;
sends the appropriate response, then waits for the "finale"
returns the results of the interaction</p>
<p>could be "chained" together to respond to more than a "single" staged prompt</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>list of four string elements representing&hellip;
channel_input - initial input to send
expected_prompt - prompt to expect after initial input
response - response to prompt
final_prompt - final prompt to expect</dd>
<dt><strong><code>hidden_response</code></strong></dt>
<dd>True/False response is hidden (i.e. password input)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Response</code></strong></dt>
<dd>scrapli Response object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_interactive(self, inputs: List[str], hidden_response: bool = False) -&gt; Response:
    &#34;&#34;&#34;
    Send inputs in an interactive fashion; used to handle prompts

    accepts inputs and looks for expected prompt;
    sends the appropriate response, then waits for the &#34;finale&#34;
    returns the results of the interaction

    could be &#34;chained&#34; together to respond to more than a &#34;single&#34; staged prompt

    Args:
        inputs: list of four string elements representing...
            channel_input - initial input to send
            expected_prompt - prompt to expect after initial input
            response - response to prompt
            final_prompt - final prompt to expect
        hidden_response: True/False response is hidden (i.e. password input)

    Returns:
        Response: scrapli Response object

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._current_priv_level.name != self.default_desired_priv:
        self.acquire_priv(self.default_desired_priv)
    response = self.channel.send_inputs_interact(inputs, hidden_response)
    return response</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.driver.Scrape" href="driver.html#scrapli.driver.driver.Scrape">Scrape</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.driver.Scrape.close" href="driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.driver.Scrape.isalive" href="driver.html#scrapli.driver.driver.Scrape.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.driver.Scrape.open" href="driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel"><code class="flex name class">
<span>class <span class="ident">PrivilegeLevel</span></span>
<span>(</span><span>pattern, name, deescalate_priv, deescalate, escalate_priv, escalate, escalate_auth, escalate_prompt, requestable, level)</span>
</code></dt>
<dd>
<section class="desc"><p>PrivilegeLevel(pattern, name, deescalate_priv, deescalate, escalate_priv, escalate, escalate_auth, escalate_prompt, requestable, level)</p></section>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.deescalate"><code class="name">var <span class="ident">deescalate</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.deescalate_priv"><code class="name">var <span class="ident">deescalate_priv</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.escalate"><code class="name">var <span class="ident">escalate</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 5</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.escalate_auth"><code class="name">var <span class="ident">escalate_auth</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 6</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.escalate_priv"><code class="name">var <span class="ident">escalate_priv</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.escalate_prompt"><code class="name">var <span class="ident">escalate_prompt</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 7</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 9</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.pattern"><code class="name">var <span class="ident">pattern</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="scrapli.driver.network_driver.PrivilegeLevel.requestable"><code class="name">var <span class="ident">requestable</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 8</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.driver" href="index.html">scrapli.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.driver.network_driver.NetworkDriver" href="#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.acquire_priv" href="#scrapli.driver.network_driver.NetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.get_prompt" href="#scrapli.driver.network_driver.NetworkDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_command" href="#scrapli.driver.network_driver.NetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_commands" href="#scrapli.driver.network_driver.NetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_configs" href="#scrapli.driver.network_driver.NetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_interactive" href="#scrapli.driver.network_driver.NetworkDriver.send_interactive">send_interactive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.network_driver.PrivilegeLevel" href="#scrapli.driver.network_driver.PrivilegeLevel">PrivilegeLevel</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.deescalate" href="#scrapli.driver.network_driver.PrivilegeLevel.deescalate">deescalate</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.deescalate_priv" href="#scrapli.driver.network_driver.PrivilegeLevel.deescalate_priv">deescalate_priv</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.escalate" href="#scrapli.driver.network_driver.PrivilegeLevel.escalate">escalate</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.escalate_auth" href="#scrapli.driver.network_driver.PrivilegeLevel.escalate_auth">escalate_auth</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.escalate_priv" href="#scrapli.driver.network_driver.PrivilegeLevel.escalate_priv">escalate_priv</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.escalate_prompt" href="#scrapli.driver.network_driver.PrivilegeLevel.escalate_prompt">escalate_prompt</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.level" href="#scrapli.driver.network_driver.PrivilegeLevel.level">level</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.name" href="#scrapli.driver.network_driver.PrivilegeLevel.name">name</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.pattern" href="#scrapli.driver.network_driver.PrivilegeLevel.pattern">pattern</a></code></li>
<li><code><a title="scrapli.driver.network_driver.PrivilegeLevel.requestable" href="#scrapli.driver.network_driver.PrivilegeLevel.requestable">requestable</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>