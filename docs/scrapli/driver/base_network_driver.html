<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>scrapli.driver.base_network_driver API documentation</title>
<meta name="description" content="scrapli.driver.base_network_driver" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.driver.base_network_driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli.driver.base_network_driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.driver.base_network_driver&#34;&#34;&#34;
import re
import warnings
from collections import UserList
from datetime import datetime
from enum import Enum
from functools import lru_cache
from logging import Logger
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple, Union

from scrapli.exceptions import UnknownPrivLevel
from scrapli.helper import resolve_file
from scrapli.response import Response

if TYPE_CHECKING:
    ScrapliMultiResponse = UserList[Response]  # pylint:  disable=E1136; # pragma:  no cover
else:
    ScrapliMultiResponse = UserList


class PrivilegeLevel:
    __slots__ = (
        &#34;pattern&#34;,
        &#34;name&#34;,
        &#34;previous_priv&#34;,
        &#34;deescalate&#34;,
        &#34;escalate&#34;,
        &#34;escalate_auth&#34;,
        &#34;escalate_prompt&#34;,
    )

    def __init__(
        self,
        pattern: str,
        name: str,
        previous_priv: str,
        deescalate: str,
        escalate: str,
        escalate_auth: bool,
        escalate_prompt: str,
    ):
        &#34;&#34;&#34;
        PrivilegeLevel Object

        Args:
            pattern: regex pattern to use to identify this privilege level by the prompt
            name: friendly name of this privilege level
            previous_priv: name of the lower/previous privilege level
            deescalate: how to deescalate *from* this privilege level (to the lower/previous priv)
            escalate: how to escalate *to* this privilege level (from the lower/previous priv)
            escalate_auth: True/False escalation requires authentication
            escalate_prompt: prompt pattern to search for during escalation if escalate auth is True

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.pattern = pattern
        self.name = name
        self.previous_priv = previous_priv
        self.deescalate = deescalate
        self.escalate = escalate
        self.escalate_auth = escalate_auth
        self.escalate_prompt = escalate_prompt


DUMMY_PRIV_LEVEL = PrivilegeLevel(&#34;&#34;, &#34;DUMMY&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;, False, &#34;&#34;)
PRIVS: Dict[str, PrivilegeLevel] = {}


class PrivilegeAction(Enum):
    NO_ACTION = &#34;no action&#34;
    ESCALATE = &#34;escalate&#34;
    DEESCALATE = &#34;deescalate&#34;


class NetworkDriverBase:
    # NetworkDriverBase Mixin vars for typing/linting purposes
    logger: Logger
    comms_prompt_pattern: str
    _current_priv_level = DUMMY_PRIV_LEVEL
    _priv_map: Dict[str, List[str]]
    failed_when_contains: Optional[List[str]]
    privilege_levels: Dict[str, PrivilegeLevel]
    auth_secondary: str
    textfsm_platform: str
    genie_platform: str

    @staticmethod
    def _check_kwargs_comms_prompt_pattern(kwargs: Any) -&gt; None:
        &#34;&#34;&#34;
        Warn users if passing comms prompt pattern while using NetworkDriver derived classes

        Args:
            kwargs: kwargs being passed into NetworkDriver classes

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if &#34;comms_prompt_pattern&#34; in kwargs:
            err = &#34;`comms_prompt_pattern` found in kwargs!&#34;
            msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
            fix = (
                &#34;`comms_prompt_pattern` is ignored (dropped) when using network drivers. If you &#34;
                &#34;wish to modify the patterns for any network driver sub-classes, please do so by &#34;
                &#34;modifying or providing your own `privilege_levels`.&#34;
            )
            warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
            warnings.warn(warning)
            kwargs.pop(&#34;comms_prompt_pattern&#34;)

    def _generate_comms_prompt_pattern(self) -&gt; None:
        &#34;&#34;&#34;
        Generate the `comms_prompt_pattern_all` from the currently assigned privilege levels

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.comms_prompt_pattern = r&#34;|&#34;.join(
            rf&#34;({priv_level_data.pattern})&#34; for priv_level_data in self.privilege_levels.values()
        )

    def _build_priv_map(self) -&gt; None:
        &#34;&#34;&#34;
        Build a &#34;map&#34; of privilege levels

        `_priv_map` is a &#34;map&#34; of all privilege levels mapped out to the lowest available priv. This
        map is used for determining how to escalate/deescalate.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        for priv_level in self.privilege_levels:
            self._priv_map[priv_level] = [priv_level]
            while True:
                previous_priv = self.privilege_levels[self._priv_map[priv_level][0]].previous_priv
                if not previous_priv:
                    break
                self._priv_map[priv_level].insert(0, previous_priv)

    def update_privilege_levels(self, update_channel: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Re-generate the privilege map, and update the comms prompt pattern

        Args:
            update_channel: True/False update the channel pattern too -- likely only ever set to
                False for class initialization before channel is opened

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._build_priv_map()
        self._generate_comms_prompt_pattern()
        # clear the lru cache as patterns may have been updated
        self._determine_current_priv.cache_clear()
        if update_channel is True:
            self.channel.comms_prompt_pattern = (  # type: ignore  # pylint: disable=E1101
                self.comms_prompt_pattern
            )

    @lru_cache()
    def _determine_current_priv(self, current_prompt: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Determine current privilege level from prompt string

        Args:
            current_prompt: string of current prompt

        Returns:
            matching_priv_levels: list of string names of matching privilege levels

        Raises:
            UnknownPrivLevel: if privilege level cannot be determined

        &#34;&#34;&#34;
        matching_priv_levels = []
        for priv_level in self.privilege_levels.values():
            search_result = re.search(
                pattern=priv_level.pattern, string=current_prompt, flags=re.M | re.I
            )
            if not search_result:
                continue
            matching_priv_levels.append(priv_level.name)
            self.logger.debug(f&#34;Current privilege level could be `{priv_level.name}`&#34;)
        if not matching_priv_levels:
            raise UnknownPrivLevel(
                f&#34;Could not determine privilege level from provided prompt: `{current_prompt}`&#34;
            )
        self.logger.debug(f&#34;Determined current privilege level is one of `{matching_priv_levels}`&#34;)
        return matching_priv_levels

    def _get_privilege_level_name(self, requested_priv: str) -&gt; str:
        &#34;&#34;&#34;
        Get privilege level name if provided privilege is valid

        Args:
            requested_priv: string name of desired privilege level

        Returns:
            str: name of the privilege level requested

        Raises:
            UnknownPrivLevel: if attempting to acquire an unknown priv

        &#34;&#34;&#34;
        desired_privilege_level = self.privilege_levels.get(requested_priv, None)
        if desired_privilege_level is None:
            raise UnknownPrivLevel(
                f&#34;Requested privilege level `{requested_priv}` not a valid privilege level of &#34;
                f&#34;`{self.__class__.__name__}`&#34;
            )
        resolved_privilege_level = desired_privilege_level.name
        return resolved_privilege_level

    def _update_response(self, response: Response) -&gt; None:
        &#34;&#34;&#34;
        Update response with network driver specific data

        This happens here as the underlying channel provides a response object but is unaware of any
        of the network/platform specific attributes that may need to get updated

        Args:
            response: response to update

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        response.textfsm_platform = self.textfsm_platform
        response.genie_platform = self.genie_platform

    def register_configuration_session(self, session_name: str) -&gt; None:
        &#34;&#34;&#34;
        If applicable, register a configuration session as a valid privilege level

        Args:
            session_name: name of config session to register

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            NotImplementedError: unless overridden by concrete class

        &#34;&#34;&#34;
        _ = session_name
        raise NotImplementedError(
            f&#34;Configuration sessions not supported for `{self.__class__.__name__}`&#34;
        )

    def _pre_escalate(self, escalate_priv: PrivilegeLevel) -&gt; None:
        &#34;&#34;&#34;
        Handle pre &#34;_escalate&#34; tasks for consistency between sync/async versions

        Args:
            escalate_priv: privilege level to escalate to

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if escalate_priv.escalate_auth is True and not self.auth_secondary:
            err = (
                &#34;Privilege escalation generally requires an `auth_secondary` password, &#34;
                &#34;but none is set!&#34;
            )
            msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
            fix = (
                &#34;scrapli will try to escalate privilege without entering a password but may &#34;
                &#34;fail.\nSet an `auth_secondary` password if your device requires a password to &#34;
                &#34;increase privilege, otherwise ignore this message.&#34;
            )
            warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
            warnings.warn(warning)

    def _pre_acquire_priv(self, desired_priv: str) -&gt; Tuple[str, List[str]]:
        &#34;&#34;&#34;
        Handle pre &#34;acquire_priv&#34; tasks for consistency between sync/async versions

        Args:
            desired_priv: string name of desired privilege level

        Returns:
            resolved_priv: privilege level class resolved via given privilege name
            map_to_desired_priv: map from current priv to desired priv (list of strings of privs to
                iterate through to get to target priv)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Attempting to acquire `{desired_priv}` privilege level&#34;)
        resolved_priv = self._get_privilege_level_name(requested_priv=desired_priv)
        map_to_desired_priv = self._priv_map[resolved_priv]
        return resolved_priv, map_to_desired_priv

    def _process_acquire_priv(
        self, resolved_priv: str, map_to_desired_priv: List[str], current_prompt: str,
    ) -&gt; Tuple[PrivilegeAction, PrivilegeLevel]:
        &#34;&#34;&#34;
        Handle non channel &#34;acquire_priv&#34; tasks for consistency between sync/async versions

        Args:
            resolved_priv: string name of desired privilege level
            map_to_desired_priv: list of string names of privilege levels to acquire to get to
                desired privilege level
            current_prompt: string of the current prompt

        Returns:
            PrivilegeAction: enum set to appropriate value for no action, escalate or deescalate
            PrivilegeLevel: privilege level object to pass to either escalate or deescalate method

        Raises:
            N/A

        &#34;&#34;&#34;
        # if we are already at the desired priv, we don&#39;t need to do any thing
        current_priv_patterns = self._determine_current_priv(current_prompt=current_prompt)

        # if multiple patterns match pick the zeroith... the only time patterns should be
        # identical is if we have privilege levels like &#34;configuration&#34; or
        # &#34;configuration_exclusive&#34; that have identical prompts (ex: IOSXRDriver)
        current_priv = self.privilege_levels[current_priv_patterns[0]]

        if resolved_priv in current_priv_patterns:
            self.logger.info(f&#34;Acquired requested privilege level `{resolved_priv}`&#34;)
            self._current_priv_level = self.privilege_levels[resolved_priv]
            return PrivilegeAction.NO_ACTION, current_priv

        map_to_current_priv = self._priv_map[current_priv.name]
        priv_map = (
            map_to_current_priv
            if map_to_current_priv &gt; map_to_desired_priv
            else map_to_desired_priv
        )

        desired_priv_index = priv_map.index(resolved_priv)
        try:
            current_priv_index = priv_map.index(current_priv.name)
        except ValueError:
            # if the current priv is not in the map for the desired priv; set the current index
            # to the &#34;top&#34; (end) of the priv map and work our way back down
            current_priv_index = len(priv_map)

        if current_priv_index &gt; desired_priv_index:
            deescalate_priv = priv_map[current_priv_index - 1]
            self.logger.info(
                f&#34;Attempting to deescalate from {current_priv.name} to {deescalate_priv}&#34;
            )
            return PrivilegeAction.DEESCALATE, current_priv

        escalate_priv = self.privilege_levels[priv_map[current_priv_index + 1]]
        self.logger.info(f&#34;Attempting to escalate from {current_priv.name} to {escalate_priv.name}&#34;)
        return PrivilegeAction.ESCALATE, escalate_priv

    @staticmethod
    def _pre_send_config(config: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Handle pre &#34;send_config&#34; tasks for consistency between sync/async versions

        Args:
            config: string configuration to send to the device, supports sending multi-line strings

        Returns:
            configs: list of config lines from provided &#34;config&#34; input

        Raises:
            TypeError: if anything but a string is provided for `file`

        &#34;&#34;&#34;
        if not isinstance(config, str):
            raise TypeError(
                f&#34;`send_config` expects a single string, got {type(config)}, &#34;
                &#34;to send a list of configs use the `send_configs` method instead.&#34;
            )

        # in order to handle multi-line strings, we split lines
        split_config = config.splitlines()

        return split_config

    def _post_send_config(self, config: str, multi_response: ScrapliMultiResponse,) -&gt; Response:
        &#34;&#34;&#34;
        Handle post &#34;send_config&#34; tasks for consistency between sync/async versions

        Args:
            config: string configuration to send to the device, supports sending multi-line strings
            multi_response: multi_response object send_config got from calling self.send_configs;
                we need this to parse out the multi_response back into a single Response object

        Returns:
            Response: Unified response object

        Raises:
            N/A

        &#34;&#34;&#34;
        # capture failed_when_contains and host from zeroith multi_response element (there should
        #  always be at least a zeroith element here!); getting host just lets us keep the mixin
        #  class a little cleaner without having to deal with sync vs async transport classes from
        #  a typing perspective
        failed_when_contains = multi_response[0].failed_when_contains
        host = multi_response[0].host

        # create a new unified response object
        response = Response(
            host=host, channel_input=config, failed_when_contains=failed_when_contains,
        )
        response.start_time = multi_response[0].start_time
        response.elapsed_time = (datetime.now() - response.start_time).total_seconds()

        # join all the results together into a single final result
        response.result = &#34;\n&#34;.join(response.result for response in multi_response)
        response.failed = False

        if any(response.failed for response in multi_response):
            response.failed = True
        self._update_response(response=response)

        return response

    def _pre_send_configs(
        self,
        configs: List[str],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Tuple[str, Optional[Union[str, List[str]]]]:
        &#34;&#34;&#34;
        Handle pre &#34;send_configs&#34; tasks for consistency between sync/async versions

        Args:
            configs: list of strings to send to device in config mode
            failed_when_contains: string or list of strings indicating failure if found in response
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
                JunosDriver. You can also pass in a name of a configuration session such as
                &#34;my-config-session&#34; if you have registered a session using the
                &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

        Returns:
            commands: list of commands read from file

        Raises:
            TypeError: if configs is anything but a list

        &#34;&#34;&#34;
        if not isinstance(configs, list):
            raise TypeError(
                f&#34;`send_configs` expects a list of strings, got {type(configs)}, &#34;
                &#34;to send a single configuration line/string use the `send_config` method instead.&#34;
            )

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        if privilege_level:
            resolved_privilege_level = self._get_privilege_level_name(
                requested_priv=privilege_level
            )
        else:
            resolved_privilege_level = &#34;configuration&#34;

        return resolved_privilege_level, failed_when_contains

    def _post_send_configs(self, responses: ScrapliMultiResponse) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Handle post &#34;send_configs&#34; tasks for consistency between sync/async versions

        Args:
            responses: multi_response object to update

        Returns:
            ScrapliMultiResponse: Unified response object

        Raises:
            N/A

        &#34;&#34;&#34;
        for response in responses:
            self._update_response(response=response)

        return responses

    @staticmethod
    def _pre_send_configs_from_file(file: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Handle pre &#34;send_commands_from_file&#34; tasks for consistency between sync/async versions

        Args:
            file: string path to file

        Returns:
            commands: list of commands read from file

        Raises:
            TypeError: if anything but a string is provided for `file`

        &#34;&#34;&#34;
        if not isinstance(file, str):
            raise TypeError(
                f&#34;`send_configs_from_file` expects a string path to a file, got {type(file)}&#34;
            )
        resolved_file = resolve_file(file)

        with open(resolved_file, &#34;r&#34;) as f:
            configs = f.read().splitlines()

        return configs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.driver.base_network_driver.NetworkDriverBase"><code class="flex name class">
<span>class <span class="ident">NetworkDriverBase</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkDriverBase:
    # NetworkDriverBase Mixin vars for typing/linting purposes
    logger: Logger
    comms_prompt_pattern: str
    _current_priv_level = DUMMY_PRIV_LEVEL
    _priv_map: Dict[str, List[str]]
    failed_when_contains: Optional[List[str]]
    privilege_levels: Dict[str, PrivilegeLevel]
    auth_secondary: str
    textfsm_platform: str
    genie_platform: str

    @staticmethod
    def _check_kwargs_comms_prompt_pattern(kwargs: Any) -&gt; None:
        &#34;&#34;&#34;
        Warn users if passing comms prompt pattern while using NetworkDriver derived classes

        Args:
            kwargs: kwargs being passed into NetworkDriver classes

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if &#34;comms_prompt_pattern&#34; in kwargs:
            err = &#34;`comms_prompt_pattern` found in kwargs!&#34;
            msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
            fix = (
                &#34;`comms_prompt_pattern` is ignored (dropped) when using network drivers. If you &#34;
                &#34;wish to modify the patterns for any network driver sub-classes, please do so by &#34;
                &#34;modifying or providing your own `privilege_levels`.&#34;
            )
            warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
            warnings.warn(warning)
            kwargs.pop(&#34;comms_prompt_pattern&#34;)

    def _generate_comms_prompt_pattern(self) -&gt; None:
        &#34;&#34;&#34;
        Generate the `comms_prompt_pattern_all` from the currently assigned privilege levels

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.comms_prompt_pattern = r&#34;|&#34;.join(
            rf&#34;({priv_level_data.pattern})&#34; for priv_level_data in self.privilege_levels.values()
        )

    def _build_priv_map(self) -&gt; None:
        &#34;&#34;&#34;
        Build a &#34;map&#34; of privilege levels

        `_priv_map` is a &#34;map&#34; of all privilege levels mapped out to the lowest available priv. This
        map is used for determining how to escalate/deescalate.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        for priv_level in self.privilege_levels:
            self._priv_map[priv_level] = [priv_level]
            while True:
                previous_priv = self.privilege_levels[self._priv_map[priv_level][0]].previous_priv
                if not previous_priv:
                    break
                self._priv_map[priv_level].insert(0, previous_priv)

    def update_privilege_levels(self, update_channel: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Re-generate the privilege map, and update the comms prompt pattern

        Args:
            update_channel: True/False update the channel pattern too -- likely only ever set to
                False for class initialization before channel is opened

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._build_priv_map()
        self._generate_comms_prompt_pattern()
        # clear the lru cache as patterns may have been updated
        self._determine_current_priv.cache_clear()
        if update_channel is True:
            self.channel.comms_prompt_pattern = (  # type: ignore  # pylint: disable=E1101
                self.comms_prompt_pattern
            )

    @lru_cache()
    def _determine_current_priv(self, current_prompt: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Determine current privilege level from prompt string

        Args:
            current_prompt: string of current prompt

        Returns:
            matching_priv_levels: list of string names of matching privilege levels

        Raises:
            UnknownPrivLevel: if privilege level cannot be determined

        &#34;&#34;&#34;
        matching_priv_levels = []
        for priv_level in self.privilege_levels.values():
            search_result = re.search(
                pattern=priv_level.pattern, string=current_prompt, flags=re.M | re.I
            )
            if not search_result:
                continue
            matching_priv_levels.append(priv_level.name)
            self.logger.debug(f&#34;Current privilege level could be `{priv_level.name}`&#34;)
        if not matching_priv_levels:
            raise UnknownPrivLevel(
                f&#34;Could not determine privilege level from provided prompt: `{current_prompt}`&#34;
            )
        self.logger.debug(f&#34;Determined current privilege level is one of `{matching_priv_levels}`&#34;)
        return matching_priv_levels

    def _get_privilege_level_name(self, requested_priv: str) -&gt; str:
        &#34;&#34;&#34;
        Get privilege level name if provided privilege is valid

        Args:
            requested_priv: string name of desired privilege level

        Returns:
            str: name of the privilege level requested

        Raises:
            UnknownPrivLevel: if attempting to acquire an unknown priv

        &#34;&#34;&#34;
        desired_privilege_level = self.privilege_levels.get(requested_priv, None)
        if desired_privilege_level is None:
            raise UnknownPrivLevel(
                f&#34;Requested privilege level `{requested_priv}` not a valid privilege level of &#34;
                f&#34;`{self.__class__.__name__}`&#34;
            )
        resolved_privilege_level = desired_privilege_level.name
        return resolved_privilege_level

    def _update_response(self, response: Response) -&gt; None:
        &#34;&#34;&#34;
        Update response with network driver specific data

        This happens here as the underlying channel provides a response object but is unaware of any
        of the network/platform specific attributes that may need to get updated

        Args:
            response: response to update

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        response.textfsm_platform = self.textfsm_platform
        response.genie_platform = self.genie_platform

    def register_configuration_session(self, session_name: str) -&gt; None:
        &#34;&#34;&#34;
        If applicable, register a configuration session as a valid privilege level

        Args:
            session_name: name of config session to register

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            NotImplementedError: unless overridden by concrete class

        &#34;&#34;&#34;
        _ = session_name
        raise NotImplementedError(
            f&#34;Configuration sessions not supported for `{self.__class__.__name__}`&#34;
        )

    def _pre_escalate(self, escalate_priv: PrivilegeLevel) -&gt; None:
        &#34;&#34;&#34;
        Handle pre &#34;_escalate&#34; tasks for consistency between sync/async versions

        Args:
            escalate_priv: privilege level to escalate to

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if escalate_priv.escalate_auth is True and not self.auth_secondary:
            err = (
                &#34;Privilege escalation generally requires an `auth_secondary` password, &#34;
                &#34;but none is set!&#34;
            )
            msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
            fix = (
                &#34;scrapli will try to escalate privilege without entering a password but may &#34;
                &#34;fail.\nSet an `auth_secondary` password if your device requires a password to &#34;
                &#34;increase privilege, otherwise ignore this message.&#34;
            )
            warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
            warnings.warn(warning)

    def _pre_acquire_priv(self, desired_priv: str) -&gt; Tuple[str, List[str]]:
        &#34;&#34;&#34;
        Handle pre &#34;acquire_priv&#34; tasks for consistency between sync/async versions

        Args:
            desired_priv: string name of desired privilege level

        Returns:
            resolved_priv: privilege level class resolved via given privilege name
            map_to_desired_priv: map from current priv to desired priv (list of strings of privs to
                iterate through to get to target priv)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Attempting to acquire `{desired_priv}` privilege level&#34;)
        resolved_priv = self._get_privilege_level_name(requested_priv=desired_priv)
        map_to_desired_priv = self._priv_map[resolved_priv]
        return resolved_priv, map_to_desired_priv

    def _process_acquire_priv(
        self, resolved_priv: str, map_to_desired_priv: List[str], current_prompt: str,
    ) -&gt; Tuple[PrivilegeAction, PrivilegeLevel]:
        &#34;&#34;&#34;
        Handle non channel &#34;acquire_priv&#34; tasks for consistency between sync/async versions

        Args:
            resolved_priv: string name of desired privilege level
            map_to_desired_priv: list of string names of privilege levels to acquire to get to
                desired privilege level
            current_prompt: string of the current prompt

        Returns:
            PrivilegeAction: enum set to appropriate value for no action, escalate or deescalate
            PrivilegeLevel: privilege level object to pass to either escalate or deescalate method

        Raises:
            N/A

        &#34;&#34;&#34;
        # if we are already at the desired priv, we don&#39;t need to do any thing
        current_priv_patterns = self._determine_current_priv(current_prompt=current_prompt)

        # if multiple patterns match pick the zeroith... the only time patterns should be
        # identical is if we have privilege levels like &#34;configuration&#34; or
        # &#34;configuration_exclusive&#34; that have identical prompts (ex: IOSXRDriver)
        current_priv = self.privilege_levels[current_priv_patterns[0]]

        if resolved_priv in current_priv_patterns:
            self.logger.info(f&#34;Acquired requested privilege level `{resolved_priv}`&#34;)
            self._current_priv_level = self.privilege_levels[resolved_priv]
            return PrivilegeAction.NO_ACTION, current_priv

        map_to_current_priv = self._priv_map[current_priv.name]
        priv_map = (
            map_to_current_priv
            if map_to_current_priv &gt; map_to_desired_priv
            else map_to_desired_priv
        )

        desired_priv_index = priv_map.index(resolved_priv)
        try:
            current_priv_index = priv_map.index(current_priv.name)
        except ValueError:
            # if the current priv is not in the map for the desired priv; set the current index
            # to the &#34;top&#34; (end) of the priv map and work our way back down
            current_priv_index = len(priv_map)

        if current_priv_index &gt; desired_priv_index:
            deescalate_priv = priv_map[current_priv_index - 1]
            self.logger.info(
                f&#34;Attempting to deescalate from {current_priv.name} to {deescalate_priv}&#34;
            )
            return PrivilegeAction.DEESCALATE, current_priv

        escalate_priv = self.privilege_levels[priv_map[current_priv_index + 1]]
        self.logger.info(f&#34;Attempting to escalate from {current_priv.name} to {escalate_priv.name}&#34;)
        return PrivilegeAction.ESCALATE, escalate_priv

    @staticmethod
    def _pre_send_config(config: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Handle pre &#34;send_config&#34; tasks for consistency between sync/async versions

        Args:
            config: string configuration to send to the device, supports sending multi-line strings

        Returns:
            configs: list of config lines from provided &#34;config&#34; input

        Raises:
            TypeError: if anything but a string is provided for `file`

        &#34;&#34;&#34;
        if not isinstance(config, str):
            raise TypeError(
                f&#34;`send_config` expects a single string, got {type(config)}, &#34;
                &#34;to send a list of configs use the `send_configs` method instead.&#34;
            )

        # in order to handle multi-line strings, we split lines
        split_config = config.splitlines()

        return split_config

    def _post_send_config(self, config: str, multi_response: ScrapliMultiResponse,) -&gt; Response:
        &#34;&#34;&#34;
        Handle post &#34;send_config&#34; tasks for consistency between sync/async versions

        Args:
            config: string configuration to send to the device, supports sending multi-line strings
            multi_response: multi_response object send_config got from calling self.send_configs;
                we need this to parse out the multi_response back into a single Response object

        Returns:
            Response: Unified response object

        Raises:
            N/A

        &#34;&#34;&#34;
        # capture failed_when_contains and host from zeroith multi_response element (there should
        #  always be at least a zeroith element here!); getting host just lets us keep the mixin
        #  class a little cleaner without having to deal with sync vs async transport classes from
        #  a typing perspective
        failed_when_contains = multi_response[0].failed_when_contains
        host = multi_response[0].host

        # create a new unified response object
        response = Response(
            host=host, channel_input=config, failed_when_contains=failed_when_contains,
        )
        response.start_time = multi_response[0].start_time
        response.elapsed_time = (datetime.now() - response.start_time).total_seconds()

        # join all the results together into a single final result
        response.result = &#34;\n&#34;.join(response.result for response in multi_response)
        response.failed = False

        if any(response.failed for response in multi_response):
            response.failed = True
        self._update_response(response=response)

        return response

    def _pre_send_configs(
        self,
        configs: List[str],
        failed_when_contains: Optional[Union[str, List[str]]] = None,
        privilege_level: str = &#34;&#34;,
    ) -&gt; Tuple[str, Optional[Union[str, List[str]]]]:
        &#34;&#34;&#34;
        Handle pre &#34;send_configs&#34; tasks for consistency between sync/async versions

        Args:
            configs: list of strings to send to device in config mode
            failed_when_contains: string or list of strings indicating failure if found in response
            privilege_level: name of configuration privilege level/type to acquire; this is platform
                dependent, so check the device driver for specifics. Examples of privilege_name
                would be &#34;configuration_exclusive&#34; for IOSXRDriver, or &#34;configuration_private&#34; for
                JunosDriver. You can also pass in a name of a configuration session such as
                &#34;my-config-session&#34; if you have registered a session using the
                &#34;register_config_session&#34; method of the EOSDriver or NXOSDriver.

        Returns:
            commands: list of commands read from file

        Raises:
            TypeError: if configs is anything but a list

        &#34;&#34;&#34;
        if not isinstance(configs, list):
            raise TypeError(
                f&#34;`send_configs` expects a list of strings, got {type(configs)}, &#34;
                &#34;to send a single configuration line/string use the `send_config` method instead.&#34;
            )

        if failed_when_contains is None:
            failed_when_contains = self.failed_when_contains

        if privilege_level:
            resolved_privilege_level = self._get_privilege_level_name(
                requested_priv=privilege_level
            )
        else:
            resolved_privilege_level = &#34;configuration&#34;

        return resolved_privilege_level, failed_when_contains

    def _post_send_configs(self, responses: ScrapliMultiResponse) -&gt; ScrapliMultiResponse:
        &#34;&#34;&#34;
        Handle post &#34;send_configs&#34; tasks for consistency between sync/async versions

        Args:
            responses: multi_response object to update

        Returns:
            ScrapliMultiResponse: Unified response object

        Raises:
            N/A

        &#34;&#34;&#34;
        for response in responses:
            self._update_response(response=response)

        return responses

    @staticmethod
    def _pre_send_configs_from_file(file: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Handle pre &#34;send_commands_from_file&#34; tasks for consistency between sync/async versions

        Args:
            file: string path to file

        Returns:
            commands: list of commands read from file

        Raises:
            TypeError: if anything but a string is provided for `file`

        &#34;&#34;&#34;
        if not isinstance(file, str):
            raise TypeError(
                f&#34;`send_configs_from_file` expects a string path to a file, got {type(file)}&#34;
            )
        resolved_file = resolve_file(file)

        with open(resolved_file, &#34;r&#34;) as f:
            configs = f.read().splitlines()

        return configs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></li>
<li><a title="scrapli.driver.network_driver.NetworkDriver" href="network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session"><code class="name flex">
<span>def <span class="ident">register_configuration_session</span></span>(<span>self, session_name: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If applicable, register a configuration session as a valid privilege level</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>session_name</code></strong></dt>
<dd>name of config session to register</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A:
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>unless overridden by concrete class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_configuration_session(self, session_name: str) -&gt; None:
    &#34;&#34;&#34;
    If applicable, register a configuration session as a valid privilege level

    Args:
        session_name: name of config session to register

    Returns:
        N/A:  # noqa: DAR202

    Raises:
        NotImplementedError: unless overridden by concrete class

    &#34;&#34;&#34;
    _ = session_name
    raise NotImplementedError(
        f&#34;Configuration sessions not supported for `{self.__class__.__name__}`&#34;
    )</code></pre>
</details>
</dd>
<dt id="scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels"><code class="name flex">
<span>def <span class="ident">update_privilege_levels</span></span>(<span>self, update_channel: bool = True) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Re-generate the privilege map, and update the comms prompt pattern</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>update_channel</code></strong></dt>
<dd>True/False update the channel pattern too &ndash; likely only ever set to
False for class initialization before channel is opened</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_privilege_levels(self, update_channel: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Re-generate the privilege map, and update the comms prompt pattern

    Args:
        update_channel: True/False update the channel pattern too -- likely only ever set to
            False for class initialization before channel is opened

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self._build_priv_map()
    self._generate_comms_prompt_pattern()
    # clear the lru cache as patterns may have been updated
    self._determine_current_priv.cache_clear()
    if update_channel is True:
        self.channel.comms_prompt_pattern = (  # type: ignore  # pylint: disable=E1101
            self.comms_prompt_pattern
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeAction"><code class="flex name class">
<span>class <span class="ident">PrivilegeAction</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrivilegeAction(Enum):
    NO_ACTION = &#34;no action&#34;
    ESCALATE = &#34;escalate&#34;
    DEESCALATE = &#34;deescalate&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli.driver.base_network_driver.PrivilegeAction.DEESCALATE"><code class="name">var <span class="ident">DEESCALATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeAction.ESCALATE"><code class="name">var <span class="ident">ESCALATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeAction.NO_ACTION"><code class="name">var <span class="ident">NO_ACTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel"><code class="flex name class">
<span>class <span class="ident">PrivilegeLevel</span></span>
<span>(</span><span>pattern: str, name: str, previous_priv: str, deescalate: str, escalate: str, escalate_auth: bool, escalate_prompt: str)</span>
</code></dt>
<dd>
<div class="desc"><p>PrivilegeLevel Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong></dt>
<dd>regex pattern to use to identify this privilege level by the prompt</dd>
<dt><strong><code>name</code></strong></dt>
<dd>friendly name of this privilege level</dd>
<dt><strong><code>previous_priv</code></strong></dt>
<dd>name of the lower/previous privilege level</dd>
<dt><strong><code>deescalate</code></strong></dt>
<dd>how to deescalate <em>from</em> this privilege level (to the lower/previous priv)</dd>
<dt><strong><code>escalate</code></strong></dt>
<dd>how to escalate <em>to</em> this privilege level (from the lower/previous priv)</dd>
<dt><strong><code>escalate_auth</code></strong></dt>
<dd>True/False escalation requires authentication</dd>
<dt><strong><code>escalate_prompt</code></strong></dt>
<dd>prompt pattern to search for during escalation if escalate auth is True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrivilegeLevel:
    __slots__ = (
        &#34;pattern&#34;,
        &#34;name&#34;,
        &#34;previous_priv&#34;,
        &#34;deescalate&#34;,
        &#34;escalate&#34;,
        &#34;escalate_auth&#34;,
        &#34;escalate_prompt&#34;,
    )

    def __init__(
        self,
        pattern: str,
        name: str,
        previous_priv: str,
        deescalate: str,
        escalate: str,
        escalate_auth: bool,
        escalate_prompt: str,
    ):
        &#34;&#34;&#34;
        PrivilegeLevel Object

        Args:
            pattern: regex pattern to use to identify this privilege level by the prompt
            name: friendly name of this privilege level
            previous_priv: name of the lower/previous privilege level
            deescalate: how to deescalate *from* this privilege level (to the lower/previous priv)
            escalate: how to escalate *to* this privilege level (from the lower/previous priv)
            escalate_auth: True/False escalation requires authentication
            escalate_prompt: prompt pattern to search for during escalation if escalate auth is True

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.pattern = pattern
        self.name = name
        self.previous_priv = previous_priv
        self.deescalate = deescalate
        self.escalate = escalate
        self.escalate_auth = escalate_auth
        self.escalate_prompt = escalate_prompt</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel.deescalate"><code class="name">var <span class="ident">deescalate</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel.escalate"><code class="name">var <span class="ident">escalate</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel.escalate_auth"><code class="name">var <span class="ident">escalate_auth</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel.escalate_prompt"><code class="name">var <span class="ident">escalate_prompt</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel.pattern"><code class="name">var <span class="ident">pattern</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="scrapli.driver.base_network_driver.PrivilegeLevel.previous_priv"><code class="name">var <span class="ident">previous_priv</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.driver" href="index.html">scrapli.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session" href="#scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session">register_configuration_session</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels" href="#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.base_network_driver.PrivilegeAction" href="#scrapli.driver.base_network_driver.PrivilegeAction">PrivilegeAction</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeAction.DEESCALATE" href="#scrapli.driver.base_network_driver.PrivilegeAction.DEESCALATE">DEESCALATE</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeAction.ESCALATE" href="#scrapli.driver.base_network_driver.PrivilegeAction.ESCALATE">ESCALATE</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeAction.NO_ACTION" href="#scrapli.driver.base_network_driver.PrivilegeAction.NO_ACTION">NO_ACTION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel" href="#scrapli.driver.base_network_driver.PrivilegeLevel">PrivilegeLevel</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel.deescalate" href="#scrapli.driver.base_network_driver.PrivilegeLevel.deescalate">deescalate</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel.escalate" href="#scrapli.driver.base_network_driver.PrivilegeLevel.escalate">escalate</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel.escalate_auth" href="#scrapli.driver.base_network_driver.PrivilegeLevel.escalate_auth">escalate_auth</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel.escalate_prompt" href="#scrapli.driver.base_network_driver.PrivilegeLevel.escalate_prompt">escalate_prompt</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel.name" href="#scrapli.driver.base_network_driver.PrivilegeLevel.name">name</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel.pattern" href="#scrapli.driver.base_network_driver.PrivilegeLevel.pattern">pattern</a></code></li>
<li><code><a title="scrapli.driver.base_network_driver.PrivilegeLevel.previous_priv" href="#scrapli.driver.base_network_driver.PrivilegeLevel.previous_priv">previous_priv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>