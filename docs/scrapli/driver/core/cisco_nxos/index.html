<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>scrapli.driver.core.cisco_nxos API documentation</title>
<meta name="description" content="scrapli.driver.core.cisco_nxos" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.driver.core.cisco_nxos</code></h1>
</header>
<section id="section-intro">
<p>scrapli.driver.core.cisco_nxos</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.driver.core.cisco_nxos&#34;&#34;&#34;
from scrapli.driver.core.cisco_nxos.async_driver import AsyncNXOSDriver
from scrapli.driver.core.cisco_nxos.driver import NXOSDriver

__all__ = (
    &#34;AsyncNXOSDriver&#34;,
    &#34;NXOSDriver&#34;,
)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli.driver.core.cisco_nxos.async_driver" href="async_driver.html">scrapli.driver.core.cisco_nxos.async_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.core.cisco_nxos.async_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver.core.cisco_nxos.driver" href="driver.html">scrapli.driver.core.cisco_nxos.driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver.core.cisco_nxos.driver</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.driver.core.cisco_nxos.AsyncNXOSDriver"><code class="flex name class">
<span>class <span class="ident">AsyncNXOSDriver</span></span>
<span>(</span><span>privilege_levels: Union[Dict[str, scrapli.driver.base_network_driver.PrivilegeLevel], NoneType] = None, default_desired_privilege_level: str = 'privilege_exec', auth_secondary: str = '', on_open: Union[Callable[..., Any], NoneType] = None, on_close: Union[Callable[..., Any], NoneType] = None, textfsm_platform: str = 'cisco_nxos', genie_platform: str = 'nxos', failed_when_contains: Union[List[str], NoneType] = None, transport: str = 'system', **kwargs: Dict[str, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code>Scrape</code> object from that perspective.</p>
<p>NXOSDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>optional user provided privilege levels, if left None will default to
scrapli standard privilege levels</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>on_open</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately after authentication is completed. Common use
cases for this callable would be to disable paging or accept any kind of banner
message that prompts a user upon connection</dd>
<dt><strong><code>on_close</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately prior to closing the underlying transport.
Common use cases for this callable would be to save configurations prior to exiting,
or to logout properly to free up vtys or similar.</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of textfsm parser platform</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of cisco genie parser platform</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>List of strings that indicate a command/config has failed</dd>
<dt><strong><code>transport</code></strong></dt>
<dd>system|telnet or a plugin &ndash; type of transport to use for connection
system uses system available ssh (/usr/bin/ssh)
ssh2 uses ssh2-python <em>has been migrated to a plugin
paramiko uses&hellip; paramiko </em>has been migrated to a plugin
telnet uses telnetlib
choice of driver depends on the features you need. in general system is easiest as
it will just 'auto-magically' use your ssh config file ('~/.ssh/config' or
'/etc/ssh/config_file'). ssh2 is very very fast as it is a thin wrapper around
libssh2 however it is slightly feature limited. paramiko is slower than ssh2, but
has more features built in (though scrapli does not expose/support them all).
explicitly added here to allow for nicely checking if transport is telnet.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncNXOSDriver(AsyncNetworkDriver, NXOSDriverBase):
    def __init__(
        self,
        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,
        default_desired_privilege_level: str = &#34;privilege_exec&#34;,
        auth_secondary: str = &#34;&#34;,
        on_open: Optional[Callable[..., Any]] = None,
        on_close: Optional[Callable[..., Any]] = None,
        textfsm_platform: str = &#34;cisco_nxos&#34;,
        genie_platform: str = &#34;nxos&#34;,
        failed_when_contains: Optional[List[str]] = None,
        transport: str = &#34;system&#34;,
        **kwargs: Dict[str, Any],
    ):
        &#34;&#34;&#34;
        NXOSDriver Object

        Args:
            privilege_levels: optional user provided privilege levels, if left None will default to
                scrapli standard privilege levels
            default_desired_privilege_level: string of name of default desired priv, this is the
                priv level that is generally used to disable paging/set terminal width and things
                like that upon first login, and is also the priv level scrapli will try to acquire
                for normal &#34;command&#34; operations (`send_command`, `send_commands`)
            auth_secondary: password to use for secondary authentication (enable)
            on_open: callable that accepts the class instance as its only argument. this callable,
                if provided, is executed immediately after authentication is completed. Common use
                cases for this callable would be to disable paging or accept any kind of banner
                message that prompts a user upon connection
            on_close: callable that accepts the class instance as its only argument. this callable,
                if provided, is executed immediately prior to closing the underlying transport.
                Common use cases for this callable would be to save configurations prior to exiting,
                or to logout properly to free up vtys or similar.
            textfsm_platform: string name of textfsm parser platform
            genie_platform: string name of cisco genie parser platform
            failed_when_contains: List of strings that indicate a command/config has failed
            transport: system|telnet or a plugin -- type of transport to use for connection
                system uses system available ssh (/usr/bin/ssh)
                ssh2 uses ssh2-python *has been migrated to a plugin
                paramiko uses... paramiko *has been migrated to a plugin
                telnet uses telnetlib
                choice of driver depends on the features you need. in general system is easiest as
                it will just &#39;auto-magically&#39; use your ssh config file (&#39;~/.ssh/config&#39; or
                &#39;/etc/ssh/config_file&#39;). ssh2 is very very fast as it is a thin wrapper around
                libssh2 however it is slightly feature limited. paramiko is slower than ssh2, but
                has more features built in (though scrapli does not expose/support them all).
                explicitly added here to allow for nicely checking if transport is telnet.
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A
        &#34;&#34;&#34;
        if privilege_levels is None:
            privilege_levels = PRIVS

        if on_open is None:
            on_open = nxos_on_open
        if on_close is None:
            on_close = nxos_on_close

        _telnet = False
        if transport == &#34;telnet&#34;:
            _telnet = True

        if failed_when_contains is None:
            failed_when_contains = [
                &#34;% Ambiguous command&#34;,
                &#34;% Incomplete command&#34;,
                &#34;% Invalid input detected&#34;,
                &#34;% Invalid command at&#34;,
            ]

        super().__init__(
            privilege_levels=privilege_levels,
            default_desired_privilege_level=default_desired_privilege_level,
            auth_secondary=auth_secondary,
            failed_when_contains=failed_when_contains,
            textfsm_platform=textfsm_platform,
            genie_platform=genie_platform,
            on_open=on_open,
            on_close=on_close,
            transport=transport,
            **kwargs,
        )

        if _telnet:
            self.transport.username_prompt = &#34;login:&#34;

    async def _abort_config(self) -&gt; None:
        &#34;&#34;&#34;
        Abort NXOS configuration session (if using a config session!)

        Args:
            N/A

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        # nxos pattern for config sessions should *always* have `config-s`
        if &#34;config\\-s&#34; in self._current_priv_level.pattern:
            self.channel.send_input(channel_input=&#34;abort&#34;)
            self._current_priv_level = self.privilege_levels[&#34;privilege_exec&#34;]

    def register_configuration_session(self, session_name: str) -&gt; None:
        &#34;&#34;&#34;
        NXOS specific implementation of register_configuration_session

        Args:
            session_name: name of session to register

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._create_configuration_session(session_name=session_name)
        self.update_privilege_levels(update_channel=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></li>
<li><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="../../async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></li>
<li><a title="scrapli.driver.async_driver.AsyncScrape" href="../../async_driver.html#scrapli.driver.async_driver.AsyncScrape">AsyncScrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="../../base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="../../base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="../../base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
<li><a title="scrapli.driver.core.cisco_nxos.driver.NXOSDriverBase" href="driver.html#scrapli.driver.core.cisco_nxos.driver.NXOSDriverBase">NXOSDriverBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.core.cisco_nxos.AsyncNXOSDriver.register_configuration_session"><code class="name flex">
<span>def <span class="ident">register_configuration_session</span></span>(<span>self, session_name: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>NXOS specific implementation of register_configuration_session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>session_name</code></strong></dt>
<dd>name of session to register</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A:
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_configuration_session(self, session_name: str) -&gt; None:
    &#34;&#34;&#34;
    NXOS specific implementation of register_configuration_session

    Args:
        session_name: name of session to register

    Returns:
        N/A:  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self._create_configuration_session(session_name=session_name)
    self.update_privilege_levels(update_channel=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.acquire_priv" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.close" href="../../async_driver.html#scrapli.driver.async_driver.AsyncScrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.get_prompt" href="../../async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.isalive" href="../../base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.open" href="../../async_driver.html#scrapli.driver.async_driver.AsyncScrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_command" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands_from_file" href="../../async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_config" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs_from_file" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_interactive" href="../../async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_interactive">send_interactive</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.update_privilege_levels" href="../../base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.driver.core.cisco_nxos.NXOSDriver"><code class="flex name class">
<span>class <span class="ident">NXOSDriver</span></span>
<span>(</span><span>privilege_levels: Union[Dict[str, scrapli.driver.base_network_driver.PrivilegeLevel], NoneType] = None, default_desired_privilege_level: str = 'privilege_exec', auth_secondary: str = '', on_open: Union[Callable[..., Any], NoneType] = None, on_close: Union[Callable[..., Any], NoneType] = None, textfsm_platform: str = 'cisco_nxos', genie_platform: str = 'nxos', failed_when_contains: Union[List[str], NoneType] = None, transport: str = 'system', **kwargs: Dict[str, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code>Scrape</code> object from that perspective.</p>
<p>NXOSDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>optional user provided privilege levels, if left None will default to
scrapli standard privilege levels</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>on_open</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately after authentication is completed. Common use
cases for this callable would be to disable paging or accept any kind of banner
message that prompts a user upon connection</dd>
<dt><strong><code>on_close</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately prior to closing the underlying transport.
Common use cases for this callable would be to save configurations prior to exiting,
or to logout properly to free up vtys or similar.</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of textfsm parser platform</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of cisco genie parser platform</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>List of strings that indicate a command/config has failed</dd>
<dt><strong><code>transport</code></strong></dt>
<dd>system|telnet or a plugin &ndash; type of transport to use for connection
system uses system available ssh (/usr/bin/ssh)
ssh2 uses ssh2-python <em>has been migrated to a plugin
paramiko uses&hellip; paramiko </em>has been migrated to a plugin
telnet uses telnetlib
choice of driver depends on the features you need. in general system is easiest as
it will just 'auto-magically' use your ssh config file ('~/.ssh/config' or
'/etc/ssh/config_file'). ssh2 is very very fast as it is a thin wrapper around
libssh2 however it is slightly feature limited. paramiko is slower than ssh2, but
has more features built in (though scrapli does not expose/support them all).
explicitly added here to allow for nicely checking if transport is telnet.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NXOSDriver(NetworkDriver, NXOSDriverBase):
    def __init__(
        self,
        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,
        default_desired_privilege_level: str = &#34;privilege_exec&#34;,
        auth_secondary: str = &#34;&#34;,
        on_open: Optional[Callable[..., Any]] = None,
        on_close: Optional[Callable[..., Any]] = None,
        textfsm_platform: str = &#34;cisco_nxos&#34;,
        genie_platform: str = &#34;nxos&#34;,
        failed_when_contains: Optional[List[str]] = None,
        transport: str = &#34;system&#34;,
        **kwargs: Dict[str, Any],
    ):
        &#34;&#34;&#34;
        NXOSDriver Object

        Args:
            privilege_levels: optional user provided privilege levels, if left None will default to
                scrapli standard privilege levels
            default_desired_privilege_level: string of name of default desired priv, this is the
                priv level that is generally used to disable paging/set terminal width and things
                like that upon first login, and is also the priv level scrapli will try to acquire
                for normal &#34;command&#34; operations (`send_command`, `send_commands`)
            auth_secondary: password to use for secondary authentication (enable)
            on_open: callable that accepts the class instance as its only argument. this callable,
                if provided, is executed immediately after authentication is completed. Common use
                cases for this callable would be to disable paging or accept any kind of banner
                message that prompts a user upon connection
            on_close: callable that accepts the class instance as its only argument. this callable,
                if provided, is executed immediately prior to closing the underlying transport.
                Common use cases for this callable would be to save configurations prior to exiting,
                or to logout properly to free up vtys or similar.
            textfsm_platform: string name of textfsm parser platform
            genie_platform: string name of cisco genie parser platform
            failed_when_contains: List of strings that indicate a command/config has failed
            transport: system|telnet or a plugin -- type of transport to use for connection
                system uses system available ssh (/usr/bin/ssh)
                ssh2 uses ssh2-python *has been migrated to a plugin
                paramiko uses... paramiko *has been migrated to a plugin
                telnet uses telnetlib
                choice of driver depends on the features you need. in general system is easiest as
                it will just &#39;auto-magically&#39; use your ssh config file (&#39;~/.ssh/config&#39; or
                &#39;/etc/ssh/config_file&#39;). ssh2 is very very fast as it is a thin wrapper around
                libssh2 however it is slightly feature limited. paramiko is slower than ssh2, but
                has more features built in (though scrapli does not expose/support them all).
                explicitly added here to allow for nicely checking if transport is telnet.
            **kwargs: keyword args to pass to inherited class(es)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A
        &#34;&#34;&#34;
        if privilege_levels is None:
            privilege_levels = PRIVS

        if on_open is None:
            on_open = nxos_on_open
        if on_close is None:
            on_close = nxos_on_close

        _telnet = False
        if transport == &#34;telnet&#34;:
            _telnet = True

        if failed_when_contains is None:
            failed_when_contains = [
                &#34;% Ambiguous command&#34;,
                &#34;% Incomplete command&#34;,
                &#34;% Invalid input detected&#34;,
                &#34;% Invalid command at&#34;,
            ]

        super().__init__(
            privilege_levels=privilege_levels,
            default_desired_privilege_level=default_desired_privilege_level,
            auth_secondary=auth_secondary,
            failed_when_contains=failed_when_contains,
            textfsm_platform=textfsm_platform,
            genie_platform=genie_platform,
            on_open=on_open,
            on_close=on_close,
            transport=transport,
            **kwargs,
        )

        if _telnet:
            self.transport.username_prompt = &#34;login:&#34;

    def _abort_config(self) -&gt; None:
        &#34;&#34;&#34;
        Abort NXOS configuration session (if using a config session!)

        Args:
            N/A

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        # nxos pattern for config sessions should *always* have `config-s`
        if &#34;config\\-s&#34; in self._current_priv_level.pattern:
            self.channel.send_input(channel_input=&#34;abort&#34;)
            self._current_priv_level = self.privilege_levels[&#34;privilege_exec&#34;]

    def register_configuration_session(self, session_name: str) -&gt; None:
        &#34;&#34;&#34;
        NXOS specific implementation of register_configuration_session

        Args:
            session_name: name of session to register

        Returns:
            N/A:  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._create_configuration_session(session_name=session_name)
        self.update_privilege_levels(update_channel=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.network_driver.NetworkDriver" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></li>
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="../../generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
<li><a title="scrapli.driver.driver.Scrape" href="../../driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="../../base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="../../base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="../../base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
<li><a title="scrapli.driver.core.cisco_nxos.driver.NXOSDriverBase" href="driver.html#scrapli.driver.core.cisco_nxos.driver.NXOSDriverBase">NXOSDriverBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.driver.core.cisco_nxos.NXOSDriver.register_configuration_session"><code class="name flex">
<span>def <span class="ident">register_configuration_session</span></span>(<span>self, session_name: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>NXOS specific implementation of register_configuration_session</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>session_name</code></strong></dt>
<dd>name of session to register</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A:
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_configuration_session(self, session_name: str) -&gt; None:
    &#34;&#34;&#34;
    NXOS specific implementation of register_configuration_session

    Args:
        session_name: name of session to register

    Returns:
        N/A:  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self._create_configuration_session(session_name=session_name)
    self.update_privilege_levels(update_channel=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.network_driver.NetworkDriver" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.acquire_priv" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.close" href="../../driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.get_prompt" href="../../generic_driver.html#scrapli.driver.generic_driver.GenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.isalive" href="../../base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.open" href="../../driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_command" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_commands" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_commands_from_file" href="../../generic_driver.html#scrapli.driver.generic_driver.GenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_config" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_configs" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_configs_from_file" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_interactive" href="../../network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_interactive">send_interactive</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.update_privilege_levels" href="../../base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.driver.core" href="../index.html">scrapli.driver.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli.driver.core.cisco_nxos.async_driver" href="async_driver.html">scrapli.driver.core.cisco_nxos.async_driver</a></code></li>
<li><code><a title="scrapli.driver.core.cisco_nxos.driver" href="driver.html">scrapli.driver.core.cisco_nxos.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.driver.core.cisco_nxos.AsyncNXOSDriver" href="#scrapli.driver.core.cisco_nxos.AsyncNXOSDriver">AsyncNXOSDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.core.cisco_nxos.AsyncNXOSDriver.register_configuration_session" href="#scrapli.driver.core.cisco_nxos.AsyncNXOSDriver.register_configuration_session">register_configuration_session</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.driver.core.cisco_nxos.NXOSDriver" href="#scrapli.driver.core.cisco_nxos.NXOSDriver">NXOSDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli.driver.core.cisco_nxos.NXOSDriver.register_configuration_session" href="#scrapli.driver.core.cisco_nxos.NXOSDriver.register_configuration_session">register_configuration_session</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>