<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>scrapli.decorators API documentation</title>
<meta name="description" content="scrapli.decorators" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.decorators</code></h1>
</header>
<section id="section-intro">
<p>scrapli.decorators</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.decorators&#34;&#34;&#34;
import asyncio
import multiprocessing.pool
import signal
import sys
import threading
from typing import TYPE_CHECKING, Any, Callable, Dict, Union

from scrapli.exceptions import ConnectionNotOpened, ScrapliTimeout

if TYPE_CHECKING:
    from scrapli.channel import AsyncChannel  # pragma: no cover
    from scrapli.channel import Channel  # pragma:  no cover
    from scrapli.driver import AsyncGenericDriver, GenericDriver  # pragma:  no cover
    from scrapli.transport import Transport  # pragma:  no cover

WIN = sys.platform.startswith(&#34;win&#34;)


class OperationTimeout:
    def __init__(self, attribute: str, message: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
        Operation timeout decorator

        Wrap an operation, check class for given attribute and use that for the timeout duration.

        Historically this was not a class and has gone through several iterations... the first
        iteration was using only signal... this was fast and efficient but did not work on windows
        and due to system transport spawning a pty/forking things it would not work for that either.
        Timeouts were then moved to use the multiprocessing method, which works in all cases, and is
        thread safe (unlike signal), however it is very cpu intensive and slightly slower than the
        signal method. This current iteration moved the decorator into a class so it is more orderly
        and easier to break things up into smaller chunks, and importantly now supports both timeout
        methods -- signal and multiprocessing. This will always try to use the signal method, but if
        that is not available (due to windows, system transport, or being in not the main thread),
        it will fallback to the multiprocessing method.

        Args:
            attribute: name of attribute to use to get timeout value (set in the decorator)
            message: optional message to use in timeout exception (set in the decorator)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.attribute = attribute
        self.message = message

        self.scrapli_obj: Union[&#34;Channel&#34;, &#34;Transport&#34;]
        self.session_lock: threading.Lock
        self.close: Callable[..., Any]
        self.transport: &#34;Transport&#34;
        self.timeout_duration: float
        self.timeout_exit: bool = True
        self.signals_supported_transport: bool = True
        self._use_signals: bool = False

    def __call__(self, wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:
        &#34;&#34;&#34;
        Operation timeout decorator

        This is what is called when the decorator is triggered

        Args:
            wrapped_func: function being decorated

        Returns:
            decorate: decorated func

        Raises:
            N/A

        &#34;&#34;&#34;
        if asyncio.iscoroutinefunction(wrapped_func):

            async def decorate(*args: Any, **kwargs: Any) -&gt; Any:
                self.scrapli_obj = args[0]
                self.timeout_duration = getattr(self.scrapli_obj, self.attribute, None)

                if not self.timeout_duration:
                    self.scrapli_obj.logger.info(
                        f&#34;Could not find {self.attribute} value of {self.scrapli_obj}, continuing &#34;
                        &#34;without timeout decorator&#34;
                    )
                    return await wrapped_func(*args, **kwargs)

                self.set_scrapli_obj_attrs()
                return await self.asyncio_timeout(
                    wrapped_func=wrapped_func, args=args, kwargs=kwargs
                )

        else:

            def decorate(*args: Any, **kwargs: Any) -&gt; Any:  # type: ignore
                self.scrapli_obj = args[0]
                self.timeout_duration = getattr(self.scrapli_obj, self.attribute, None)

                if not self.timeout_duration:
                    self.scrapli_obj.logger.info(
                        f&#34;Could not find {self.attribute} value of {self.scrapli_obj}, continuing &#34;
                        &#34;without timeout decorator&#34;
                    )
                    return wrapped_func(*args, **kwargs)

                self.set_scrapli_obj_attrs()
                self.determine_sync_timeout_method()

                if self._use_signals:
                    return self.signal_timeout(wrapped_func=wrapped_func, args=args, kwargs=kwargs)
                return self.multiprocessing_timeout(
                    wrapped_func=wrapped_func, args=args, kwargs=kwargs
                )

        return decorate

    def set_scrapli_obj_attrs(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to set attributes of wrapped functions class object

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        from scrapli.channel import AsyncChannel, Channel  # pylint: disable=C0415

        if isinstance(self.scrapli_obj, (AsyncChannel, Channel)):
            self.timeout_exit = self.scrapli_obj.transport.timeout_exit
            self.close = self.scrapli_obj.transport.close
            self.transport = self.scrapli_obj.transport
        else:
            self.timeout_exit = self.scrapli_obj.timeout_exit
            self.close = self.scrapli_obj.close
            self.transport = self.scrapli_obj

    def determine_sync_timeout_method(self) -&gt; None:
        &#34;&#34;&#34;
        Decide what timeout mechanism to use for synchronous usage

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        from scrapli.transport.systemssh import SystemSSHTransport  # pylint: disable=C0415
        from scrapli.transport.telnet import TelnetTransport  # pylint: disable=C0415

        if isinstance(self.transport, (SystemSSHTransport, TelnetTransport)):
            # system transport cant use signals due to pty, unclear why telnetlib doesnt work with
            # signals, but it does not
            self.signals_supported_transport = False

        if (
            not self.signals_supported_transport
            or WIN
            or threading.current_thread() is not threading.main_thread()
        ):
            self._use_signals = False
        else:
            self._use_signals = True

    def _handle_timeout(self) -&gt; None:
        &#34;&#34;&#34;
        Timeout handler method to close connections and raise ScrapliTimeout

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliTimeout: always, if we hit this method we have already timed out!

        &#34;&#34;&#34;
        if self.timeout_exit:
            self.scrapli_obj.logger.info(&#34;timeout_exit is True, closing transport&#34;)
            self.close()
        raise ScrapliTimeout(self.message)

    def _signal_raise_exception(self, signum: Any, frame: Any) -&gt; None:
        &#34;&#34;&#34;
        Signal method exception handler

        Args:
            signum: singum from the singal handler, unused here
            frame: frame from the signal handler, unused here

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        _, _ = signum, frame
        self._handle_timeout()

    async def asyncio_timeout(
        self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any
    ) -&gt; Any:
        &#34;&#34;&#34;
        Asyncio method for timeouts

        Args:
            wrapped_func: function being decorated
            args: function being decorated args
            kwargs: function being decorated kwargs

        Returns:
            Any: result of decorated function

        Raises:
            N/A

        &#34;&#34;&#34;
        try:
            return await asyncio.wait_for(
                wrapped_func(*args, **kwargs), timeout=self.timeout_duration
            )
        except asyncio.TimeoutError:
            self._handle_timeout()

    def signal_timeout(self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any) -&gt; Any:
        &#34;&#34;&#34;
        Signal method for timeouts; does not work with system transport, on windows, or in threads

        Perhaps wondering why, if this doesnt work in so many places, do we have it? Great question!
        Because it is way way way way faster/less cpu intensive than the multiprocessing method!

        Args:
            wrapped_func: function being decorated
            args: function being decorated args
            kwargs: function being decorated kwargs

        Returns:
            Any: result of decorated function

        Raises:
            N/A

        &#34;&#34;&#34;
        old = signal.signal(signal.SIGALRM, self._signal_raise_exception)
        signal.setitimer(signal.ITIMER_REAL, self.timeout_duration)
        try:
            return wrapped_func(*args, **kwargs)
        finally:
            if self.timeout_duration:
                signal.setitimer(signal.ITIMER_REAL, 0)
                signal.signal(signal.SIGALRM, old)

    def multiprocessing_timeout(
        self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any
    ) -&gt; Any:
        &#34;&#34;&#34;
        Multiprocessing method for timeouts; works in threads and on windows

        Args:
            wrapped_func: function being decorated
            args: function being decorated args
            kwargs: function being decorated kwargs

        Returns:
            Any: result of decorated function

        Raises:
            N/A

        &#34;&#34;&#34;
        with multiprocessing.pool.ThreadPool(processes=1) as pool:
            future = pool.apply_async(wrapped_func, args, kwargs)
            try:
                result = future.get(timeout=self.timeout_duration)
            except multiprocessing.context.TimeoutError:
                self._handle_timeout()
        return result


def requires_open_session() -&gt; Callable[..., Any]:
    &#34;&#34;&#34;
    Decorate an &#34;operation&#34; to require that the underlying scrapli session has been opened

    Args:
        N/A

    Returns:
        decorate: wrapped function

    Raises:
        ConnectionNotOpened: if scrapli connection has not been opened yet

    &#34;&#34;&#34;

    def decorate(wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:
        def requires_open_session_wrapper(
            *args: Union[str, int],
            **kwargs: Dict[str, Union[str, int]],
        ) -&gt; Any:
            try:
                return wrapped_func(*args, **kwargs)
            except AttributeError as exc:
                raise ConnectionNotOpened(
                    &#34;Attempting to call method that requires an open connection, but connection is &#34;
                    &#34;not open. Call the `.open()` method of your connection object, or use a &#34;
                    &#34;context manager to ensue your connection has been opened.&#34;
                ) from exc

        return requires_open_session_wrapper

    return decorate


class TimeoutModifier:
    def __call__(self, wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:
        &#34;&#34;&#34;
        Decorate an &#34;operation&#34; to modify the timeout_ops value for duration of that operation

        This decorator wraps send command/config ops and is used to allow users to set a
        `timeout_ops` value for the duration of a single method call -- this makes it so users don&#39;t
        need to manually set/reset the value

        Args:
            wrapped_func: function being decorated

        Returns:
            decorate: decorated func

        Raises:
            N/A

        &#34;&#34;&#34;
        if asyncio.iscoroutinefunction(wrapped_func):

            async def decorate(*args: Any, **kwargs: Any) -&gt; Any:
                scrapli_obj: Union[&#34;AsyncGenericDriver&#34;, &#34;GenericDriver&#34;] = args[0]
                if kwargs.get(&#34;timeout_ops&#34;, None) is None:
                    result = await wrapped_func(*args, **kwargs)
                elif kwargs.get(&#34;timeout_ops&#34;, scrapli_obj.timeout_ops) == scrapli_obj.timeout_ops:
                    result = await wrapped_func(*args, **kwargs)
                else:
                    base_timeout_ops = scrapli_obj.timeout_ops
                    scrapli_obj.timeout_ops = kwargs[&#34;timeout_ops&#34;]
                    result = await wrapped_func(*args, **kwargs)
                    scrapli_obj.timeout_ops = base_timeout_ops
                return result

        else:

            def decorate(*args: Any, **kwargs: Any) -&gt; Any:  # type: ignore
                scrapli_obj: Union[&#34;AsyncGenericDriver&#34;, &#34;GenericDriver&#34;] = args[0]
                if kwargs.get(&#34;timeout_ops&#34;, None) is None:
                    result = wrapped_func(*args, **kwargs)
                elif kwargs.get(&#34;timeout_ops&#34;, scrapli_obj.timeout_ops) == scrapli_obj.timeout_ops:
                    result = wrapped_func(*args, **kwargs)
                else:
                    base_timeout_ops = scrapli_obj.timeout_ops
                    scrapli_obj.timeout_ops = kwargs[&#34;timeout_ops&#34;]
                    result = wrapped_func(*args, **kwargs)
                    scrapli_obj.timeout_ops = base_timeout_ops
                return result

        return decorate</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scrapli.decorators.requires_open_session"><code class="name flex">
<span>def <span class="ident">requires_open_session</span></span>(<span>) ‑> Callable[..., Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate an "operation" to require that the underlying scrapli session has been opened</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>decorate</code></dt>
<dd>wrapped function</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionNotOpened</code></dt>
<dd>if scrapli connection has not been opened yet</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires_open_session() -&gt; Callable[..., Any]:
    &#34;&#34;&#34;
    Decorate an &#34;operation&#34; to require that the underlying scrapli session has been opened

    Args:
        N/A

    Returns:
        decorate: wrapped function

    Raises:
        ConnectionNotOpened: if scrapli connection has not been opened yet

    &#34;&#34;&#34;

    def decorate(wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:
        def requires_open_session_wrapper(
            *args: Union[str, int],
            **kwargs: Dict[str, Union[str, int]],
        ) -&gt; Any:
            try:
                return wrapped_func(*args, **kwargs)
            except AttributeError as exc:
                raise ConnectionNotOpened(
                    &#34;Attempting to call method that requires an open connection, but connection is &#34;
                    &#34;not open. Call the `.open()` method of your connection object, or use a &#34;
                    &#34;context manager to ensue your connection has been opened.&#34;
                ) from exc

        return requires_open_session_wrapper

    return decorate</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.decorators.OperationTimeout"><code class="flex name class">
<span>class <span class="ident">OperationTimeout</span></span>
<span>(</span><span>attribute: str, message: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Operation timeout decorator</p>
<p>Wrap an operation, check class for given attribute and use that for the timeout duration.</p>
<p>Historically this was not a class and has gone through several iterations&hellip; the first
iteration was using only signal&hellip; this was fast and efficient but did not work on windows
and due to system transport spawning a pty/forking things it would not work for that either.
Timeouts were then moved to use the multiprocessing method, which works in all cases, and is
thread safe (unlike signal), however it is very cpu intensive and slightly slower than the
signal method. This current iteration moved the decorator into a class so it is more orderly
and easier to break things up into smaller chunks, and importantly now supports both timeout
methods &ndash; signal and multiprocessing. This will always try to use the signal method, but if
that is not available (due to windows, system transport, or being in not the main thread),
it will fallback to the multiprocessing method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute</code></strong></dt>
<dd>name of attribute to use to get timeout value (set in the decorator)</dd>
<dt><strong><code>message</code></strong></dt>
<dd>optional message to use in timeout exception (set in the decorator)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperationTimeout:
    def __init__(self, attribute: str, message: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
        Operation timeout decorator

        Wrap an operation, check class for given attribute and use that for the timeout duration.

        Historically this was not a class and has gone through several iterations... the first
        iteration was using only signal... this was fast and efficient but did not work on windows
        and due to system transport spawning a pty/forking things it would not work for that either.
        Timeouts were then moved to use the multiprocessing method, which works in all cases, and is
        thread safe (unlike signal), however it is very cpu intensive and slightly slower than the
        signal method. This current iteration moved the decorator into a class so it is more orderly
        and easier to break things up into smaller chunks, and importantly now supports both timeout
        methods -- signal and multiprocessing. This will always try to use the signal method, but if
        that is not available (due to windows, system transport, or being in not the main thread),
        it will fallback to the multiprocessing method.

        Args:
            attribute: name of attribute to use to get timeout value (set in the decorator)
            message: optional message to use in timeout exception (set in the decorator)

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.attribute = attribute
        self.message = message

        self.scrapli_obj: Union[&#34;Channel&#34;, &#34;Transport&#34;]
        self.session_lock: threading.Lock
        self.close: Callable[..., Any]
        self.transport: &#34;Transport&#34;
        self.timeout_duration: float
        self.timeout_exit: bool = True
        self.signals_supported_transport: bool = True
        self._use_signals: bool = False

    def __call__(self, wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:
        &#34;&#34;&#34;
        Operation timeout decorator

        This is what is called when the decorator is triggered

        Args:
            wrapped_func: function being decorated

        Returns:
            decorate: decorated func

        Raises:
            N/A

        &#34;&#34;&#34;
        if asyncio.iscoroutinefunction(wrapped_func):

            async def decorate(*args: Any, **kwargs: Any) -&gt; Any:
                self.scrapli_obj = args[0]
                self.timeout_duration = getattr(self.scrapli_obj, self.attribute, None)

                if not self.timeout_duration:
                    self.scrapli_obj.logger.info(
                        f&#34;Could not find {self.attribute} value of {self.scrapli_obj}, continuing &#34;
                        &#34;without timeout decorator&#34;
                    )
                    return await wrapped_func(*args, **kwargs)

                self.set_scrapli_obj_attrs()
                return await self.asyncio_timeout(
                    wrapped_func=wrapped_func, args=args, kwargs=kwargs
                )

        else:

            def decorate(*args: Any, **kwargs: Any) -&gt; Any:  # type: ignore
                self.scrapli_obj = args[0]
                self.timeout_duration = getattr(self.scrapli_obj, self.attribute, None)

                if not self.timeout_duration:
                    self.scrapli_obj.logger.info(
                        f&#34;Could not find {self.attribute} value of {self.scrapli_obj}, continuing &#34;
                        &#34;without timeout decorator&#34;
                    )
                    return wrapped_func(*args, **kwargs)

                self.set_scrapli_obj_attrs()
                self.determine_sync_timeout_method()

                if self._use_signals:
                    return self.signal_timeout(wrapped_func=wrapped_func, args=args, kwargs=kwargs)
                return self.multiprocessing_timeout(
                    wrapped_func=wrapped_func, args=args, kwargs=kwargs
                )

        return decorate

    def set_scrapli_obj_attrs(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to set attributes of wrapped functions class object

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        from scrapli.channel import AsyncChannel, Channel  # pylint: disable=C0415

        if isinstance(self.scrapli_obj, (AsyncChannel, Channel)):
            self.timeout_exit = self.scrapli_obj.transport.timeout_exit
            self.close = self.scrapli_obj.transport.close
            self.transport = self.scrapli_obj.transport
        else:
            self.timeout_exit = self.scrapli_obj.timeout_exit
            self.close = self.scrapli_obj.close
            self.transport = self.scrapli_obj

    def determine_sync_timeout_method(self) -&gt; None:
        &#34;&#34;&#34;
        Decide what timeout mechanism to use for synchronous usage

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        from scrapli.transport.systemssh import SystemSSHTransport  # pylint: disable=C0415
        from scrapli.transport.telnet import TelnetTransport  # pylint: disable=C0415

        if isinstance(self.transport, (SystemSSHTransport, TelnetTransport)):
            # system transport cant use signals due to pty, unclear why telnetlib doesnt work with
            # signals, but it does not
            self.signals_supported_transport = False

        if (
            not self.signals_supported_transport
            or WIN
            or threading.current_thread() is not threading.main_thread()
        ):
            self._use_signals = False
        else:
            self._use_signals = True

    def _handle_timeout(self) -&gt; None:
        &#34;&#34;&#34;
        Timeout handler method to close connections and raise ScrapliTimeout

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliTimeout: always, if we hit this method we have already timed out!

        &#34;&#34;&#34;
        if self.timeout_exit:
            self.scrapli_obj.logger.info(&#34;timeout_exit is True, closing transport&#34;)
            self.close()
        raise ScrapliTimeout(self.message)

    def _signal_raise_exception(self, signum: Any, frame: Any) -&gt; None:
        &#34;&#34;&#34;
        Signal method exception handler

        Args:
            signum: singum from the singal handler, unused here
            frame: frame from the signal handler, unused here

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        _, _ = signum, frame
        self._handle_timeout()

    async def asyncio_timeout(
        self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any
    ) -&gt; Any:
        &#34;&#34;&#34;
        Asyncio method for timeouts

        Args:
            wrapped_func: function being decorated
            args: function being decorated args
            kwargs: function being decorated kwargs

        Returns:
            Any: result of decorated function

        Raises:
            N/A

        &#34;&#34;&#34;
        try:
            return await asyncio.wait_for(
                wrapped_func(*args, **kwargs), timeout=self.timeout_duration
            )
        except asyncio.TimeoutError:
            self._handle_timeout()

    def signal_timeout(self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any) -&gt; Any:
        &#34;&#34;&#34;
        Signal method for timeouts; does not work with system transport, on windows, or in threads

        Perhaps wondering why, if this doesnt work in so many places, do we have it? Great question!
        Because it is way way way way faster/less cpu intensive than the multiprocessing method!

        Args:
            wrapped_func: function being decorated
            args: function being decorated args
            kwargs: function being decorated kwargs

        Returns:
            Any: result of decorated function

        Raises:
            N/A

        &#34;&#34;&#34;
        old = signal.signal(signal.SIGALRM, self._signal_raise_exception)
        signal.setitimer(signal.ITIMER_REAL, self.timeout_duration)
        try:
            return wrapped_func(*args, **kwargs)
        finally:
            if self.timeout_duration:
                signal.setitimer(signal.ITIMER_REAL, 0)
                signal.signal(signal.SIGALRM, old)

    def multiprocessing_timeout(
        self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any
    ) -&gt; Any:
        &#34;&#34;&#34;
        Multiprocessing method for timeouts; works in threads and on windows

        Args:
            wrapped_func: function being decorated
            args: function being decorated args
            kwargs: function being decorated kwargs

        Returns:
            Any: result of decorated function

        Raises:
            N/A

        &#34;&#34;&#34;
        with multiprocessing.pool.ThreadPool(processes=1) as pool:
            future = pool.apply_async(wrapped_func, args, kwargs)
            try:
                result = future.get(timeout=self.timeout_duration)
            except multiprocessing.context.TimeoutError:
                self._handle_timeout()
        return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scrapli.decorators.OperationTimeout.asyncio_timeout"><code class="name flex">
<span>async def <span class="ident">asyncio_timeout</span></span>(<span>self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Asyncio method for timeouts</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapped_func</code></strong></dt>
<dd>function being decorated</dd>
<dt><strong><code>args</code></strong></dt>
<dd>function being decorated args</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>function being decorated kwargs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>result of decorated function</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def asyncio_timeout(
    self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any
) -&gt; Any:
    &#34;&#34;&#34;
    Asyncio method for timeouts

    Args:
        wrapped_func: function being decorated
        args: function being decorated args
        kwargs: function being decorated kwargs

    Returns:
        Any: result of decorated function

    Raises:
        N/A

    &#34;&#34;&#34;
    try:
        return await asyncio.wait_for(
            wrapped_func(*args, **kwargs), timeout=self.timeout_duration
        )
    except asyncio.TimeoutError:
        self._handle_timeout()</code></pre>
</details>
</dd>
<dt id="scrapli.decorators.OperationTimeout.determine_sync_timeout_method"><code class="name flex">
<span>def <span class="ident">determine_sync_timeout_method</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Decide what timeout mechanism to use for synchronous usage</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_sync_timeout_method(self) -&gt; None:
    &#34;&#34;&#34;
    Decide what timeout mechanism to use for synchronous usage

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    from scrapli.transport.systemssh import SystemSSHTransport  # pylint: disable=C0415
    from scrapli.transport.telnet import TelnetTransport  # pylint: disable=C0415

    if isinstance(self.transport, (SystemSSHTransport, TelnetTransport)):
        # system transport cant use signals due to pty, unclear why telnetlib doesnt work with
        # signals, but it does not
        self.signals_supported_transport = False

    if (
        not self.signals_supported_transport
        or WIN
        or threading.current_thread() is not threading.main_thread()
    ):
        self._use_signals = False
    else:
        self._use_signals = True</code></pre>
</details>
</dd>
<dt id="scrapli.decorators.OperationTimeout.multiprocessing_timeout"><code class="name flex">
<span>def <span class="ident">multiprocessing_timeout</span></span>(<span>self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Multiprocessing method for timeouts; works in threads and on windows</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapped_func</code></strong></dt>
<dd>function being decorated</dd>
<dt><strong><code>args</code></strong></dt>
<dd>function being decorated args</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>function being decorated kwargs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>result of decorated function</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiprocessing_timeout(
    self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any
) -&gt; Any:
    &#34;&#34;&#34;
    Multiprocessing method for timeouts; works in threads and on windows

    Args:
        wrapped_func: function being decorated
        args: function being decorated args
        kwargs: function being decorated kwargs

    Returns:
        Any: result of decorated function

    Raises:
        N/A

    &#34;&#34;&#34;
    with multiprocessing.pool.ThreadPool(processes=1) as pool:
        future = pool.apply_async(wrapped_func, args, kwargs)
        try:
            result = future.get(timeout=self.timeout_duration)
        except multiprocessing.context.TimeoutError:
            self._handle_timeout()
    return result</code></pre>
</details>
</dd>
<dt id="scrapli.decorators.OperationTimeout.set_scrapli_obj_attrs"><code class="name flex">
<span>def <span class="ident">set_scrapli_obj_attrs</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Parent method to set attributes of wrapped functions class object</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scrapli_obj_attrs(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to set attributes of wrapped functions class object

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    from scrapli.channel import AsyncChannel, Channel  # pylint: disable=C0415

    if isinstance(self.scrapli_obj, (AsyncChannel, Channel)):
        self.timeout_exit = self.scrapli_obj.transport.timeout_exit
        self.close = self.scrapli_obj.transport.close
        self.transport = self.scrapli_obj.transport
    else:
        self.timeout_exit = self.scrapli_obj.timeout_exit
        self.close = self.scrapli_obj.close
        self.transport = self.scrapli_obj</code></pre>
</details>
</dd>
<dt id="scrapli.decorators.OperationTimeout.signal_timeout"><code class="name flex">
<span>def <span class="ident">signal_timeout</span></span>(<span>self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Signal method for timeouts; does not work with system transport, on windows, or in threads</p>
<p>Perhaps wondering why, if this doesnt work in so many places, do we have it? Great question!
Because it is way way way way faster/less cpu intensive than the multiprocessing method!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrapped_func</code></strong></dt>
<dd>function being decorated</dd>
<dt><strong><code>args</code></strong></dt>
<dd>function being decorated args</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>function being decorated kwargs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>result of decorated function</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_timeout(self, wrapped_func: Callable[..., Any], args: Any, kwargs: Any) -&gt; Any:
    &#34;&#34;&#34;
    Signal method for timeouts; does not work with system transport, on windows, or in threads

    Perhaps wondering why, if this doesnt work in so many places, do we have it? Great question!
    Because it is way way way way faster/less cpu intensive than the multiprocessing method!

    Args:
        wrapped_func: function being decorated
        args: function being decorated args
        kwargs: function being decorated kwargs

    Returns:
        Any: result of decorated function

    Raises:
        N/A

    &#34;&#34;&#34;
    old = signal.signal(signal.SIGALRM, self._signal_raise_exception)
    signal.setitimer(signal.ITIMER_REAL, self.timeout_duration)
    try:
        return wrapped_func(*args, **kwargs)
    finally:
        if self.timeout_duration:
            signal.setitimer(signal.ITIMER_REAL, 0)
            signal.signal(signal.SIGALRM, old)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrapli.decorators.TimeoutModifier"><code class="flex name class">
<span>class <span class="ident">TimeoutModifier</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeoutModifier:
    def __call__(self, wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:
        &#34;&#34;&#34;
        Decorate an &#34;operation&#34; to modify the timeout_ops value for duration of that operation

        This decorator wraps send command/config ops and is used to allow users to set a
        `timeout_ops` value for the duration of a single method call -- this makes it so users don&#39;t
        need to manually set/reset the value

        Args:
            wrapped_func: function being decorated

        Returns:
            decorate: decorated func

        Raises:
            N/A

        &#34;&#34;&#34;
        if asyncio.iscoroutinefunction(wrapped_func):

            async def decorate(*args: Any, **kwargs: Any) -&gt; Any:
                scrapli_obj: Union[&#34;AsyncGenericDriver&#34;, &#34;GenericDriver&#34;] = args[0]
                if kwargs.get(&#34;timeout_ops&#34;, None) is None:
                    result = await wrapped_func(*args, **kwargs)
                elif kwargs.get(&#34;timeout_ops&#34;, scrapli_obj.timeout_ops) == scrapli_obj.timeout_ops:
                    result = await wrapped_func(*args, **kwargs)
                else:
                    base_timeout_ops = scrapli_obj.timeout_ops
                    scrapli_obj.timeout_ops = kwargs[&#34;timeout_ops&#34;]
                    result = await wrapped_func(*args, **kwargs)
                    scrapli_obj.timeout_ops = base_timeout_ops
                return result

        else:

            def decorate(*args: Any, **kwargs: Any) -&gt; Any:  # type: ignore
                scrapli_obj: Union[&#34;AsyncGenericDriver&#34;, &#34;GenericDriver&#34;] = args[0]
                if kwargs.get(&#34;timeout_ops&#34;, None) is None:
                    result = wrapped_func(*args, **kwargs)
                elif kwargs.get(&#34;timeout_ops&#34;, scrapli_obj.timeout_ops) == scrapli_obj.timeout_ops:
                    result = wrapped_func(*args, **kwargs)
                else:
                    base_timeout_ops = scrapli_obj.timeout_ops
                    scrapli_obj.timeout_ops = kwargs[&#34;timeout_ops&#34;]
                    result = wrapped_func(*args, **kwargs)
                    scrapli_obj.timeout_ops = base_timeout_ops
                return result

        return decorate</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli" href="index.html">scrapli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scrapli.decorators.requires_open_session" href="#scrapli.decorators.requires_open_session">requires_open_session</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.decorators.OperationTimeout" href="#scrapli.decorators.OperationTimeout">OperationTimeout</a></code></h4>
<ul class="">
<li><code><a title="scrapli.decorators.OperationTimeout.asyncio_timeout" href="#scrapli.decorators.OperationTimeout.asyncio_timeout">asyncio_timeout</a></code></li>
<li><code><a title="scrapli.decorators.OperationTimeout.determine_sync_timeout_method" href="#scrapli.decorators.OperationTimeout.determine_sync_timeout_method">determine_sync_timeout_method</a></code></li>
<li><code><a title="scrapli.decorators.OperationTimeout.multiprocessing_timeout" href="#scrapli.decorators.OperationTimeout.multiprocessing_timeout">multiprocessing_timeout</a></code></li>
<li><code><a title="scrapli.decorators.OperationTimeout.set_scrapli_obj_attrs" href="#scrapli.decorators.OperationTimeout.set_scrapli_obj_attrs">set_scrapli_obj_attrs</a></code></li>
<li><code><a title="scrapli.decorators.OperationTimeout.signal_timeout" href="#scrapli.decorators.OperationTimeout.signal_timeout">signal_timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.decorators.TimeoutModifier" href="#scrapli.decorators.TimeoutModifier">TimeoutModifier</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>