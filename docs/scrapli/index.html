<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>scrapli API documentation</title>
<meta name="description" content="scrapli network ssh client library" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>scrapli</code></h1>
</header>
<section id="section-intro">
<p>scrapli network ssh client library</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli network ssh client library&#34;&#34;&#34;
import logging
from logging import getLogger
from typing import Optional, Tuple

from scrapli.driver import AsyncScrape, Scrape
from scrapli.factory import AsyncScrapli, Scrapli

__version__ = &#34;2020.11.15&#34;
__all__ = (&#34;AsyncScrape&#34;, &#34;Scrape&#34;, &#34;AsyncScrapli&#34;, &#34;Scrapli&#34;)


class DuplicateFilter(logging.Filter):
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Remove duplicates from log

        Thank you to our lord and savior, StackOverflow... src:
        https://stackoverflow.com/questions/44691558/suppress-multiple-messages-with-same-content- \
        in-python-logging-module-aka-log-co

        &#34;&#34;&#34;
        super().__init__()
        self.last_log: Optional[Tuple[str, int, str]] = None

    def filter(self, record: logging.LogRecord) -&gt; bool:
        &#34;&#34;&#34;
        Filter duplicate entries in logs

        Fields to compare to previous log entry if these fields match; skip log entry

        Args:
            record: log record to check

        Returns:
            bool: filter or not

        Raises:
            N/A  # noqa

        &#34;&#34;&#34;
        current_log = (record.module, record.levelno, record.msg)
        if current_log != getattr(self, &#34;last_log&#34;, None):
            self.last_log = current_log
            return True
        return False


SCRAPLI_LOG = getLogger(&#34;scrapli&#34;)
SCRAPLI_LOG.addFilter(DuplicateFilter())</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli.channel" href="channel/index.html">scrapli.channel</a></code></dt>
<dd>
<div class="desc"><p>scrapli.channel</p></div>
</dd>
<dt><code class="name"><a title="scrapli.decorators" href="decorators.html">scrapli.decorators</a></code></dt>
<dd>
<div class="desc"><p>scrapli.decorators</p></div>
</dd>
<dt><code class="name"><a title="scrapli.driver" href="driver/index.html">scrapli.driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli.driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli.exceptions" href="exceptions.html">scrapli.exceptions</a></code></dt>
<dd>
<div class="desc"><p>scrapli.exceptions</p></div>
</dd>
<dt><code class="name"><a title="scrapli.factory" href="factory.html">scrapli.factory</a></code></dt>
<dd>
<div class="desc"><p>scrapli.factory</p></div>
</dd>
<dt><code class="name"><a title="scrapli.helper" href="helper.html">scrapli.helper</a></code></dt>
<dd>
<div class="desc"><p>scrapli.helper</p></div>
</dd>
<dt><code class="name"><a title="scrapli.response" href="response.html">scrapli.response</a></code></dt>
<dd>
<div class="desc"><p>scrapli.response</p></div>
</dd>
<dt><code class="name"><a title="scrapli.ssh_config" href="ssh_config.html">scrapli.ssh_config</a></code></dt>
<dd>
<div class="desc"><p>scrapli.ssh_config</p></div>
</dd>
<dt><code class="name"><a title="scrapli.transport" href="transport/index.html">scrapli.transport</a></code></dt>
<dd>
<div class="desc"><p>scrapli.transport</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.AsyncScrape"><code class="flex name class">
<span>class <span class="ident">AsyncScrape</span></span>
<span>(</span><span>**kwargs:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>AsyncScrape Object</p>
<p>AsyncScrape is the base class for AsyncNetworkDriver, and subsequent async platform specific
drivers (i.e. AsyncIOSXEDriver). AsyncScrape can be used on its own and offers a
semi-pexpect like experience in that it doesn't know or care about privilege levels,
platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments to pass to <code>ScrapeBase</code> &ndash; see <code>ScrapeBase</code> for available args</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TransportPluginError</code></dt>
<dd>if attempting to use a non-asyncio transport plugin</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncScrape(ScrapeBase):
    def __init__(self, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;
        AsyncScrape Object

        AsyncScrape is the base class for AsyncNetworkDriver, and subsequent async platform specific
        drivers (i.e. AsyncIOSXEDriver). AsyncScrape can be used on its own and offers a
        semi-pexpect like experience in that it doesn&#39;t know or care about privilege levels,
        platform types, and things like that.

        *Note* most arguments passed to Scrape do not actually get assigned to the scrape object
        itself, but instead are used to construct the Transport and Channel classes that Scrape
        relies on, see Transport and Channel docs for details.

        Args:
            kwargs: Keyword arguments to pass to `ScrapeBase` -- see `ScrapeBase` for available args

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TransportPluginError: if attempting to use a non-asyncio transport plugin

        &#34;&#34;&#34;
        super().__init__(**kwargs)

        if self._transport not in ASYNCIO_TRANSPORTS:
            raise TransportPluginError(
                f&#34;Attempting to use transport type {self._transport} with an asyncio driver, &#34;
                f&#34;must use one of {list(ASYNCIO_TRANSPORTS)} transports&#34;
            )

        self.channel = AsyncChannel(transport=self.transport, **self.channel_args)

    async def __aenter__(self) -&gt; &#34;AsyncScrape&#34;:
        &#34;&#34;&#34;
        Enter method for context manager

        Args:
            N/A

        Returns:
            self: instance of self

        Raises:
            N/A

        &#34;&#34;&#34;
        await self.open()
        return self

    async def __aexit__(
        self,
        exception_type: Optional[Type[BaseException]],
        exception_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        &#34;&#34;&#34;
        Exit method to cleanup for context manager

        Args:
            exception_type: exception type being raised
            exception_value: message from exception being raised
            traceback: traceback from exception being raised

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        await self.close()

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open Transport (socket/session) and establish channel

        If on_open callable provided, execute that callable after opening connection

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        await self.transport.open()
        if self.on_open:
            await self.on_open(self)
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    async def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close Transport (socket/session)

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        if self.on_close:
            await self.on_close(self)
        self.transport.close()
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)

    @property
    def timeout_ops(self) -&gt; float:
        &#34;&#34;&#34;
        Property for timeout_ops attribute

        Args:
            N/A

        Returns:
            float: value of timeout_ops

        Raises:
            N/A

        &#34;&#34;&#34;
        return self._timeout_ops

    @timeout_ops.setter
    def timeout_ops(self, timeout_value: float) -&gt; None:
        &#34;&#34;&#34;
        Setter for timeout_ops attribute

        Sets timeout value for the channel class as well as the internal `_timeout_ops` value of the
        base driver class

        Args:
            timeout_value: float value to set as timeout_ops

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.channel.timeout_ops = timeout_value
        self._timeout_ops = timeout_value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="driver/async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="scrapli.AsyncScrape.timeout_ops"><code class="name">var <span class="ident">timeout_ops</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Property for timeout_ops attribute</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>value of timeout_ops</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timeout_ops(self) -&gt; float:
    &#34;&#34;&#34;
    Property for timeout_ops attribute

    Args:
        N/A

    Returns:
        float: value of timeout_ops

    Raises:
        N/A

    &#34;&#34;&#34;
    return self._timeout_ops</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrapli.AsyncScrape.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) â>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close Transport (socket/session)</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;
    Close Transport (socket/session)

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    if self.on_close:
        await self.on_close(self)
    self.transport.close()
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)</code></pre>
</details>
</dd>
<dt id="scrapli.AsyncScrape.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) â>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open Transport (socket/session) and establish channel</p>
<p>If on_open callable provided, execute that callable after opening connection</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open Transport (socket/session) and establish channel

    If on_open callable provided, execute that callable after opening connection

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    await self.transport.open()
    if self.on_open:
        await self.on_open(self)
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.base_driver.ScrapeBase.isalive" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.AsyncScrapli"><code class="flex name class">
<span>class <span class="ident">AsyncScrapli</span></span>
<span>(</span><span>privilege_levels:Â Dict[str,Â <a title="scrapli.driver.base_network_driver.PrivilegeLevel" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.PrivilegeLevel">PrivilegeLevel</a>], default_desired_privilege_level:Â str, auth_secondary:Â strÂ =Â '', failed_when_contains:Â Union[List[str],Â NoneType]Â =Â None, textfsm_platform:Â strÂ =Â '', genie_platform:Â strÂ =Â '', **kwargs:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code><a title="scrapli.Scrape" href="#scrapli.Scrape">Scrape</a></code> object from that perspective.</p>
<p>AsyncNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>Dict of privilege levels for a given platform</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that indicate a command/configuration has failed</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of platform to use for textfsm parsing</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of platform to use for genie parsing</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncScrapli(AsyncNetworkDriver):
    def __new__(
        cls, platform: str, variant: Optional[str] = None, **kwargs: Dict[Any, Any]
    ) -&gt; &#34;AsyncScrapli&#34;:
        &#34;&#34;&#34;
        Scrapli Factory method for asynchronous drivers

        Args:
            cls: class object
            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.
            variant: optional name of variant of community platform
            **kwargs: keyword arguments to pass to selected driver class

        Returns:
            final_driver: synchronous driver class for provided driver

        Raises:
            ScrapliException: if provided transport is not asyncio
            ScrapliException: if `platform` not in keyword arguments

        &#34;&#34;&#34;
        LOG.debug(&#34;Scrapli factory initialized&#34;)

        if kwargs.get(&#34;transport&#34;, &#34;system&#34;) not in ASYNCIO_TRANSPORTS:
            raise ScrapliException(&#34;Use `Scrapli` if using a synchronous transport!&#34;)

        if not isinstance(platform, str):
            raise ScrapliException(f&#34;Argument `platform` must be `str` got `{type(platform)}`&#34;)

        final_driver, additional_kwargs = _get_driver(
            platform=platform, variant=variant, _async=True
        )

        # at this point will need to merge the additional kwargs in (for community drivers),
        # ensure that kwargs passed by user supersede the ones coming from community platform
        if additional_kwargs:
            final_kwargs = {**additional_kwargs, **kwargs}
        else:
            final_kwargs = kwargs

        # mypy was displeased about NetworkDriver not being callable, fix later probably :)
        final_conn: &#34;AsyncScrapli&#34; = final_driver(**final_kwargs)  # type: ignore
        return final_conn</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></li>
<li><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="driver/async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></li>
<li><a title="scrapli.driver.async_driver.AsyncScrape" href="driver/async_driver.html#scrapli.driver.async_driver.AsyncScrape">AsyncScrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="driver/base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli.AsyncScrapli.auth_secondary"><code class="name">var <span class="ident">auth_secondary</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.AsyncScrapli.comms_prompt_pattern"><code class="name">var <span class="ident">comms_prompt_pattern</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.AsyncScrapli.failed_when_contains"><code class="name">var <span class="ident">failed_when_contains</span> :Â Union[List[str],Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.AsyncScrapli.genie_platform"><code class="name">var <span class="ident">genie_platform</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.AsyncScrapli.logger"><code class="name">var <span class="ident">logger</span> :Â logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.AsyncScrapli.privilege_levels"><code class="name">var <span class="ident">privilege_levels</span> :Â Dict[str,Â <a title="scrapli.driver.base_network_driver.PrivilegeLevel" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.PrivilegeLevel">PrivilegeLevel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.AsyncScrapli.textfsm_platform"><code class="name">var <span class="ident">textfsm_platform</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.acquire_priv" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.close" href="driver/async_driver.html#scrapli.driver.async_driver.AsyncScrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.get_prompt" href="driver/async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.isalive" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.open" href="driver/async_driver.html#scrapli.driver.async_driver.AsyncScrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.register_configuration_session" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session">register_configuration_session</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_command" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands_from_file" href="driver/async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_config" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs_from_file" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_interactive" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_interactive">send_interactive</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.timeout_ops" href="driver/async_driver.html#scrapli.driver.async_driver.AsyncScrape.timeout_ops">timeout_ops</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.update_privilege_levels" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.Scrape"><code class="flex name class">
<span>class <span class="ident">Scrape</span></span>
<span>(</span><span>**kwargs:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Scrape Object</p>
<p>Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
that it doesn't know or care about privilege levels, platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments to pass to <code>ScrapeBase</code> &ndash; see <code>ScrapeBase</code> for available args</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TransportPluginError</code></dt>
<dd>if attempting to use an asyncio transport plugin</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scrape(ScrapeBase):
    def __init__(self, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;
        Scrape Object

        Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
        IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
        that it doesn&#39;t know or care about privilege levels, platform types, and things like that.

        *Note* most arguments passed to Scrape do not actually get assigned to the scrape object
        itself, but instead are used to construct the Transport and Channel classes that Scrape
        relies on, see Transport and Channel docs for details.

        Args:
            kwargs: Keyword arguments to pass to `ScrapeBase` -- see `ScrapeBase` for available args

        Returns:
            N/A  # noqa: DAR202

        Raises:
            TransportPluginError: if attempting to use an asyncio transport plugin

        &#34;&#34;&#34;
        super().__init__(**kwargs)

        if self._transport in ASYNCIO_TRANSPORTS:
            raise TransportPluginError(
                f&#34;Attempting to use transport type {self._transport} with a sync driver, &#34;
                &#34;must use a non-asyncio transport&#34;
            )

        self.channel = Channel(transport=self.transport, **self.channel_args)

    def __enter__(self) -&gt; &#34;Scrape&#34;:
        &#34;&#34;&#34;
        Enter method for context manager

        Args:
            N/A

        Returns:
            self: instance of self

        Raises:
            N/A

        &#34;&#34;&#34;
        self.open()
        return self

    def __exit__(
        self,
        exception_type: Optional[Type[BaseException]],
        exception_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        &#34;&#34;&#34;
        Exit method to cleanup for context manager

        Args:
            exception_type: exception type being raised
            exception_value: message from exception being raised
            traceback: traceback from exception being raised

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.close()

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open Transport (socket/session) and establish channel

        If on_open callable provided, execute that callable after opening connection

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        self.transport.open()
        if self.on_open:
            self.on_open(self)
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close Transport (socket/session)

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        if self.on_close:
            self.on_close(self)
        self.transport.close()
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)

    @property
    def timeout_ops(self) -&gt; float:
        &#34;&#34;&#34;
        Property for timeout_ops attribute

        Args:
            N/A

        Returns:
            float: value of timeout_ops

        Raises:
            N/A

        &#34;&#34;&#34;
        return self._timeout_ops

    @timeout_ops.setter
    def timeout_ops(self, timeout_value: float) -&gt; None:
        &#34;&#34;&#34;
        Setter for timeout_ops attribute

        Sets timeout value for the channel class as well as the internal `_timeout_ops` value of the
        base driver class

        Args:
            timeout_value: float value to set as timeout_ops

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.channel.timeout_ops = timeout_value
        self._timeout_ops = timeout_value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="driver/generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="scrapli.Scrape.timeout_ops"><code class="name">var <span class="ident">timeout_ops</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Property for timeout_ops attribute</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>value of timeout_ops</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timeout_ops(self) -&gt; float:
    &#34;&#34;&#34;
    Property for timeout_ops attribute

    Args:
        N/A

    Returns:
        float: value of timeout_ops

    Raises:
        N/A

    &#34;&#34;&#34;
    return self._timeout_ops</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrapli.Scrape.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) â>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close Transport (socket/session)</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;
    Close Transport (socket/session)

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Closing connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    if self.on_close:
        self.on_close(self)
    self.transport.close()
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} closed successfully&#34;)</code></pre>
</details>
</dd>
<dt id="scrapli.Scrape.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) â>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open Transport (socket/session) and establish channel</p>
<p>If on_open callable provided, execute that callable after opening connection</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open Transport (socket/session) and establish channel

    If on_open callable provided, execute that callable after opening connection

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    self.transport.open()
    if self.on_open:
        self.on_open(self)
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.base_driver.ScrapeBase.isalive" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.Scrapli"><code class="flex name class">
<span>class <span class="ident">Scrapli</span></span>
<span>(</span><span>privilege_levels:Â Dict[str,Â <a title="scrapli.driver.base_network_driver.PrivilegeLevel" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.PrivilegeLevel">PrivilegeLevel</a>], default_desired_privilege_level:Â str, auth_secondary:Â strÂ =Â '', failed_when_contains:Â Union[List[str],Â NoneType]Â =Â None, textfsm_platform:Â strÂ =Â '', genie_platform:Â strÂ =Â '', **kwargs:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code><a title="scrapli.Scrape" href="#scrapli.Scrape">Scrape</a></code> object from that perspective.</p>
<p>BaseNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>Dict of privilege levels for a given platform</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that indicate a command/configuration has failed</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of platform to use for textfsm parsing</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of platform to use for genie parsing</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scrapli(NetworkDriver):
    def __new__(
        cls, platform: str, variant: Optional[str] = None, **kwargs: Dict[Any, Any]
    ) -&gt; &#34;Scrapli&#34;:
        &#34;&#34;&#34;
        Scrapli Factory method for synchronous drivers

        Args:
            cls: class object
            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.
            variant: optional name of variant of community platform
            **kwargs: keyword arguments to pass to selected driver class

        Returns:
            final_driver: synchronous driver class for provided driver

        Raises:
            ScrapliException: if provided transport is asyncio
            ScrapliException: if `platform` not in keyword arguments

        &#34;&#34;&#34;
        LOG.debug(&#34;Scrapli factory initialized&#34;)

        if kwargs.get(&#34;transport&#34;, &#34;system&#34;) in ASYNCIO_TRANSPORTS:
            raise ScrapliException(&#34;Use `AsyncScrapli` if using an async transport!&#34;)

        if not isinstance(platform, str):
            raise ScrapliException(f&#34;Argument `platform` must be `str` got `{type(platform)}`&#34;)

        final_driver, additional_kwargs = _get_driver(
            platform=platform, variant=variant, _async=False
        )

        # at this point will need to merge the additional kwargs in (for community drivers),
        # ensure that kwargs passed by user supersede the ones coming from community platform
        if additional_kwargs:
            final_kwargs = {**additional_kwargs, **kwargs}
        else:
            final_kwargs = kwargs

        # mypy was displeased about NetworkDriver not being callable, fix later probably :)
        final_conn: &#34;Scrapli&#34; = final_driver(**final_kwargs)  # type: ignore
        return final_conn</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.network_driver.NetworkDriver" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></li>
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="driver/generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
<li><a title="scrapli.driver.driver.Scrape" href="driver/driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="driver/base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli.Scrapli.auth_secondary"><code class="name">var <span class="ident">auth_secondary</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.Scrapli.comms_prompt_pattern"><code class="name">var <span class="ident">comms_prompt_pattern</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.Scrapli.failed_when_contains"><code class="name">var <span class="ident">failed_when_contains</span> :Â Union[List[str],Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.Scrapli.genie_platform"><code class="name">var <span class="ident">genie_platform</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.Scrapli.logger"><code class="name">var <span class="ident">logger</span> :Â logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.Scrapli.privilege_levels"><code class="name">var <span class="ident">privilege_levels</span> :Â Dict[str,Â <a title="scrapli.driver.base_network_driver.PrivilegeLevel" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.PrivilegeLevel">PrivilegeLevel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.Scrapli.textfsm_platform"><code class="name">var <span class="ident">textfsm_platform</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.network_driver.NetworkDriver" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.acquire_priv" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.close" href="driver/driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.get_prompt" href="driver/generic_driver.html#scrapli.driver.generic_driver.GenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.isalive" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.open" href="driver/driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.register_configuration_session" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session">register_configuration_session</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_command" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_commands" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_commands_from_file" href="driver/generic_driver.html#scrapli.driver.generic_driver.GenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_config" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_configs" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_configs_from_file" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_interactive" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_interactive">send_interactive</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.timeout_ops" href="driver/driver.html#scrapli.driver.driver.Scrape.timeout_ops">timeout_ops</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.update_privilege_levels" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli.channel" href="channel/index.html">scrapli.channel</a></code></li>
<li><code><a title="scrapli.decorators" href="decorators.html">scrapli.decorators</a></code></li>
<li><code><a title="scrapli.driver" href="driver/index.html">scrapli.driver</a></code></li>
<li><code><a title="scrapli.exceptions" href="exceptions.html">scrapli.exceptions</a></code></li>
<li><code><a title="scrapli.factory" href="factory.html">scrapli.factory</a></code></li>
<li><code><a title="scrapli.helper" href="helper.html">scrapli.helper</a></code></li>
<li><code><a title="scrapli.response" href="response.html">scrapli.response</a></code></li>
<li><code><a title="scrapli.ssh_config" href="ssh_config.html">scrapli.ssh_config</a></code></li>
<li><code><a title="scrapli.transport" href="transport/index.html">scrapli.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.AsyncScrape" href="#scrapli.AsyncScrape">AsyncScrape</a></code></h4>
<ul class="">
<li><code><a title="scrapli.AsyncScrape.close" href="#scrapli.AsyncScrape.close">close</a></code></li>
<li><code><a title="scrapli.AsyncScrape.open" href="#scrapli.AsyncScrape.open">open</a></code></li>
<li><code><a title="scrapli.AsyncScrape.timeout_ops" href="#scrapli.AsyncScrape.timeout_ops">timeout_ops</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.AsyncScrapli" href="#scrapli.AsyncScrapli">AsyncScrapli</a></code></h4>
<ul class="">
<li><code><a title="scrapli.AsyncScrapli.auth_secondary" href="#scrapli.AsyncScrapli.auth_secondary">auth_secondary</a></code></li>
<li><code><a title="scrapli.AsyncScrapli.comms_prompt_pattern" href="#scrapli.AsyncScrapli.comms_prompt_pattern">comms_prompt_pattern</a></code></li>
<li><code><a title="scrapli.AsyncScrapli.failed_when_contains" href="#scrapli.AsyncScrapli.failed_when_contains">failed_when_contains</a></code></li>
<li><code><a title="scrapli.AsyncScrapli.genie_platform" href="#scrapli.AsyncScrapli.genie_platform">genie_platform</a></code></li>
<li><code><a title="scrapli.AsyncScrapli.logger" href="#scrapli.AsyncScrapli.logger">logger</a></code></li>
<li><code><a title="scrapli.AsyncScrapli.privilege_levels" href="#scrapli.AsyncScrapli.privilege_levels">privilege_levels</a></code></li>
<li><code><a title="scrapli.AsyncScrapli.textfsm_platform" href="#scrapli.AsyncScrapli.textfsm_platform">textfsm_platform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.Scrape" href="#scrapli.Scrape">Scrape</a></code></h4>
<ul class="">
<li><code><a title="scrapli.Scrape.close" href="#scrapli.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.Scrape.open" href="#scrapli.Scrape.open">open</a></code></li>
<li><code><a title="scrapli.Scrape.timeout_ops" href="#scrapli.Scrape.timeout_ops">timeout_ops</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.Scrapli" href="#scrapli.Scrapli">Scrapli</a></code></h4>
<ul class="">
<li><code><a title="scrapli.Scrapli.auth_secondary" href="#scrapli.Scrapli.auth_secondary">auth_secondary</a></code></li>
<li><code><a title="scrapli.Scrapli.comms_prompt_pattern" href="#scrapli.Scrapli.comms_prompt_pattern">comms_prompt_pattern</a></code></li>
<li><code><a title="scrapli.Scrapli.failed_when_contains" href="#scrapli.Scrapli.failed_when_contains">failed_when_contains</a></code></li>
<li><code><a title="scrapli.Scrapli.genie_platform" href="#scrapli.Scrapli.genie_platform">genie_platform</a></code></li>
<li><code><a title="scrapli.Scrapli.logger" href="#scrapli.Scrapli.logger">logger</a></code></li>
<li><code><a title="scrapli.Scrapli.privilege_levels" href="#scrapli.Scrapli.privilege_levels">privilege_levels</a></code></li>
<li><code><a title="scrapli.Scrapli.textfsm_platform" href="#scrapli.Scrapli.textfsm_platform">textfsm_platform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>