<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>scrapli.transport API documentation</title>
<meta name="description" content="scrapli.transport" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.transport</code></h1>
</header>
<section id="section-intro">
<p>scrapli.transport</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.transport&#34;&#34;&#34;
from scrapli.transport.async_transport import AsyncTransport
from scrapli.transport.systemssh import SYSTEM_SSH_TRANSPORT_ARGS, SystemSSHTransport
from scrapli.transport.telnet import TELNET_TRANSPORT_ARGS, TelnetTransport
from scrapli.transport.transport import Transport

__all__ = (
    &#34;AsyncTransport&#34;,
    &#34;Transport&#34;,
    &#34;SystemSSHTransport&#34;,
    &#34;SYSTEM_SSH_TRANSPORT_ARGS&#34;,
    &#34;TELNET_TRANSPORT_ARGS&#34;,
    &#34;TelnetTransport&#34;,
)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli.transport.async_transport" href="async_transport.html">scrapli.transport.async_transport</a></code></dt>
<dd>
<div class="desc"><p>scrapli.transport.async_transport</p></div>
</dd>
<dt><code class="name"><a title="scrapli.transport.base_transport" href="base_transport.html">scrapli.transport.base_transport</a></code></dt>
<dd>
<div class="desc"><p>scrapli.transport.base_transport</p></div>
</dd>
<dt><code class="name"><a title="scrapli.transport.ptyprocess" href="ptyprocess.html">scrapli.transport.ptyprocess</a></code></dt>
<dd>
<div class="desc"><p>Ptyprocess is under the ISC license, as code derived from Pexpect.
<a href="http://opensource.org/licenses/ISC">http://opensource.org/licenses/ISC</a> …</p></div>
</dd>
<dt><code class="name"><a title="scrapli.transport.socket" href="socket.html">scrapli.transport.socket</a></code></dt>
<dd>
<div class="desc"><p>scrapli.transport.socket</p></div>
</dd>
<dt><code class="name"><a title="scrapli.transport.systemssh" href="systemssh.html">scrapli.transport.systemssh</a></code></dt>
<dd>
<div class="desc"><p>scrapli.transport.systemssh</p></div>
</dd>
<dt><code class="name"><a title="scrapli.transport.telnet" href="telnet.html">scrapli.transport.telnet</a></code></dt>
<dd>
<div class="desc"><p>scrapli.transport.telnet</p></div>
</dd>
<dt><code class="name"><a title="scrapli.transport.transport" href="transport.html">scrapli.transport.transport</a></code></dt>
<dd>
<div class="desc"><p>scrapli.transport.transport</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.transport.AsyncTransport"><code class="flex name class">
<span>class <span class="ident">AsyncTransport</span></span>
<span>(</span><span>host: str = '', port: int = 22, timeout_socket: int = 5, timeout_transport: int = 5, timeout_exit: bool = True, keepalive: bool = False, keepalive_interval: int = 30, keepalive_type: str = 'network', keepalive_pattern: str = '\x05')</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Transport Base Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' attempts to use whatever 'standard'
keepalive mechanisms are available in the selected transport mechanism. Check the
transport documentation for details on what is supported and/or how it is
implemented for any given transport driver</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'\005' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncTransport(TransportBase, ABC):
    @abstractmethod
    async def open(self) -&gt; None:  # pylint: disable=W0236
        &#34;&#34;&#34;
        Async open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    async def read(self) -&gt; bytes:  # pylint: disable=W0236
        &#34;&#34;&#34;
        Async read data from the channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.base_transport.TransportBase" href="base_transport.html#scrapli.transport.base_transport.TransportBase">TransportBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.AsyncTransport.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Async open channel, acquire pty, request interactive shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def open(self) -&gt; None:  # pylint: disable=W0236
    &#34;&#34;&#34;
    Async open channel, acquire pty, request interactive shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.AsyncTransport.read"><code class="name flex">
<span>async def <span class="ident">read</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Async read data from the channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def read(self) -&gt; bytes:  # pylint: disable=W0236
    &#34;&#34;&#34;
    Async read data from the channel

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.AsyncTransport.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, channel_input: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to the channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_input</code></strong></dt>
<dd>string to send to channel</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def write(self, channel_input: str) -&gt; None:
    &#34;&#34;&#34;
    Write data to the channel

    Args:
        channel_input: string to send to channel

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.base_transport.TransportBase" href="base_transport.html#scrapli.transport.base_transport.TransportBase">TransportBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.base_transport.TransportBase.close" href="base_transport.html#scrapli.transport.base_transport.TransportBase.close">close</a></code></li>
<li><code><a title="scrapli.transport.base_transport.TransportBase.isalive" href="base_transport.html#scrapli.transport.base_transport.TransportBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.base_transport.TransportBase.set_timeout" href="base_transport.html#scrapli.transport.base_transport.TransportBase.set_timeout">set_timeout</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.transport.SystemSSHTransport"><code class="flex name class">
<span>class <span class="ident">SystemSSHTransport</span></span>
<span>(</span><span>host: str = '', port: int = 22, auth_username: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_password: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: int = 5, timeout_transport: int = 5, timeout_ops: float = 10, timeout_exit: bool = True, keepalive: bool = False, keepalive_interval: int = 30, keepalive_type: str = '', keepalive_pattern: str = '\x05', comms_prompt_pattern: str = &#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$&#x27;, comms_return_char: str = '\n', comms_ansi: bool = False, ssh_config_file: str = '', ssh_known_hosts_file: str = '', transport_options: Union[Dict[str, Any], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>SystemSSHTransport Object</p>
<p>Inherit from Transport ABC
SSH2Transport &lt;- Transport (ABC)</p>
<p>If using this driver, and passing a ssh_config_file (or setting this argument to <code>True</code>),
all settings in the ssh config file will be superseded by any arguments passed here!</p>
<p>Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
handle "in channel" authentication required by SystemSSH &ndash; these are assigned to private
attributes in this class and ignored after authentication. If you wish to modify these
values on a "live" scrapli connection, modify them in the Channel object, i.e.
<code>conn.channel.comms_prompt_pattern</code>. Additionally timeout_ops is passed and assigned to
_timeout_ops to use the same timeout_ops that is used in Channel to decorate the
authentication methods here.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_private_key</code></strong></dt>
<dd>path to private key for authentication</dd>
<dt><strong><code>auth_private_key_passphrase</code></strong></dt>
<dd>passphrase for decrypting ssh key if necessary</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>True/False to enforce strict key checking (default is True)</dd>
<dt><strong><code>auth_bypass</code></strong></dt>
<dd>bypass ssh key or password auth for devices without authentication, or that
have auth prompts after ssh session establishment</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for ssh session to start &ndash; this directly maps to ConnectTimeout
ssh argument; see <code>man ssh_config</code></dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for transport in seconds. since system ssh is using popen/pty
we can't really set a timeout directly, so this value governs the time timeout
decorator for the transport read and write methods</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for telnet channel operations in seconds &ndash; this is also the
timeout for finding and responding to username and password prompts at initial
login. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' is not currently implemented for
system ssh</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'\005' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>prompt pattern expected for device, same as the one provided to
channel &ndash; system ssh needs to know this to know how to decide if we are properly
sending/receiving data &ndash; i.e. we are not stuck at some password prompt or some
other failure scenario. If using driver, this should be passed from driver (Scrape,
or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
is ignored after authentication is completed.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>return character to use on the channel, same as the one provided to
channel &ndash; system ssh needs to know this to know what to send so that we can probe
the channel to make sure we are authenticated and sending/receiving data. If using
driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
class. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; this value is assigned
self._comms_ansi and is ignored after authentication. We only need it for transport
on the off chance (maybe never?) that username/password prompts contain ansi
characters, otherwise "comms_ansi" is really a channel attribute and is treated as
such. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file</dd>
<dt><strong><code>transport_options</code></strong></dt>
<dd>SystemSSHTransport specific transport options (options that don't
apply to any of the other transport classes) supplied in a dictionary where the key
is the name of the option and the value is of course the value.
- open_cmd: string or list of strings to extend the open_cmd with, for example:
<code>["-o", "KexAlgorithms=+diffie-hellman-group1-sha1"]</code> or:
<code>-oKexAlgorithms=+diffie-hellman-group1-sha1</code>
these commands will be appended to the open command that scrapli builds which
looks something like the following depending on the inputs provided:
ssh 172.31.254.1 -p 22 -o ConnectTimeout=5 -o ServerAliveInterval=10
-l scrapli -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
-F /dev/null
You can pass any arguments that would be supported if you were ssh'ing on your
terminal "normally", passing some bad arguments can break things!</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SystemSSHTransport(Transport):
    def __init__(
        self,
        host: str = &#34;&#34;,
        port: int = 22,
        auth_username: str = &#34;&#34;,
        auth_private_key: str = &#34;&#34;,
        auth_private_key_passphrase: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_strict_key: bool = True,
        auth_bypass: bool = False,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_ops: float = 10,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
        ssh_config_file: str = &#34;&#34;,
        ssh_known_hosts_file: str = &#34;&#34;,
        transport_options: Optional[Dict[str, Any]] = None,
    ) -&gt; None:
        r&#34;&#34;&#34;
        SystemSSHTransport Object

        Inherit from Transport ABC
        SSH2Transport &lt;- Transport (ABC)

        If using this driver, and passing a ssh_config_file (or setting this argument to `True`),
        all settings in the ssh config file will be superseded by any arguments passed here!

        Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
        handle &#34;in channel&#34; authentication required by SystemSSH -- these are assigned to private
        attributes in this class and ignored after authentication. If you wish to modify these
        values on a &#34;live&#34; scrapli connection, modify them in the Channel object, i.e.
        `conn.channel.comms_prompt_pattern`. Additionally timeout_ops is passed and assigned to
        _timeout_ops to use the same timeout_ops that is used in Channel to decorate the
        authentication methods here.

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_private_key: path to private key for authentication
            auth_private_key_passphrase: passphrase for decrypting ssh key if necessary
            auth_password: password for authentication
            auth_strict_key: True/False to enforce strict key checking (default is True)
            auth_bypass: bypass ssh key or password auth for devices without authentication, or that
                have auth prompts after ssh session establishment
            timeout_socket: timeout for ssh session to start -- this directly maps to ConnectTimeout
                ssh argument; see `man ssh_config`
            timeout_transport: timeout for transport in seconds. since system ssh is using popen/pty
                we can&#39;t really set a timeout directly, so this value governs the time timeout
                decorator for the transport read and write methods
            timeout_ops: timeout for telnet channel operations in seconds -- this is also the
                timeout for finding and responding to username and password prompts at initial
                login. This is assigned to a private attribute and is ignored after authentication
                is completed.
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; is not currently implemented for
                system ssh
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- system ssh needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
                is ignored after authentication is completed.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- system ssh needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class. This is assigned to a private attribute and is ignored after authentication
                is completed.
            comms_ansi: True/False strip comms_ansi characters from output; this value is assigned
                self._comms_ansi and is ignored after authentication. We only need it for transport
                on the off chance (maybe never?) that username/password prompts contain ansi
                characters, otherwise &#34;comms_ansi&#34; is really a channel attribute and is treated as
                such. This is assigned to a private attribute and is ignored after authentication
                is completed.
            ssh_config_file: string to path for ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file
            transport_options: SystemSSHTransport specific transport options (options that don&#39;t
                apply to any of the other transport classes) supplied in a dictionary where the key
                is the name of the option and the value is of course the value.
                - open_cmd: string or list of strings to extend the open_cmd with, for example:
                    `[&#34;-o&#34;, &#34;KexAlgorithms=+diffie-hellman-group1-sha1&#34;]` or:
                    `-oKexAlgorithms=+diffie-hellman-group1-sha1`
                    these commands will be appended to the open command that scrapli builds which
                    looks something like the following depending on the inputs provided:
                        ssh 172.31.254.1 -p 22 -o ConnectTimeout=5 -o ServerAliveInterval=10
                         -l scrapli -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
                         -F /dev/null
                    You can pass any arguments that would be supported if you were ssh&#39;ing on your
                    terminal &#34;normally&#34;, passing some bad arguments can break things!

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )

        self.auth_username: str = auth_username
        self.auth_private_key: str = auth_private_key
        self.auth_private_key_passphrase: str = auth_private_key_passphrase
        self.auth_password: str = auth_password
        self.auth_strict_key: bool = auth_strict_key
        self.auth_bypass: bool = auth_bypass

        self._timeout_ops: float = timeout_ops
        self._comms_prompt_pattern: str = comms_prompt_pattern
        self._comms_return_char: str = comms_return_char
        self._comms_ansi: bool = comms_ansi
        self._process_ssh_config(ssh_config_file)
        self.ssh_known_hosts_file: str = ssh_known_hosts_file

        self.session: PtyProcess
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

        # ensure we set transport_options to a dict if its left as None
        self.transport_options = transport_options or {}

        self.open_cmd = [&#34;ssh&#34;, self.host]
        self._build_open_cmd()

    def _process_ssh_config(self, ssh_config_file: str) -&gt; None:
        &#34;&#34;&#34;
        Method to parse ssh config file

        Ensure ssh_config_file is valid (if providing a string path to config file), or resolve
        config file if passed True.

        Args:
            ssh_config_file: string path to ssh config file; passed down from `Scrape`, or the
                `NetworkDriver` or subclasses of it, in most cases.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        ssh = SSHConfig(ssh_config_file=ssh_config_file)
        self.ssh_config_file = ssh.ssh_config_file

    def _build_open_cmd(self) -&gt; None:
        &#34;&#34;&#34;
        Method to craft command to open ssh session

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.open_cmd.extend([&#34;-p&#34;, str(self.port)])
        self.open_cmd.extend([&#34;-o&#34;, f&#34;ConnectTimeout={self.timeout_socket}&#34;])
        self.open_cmd.extend([&#34;-o&#34;, f&#34;ServerAliveInterval={self.timeout_transport}&#34;])
        if self.auth_private_key:
            self.open_cmd.extend([&#34;-i&#34;, self.auth_private_key])
        if self.auth_username:
            self.open_cmd.extend([&#34;-l&#34;, self.auth_username])
        if self.auth_strict_key is False:
            self.open_cmd.extend([&#34;-o&#34;, &#34;StrictHostKeyChecking=no&#34;])
            self.open_cmd.extend([&#34;-o&#34;, &#34;UserKnownHostsFile=/dev/null&#34;])
        else:
            self.open_cmd.extend([&#34;-o&#34;, &#34;StrictHostKeyChecking=yes&#34;])
            if self.ssh_known_hosts_file:
                self.open_cmd.extend([&#34;-o&#34;, f&#34;UserKnownHostsFile={self.ssh_known_hosts_file}&#34;])
        if self.ssh_config_file:
            self.open_cmd.extend([&#34;-F&#34;, self.ssh_config_file])
        else:
            self.open_cmd.extend([&#34;-F&#34;, &#34;/dev/null&#34;])

        user_args = self.transport_options.get(&#34;open_cmd&#34;, [])
        if isinstance(user_args, str):
            user_args = [user_args]
        self.open_cmd.extend(user_args)

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to open session, authenticate and acquire shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Attempting to authenticate to {self.host}&#34;)
        self._open_pty()
        self.logger.info(f&#34;Successfully authenticated to {self.host}&#34;)

        if self.keepalive:
            self._session_keepalive()

    def _ssh_message_handler(self, output: bytes) -&gt; None:  # noqa: C901
        &#34;&#34;&#34;
        Parse EOF messages from _pty_authenticate and create log/stack exception message

        Args:
            output: bytes output from _pty_authenticate

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if any errors are read in the output

        &#34;&#34;&#34;
        msg = &#34;&#34;
        if b&#34;host key verification failed&#34; in output.lower():
            msg = f&#34;Host key verification failed for host {self.host}&#34;
        elif b&#34;operation timed out&#34; in output.lower() or b&#34;connection timed out&#34; in output.lower():
            msg = f&#34;Timed out connecting to host {self.host}&#34;
        elif b&#34;no route to host&#34; in output.lower():
            msg = f&#34;No route to host {self.host}&#34;
        elif b&#34;no matching key exchange&#34; in output.lower():
            msg = f&#34;No matching key exchange found for host {self.host}&#34;
            key_exchange_pattern = re.compile(
                pattern=rb&#34;their offer: ([a-z0-9\-,]*)&#34;, flags=re.M | re.I
            )
            offered_key_exchanges_match = re.search(pattern=key_exchange_pattern, string=output)
            if offered_key_exchanges_match:
                offered_key_exchanges = offered_key_exchanges_match.group(1).decode()
                msg = (
                    f&#34;No matching key exchange found for host {self.host}, their offer: &#34;
                    f&#34;{offered_key_exchanges}&#34;
                )
        elif b&#34;no matching cipher&#34; in output.lower():
            msg = f&#34;No matching cipher found for host {self.host}&#34;
            ciphers_pattern = re.compile(pattern=rb&#34;their offer: ([a-z0-9\-,]*)&#34;, flags=re.M | re.I)
            offered_ciphers_match = re.search(pattern=ciphers_pattern, string=output)
            if offered_ciphers_match:
                offered_ciphers = offered_ciphers_match.group(1).decode()
                msg = (
                    f&#34;No matching cipher found for host {self.host}, their offer: {offered_ciphers}&#34;
                )
        elif b&#34;bad configuration&#34; in output.lower():
            msg = f&#34;Bad SSH configuration option(s) for host {self.host}&#34;
            configuration_pattern = re.compile(
                pattern=rb&#34;bad configuration option: ([a-z0-9\+\=,]*)&#34;, flags=re.M | re.I
            )
            configuration_issue_match = re.search(pattern=configuration_pattern, string=output)
            if configuration_issue_match:
                configuration_issues = configuration_issue_match.group(1).decode()
                msg = (
                    f&#34;Bad SSH configuration option(s) for host {self.host}, bad option(s): &#34;
                    f&#34;{configuration_issues}&#34;
                )
        elif b&#34;WARNING: UNPROTECTED PRIVATE KEY FILE!&#34; in output:
            msg = (
                f&#34;Permissions for private key `{self.auth_private_key}` are too open, &#34;
                &#34;authentication failed!&#34;
            )
        elif b&#34;could not resolve hostname&#34; in output.lower():
            msg = f&#34;Could not resolve address for host `{self.host}`&#34;
        if msg:
            self.logger.critical(msg)
            raise ScrapliAuthenticationFailed(msg)

    def _open_pty(self) -&gt; bool:
        &#34;&#34;&#34;
        Private method to open session with PtyProcess

        Args:
            N/A

        Returns:
            bool: True/False session was opened and authenticated

        Raises:
            ScrapliAuthenticationFailed: if all authentication means fail

        &#34;&#34;&#34;
        self.logger.info(f&#34;Attempting to open session with the following command: {self.open_cmd}&#34;)
        self.session = PtyProcess.spawn(self.open_cmd)
        self.logger.debug(f&#34;Session to host {self.host} spawned&#34;)

        if not self.auth_bypass:
            self._authenticate()
        else:
            self.logger.info(&#34;`auth_bypass` is True, bypassing authentication&#34;)
            # if we skip auth, we&#39;ll manually set _isauthenticated to True
            self._isauthenticated = True

        if not self._isauthenticated and not self._system_isauthenticated():
            msg = f&#34;Authentication to host {self.host} failed&#34;
            self.logger.critical(msg)
            raise ScrapliAuthenticationFailed(msg)

        self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)
        return True

    @OperationTimeout(&#34;_timeout_ops&#34;, &#34;Timed out attempting to authenticate&#34;)
    def _authenticate(self) -&gt; None:
        &#34;&#34;&#34;
        Private method to check initial authentication when using pty_session

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if we get EOF and _ssh_message_handler does not raise an
                explicit exception/message

        &#34;&#34;&#34;
        output = b&#34;&#34;
        prompt_pattern = get_prompt_pattern(prompt=&#34;&#34;, class_prompt=self._comms_prompt_pattern)
        with self.session_lock:
            while True:
                try:
                    new_output = self.session.read()
                    output += new_output
                    self.logger.debug(f&#34;Attempting to authenticate. Read: {repr(new_output)}&#34;)
                except EOFError as exc:
                    self._ssh_message_handler(output=output)
                    # if _ssh_message_handler didn&#39;t raise any exception, we can raise the standard
                    # &#34;did you disable strict key message/exception&#34;
                    msg = (
                        f&#34;Failed to open connection to host {self.host}. Do you need to disable &#34;
                        &#34;`auth_strict_key`?&#34;
                    )
                    self.logger.critical(msg)
                    raise ScrapliAuthenticationFailed(msg) from exc

                # even if we dont hit EOF, we may still have hit a message we need to process such
                # as insecure key permissions
                self._ssh_message_handler(output=output)

                if self._comms_ansi or b&#34;\x1B&#34; in output:
                    output = strip_ansi(output=output)
                if b&#34;password&#34; in output.lower():
                    self.logger.info(&#34;Found password prompt, sending password&#34;)
                    self.session.write(self.auth_password.encode())
                    self.session.write(self._comms_return_char.encode())
                    break
                if b&#34;enter passphrase for key&#34; in output.lower():
                    self.logger.info(&#34;Found key passphrase prompt, sending passphrase&#34;)
                    self.session.write(self.auth_private_key_passphrase.encode())
                    self.session.write(self._comms_return_char.encode())
                    break
                channel_match = re.search(pattern=prompt_pattern, string=output)
                if channel_match:
                    self.logger.info(
                        &#34;Found channel prompt, assuming that key based authentication has succeeded&#34;
                    )
                    # set _isauthenticated to true, we&#39;ve already authenticated, don&#39;t re-check
                    self._isauthenticated = True
                    break

    @OperationTimeout(&#34;_timeout_ops&#34;, &#34;Timed out determining if session is authenticated&#34;)
    def _system_isauthenticated(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the sub process is alive and has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            N/A

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Attempting to determine if authentication was successful&#34;)
        with self.session_lock:
            if self.session.isalive() and not self.session.eof():
                prompt_pattern = get_prompt_pattern(
                    prompt=&#34;&#34;, class_prompt=self._comms_prompt_pattern
                )
                self.session.write(self._comms_return_char.encode())
                self._wait_for_session_fd_ready(fd=self.session.fd)

                output = b&#34;&#34;
                while True:
                    new_output = self.session.read()
                    output += new_output
                    self.logger.debug(
                        f&#34;Attempting to validate authentication. Read: {repr(new_output)}&#34;
                    )
                    # we do not need to deal w/ line replacement for the actual output, only for
                    # parsing if a prompt-like thing is at the end of the output
                    output = output.replace(b&#34;\r&#34;, b&#34;&#34;)
                    # always check to see if we should strip ansi here; if we don&#39;t handle this we
                    # may raise auth failures for the wrong reason which would be confusing for
                    # users
                    if self._comms_ansi or b&#34;\x1B&#34; in output:
                        output = strip_ansi(output=output)
                    channel_match = re.search(pattern=prompt_pattern, string=output)
                    if channel_match:
                        self._isauthenticated = True
                        break
                    if b&#34;password:&#34; in output.lower():
                        # if we see &#34;password&#34; we know auth failed (hopefully in all scenarios!)
                        self.logger.critical(
                            &#34;Found `password:` in output, assuming password authentication failed&#34;
                        )
                        break
                    if output:
                        self.logger.debug(
                            f&#34;Cannot determine if authenticated, \n\tRead: {repr(output)}&#34;
                        )

        if self._isauthenticated:
            return True

        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.close()
        self.logger.debug(f&#34;Channel to host {self.host} closed&#34;)

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if session is alive and session authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.session.isalive() and self._isauthenticated and not self.session.eof():
            return True
        return False

    @requires_open_session()
    @OperationTimeout(&#34;timeout_transport&#34;, &#34;Timed out reading from transport&#34;)
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes output as read from channel

        Raises:
            N/A

        &#34;&#34;&#34;
        read_bytes = 65535
        return self.session.read(read_bytes)

    @requires_open_session()
    @OperationTimeout(&#34;timeout_transport&#34;, &#34;Timed out writing to transport&#34;)
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.write(channel_input.encode())

    def set_timeout(self, timeout: int) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.timeout_transport = timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: &#39;standard&#39; keepalive mechanism not yet implemented for system

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;&#39;standard&#39; keepalive mechanism not yet implemented for system.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li><a title="scrapli.transport.base_transport.TransportBase" href="base_transport.html#scrapli.transport.base_transport.TransportBase">TransportBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.SystemSSHTransport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if session is alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if session is alive and session authenticated, else False</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if session is alive and session is authenticated

    Args:
        N/A

    Returns:
        bool: True if session is alive and session authenticated, else False

    Raises:
        N/A

    &#34;&#34;&#34;
    if self.session.isalive() and self._isauthenticated and not self.session.eof():
        return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.SystemSSHTransport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Parent method to open session, authenticate and acquire shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to open session, authenticate and acquire shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Attempting to authenticate to {self.host}&#34;)
    self._open_pty()
    self.logger.info(f&#34;Successfully authenticated to {self.host}&#34;)

    if self.keepalive:
        self._session_keepalive()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="base_transport.html#scrapli.transport.base_transport.TransportBase.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.read" href="transport.html#scrapli.transport.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_timeout" href="base_transport.html#scrapli.transport.base_transport.TransportBase.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.transport.TelnetTransport"><code class="flex name class">
<span>class <span class="ident">TelnetTransport</span></span>
<span>(</span><span>host: str, port: int = 23, auth_username: str = '', auth_password: str = '', auth_bypass: bool = False, timeout_socket: int = 5, timeout_transport: int = 5, timeout_ops: int = 10, timeout_exit: bool = True, keepalive: bool = False, keepalive_interval: int = 30, keepalive_type: str = '', keepalive_pattern: str = '\x05', comms_prompt_pattern: str = &#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$&#x27;, comms_return_char: str = '\n', comms_ansi: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>TelnetTransport Object</p>
<p>Inherit from Transport ABC
TelnetTransport &lt;- Transport (ABC)</p>
<p>Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
handle "in channel" authentication required by SystemSSH &ndash; these are assigned to private
attributes in this class and ignored after authentication. If you wish to modify these
values on a "live" scrapli connection, modify them in the Channel object, i.e.
<code>conn.channel.comms_prompt_pattern</code>. Additionally timeout_ops is passed and assigned to
_timeout_ops to use the same timeout_ops that is used in Channel to decorate the
authentication methods here.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_bypass</code></strong></dt>
<dd>bypass authentication process</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds &ndash; since this is not directly
exposed in telnetlib, this is just the initial timeout for the telnet connection.
After the connection is established, the timeout is modified to the value of
<code>timeout_transport</code>.</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for telnet channel operations in seconds &ndash; this is also the
timeout for finding and responding to username and password prompts at initial
login. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
"standard" keepalive mechanisms. 'standard' is not currently implemented for telnet</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'\005' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>prompt pattern expected for device, same as the one provided to
channel &ndash; telnet needs to know this to know how to decide if we are properly
sending/receiving data &ndash; i.e. we are not stuck at some password prompt or some
other failure scenario. If using driver, this should be passed from driver (Scrape,
or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
is ignored after authentication is completed.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>return character to use on the channel, same as the one provided to
channel &ndash; telnet needs to know this to know what to send so that we can probe
the channel to make sure we are authenticated and sending/receiving data. If using
driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
class. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; this value is assigned
self._comms_ansi and is ignored after authentication. We only need it for transport
on the off chance (maybe never, especially here in telnet land?) that
username/password prompts contain ansi characters, otherwise "comms_ansi" is really
a channel attribute and is treated as such. This is assigned to a private attribute
and is ignored after authentication is completed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TelnetTransport(Transport):
    def __init__(
        self,
        host: str,
        port: int = 23,
        auth_username: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_bypass: bool = False,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_ops: int = 10,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
    ) -&gt; None:
        r&#34;&#34;&#34;
        TelnetTransport Object

        Inherit from Transport ABC
        TelnetTransport &lt;- Transport (ABC)

        Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
        handle &#34;in channel&#34; authentication required by SystemSSH -- these are assigned to private
        attributes in this class and ignored after authentication. If you wish to modify these
        values on a &#34;live&#34; scrapli connection, modify them in the Channel object, i.e.
        `conn.channel.comms_prompt_pattern`. Additionally timeout_ops is passed and assigned to
        _timeout_ops to use the same timeout_ops that is used in Channel to decorate the
        authentication methods here.

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_password: password for authentication
            auth_bypass: bypass authentication process
            timeout_socket: timeout for establishing socket in seconds -- since this is not directly
                exposed in telnetlib, this is just the initial timeout for the telnet connection.
                After the connection is established, the timeout is modified to the value of
                `timeout_transport`.
            timeout_transport: timeout for telnet transport in seconds
            timeout_ops: timeout for telnet channel operations in seconds -- this is also the
                timeout for finding and responding to username and password prompts at initial
                login. This is assigned to a private attribute and is ignored after authentication
                is completed.
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#34;standard&#34; keepalive mechanisms. &#39;standard&#39; is not currently implemented for telnet
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- telnet needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
                is ignored after authentication is completed.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- telnet needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class. This is assigned to a private attribute and is ignored after authentication
                is completed.
            comms_ansi: True/False strip comms_ansi characters from output; this value is assigned
                self._comms_ansi and is ignored after authentication. We only need it for transport
                on the off chance (maybe never, especially here in telnet land?) that
                username/password prompts contain ansi characters, otherwise &#34;comms_ansi&#34; is really
                a channel attribute and is treated as such. This is assigned to a private attribute
                and is ignored after authentication is completed.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )
        self.auth_username: str = auth_username
        self.auth_password: str = auth_password
        self.auth_bypass: bool = auth_bypass

        self._timeout_ops: int = timeout_ops
        # timeout_ops_auth is only used for authentication; base ops timeout * 2 as we are doing
        # two operations -- entering username and entering password (in most cases at least)
        self._timeout_ops_auth: int = timeout_ops * 2

        self._comms_prompt_pattern: str = comms_prompt_pattern
        self._comms_return_char: str = comms_return_char
        self._comms_ansi: bool = comms_ansi

        self.username_prompt: str = &#34;Username:&#34;
        self.password_prompt: str = &#34;Password:&#34;

        self.session: ScrapliTelnet
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open telnet channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ConnectionNotOpened: if connection cant be opened
            ScrapliAuthenticationFailed: if cant successfully authenticate

        &#34;&#34;&#34;
        with self.session_lock:
            # establish session with &#34;socket&#34; timeout, then reset timeout to &#34;transport&#34; timeout
            try:
                self.session = ScrapliTelnet(
                    host=self.host, port=self.port, timeout=self.timeout_socket
                )
            except ConnectionError as exc:
                msg = f&#34;Failed to open telnet session to host {self.host}&#34;
                if &#34;connection refused&#34; in str(exc).lower():
                    msg = f&#34;Failed to open telnet session to host {self.host}, connection refused&#34;
                raise ConnectionNotOpened(msg) from exc
            self.session.timeout = self.timeout_transport
            self.logger.debug(f&#34;Session to host {self.host} spawned&#34;)

        if not self.auth_bypass:
            self._authenticate()
        else:
            self.logger.info(&#34;`auth_bypass` is True, bypassing authentication&#34;)
            # if we skip auth, we&#39;ll manually set _isauthenticated to True
            self._isauthenticated = True

        if not self._isauthenticated and not self._telnet_isauthenticated():
            raise ScrapliAuthenticationFailed(
                f&#34;Could not authenticate over telnet to host: {self.host}&#34;
            )

        self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)

    @OperationTimeout(&#34;_timeout_ops_auth&#34;, &#34;Timed out looking for telnet login prompts&#34;)
    def _authenticate(self) -&gt; None:
        &#34;&#34;&#34;
        Parent private method to handle telnet authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if an EOFError is encountered; we in theory *did* open the
                connection, so we won&#39;t raise a ConnectionNotOpened here

        &#34;&#34;&#34;
        output = b&#34;&#34;

        # capture the start time of the authentication event; we also set a &#34;return_interval&#34; which
        # is 1/10 the timout_ops value, we will send a return character at roughly this interval if
        # there is no output on the channel. we do this because sometimes telnet needs a kick to get
        # it to prompt for auth -- particularity when connecting to terminal server/console port
        auth_start_time = datetime.now().timestamp()
        return_interval = self._timeout_ops / 10
        return_attempts = 1

        with self.session_lock:
            while True:
                try:
                    new_output = self.session.read_eager()
                    output += new_output
                    self.logger.debug(f&#34;Attempting to authenticate. Read: {repr(new_output)}&#34;)
                except EOFError as exc:
                    # EOF means telnet connection is dead :(
                    msg = f&#34;Failed to open connection to host {self.host}. Connection lost.&#34;
                    self.logger.critical(msg)
                    raise ScrapliAuthenticationFailed(msg) from exc

                if self.username_prompt.lower().encode() in output.lower():
                    self.logger.info(&#34;Found username prompt, sending username&#34;)
                    # if/when we see username, reset the output to empty byte string
                    output = b&#34;&#34;
                    self.session.write(self.auth_username.encode())
                    self.session.write(self._comms_return_char.encode())
                elif self.password_prompt.lower().encode() in output.lower():
                    self.logger.info(&#34;Found password prompt, sending password&#34;)
                    self.session.write(self.auth_password.encode())
                    self.session.write(self._comms_return_char.encode())
                    break
                elif not output:
                    current_iteration_time = datetime.now().timestamp()
                    if (current_iteration_time - auth_start_time) &gt; (
                        return_interval * return_attempts
                    ):
                        self.logger.debug(
                            &#34;No username or password prompt found, sending return character...&#34;
                        )
                        self.session.write(self._comms_return_char.encode())
                        return_attempts += 1

    @OperationTimeout(&#34;_timeout_ops_auth&#34;, &#34;Timed determining if telnet session is authenticated&#34;)
    def _telnet_isauthenticated(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the telnet session has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            N/A

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Attempting to determine if telnet authentication was successful&#34;)
        with self.session_lock:
            if not self.session.eof:
                prompt_pattern = get_prompt_pattern(
                    prompt=&#34;&#34;, class_prompt=self._comms_prompt_pattern
                )
                self.session.write(self._comms_return_char.encode())
                self._wait_for_session_fd_ready(fd=self.session.fileno())

                output = b&#34;&#34;
                while True:
                    new_output = self.session.read_eager()
                    output += new_output
                    self.logger.debug(
                        f&#34;Attempting to validate authentication. Read: {repr(new_output)}&#34;
                    )
                    # we do not need to deal w/ line replacement for the actual output, only for
                    # parsing if a prompt-like thing is at the end of the output
                    output = output.replace(b&#34;\r&#34;, b&#34;&#34;)
                    # always check to see if we should strip ansi here; if we don&#39;t handle this we
                    # may raise auth failures for the wrong reason which would be confusing for
                    # users
                    if self._comms_ansi or b&#34;\x1B&#34; in output:
                        output = strip_ansi(output=output)
                    channel_match = re.search(pattern=prompt_pattern, string=output)
                    if channel_match:
                        self._isauthenticated = True
                        break
                    if b&#34;username:&#34; in output.lower():
                        # if we see &#34;username&#34; prompt we can assume (because telnet) that we failed
                        # to authenticate
                        self.logger.critical(
                            &#34;Found `username:` in output, assuming password authentication failed&#34;
                        )
                        break
                    if b&#34;password:&#34; in output.lower():
                        # if we see &#34;password&#34; we know auth failed (hopefully in all scenarios!)
                        self.logger.critical(
                            &#34;Found `password:` in output, assuming password authentication failed&#34;
                        )
                        break
                    if output:
                        self.logger.debug(
                            f&#34;Cannot determine if authenticated, \n\tRead: {repr(output)}&#34;
                        )

            if self._isauthenticated:
                return True

            return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        self.logger.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if alive, False otherwise.

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._isauthenticated and not self.session.eof:
            return True
        return False

    @requires_open_session()
    @OperationTimeout(&#34;timeout_transport&#34;, &#34;Timed out reading from transport&#34;)
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes read from the telnet channel

        Raises:
            N/A

        &#34;&#34;&#34;
        return self.session.read_eager()

    @requires_open_session()
    @OperationTimeout(&#34;timeout_transport&#34;, &#34;Timed out writing to transport&#34;)
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.write(channel_input.encode())

    @requires_open_session()
    def set_timeout(self, timeout: int) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.timeout = timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: always, because this is not implemented for telnet

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for telnet.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li><a title="scrapli.transport.base_transport.TransportBase" href="base_transport.html#scrapli.transport.base_transport.TransportBase">TransportBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.TelnetTransport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if alive, False otherwise.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if alive and session is authenticated

    Args:
        N/A

    Returns:
        bool: True if alive, False otherwise.

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._isauthenticated and not self.session.eof:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.TelnetTransport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open telnet channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionNotOpened</code></dt>
<dd>if connection cant be opened</dd>
<dt><code>ScrapliAuthenticationFailed</code></dt>
<dd>if cant successfully authenticate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open telnet channel

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        ConnectionNotOpened: if connection cant be opened
        ScrapliAuthenticationFailed: if cant successfully authenticate

    &#34;&#34;&#34;
    with self.session_lock:
        # establish session with &#34;socket&#34; timeout, then reset timeout to &#34;transport&#34; timeout
        try:
            self.session = ScrapliTelnet(
                host=self.host, port=self.port, timeout=self.timeout_socket
            )
        except ConnectionError as exc:
            msg = f&#34;Failed to open telnet session to host {self.host}&#34;
            if &#34;connection refused&#34; in str(exc).lower():
                msg = f&#34;Failed to open telnet session to host {self.host}, connection refused&#34;
            raise ConnectionNotOpened(msg) from exc
        self.session.timeout = self.timeout_transport
        self.logger.debug(f&#34;Session to host {self.host} spawned&#34;)

    if not self.auth_bypass:
        self._authenticate()
    else:
        self.logger.info(&#34;`auth_bypass` is True, bypassing authentication&#34;)
        # if we skip auth, we&#39;ll manually set _isauthenticated to True
        self._isauthenticated = True

    if not self._isauthenticated and not self._telnet_isauthenticated():
        raise ScrapliAuthenticationFailed(
            f&#34;Could not authenticate over telnet to host: {self.host}&#34;
        )

    self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="base_transport.html#scrapli.transport.base_transport.TransportBase.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.read" href="transport.html#scrapli.transport.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_timeout" href="base_transport.html#scrapli.transport.base_transport.TransportBase.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.transport.Transport"><code class="flex name class">
<span>class <span class="ident">Transport</span></span>
<span>(</span><span>host: str = '', port: int = 22, timeout_socket: int = 5, timeout_transport: int = 5, timeout_exit: bool = True, keepalive: bool = False, keepalive_interval: int = 30, keepalive_type: str = 'network', keepalive_pattern: str = '\x05')</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Transport Base Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' attempts to use whatever 'standard'
keepalive mechanisms are available in the selected transport mechanism. Check the
transport documentation for details on what is supported and/or how it is
implemented for any given transport driver</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'\005' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transport(TransportBase, ABC):
    @abstractmethod
    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def _session_keepalive(self) -&gt; None:
        &#34;&#34;&#34;
        Spawn keepalive thread for transport session

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if not self.keepalive:
            return
        pool = ThreadPoolExecutor()
        if self.keepalive_type == &#34;network&#34;:
            pool.submit(self._keepalive_network)
        else:
            pool.submit(self._keepalive_standard)

    def _keepalive_network(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;in band&#34; keepalives to devices.

        Generally used with &#34;network&#34; devices which do not have native keepalive support. This will
        try to acquire a session lock and send an innocuous character -- such as CTRL+E -- to keep
        the device &#34;exec-timeout&#34; (in network-y words) from expiring.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliKeepaliveFailure: if scrapli cant unlock and send keepalive in less than 3 *
                the keepalive_interval

        &#34;&#34;&#34;

        def kill_transport() -&gt; None:
            if self.isalive():
                self.close()

        # ensure the transport is closed so keepalive can terminate if main thread tries to exit
        atexit.register(kill_transport)

        lock_counter = 0
        last_keepalive = datetime.now()
        while True:
            if not self.isalive():
                return
            diff = datetime.now() - last_keepalive
            if diff.seconds &gt;= self.keepalive_interval:
                if not self.session_lock.locked():
                    self.logger.debug(
                        f&#34;Sending &#39;network&#39; keepalive with pattern {repr(self.keepalive_pattern)}.&#34;
                    )
                    lock_counter = 0
                    self.session_lock.acquire()
                    self.write(channel_input=self.keepalive_pattern)
                    self.session_lock.release()
                    last_keepalive = datetime.now()
                else:
                    lock_counter += 1
                    if lock_counter &gt;= 3:
                        self.logger.info(
                            f&#34;Keepalive thread missed {lock_counter} consecutive keepalives.&#34;
                        )
            if diff.seconds &gt; self.keepalive_interval * 3:
                msg = (
                    &#34;Keepalive thread has failed to send a keepalive in greater than three &#34;
                    &#34;times the keepalive interval!&#34;
                )
                self.logger.critical(msg)
                raise ScrapliKeepaliveFailure(msg)
            time.sleep(self.keepalive_interval / 10)

    @abstractmethod
    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def _wait_for_session_fd_ready(self, fd: int) -&gt; None:
        &#34;&#34;&#34;
        Wait for a session fd to be ready to read

        Only applicable for &#34;core&#34; transports system/telnet

        Args:
            fd: fd id to check on

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        while True:
            fd_ready, _, _ = select([fd], [], [], 0)
            if fd in fd_ready:
                break
            self.logger.debug(&#34;Session fd not ready yet...&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.base_transport.TransportBase" href="base_transport.html#scrapli.transport.base_transport.TransportBase">TransportBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.transport.systemssh.SystemSSHTransport" href="systemssh.html#scrapli.transport.systemssh.SystemSSHTransport">SystemSSHTransport</a></li>
<li><a title="scrapli.transport.telnet.TelnetTransport" href="telnet.html#scrapli.transport.telnet.TelnetTransport">TelnetTransport</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.Transport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open channel, acquire pty, request interactive shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open channel, acquire pty, request interactive shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.Transport.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Read data from the channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(self) -&gt; bytes:
    &#34;&#34;&#34;
    Read data from the channel

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.Transport.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, channel_input: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to the channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_input</code></strong></dt>
<dd>string to send to channel</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def write(self, channel_input: str) -&gt; None:
    &#34;&#34;&#34;
    Write data to the channel

    Args:
        channel_input: string to send to channel

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.base_transport.TransportBase" href="base_transport.html#scrapli.transport.base_transport.TransportBase">TransportBase</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.base_transport.TransportBase.close" href="base_transport.html#scrapli.transport.base_transport.TransportBase.close">close</a></code></li>
<li><code><a title="scrapli.transport.base_transport.TransportBase.isalive" href="base_transport.html#scrapli.transport.base_transport.TransportBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.base_transport.TransportBase.set_timeout" href="base_transport.html#scrapli.transport.base_transport.TransportBase.set_timeout">set_timeout</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli" href="../index.html">scrapli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli.transport.async_transport" href="async_transport.html">scrapli.transport.async_transport</a></code></li>
<li><code><a title="scrapli.transport.base_transport" href="base_transport.html">scrapli.transport.base_transport</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess" href="ptyprocess.html">scrapli.transport.ptyprocess</a></code></li>
<li><code><a title="scrapli.transport.socket" href="socket.html">scrapli.transport.socket</a></code></li>
<li><code><a title="scrapli.transport.systemssh" href="systemssh.html">scrapli.transport.systemssh</a></code></li>
<li><code><a title="scrapli.transport.telnet" href="telnet.html">scrapli.transport.telnet</a></code></li>
<li><code><a title="scrapli.transport.transport" href="transport.html">scrapli.transport.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.transport.AsyncTransport" href="#scrapli.transport.AsyncTransport">AsyncTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.AsyncTransport.open" href="#scrapli.transport.AsyncTransport.open">open</a></code></li>
<li><code><a title="scrapli.transport.AsyncTransport.read" href="#scrapli.transport.AsyncTransport.read">read</a></code></li>
<li><code><a title="scrapli.transport.AsyncTransport.write" href="#scrapli.transport.AsyncTransport.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.SystemSSHTransport" href="#scrapli.transport.SystemSSHTransport">SystemSSHTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.SystemSSHTransport.isalive" href="#scrapli.transport.SystemSSHTransport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.SystemSSHTransport.open" href="#scrapli.transport.SystemSSHTransport.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.TelnetTransport" href="#scrapli.transport.TelnetTransport">TelnetTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.TelnetTransport.isalive" href="#scrapli.transport.TelnetTransport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.TelnetTransport.open" href="#scrapli.transport.TelnetTransport.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.Transport" href="#scrapli.transport.Transport">Transport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.Transport.open" href="#scrapli.transport.Transport.open">open</a></code></li>
<li><code><a title="scrapli.transport.Transport.read" href="#scrapli.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.Transport.write" href="#scrapli.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>