<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>scrapli.transport API documentation</title>
<meta name="description" content="scrapli.transport" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.transport</code></h1>
</header>
<section id="section-intro">
<p>scrapli.transport</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.transport&#34;&#34;&#34;
from scrapli.transport.cssh2 import SSH2_TRANSPORT_ARGS, SSH2Transport
from scrapli.transport.miko import MIKO_TRANSPORT_ARGS, MikoTransport
from scrapli.transport.systemssh import SYSTEM_SSH_TRANSPORT_ARGS, SystemSSHTransport
from scrapli.transport.telnet import TELNET_TRANSPORT_ARGS, TelnetTransport
from scrapli.transport.transport import Transport

__all__ = (
    &#34;Transport&#34;,
    &#34;MikoTransport&#34;,
    &#34;MIKO_TRANSPORT_ARGS&#34;,
    &#34;SSH2Transport&#34;,
    &#34;SSH2_TRANSPORT_ARGS&#34;,
    &#34;SystemSSHTransport&#34;,
    &#34;SYSTEM_SSH_TRANSPORT_ARGS&#34;,
    &#34;TELNET_TRANSPORT_ARGS&#34;,
    &#34;TelnetTransport&#34;,
)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli.transport.cssh2" href="cssh2.html">scrapli.transport.cssh2</a></code></dt>
<dd>
<section class="desc"><p>scrapli.transport.cssh2</p></section>
</dd>
<dt><code class="name"><a title="scrapli.transport.miko" href="miko.html">scrapli.transport.miko</a></code></dt>
<dd>
<section class="desc"><p>scrapli.transport.miko</p></section>
</dd>
<dt><code class="name"><a title="scrapli.transport.ptyprocess" href="ptyprocess.html">scrapli.transport.ptyprocess</a></code></dt>
<dd>
<section class="desc"><p>Ptyprocess is under the ISC license, as code derived from Pexpect.
<a href="http://opensource.org/licenses/ISC">http://opensource.org/licenses/ISC</a> â€¦</p></section>
</dd>
<dt><code class="name"><a title="scrapli.transport.socket" href="socket.html">scrapli.transport.socket</a></code></dt>
<dd>
<section class="desc"><p>scrapli.transport.socket</p></section>
</dd>
<dt><code class="name"><a title="scrapli.transport.systemssh" href="systemssh.html">scrapli.transport.systemssh</a></code></dt>
<dd>
<section class="desc"><p>scrapli.transport.systemssh</p></section>
</dd>
<dt><code class="name"><a title="scrapli.transport.telnet" href="telnet.html">scrapli.transport.telnet</a></code></dt>
<dd>
<section class="desc"><p>scrapli.transport.telnet</p></section>
</dd>
<dt><code class="name"><a title="scrapli.transport.transport" href="transport.html">scrapli.transport.transport</a></code></dt>
<dd>
<section class="desc"><p>scrapli.transport.transport</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.transport.MikoTransport"><code class="flex name class">
<span>class <span class="ident">MikoTransport</span></span>
<span>(</span><span>host, port=-1, auth_username='', auth_public_key='', auth_password='', auth_strict_key=True, timeout_socket=5, timeout_transport=5, timeout_exit=True, keepalive=False, keepalive_interval=30, keepalive_type='', keepalive_pattern='\x05', ssh_config_file='', ssh_known_hosts_file='')</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>MikoTransport Object</p>
<p>Inherit from Transport ABC
MikoTransport &lt;- Transport (ABC)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_public_key</code></strong></dt>
<dd>path to public key for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>True/False to enforce strict key checking (default is True)</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh transport in seconds</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' is not currently implemented w/ paramiko</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MissingDependencies</code></strong></dt>
<dd>if paramiko is not installed</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MikoTransport(Transport):
    def __init__(
        self,
        host: str,
        port: int = -1,
        auth_username: str = &#34;&#34;,
        auth_public_key: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_strict_key: bool = True,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        ssh_config_file: str = &#34;&#34;,
        ssh_known_hosts_file: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        MikoTransport Object

        Inherit from Transport ABC
        MikoTransport &lt;- Transport (ABC)

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_public_key: path to public key for authentication
            auth_password: password for authentication
            auth_strict_key: True/False to enforce strict key checking (default is True)
            timeout_socket: timeout for establishing socket in seconds
            timeout_transport: timeout for ssh transport in seconds
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; is not currently implemented w/ paramiko
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            ssh_config_file: string to path for ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file

        Returns:
            N/A  # noqa: DAR202

        Raises:
            MissingDependencies: if paramiko is not installed

        &#34;&#34;&#34;
        cfg_port, cfg_user, cfg_public_key = self._process_ssh_config(host, ssh_config_file)

        if port == -1:
            port = cfg_port or 22

        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )

        self.auth_username: str = auth_username or cfg_user
        self.auth_public_key: str = auth_public_key or cfg_public_key
        self.auth_password: str = auth_password
        self.auth_strict_key: bool = auth_strict_key
        self.ssh_known_hosts_file: str = ssh_known_hosts_file

        self.session_lock: Lock = Lock()

        try:
            # import here so these are optional
            from paramiko import Transport as pTransport  # pylint: disable=C0415
            from paramiko import Channel  # pylint: disable=C0415
            from paramiko.ssh_exception import (  # pylint: disable=C0415
                AuthenticationException,
                SSHException,
            )

            self.lib_session = pTransport
            self.session: pTransport = None
            self.channel: Channel = None
            self.lib_auth_exception = AuthenticationException
        except ModuleNotFoundError as exc:
            err = f&#34;Module &#39;{exc.name}&#39; not installed!&#34;
            msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
            fix = (
                f&#34;To resolve this issue, install &#39;{exc.name}&#39;. You can do this in one of the &#34;
                &#34;following ways:\n&#34;
                &#34;1: &#39;pip install -r requirements-paramiko.txt&#39;\n&#34;
                &#34;2: &#39;pip install scrapli[paramiko]&#39;&#34;
            )
            warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
            warnings.warn(warning)
            LOG.warning(warning)
            raise MissingDependencies

        self.socket = Socket(host=self.host, port=self.port, timeout=self.timeout_socket)

    @staticmethod
    def _process_ssh_config(host: str, ssh_config_file: str) -&gt; Tuple[Optional[int], str, str]:
        &#34;&#34;&#34;
        Method to parse ssh config file

        In the future this may move to be a &#39;helper&#39; function as it should be very similar between
        paramiko and and ssh2-python... for now it can be a static method as there may be varying
        supported args between the two transport drivers.

        Args:
            host: host to lookup in ssh config file
            ssh_config_file: string path to ssh config file; passed down from `Scrape`, or the
                `NetworkDriver` or subclasses of it, in most cases.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        ssh = SSHConfig(ssh_config_file)
        host_config = ssh.lookup(host)
        return host_config.port, host_config.user or &#34;&#34;, host_config.identity_file or &#34;&#34;

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to open session, authenticate and acquire shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if socket handshake fails
            ScrapliAuthenticationFailed: if all authentication means fail

        &#34;&#34;&#34;
        if not self.socket.socket_isalive():
            self.socket.socket_open()
        self.session_lock.acquire()
        try:
            self.session = self.lib_session(self.socket.sock)
            self.session.start_client()
        except Exception as exc:
            LOG.critical(
                f&#34;Failed to complete handshake with host {self.host}; &#34; f&#34;Exception: {exc}&#34;
            )
            raise exc

        if self.auth_strict_key:
            LOG.debug(f&#34;Attempting to validate {self.host} public key&#34;)
            self._verify_key()

        LOG.debug(f&#34;Session to host {self.host} opened&#34;)
        self.authenticate()
        if not self.isauthenticated():
            msg = f&#34;Authentication to host {self.host} failed&#34;
            LOG.critical(msg)
            raise ScrapliAuthenticationFailed(msg)
        self._open_channel()
        self.session_lock.release()

        if self.keepalive:
            self._session_keepalive()

    def _verify_key(self) -&gt; None:
        &#34;&#34;&#34;
        Verify target host public key, raise exception if invalid/unknown

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            KeyVerificationFailed: if host is not in known hosts
            KeyVerificationFailed: if host is in known hosts but public key does not match

        &#34;&#34;&#34;
        known_hosts = SSHKnownHosts(self.ssh_known_hosts_file)

        if self.host not in known_hosts.hosts.keys():
            raise KeyVerificationFailed(f&#34;{self.host} not in known_hosts!&#34;)

        remote_server_key = self.session.get_remote_server_key()
        remote_public_key = remote_server_key.get_base64()

        if known_hosts.hosts[self.host][&#34;public_key&#34;] != remote_public_key:
            raise KeyVerificationFailed(
                f&#34;{self.host} in known_hosts but public key does not match!&#34;
            )

    def authenticate(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to try all means of authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.auth_public_key:
            self._authenticate_public_key()
            if self.isauthenticated():
                LOG.debug(f&#34;Authenticated to host {self.host} with public key&#34;)
                return
        if self.auth_password:
            self._authenticate_password()
            if self.isauthenticated():
                LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
                return
        return

    def _authenticate_public_key(self) -&gt; None:
        &#34;&#34;&#34;
        Attempt to authenticate with public key authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            # paramiko wants to see its key in a PKey object when crafting the paramiko connection
            # from Transport and Channel objects
            from paramiko.rsakey import RSAKey  # pylint: disable=C0415

            paramiko_key = RSAKey(filename=self.auth_public_key)
            self.session.auth_publickey(self.auth_username, paramiko_key)
        except self.lib_auth_exception as exc:
            LOG.critical(
                f&#34;Public key authentication with host {self.host} failed. Exception: {exc}.&#34;
            )
        except Exception as exc:
            LOG.critical(
                &#34;Unknown error occurred during public key authentication with host &#34;
                f&#34;{self.host}; Exception: {exc}&#34;
            )
            raise exc

    def _authenticate_password(self) -&gt; None:
        &#34;&#34;&#34;
        Attempt to authenticate with password authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session.auth_password(self.auth_username, self.auth_password)
        except self.lib_auth_exception as exc:
            LOG.critical(
                f&#34;Password authentication with host {self.host} failed. Exception: {exc}.&#34;
                &#34;\n\tNote: Paramiko automatically attempts both standard auth as well as keyboard &#34;
                &#34;interactive auth. Paramiko exception about bad auth type may be misleading!&#34;
            )
        except Exception as exc:
            LOG.critical(
                &#34;Unknown error occurred during password authentication with host &#34;
                f&#34;{self.host}; Exception: {exc}&#34;
            )
            raise exc

    def isauthenticated(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        Args:
            N/A

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        authenticated: bool = self.session.is_authenticated()
        return authenticated

    def _open_channel(self) -&gt; None:
        &#34;&#34;&#34;
        Open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.channel = self.session.open_session()
        self.set_timeout(self.timeout_transport)
        self.channel.get_pty()
        self.channel.invoke_shell()
        LOG.debug(f&#34;Channel to host {self.host} opened&#34;)

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.channel.close()
        LOG.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.socket.socket_close()
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if socket is alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if socket is alive and session authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.socket.socket_isalive() and self.session.is_alive() and self.isauthenticated():
            return True
        return False

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes output as read from channel

        Raises:
            N/A

        &#34;&#34;&#34;
        channel_read: bytes = self.channel.recv(65535)
        return channel_read

    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.channel.send(channel_input)

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        self.channel.settimeout(set_timeout)

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#39;out of band&#39; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: always, because this is not implemented for telnet

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for telnet.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.MikoTransport.authenticate"><code class="name flex">
<span>def <span class="ident">authenticate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Parent method to try all means of authentication</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to try all means of authentication

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    if self.auth_public_key:
        self._authenticate_public_key()
        if self.isauthenticated():
            LOG.debug(f&#34;Authenticated to host {self.host} with public key&#34;)
            return
    if self.auth_password:
        self._authenticate_password()
        if self.isauthenticated():
            LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
            return
    return</code></pre>
</details>
</dd>
<dt id="scrapli.transport.MikoTransport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if socket is alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if socket is alive and session authenticated, else False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if socket is alive and session is authenticated

    Args:
        N/A

    Returns:
        bool: True if socket is alive and session authenticated, else False

    Raises:
        N/A

    &#34;&#34;&#34;
    if self.socket.socket_isalive() and self.session.is_alive() and self.isauthenticated():
        return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.MikoTransport.isauthenticated"><code class="name flex">
<span>def <span class="ident">isauthenticated</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if authenticated, else False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isauthenticated(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if session is authenticated

    Args:
        N/A

    Returns:
        bool: True if authenticated, else False

    Raises:
        N/A

    &#34;&#34;&#34;
    authenticated: bool = self.session.is_authenticated()
    return authenticated</code></pre>
</details>
</dd>
<dt id="scrapli.transport.MikoTransport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Parent method to open session, authenticate and acquire shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>exc</code></strong></dt>
<dd>if socket handshake fails</dd>
<dt><strong><code>ScrapliAuthenticationFailed</code></strong></dt>
<dd>if all authentication means fail</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to open session, authenticate and acquire shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        exc: if socket handshake fails
        ScrapliAuthenticationFailed: if all authentication means fail

    &#34;&#34;&#34;
    if not self.socket.socket_isalive():
        self.socket.socket_open()
    self.session_lock.acquire()
    try:
        self.session = self.lib_session(self.socket.sock)
        self.session.start_client()
    except Exception as exc:
        LOG.critical(
            f&#34;Failed to complete handshake with host {self.host}; &#34; f&#34;Exception: {exc}&#34;
        )
        raise exc

    if self.auth_strict_key:
        LOG.debug(f&#34;Attempting to validate {self.host} public key&#34;)
        self._verify_key()

    LOG.debug(f&#34;Session to host {self.host} opened&#34;)
    self.authenticate()
    if not self.isauthenticated():
        msg = f&#34;Authentication to host {self.host} failed&#34;
        LOG.critical(msg)
        raise ScrapliAuthenticationFailed(msg)
    self._open_channel()
    self.session_lock.release()

    if self.keepalive:
        self._session_keepalive()</code></pre>
</details>
</dd>
<dt id="scrapli.transport.MikoTransport.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Read data from the channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bytes</code></strong></dt>
<dd>bytes output as read from channel</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; bytes:
    &#34;&#34;&#34;
    Read data from the channel

    Args:
        N/A

    Returns:
        bytes: bytes output as read from channel

    Raises:
        N/A

    &#34;&#34;&#34;
    channel_read: bytes = self.channel.recv(65535)
    return channel_read</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="transport.html#scrapli.transport.transport.Transport.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_timeout" href="transport.html#scrapli.transport.transport.Transport.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.transport.SSH2Transport"><code class="flex name class">
<span>class <span class="ident">SSH2Transport</span></span>
<span>(</span><span>host, port=-1, auth_username='', auth_public_key='', auth_password='', auth_strict_key=True, timeout_socket=5, timeout_transport=5, timeout_exit=True, keepalive=False, keepalive_interval=30, keepalive_type='', keepalive_pattern='\x05', ssh_config_file='', ssh_known_hosts_file='')</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>SSH2Transport Object</p>
<p>Inherit from Transport ABC
SSH2Transport &lt;- Transport (ABC)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_public_key</code></strong></dt>
<dd>path to public key for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>True/False to enforce strict key checking (default is True)</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh2 transport in seconds</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' attempts to ssh2-python built in
keepalive method (using standard openssh keepalive)</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MissingDependencies</code></strong></dt>
<dd>if ssh2-python is not installed</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SSH2Transport(Transport):
    def __init__(
        self,
        host: str,
        port: int = -1,
        auth_username: str = &#34;&#34;,
        auth_public_key: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_strict_key: bool = True,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        ssh_config_file: str = &#34;&#34;,
        ssh_known_hosts_file: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        SSH2Transport Object

        Inherit from Transport ABC
        SSH2Transport &lt;- Transport (ABC)

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_public_key: path to public key for authentication
            auth_password: password for authentication
            auth_strict_key: True/False to enforce strict key checking (default is True)
            timeout_socket: timeout for establishing socket in seconds
            timeout_transport: timeout for ssh2 transport in seconds
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; attempts to ssh2-python built in
                keepalive method (using standard openssh keepalive)
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            ssh_config_file: string to path for ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file

        Returns:
            N/A  # noqa: DAR202

        Raises:
            MissingDependencies: if ssh2-python is not installed

        &#34;&#34;&#34;
        cfg_port, cfg_user, cfg_public_key = self._process_ssh_config(host, ssh_config_file)

        if port == -1:
            port = cfg_port or 22

        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )

        self.auth_username: str = auth_username or cfg_user
        self.auth_public_key: str = auth_public_key or cfg_public_key
        self.auth_password: str = auth_password
        self.auth_strict_key: bool = auth_strict_key
        self.ssh_known_hosts_file: str = ssh_known_hosts_file

        try:
            # import here so these are optional
            from ssh2.channel import Channel  # pylint: disable=C0415
            from ssh2.session import Session  # pylint: disable=C0415
            from ssh2.exceptions import AuthenticationError  # pylint: disable=C0415

            self.lib_session = Session
            self.session: Session = None
            self.channel: Channel = None
            self.lib_auth_exception = AuthenticationError
        except ModuleNotFoundError as exc:
            err = f&#34;Module &#39;{exc.name}&#39; not installed!&#34;
            msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
            fix = (
                f&#34;To resolve this issue, install &#39;{exc.name}&#39;. You can do this in one of the &#34;
                &#34;following ways:\n&#34;
                &#34;1: &#39;pip install -r requirements-ssh2.txt&#39;\n&#34;
                &#34;2: &#39;pip install scrapli[ssh2]&#39;&#34;
            )
            warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
            warnings.warn(warning)
            LOG.warning(warning)
            raise MissingDependencies

        self.socket = Socket(host=self.host, port=self.port, timeout=self.timeout_socket)

    @staticmethod
    def _process_ssh_config(host: str, ssh_config_file: str) -&gt; Tuple[Optional[int], str, str]:
        &#34;&#34;&#34;
        Method to parse ssh config file

        In the future this may move to be a &#34;helper&#34; function as it should be very similar between
        paramiko and and ssh2-python... for now it can be a static method as there may be varying
        supported args between the two transport drivers.

        Args:
            host: host to lookup in ssh config file
            ssh_config_file: string path to ssh config file; passed down from `Scrape`, or the
                `NetworkDriver` or subclasses of it, in most cases.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        ssh = SSHConfig(ssh_config_file)
        host_config = ssh.lookup(host)
        return host_config.port, host_config.user or &#34;&#34;, host_config.identity_file or &#34;&#34;

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to open session, authenticate and acquire shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if socket handshake fails
            ScrapliAuthenticationFailed: if all authentication means fail

        &#34;&#34;&#34;
        if not self.socket.socket_isalive():
            self.socket.socket_open()
        self.session_lock.acquire()
        self.session = self.lib_session()
        self.set_timeout(self.timeout_transport)
        try:
            self.session.handshake(self.socket.sock)
        except Exception as exc:
            LOG.critical(
                f&#34;Failed to complete handshake with host {self.host}; &#34; f&#34;Exception: {exc}&#34;
            )
            raise exc

        if self.auth_strict_key:
            LOG.debug(f&#34;Attempting to validate {self.host} public key&#34;)
            self._verify_key()

        LOG.debug(f&#34;Session to host {self.host} opened&#34;)
        self.authenticate()
        if not self.isauthenticated():
            msg = f&#34;Authentication to host {self.host} failed&#34;
            LOG.critical(msg)
            raise ScrapliAuthenticationFailed(msg)
        self._open_channel()
        if self.keepalive:
            self._session_keepalive()
        self.session_lock.release()

    def _verify_key(self) -&gt; None:
        &#34;&#34;&#34;
        Verify target host public key, raise exception if invalid/unknown

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            KeyVerificationFailed: if public key verification fails

        &#34;&#34;&#34;
        known_hosts = SSHKnownHosts(self.ssh_known_hosts_file)

        if self.host not in known_hosts.hosts.keys():
            raise KeyVerificationFailed(f&#34;{self.host} not in known_hosts!&#34;)

        remote_server_key_info = self.session.hostkey()
        encoded_remote_server_key = remote_server_key_info[0]
        raw_remote_public_key = base64.encodebytes(encoded_remote_server_key)
        remote_public_key = raw_remote_public_key.replace(b&#34;\n&#34;, b&#34;&#34;).decode()

        if known_hosts.hosts[self.host][&#34;public_key&#34;] != remote_public_key:
            raise KeyVerificationFailed(
                f&#34;{self.host} in known_hosts but public key does not match!&#34;
            )

    def authenticate(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to try all means of authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.auth_public_key:
            self._authenticate_public_key()
            if self.isauthenticated():
                LOG.debug(f&#34;Authenticated to host {self.host} with public key&#34;)
                return
        if self.auth_password:
            self._authenticate_password()
            if self.isauthenticated():
                LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
                return
            self._authenticate_keyboard_interactive()
            if self.isauthenticated():
                LOG.debug(f&#34;Authenticated to host {self.host} with keyboard interactive&#34;)
                return
        return

    def _authenticate_public_key(self) -&gt; None:
        &#34;&#34;&#34;
        Attempt to authenticate with public key authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session.userauth_publickey_fromfile(self.auth_username, self.auth_public_key)
        except self.lib_auth_exception as exc:
            LOG.critical(
                f&#34;Public key authentication with host {self.host} failed. Exception: {exc}.&#34;
            )
        except Exception as exc:
            LOG.critical(
                &#34;Unknown error occurred during public key authentication with host &#34;
                f&#34;{self.host}; Exception: {exc}&#34;
            )
            raise exc

    def _authenticate_password(self) -&gt; None:
        &#34;&#34;&#34;
        Attempt to authenticate with password authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session.userauth_password(self.auth_username, self.auth_password)
        except self.lib_auth_exception as exc:
            LOG.critical(f&#34;Password authentication with host {self.host} failed. Exception: {exc}.&#34;)
        except Exception as exc:
            LOG.critical(
                &#34;Unknown error occurred during password authentication with host &#34;
                f&#34;{self.host}; Exception: {exc}&#34;
            )
            raise exc

    def _authenticate_keyboard_interactive(self) -&gt; None:
        &#34;&#34;&#34;
        Attempt to authenticate with keyboard interactive authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session.userauth_keyboardinteractive(  # pylint: disable=C0415
                self.auth_username, self.auth_password
            )
        except AttributeError as exc:
            LOG.critical(
                &#34;Keyboard interactive authentication not supported in your ssh2-python version. &#34;
                f&#34;Exception: {exc}&#34;
            )
        except self.lib_auth_exception as exc:
            LOG.critical(
                f&#34;Keyboard interactive authentication with host {self.host} failed. &#34;
                f&#34;Exception: {exc}.&#34;
            )
        except Exception as exc:
            LOG.critical(
                &#34;Unknown error occurred during keyboard interactive authentication with host &#34;
                f&#34;{self.host}; Exception: {exc}&#34;
            )
            raise exc

    def isauthenticated(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        Args:
            N/A

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        authenticated: bool = self.session.userauth_authenticated()
        return authenticated

    def _open_channel(self) -&gt; None:
        &#34;&#34;&#34;
        Open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.channel = self.session.open_session()
        self.channel.pty()
        self.channel.shell()
        LOG.debug(f&#34;Channel to host {self.host} opened&#34;)

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.channel.close()
        LOG.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.socket.socket_close()
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if socket is alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if socket is alive and session authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.socket.socket_isalive() and not self.channel.eof() and self.isauthenticated():
            return True
        return False

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes output as read from channel

        Raises:
            N/A

        &#34;&#34;&#34;
        output: bytes
        _, output = self.channel.read(65535)
        return output

    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.channel.write(channel_input)

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        # ssh2-python expects timeout in milliseconds
        self.session.set_timeout(set_timeout * 1000)

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.keepalive_config(want_reply=False, interval=self.keepalive_interval)
        while True:
            if not self.isalive():
                return
            LOG.debug(&#34;Sending &#39;standard&#39; keepalive.&#34;)
            self.session.keepalive_send()
            time.sleep(self.keepalive_interval / 10)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.SSH2Transport.authenticate"><code class="name flex">
<span>def <span class="ident">authenticate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Parent method to try all means of authentication</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to try all means of authentication

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    if self.auth_public_key:
        self._authenticate_public_key()
        if self.isauthenticated():
            LOG.debug(f&#34;Authenticated to host {self.host} with public key&#34;)
            return
    if self.auth_password:
        self._authenticate_password()
        if self.isauthenticated():
            LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
            return
        self._authenticate_keyboard_interactive()
        if self.isauthenticated():
            LOG.debug(f&#34;Authenticated to host {self.host} with keyboard interactive&#34;)
            return
    return</code></pre>
</details>
</dd>
<dt id="scrapli.transport.SSH2Transport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if socket is alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if socket is alive and session authenticated, else False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if socket is alive and session is authenticated

    Args:
        N/A

    Returns:
        bool: True if socket is alive and session authenticated, else False

    Raises:
        N/A

    &#34;&#34;&#34;
    if self.socket.socket_isalive() and not self.channel.eof() and self.isauthenticated():
        return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.SSH2Transport.isauthenticated"><code class="name flex">
<span>def <span class="ident">isauthenticated</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if authenticated, else False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isauthenticated(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if session is authenticated

    Args:
        N/A

    Returns:
        bool: True if authenticated, else False

    Raises:
        N/A

    &#34;&#34;&#34;
    authenticated: bool = self.session.userauth_authenticated()
    return authenticated</code></pre>
</details>
</dd>
<dt id="scrapli.transport.SSH2Transport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Parent method to open session, authenticate and acquire shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>exc</code></strong></dt>
<dd>if socket handshake fails</dd>
<dt><strong><code>ScrapliAuthenticationFailed</code></strong></dt>
<dd>if all authentication means fail</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to open session, authenticate and acquire shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        exc: if socket handshake fails
        ScrapliAuthenticationFailed: if all authentication means fail

    &#34;&#34;&#34;
    if not self.socket.socket_isalive():
        self.socket.socket_open()
    self.session_lock.acquire()
    self.session = self.lib_session()
    self.set_timeout(self.timeout_transport)
    try:
        self.session.handshake(self.socket.sock)
    except Exception as exc:
        LOG.critical(
            f&#34;Failed to complete handshake with host {self.host}; &#34; f&#34;Exception: {exc}&#34;
        )
        raise exc

    if self.auth_strict_key:
        LOG.debug(f&#34;Attempting to validate {self.host} public key&#34;)
        self._verify_key()

    LOG.debug(f&#34;Session to host {self.host} opened&#34;)
    self.authenticate()
    if not self.isauthenticated():
        msg = f&#34;Authentication to host {self.host} failed&#34;
        LOG.critical(msg)
        raise ScrapliAuthenticationFailed(msg)
    self._open_channel()
    if self.keepalive:
        self._session_keepalive()
    self.session_lock.release()</code></pre>
</details>
</dd>
<dt id="scrapli.transport.SSH2Transport.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Read data from the channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bytes</code></strong></dt>
<dd>bytes output as read from channel</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; bytes:
    &#34;&#34;&#34;
    Read data from the channel

    Args:
        N/A

    Returns:
        bytes: bytes output as read from channel

    Raises:
        N/A

    &#34;&#34;&#34;
    output: bytes
    _, output = self.channel.read(65535)
    return output</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="transport.html#scrapli.transport.transport.Transport.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_timeout" href="transport.html#scrapli.transport.transport.Transport.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.transport.SystemSSHTransport"><code class="flex name class">
<span>class <span class="ident">SystemSSHTransport</span></span>
<span>(</span><span>host='', port=22, auth_username='', auth_public_key='', auth_password='', auth_strict_key=True, timeout_socket=5, timeout_transport=5, timeout_ops=10, timeout_exit=True, keepalive=False, keepalive_interval=30, keepalive_type='', keepalive_pattern='\x05', comms_prompt_pattern=&#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$&#x27;, comms_return_char='\n', comms_ansi=False, ssh_config_file='', ssh_known_hosts_file='')</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>SystemSSHTransport Object</p>
<p>Inherit from Transport ABC
SSH2Transport &lt;- Transport (ABC)</p>
<p>If using this driver, and passing a ssh_config_file (or setting this argument to <code>True</code>),
all settings in the ssh config file will be superseded by any arguments passed here!</p>
<p>SystemSSHTransport <em>always</em> prefers public key auth if given the option! If auth_public_key
is set in the provided arguments OR if ssh_config_file is passed/True and there is a key for
ANY match (i.e. <code>*</code> has a key in ssh config file!!), we will use that key! If public key
auth fails and a username and password is set (manually or by ssh config file), password
auth will be attempted.</p>
<p>Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
handle "in channel" authentication required by SystemSSH &ndash; these are assigned to private
attributes in this class and ignored after authentication. If you wish to modify these
values on a "live" scrapli connection, modify them in the Channel object, i.e.
<code>conn.channel.comms_prompt_pattern</code>. Additionally timeout_ops is passed and assigned to
_timeout_ops to use the same timeout_ops that is used in Channel to decorate the
authentication methods here.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_public_key</code></strong></dt>
<dd>path to public key for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>True/False to enforce strict key checking (default is True)</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for ssh session to start &ndash; this directly maps to ConnectTimeout
ssh argument; see <code>man ssh_config</code></dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for transport in seconds. since system ssh is using popen/pty
we can't really set a timeout directly, so this value governs the time timeout
decorator for the transport read and write methods</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for telnet channel operations in seconds &ndash; this is also the
timeout for finding and responding to username and password prompts at initial
login. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' is not currently implemented for
system ssh</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>prompt pattern expected for device, same as the one provided to
channel &ndash; system ssh needs to know this to know how to decide if we are properly
sending/receiving data &ndash; i.e. we are not stuck at some password prompt or some
other failure scenario. If using driver, this should be passed from driver (Scrape,
or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
is ignored after authentication is completed.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>return character to use on the channel, same as the one provided to
channel &ndash; system ssh needs to know this to know what to send so that we can probe
the channel to make sure we are authenticated and sending/receiving data. If using
driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
class. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; this value is assigned
self._comms_ansi and is ignored after authentication. We only need it for transport
on the off chance (maybe never?) that username/password prompts contain ansi
characters, otherwise "comms_ansi" is really a channel attribute and is treated as
such. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SystemSSHTransport(Transport):
    def __init__(
        self,
        host: str = &#34;&#34;,
        port: int = 22,
        auth_username: str = &#34;&#34;,
        auth_public_key: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_strict_key: bool = True,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_ops: int = 10,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
        ssh_config_file: str = &#34;&#34;,
        ssh_known_hosts_file: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        SystemSSHTransport Object

        Inherit from Transport ABC
        SSH2Transport &lt;- Transport (ABC)

        If using this driver, and passing a ssh_config_file (or setting this argument to `True`),
        all settings in the ssh config file will be superseded by any arguments passed here!

        SystemSSHTransport *always* prefers public key auth if given the option! If auth_public_key
        is set in the provided arguments OR if ssh_config_file is passed/True and there is a key for
        ANY match (i.e. `*` has a key in ssh config file!!), we will use that key! If public key
        auth fails and a username and password is set (manually or by ssh config file), password
        auth will be attempted.

        Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
        handle &#34;in channel&#34; authentication required by SystemSSH -- these are assigned to private
        attributes in this class and ignored after authentication. If you wish to modify these
        values on a &#34;live&#34; scrapli connection, modify them in the Channel object, i.e.
        `conn.channel.comms_prompt_pattern`. Additionally timeout_ops is passed and assigned to
        _timeout_ops to use the same timeout_ops that is used in Channel to decorate the
        authentication methods here.

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_public_key: path to public key for authentication
            auth_password: password for authentication
            auth_strict_key: True/False to enforce strict key checking (default is True)
            timeout_socket: timeout for ssh session to start -- this directly maps to ConnectTimeout
                ssh argument; see `man ssh_config`
            timeout_transport: timeout for transport in seconds. since system ssh is using popen/pty
                we can&#39;t really set a timeout directly, so this value governs the time timeout
                decorator for the transport read and write methods
            timeout_ops: timeout for telnet channel operations in seconds -- this is also the
                timeout for finding and responding to username and password prompts at initial
                login. This is assigned to a private attribute and is ignored after authentication
                is completed.
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; is not currently implemented for
                system ssh
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- system ssh needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
                is ignored after authentication is completed.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- system ssh needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class. This is assigned to a private attribute and is ignored after authentication
                is completed.
            comms_ansi: True/False strip comms_ansi characters from output; this value is assigned
                self._comms_ansi and is ignored after authentication. We only need it for transport
                on the off chance (maybe never?) that username/password prompts contain ansi
                characters, otherwise &#34;comms_ansi&#34; is really a channel attribute and is treated as
                such. This is assigned to a private attribute and is ignored after authentication
                is completed.
            ssh_config_file: string to path for ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )

        self.auth_username: str = auth_username
        self.auth_public_key: str = auth_public_key
        self.auth_password: str = auth_password
        self.auth_strict_key: bool = auth_strict_key

        self._timeout_ops: int = timeout_ops
        self._comms_prompt_pattern: str = comms_prompt_pattern
        self._comms_return_char: str = comms_return_char
        self._comms_ansi: bool = comms_ansi
        self._process_ssh_config(ssh_config_file)
        self.ssh_known_hosts_file: str = ssh_known_hosts_file

        self.session: Union[Popen[bytes], PtyProcess]  # pylint: disable=E1136
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

        self.open_cmd = [&#34;ssh&#34;, self.host]
        self._build_open_cmd()

    def _process_ssh_config(self, ssh_config_file: str) -&gt; None:
        &#34;&#34;&#34;
        Method to parse ssh config file

        Ensure ssh_config_file is valid (if providing a string path to config file), or resolve
        config file if passed True. Search config file for any public key, if ANY matching key is
        found and user has not provided a public key, set `auth_public_key` to the value of the
        found key. This is because we prefer to use `open_pipes` over `open_pty`!

        Args:
            ssh_config_file: string path to ssh config file; passed down from `Scrape`, or the
                `NetworkDriver` or subclasses of it, in most cases.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        ssh = SSHConfig(ssh_config_file)
        self.ssh_config_file = ssh.ssh_config_file
        host_config = ssh.lookup(self.host)
        if not self.auth_public_key and host_config.identity_file:
            self.auth_public_key = os.path.expanduser(host_config.identity_file.strip())

    def _build_open_cmd(self) -&gt; None:
        &#34;&#34;&#34;
        Method to craft command to open ssh session

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.open_cmd.extend([&#34;-p&#34;, str(self.port)])
        self.open_cmd.extend([&#34;-o&#34;, f&#34;ConnectTimeout={self.timeout_socket}&#34;])
        if self.auth_public_key:
            self.open_cmd.extend([&#34;-i&#34;, self.auth_public_key])
        if self.auth_username:
            self.open_cmd.extend([&#34;-l&#34;, self.auth_username])
        if self.auth_strict_key is False:
            self.open_cmd.extend([&#34;-o&#34;, &#34;StrictHostKeyChecking=no&#34;])
            self.open_cmd.extend([&#34;-o&#34;, &#34;UserKnownHostsFile=/dev/null&#34;])
        else:
            self.open_cmd.extend([&#34;-o&#34;, &#34;StrictHostKeyChecking=yes&#34;])
            if self.ssh_known_hosts_file:
                self.open_cmd.extend([&#34;-o&#34;, f&#34;UserKnownHostsFile={self.ssh_known_hosts_file}&#34;])
        if self.ssh_config_file:
            self.open_cmd.extend([&#34;-F&#34;, self.ssh_config_file])
        else:
            self.open_cmd.extend([&#34;-F&#34;, &#34;/dev/null&#34;])

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to open session, authenticate and acquire shell

        If possible it is preferable to use the `_open_pipes` method, but we can only do this IF we
        can authenticate with public key authorization (because we don&#39;t have to spawn a PTY; if no
        public key we have to spawn PTY to deal w/ authentication prompts). IF we get a public key
        provided, use pipes method, we will just deal with `_open_pty`. `_open_pty` is less
        preferable because we have to spawn a PTY and cannot as easily tell if SSH authentication is
        successful. With `_open_pipes` we can read stderr which contains the output from the verbose
        flag for SSH -- this contains a message that indicates success of SSH auth. In the case of
        `_open_pty` we have to read from the channel directly like in the case of telnet... so it
        works, but its just a bit less desirable.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if all authentication means fail

        &#34;&#34;&#34;
        self.session_lock.acquire()

        # If authenticating with public key prefer to use open pipes
        # _open_pipes uses subprocess Popen which is preferable to opening a pty
        # if _open_pipes fails and no password available, raise failure, otherwise try password auth
        if self.auth_public_key:
            open_pipes_result = self._open_pipes()
            if open_pipes_result:
                return
            if not open_pipes_result and (not self.auth_password or not self.auth_username):
                msg = f&#34;Authentication to host {self.host} failed&#34;
                LOG.critical(msg)
                raise ScrapliAuthenticationFailed(msg)

        # If public key auth fails or is not configured, open a pty session
        if not self._open_pty():
            msg = f&#34;Authentication to host {self.host} failed&#34;
            LOG.critical(msg)
            raise ScrapliAuthenticationFailed(msg)

        if self.keepalive:
            self._session_keepalive()

    def _open_pipes(self) -&gt; bool:
        &#34;&#34;&#34;
        Private method to open session with subprocess.Popen

        Args:
            N/A

        Returns:
            bool: True/False session was opened and authenticated

        Raises:
            N/A

        &#34;&#34;&#34;
        # copy the open_cmd as we don&#39;t want to update the objects open_cmd until we know we can
        # authenticate. add verbose output and disable batch mode (disables passphrase/password
        # queries). If auth is successful update the object open_cmd to represent what was used
        open_cmd = self.open_cmd.copy()
        open_cmd.append(&#34;-v&#34;)
        open_cmd.extend([&#34;-o&#34;, &#34;BatchMode=yes&#34;])

        self.session = Popen(open_cmd, bufsize=0, shell=False, stdin=PIPE, stdout=PIPE, stderr=PIPE)
        LOG.debug(f&#34;Session to host {self.host} spawned&#34;)

        try:
            self._pipes_isauthenticated(self.session)
        except TimeoutError:
            # If auth fails, kill the popen session
            self.session.kill()
            return False

        LOG.debug(f&#34;Authenticated to host {self.host} with public key&#34;)
        self.open_cmd = open_cmd
        self.session_lock.release()
        return True

    @operation_timeout(&#34;_timeout_ops&#34;, &#34;Timed out determining if session is authenticated&#34;)
    def _pipes_isauthenticated(self, pipes_session: &#34;PopenBytes&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Private method to check initial authentication when using subprocess.Popen

        Since we always run ssh with `-v` we can simply check the stderr (where verbose output goes)
        to see if `Authenticated to [our host]` is in the output.

        Args:
            pipes_session: Popen pipes session object

        Returns:
            bool: True/False session was authenticated

        Raises:
            N/A

        &#34;&#34;&#34;
        output = b&#34;&#34;
        while True:
            output += pipes_session.stderr.read(1024)
            if f&#34;Authenticated to {self.host}&#34;.encode() in output:
                self._isauthenticated = True
                return True

    def _open_pty(self) -&gt; bool:
        &#34;&#34;&#34;
        Private method to open session with PtyProcess

        Args:
            N/A

        Returns:
            bool: True/False session was opened and authenticated

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session = PtyProcess.spawn(self.open_cmd)
        LOG.debug(f&#34;Session to host {self.host} spawned&#34;)
        self.session_lock.release()
        self._pty_authenticate(self.session)
        if not self._pty_isauthenticated(self.session):
            return False
        LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
        return True

    @operation_timeout(&#34;_timeout_ops&#34;, &#34;Timed out looking for SSH login password prompt&#34;)
    def _pty_authenticate(self, pty_session: PtyProcess) -&gt; None:
        &#34;&#34;&#34;
        Private method to check initial authentication when using pty_session

        Args:
            pty_session: PtyProcess session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if we receive an EOFError -- this usually indicates that
                host key checking is enabled and failed.

        &#34;&#34;&#34;
        self.session_lock.acquire()
        while True:
            try:
                output = pty_session.read()
            except EOFError:
                raise ScrapliAuthenticationFailed(
                    &#34;PTY Authentication failed to find password prompt, often this means strict &#34;
                    &#34;host key checking is enabled and is failing!&#34;
                )
            if self._comms_ansi:
                output = strip_ansi(output)
            if b&#34;WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!&#34; in output:
                raise ScrapliAuthenticationFailed(
                    &#34;PTY Authentication failed! It looks like the remote host identification has&#34;
                    &#34;changed. Fix this or disable `auth_strict_key` or pass a &#34;
                    &#34;`ssh_known_hosts_file` containing the hosts identification.&#34;
                )
            if b&#34;password&#34; in output.lower():
                LOG.debug(&#34;Found password prompt, sending password&#34;)
                pty_session.write(self.auth_password.encode())
                pty_session.write(self._comms_return_char.encode())
                self.session_lock.release()
                break

    @operation_timeout(&#34;_timeout_ops&#34;, &#34;Timed out determining if session is authenticated&#34;)
    def _pty_isauthenticated(self, pty_session: PtyProcess) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the sub process is alive and has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            pty_session: PtyProcess session object

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if pty_session.isalive() and not pty_session.eof():
            prompt_pattern = get_prompt_pattern(&#34;&#34;, self._comms_prompt_pattern)
            self.session_lock.acquire()
            pty_session.write(self._comms_return_char.encode())
            fd_ready, _, _ = select([pty_session.fd], [], [], 0)
            if pty_session.fd in fd_ready:
                output = b&#34;&#34;
                while True:
                    output += pty_session.read()
                    # we do not need to deal w/ line replacement for the actual output, only for
                    # parsing if a prompt-like thing is at the end of the output
                    output = re.sub(b&#34;\r&#34;, b&#34;&#34;, output)
                    if self._comms_ansi:
                        output = strip_ansi(output)
                    channel_match = re.search(prompt_pattern, output)
                    if channel_match:
                        self.session_lock.release()
                        self._isauthenticated = True
                        return True
        self.session_lock.release()
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        if isinstance(self.session, Popen):
            self.session.kill()
        elif isinstance(self.session, PtyProcess):
            self.session.kill(1)
        LOG.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if session is alive and session authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(self.session, Popen):
            if self.session.poll() is None and self._isauthenticated:
                return True
        elif isinstance(self.session, PtyProcess):
            if self.session.isalive() and self._isauthenticated and not self.session.eof():
                return True
        return False

    @operation_timeout(&#34;timeout_transport&#34;, &#34;Transport timeout during read operation.&#34;)
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes output as read from channel

        Raises:
            N/A

        &#34;&#34;&#34;
        read_bytes = 65535
        if isinstance(self.session, Popen):
            return self.session.stdout.read(read_bytes)
        if isinstance(self.session, PtyProcess):
            return self.session.read(read_bytes)
        return b&#34;&#34;

    @operation_timeout(&#34;timeout_transport&#34;, &#34;Transport timeout during write operation.&#34;)
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(self.session, Popen):
            self.session.stdin.write(channel_input.encode())
        elif isinstance(self.session, PtyProcess):
            self.session.write(channel_input.encode())

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Note that this modifies the objects `timeout_transport` value directly as this value is
        what controls the timeout decorator for read/write methods. This is slightly different
        behavior from ssh2/paramiko/telnet in that those transports modify the session value and
        leave the objects `timeout_transport` alone.

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        self.timeout_transport = set_timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: always, because this is not implemented for telnet

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for telnet.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.SystemSSHTransport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if session is alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if session is alive and session authenticated, else False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if session is alive and session is authenticated

    Args:
        N/A

    Returns:
        bool: True if session is alive and session authenticated, else False

    Raises:
        N/A

    &#34;&#34;&#34;
    if isinstance(self.session, Popen):
        if self.session.poll() is None and self._isauthenticated:
            return True
    elif isinstance(self.session, PtyProcess):
        if self.session.isalive() and self._isauthenticated and not self.session.eof():
            return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.SystemSSHTransport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Parent method to open session, authenticate and acquire shell</p>
<p>If possible it is preferable to use the <code>_open_pipes</code> method, but we can only do this IF we
can authenticate with public key authorization (because we don't have to spawn a PTY; if no
public key we have to spawn PTY to deal w/ authentication prompts). IF we get a public key
provided, use pipes method, we will just deal with <code>_open_pty</code>. <code>_open_pty</code> is less
preferable because we have to spawn a PTY and cannot as easily tell if SSH authentication is
successful. With <code>_open_pipes</code> we can read stderr which contains the output from the verbose
flag for SSH &ndash; this contains a message that indicates success of SSH auth. In the case of
<code>_open_pty</code> we have to read from the channel directly like in the case of telnet&hellip; so it
works, but its just a bit less desirable.</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ScrapliAuthenticationFailed</code></strong></dt>
<dd>if all authentication means fail</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to open session, authenticate and acquire shell

    If possible it is preferable to use the `_open_pipes` method, but we can only do this IF we
    can authenticate with public key authorization (because we don&#39;t have to spawn a PTY; if no
    public key we have to spawn PTY to deal w/ authentication prompts). IF we get a public key
    provided, use pipes method, we will just deal with `_open_pty`. `_open_pty` is less
    preferable because we have to spawn a PTY and cannot as easily tell if SSH authentication is
    successful. With `_open_pipes` we can read stderr which contains the output from the verbose
    flag for SSH -- this contains a message that indicates success of SSH auth. In the case of
    `_open_pty` we have to read from the channel directly like in the case of telnet... so it
    works, but its just a bit less desirable.

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        ScrapliAuthenticationFailed: if all authentication means fail

    &#34;&#34;&#34;
    self.session_lock.acquire()

    # If authenticating with public key prefer to use open pipes
    # _open_pipes uses subprocess Popen which is preferable to opening a pty
    # if _open_pipes fails and no password available, raise failure, otherwise try password auth
    if self.auth_public_key:
        open_pipes_result = self._open_pipes()
        if open_pipes_result:
            return
        if not open_pipes_result and (not self.auth_password or not self.auth_username):
            msg = f&#34;Authentication to host {self.host} failed&#34;
            LOG.critical(msg)
            raise ScrapliAuthenticationFailed(msg)

    # If public key auth fails or is not configured, open a pty session
    if not self._open_pty():
        msg = f&#34;Authentication to host {self.host} failed&#34;
        LOG.critical(msg)
        raise ScrapliAuthenticationFailed(msg)

    if self.keepalive:
        self._session_keepalive()</code></pre>
</details>
</dd>
<dt id="scrapli.transport.SystemSSHTransport.set_timeout"><code class="name flex">
<span>def <span class="ident">set_timeout</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Set session timeout</p>
<p>Note that this modifies the objects <code>timeout_transport</code> value directly as this value is
what controls the timeout decorator for read/write methods. This is slightly different
behavior from ssh2/paramiko/telnet in that those transports modify the session value and
leave the objects <code>timeout_transport</code> alone.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Set session timeout

    Note that this modifies the objects `timeout_transport` value directly as this value is
    what controls the timeout decorator for read/write methods. This is slightly different
    behavior from ssh2/paramiko/telnet in that those transports modify the session value and
    leave the objects `timeout_transport` alone.

    Args:
        timeout: timeout in seconds

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    if isinstance(timeout, int):
        set_timeout = timeout
    else:
        set_timeout = self.timeout_transport
    self.timeout_transport = set_timeout</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="transport.html#scrapli.transport.transport.Transport.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.read" href="transport.html#scrapli.transport.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.transport.TelnetTransport"><code class="flex name class">
<span>class <span class="ident">TelnetTransport</span></span>
<span>(</span><span>host, port=23, auth_username='', auth_password='', timeout_socket=5, timeout_transport=5, timeout_ops=10, timeout_exit=True, keepalive=False, keepalive_interval=30, keepalive_type='', keepalive_pattern='\x05', comms_prompt_pattern=&#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$&#x27;, comms_return_char='\n', comms_ansi=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>TelnetTransport Object</p>
<p>Inherit from Transport ABC
TelnetTransport &lt;- Transport (ABC)</p>
<p>Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
handle "in channel" authentication required by SystemSSH &ndash; these are assigned to private
attributes in this class and ignored after authentication. If you wish to modify these
values on a "live" scrapli connection, modify them in the Channel object, i.e.
<code>conn.channel.comms_prompt_pattern</code>. Additionally timeout_ops is passed and assigned to
_timeout_ops to use the same timeout_ops that is used in Channel to decorate the
authentication methods here.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds &ndash; since this is not directly
exposed in telnetlib, this is just the initial timeout for the telnet connection.
After the connection is established, the timeout is modified to the value of
<code>timeout_transport</code>.</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for telnet channel operations in seconds &ndash; this is also the
timeout for finding and responding to username and password prompts at initial
login. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
"standard" keepalive mechanisms. 'standard' is not currently implemented for telnet</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>prompt pattern expected for device, same as the one provided to
channel &ndash; telnet needs to know this to know how to decide if we are properly
sending/receiving data &ndash; i.e. we are not stuck at some password prompt or some
other failure scenario. If using driver, this should be passed from driver (Scrape,
or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
is ignored after authentication is completed.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>return character to use on the channel, same as the one provided to
channel &ndash; telnet needs to know this to know what to send so that we can probe
the channel to make sure we are authenticated and sending/receiving data. If using
driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
class. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; this value is assigned
self._comms_ansi and is ignored after authentication. We only need it for transport
on the off chance (maybe never, especially here in telnet land?) that
username/password prompts contain ansi characters, otherwise "comms_ansi" is really
a channel attribute and is treated as such. This is assigned to a private attribute
and is ignored after authentication is completed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TelnetTransport(Transport):
    def __init__(
        self,
        host: str,
        port: int = 23,
        auth_username: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_ops: int = 10,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;
        TelnetTransport Object

        Inherit from Transport ABC
        TelnetTransport &lt;- Transport (ABC)

        Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
        handle &#34;in channel&#34; authentication required by SystemSSH -- these are assigned to private
        attributes in this class and ignored after authentication. If you wish to modify these
        values on a &#34;live&#34; scrapli connection, modify them in the Channel object, i.e.
        `conn.channel.comms_prompt_pattern`. Additionally timeout_ops is passed and assigned to
        _timeout_ops to use the same timeout_ops that is used in Channel to decorate the
        authentication methods here.

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_password: password for authentication
            timeout_socket: timeout for establishing socket in seconds -- since this is not directly
                exposed in telnetlib, this is just the initial timeout for the telnet connection.
                After the connection is established, the timeout is modified to the value of
                `timeout_transport`.
            timeout_transport: timeout for telnet transport in seconds
            timeout_ops: timeout for telnet channel operations in seconds -- this is also the
                timeout for finding and responding to username and password prompts at initial
                login. This is assigned to a private attribute and is ignored after authentication
                is completed.
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#34;standard&#34; keepalive mechanisms. &#39;standard&#39; is not currently implemented for telnet
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- telnet needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
                is ignored after authentication is completed.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- telnet needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class. This is assigned to a private attribute and is ignored after authentication
                is completed.
            comms_ansi: True/False strip comms_ansi characters from output; this value is assigned
                self._comms_ansi and is ignored after authentication. We only need it for transport
                on the off chance (maybe never, especially here in telnet land?) that
                username/password prompts contain ansi characters, otherwise &#34;comms_ansi&#34; is really
                a channel attribute and is treated as such. This is assigned to a private attribute
                and is ignored after authentication is completed.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )
        self.auth_username: str = auth_username
        self.auth_password: str = auth_password

        self._timeout_ops: int = timeout_ops
        self._comms_prompt_pattern: str = comms_prompt_pattern
        self._comms_return_char: str = comms_return_char
        self._comms_ansi: bool = comms_ansi

        self.username_prompt: str = &#34;Username:&#34;
        self.password_prompt: str = &#34;Password:&#34;

        self.session: ScrapliTelnet
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if cant successfully authenticate

        &#34;&#34;&#34;
        self.session_lock.acquire()
        # establish session with &#34;socket&#34; timeout, then reset timeout to &#34;transport&#34; timeout
        telnet_session = ScrapliTelnet(host=self.host, port=self.port, timeout=self.timeout_socket)
        telnet_session.timeout = self.timeout_transport
        LOG.debug(f&#34;Session to host {self.host} spawned&#34;)
        self.session_lock.release()
        self._authenticate(telnet_session)
        if not self._telnet_isauthenticated(telnet_session):
            raise ScrapliAuthenticationFailed(
                f&#34;Could not authenticate over telnet to host: {self.host}&#34;
            )
        LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
        self.session = telnet_session

    def _authenticate(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Parent private method to handle telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._authenticate_username(telnet_session)
        self._authenticate_password(telnet_session)

    @operation_timeout(&#34;_timeout_ops&#34;, &#34;Timed out looking for telnet login username prompt&#34;)
    def _authenticate_username(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Private method to enter username for telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        while True:
            output = telnet_session.read_eager()
            if self.username_prompt.lower().encode() in output.lower():
                telnet_session.write(self.auth_username.encode())
                telnet_session.write(self._comms_return_char.encode())
                self.session_lock.release()
                break

    @operation_timeout(&#34;timeout_ops&#34;, &#34;Timed out looking for telnet login password prompt&#34;)
    def _authenticate_password(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Private method to enter password for telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        while True:
            output = telnet_session.read_eager()
            if self.password_prompt.lower().encode() in output.lower():
                telnet_session.write(self.auth_password.encode())
                telnet_session.write(self._comms_return_char.encode())
                self.session_lock.release()
                break

    def _telnet_isauthenticated(self, telnet_session: ScrapliTelnet) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the sub process is alive and has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            telnet_session: Telnet session object

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if not telnet_session.eof:
            prompt_pattern = get_prompt_pattern(&#34;&#34;, self._comms_prompt_pattern)
            telnet_session_fd = telnet_session.fileno()
            self.session_lock.acquire()
            telnet_session.write(self._comms_return_char.encode())
            time.sleep(0.25)
            fd_ready, _, _ = select([telnet_session_fd], [], [], 0)
            if telnet_session_fd in fd_ready:
                output = telnet_session.read_eager()
                # we do not need to deal w/ line replacement for the actual output, only for
                # parsing if a prompt-like thing is at the end of the output
                output = re.sub(b&#34;\r&#34;, b&#34;&#34;, output)
                if self._comms_ansi:
                    output = strip_ansi(output)
                channel_match = re.search(prompt_pattern, output)
                if channel_match:
                    self.session_lock.release()
                    self._isauthenticated = True
                    return True
        self.session_lock.release()
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        LOG.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if alive and session is authenticated

        Args:
            N/A

        Returns:
           bool: True/False connection alive

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._isauthenticated and not self.session.eof:
            return True
        return False

    @operation_timeout(&#34;timeout_transport&#34;, &#34;Transport timeout during read operation.&#34;)
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes read from the telnet channel

        Raises:
            N/A

        &#34;&#34;&#34;
        return self.session.read_eager()

    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.write(channel_input.encode())

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        self.session.timeout = set_timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: always, because this is not implemented for telnet

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for telnet.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.TelnetTransport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True/False connection alive</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if alive and session is authenticated

    Args:
        N/A

    Returns:
       bool: True/False connection alive

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._isauthenticated and not self.session.eof:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.TelnetTransport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Open channel, acquire pty, request interactive shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ScrapliAuthenticationFailed</code></strong></dt>
<dd>if cant successfully authenticate</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open channel, acquire pty, request interactive shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        ScrapliAuthenticationFailed: if cant successfully authenticate

    &#34;&#34;&#34;
    self.session_lock.acquire()
    # establish session with &#34;socket&#34; timeout, then reset timeout to &#34;transport&#34; timeout
    telnet_session = ScrapliTelnet(host=self.host, port=self.port, timeout=self.timeout_socket)
    telnet_session.timeout = self.timeout_transport
    LOG.debug(f&#34;Session to host {self.host} spawned&#34;)
    self.session_lock.release()
    self._authenticate(telnet_session)
    if not self._telnet_isauthenticated(telnet_session):
        raise ScrapliAuthenticationFailed(
            f&#34;Could not authenticate over telnet to host: {self.host}&#34;
        )
    LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
    self.session = telnet_session</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="transport.html#scrapli.transport.transport.Transport.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.read" href="transport.html#scrapli.transport.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_timeout" href="transport.html#scrapli.transport.transport.Transport.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.transport.Transport"><code class="flex name class">
<span>class <span class="ident">Transport</span></span>
<span>(</span><span>host='', port=22, timeout_socket=5, timeout_transport=5, timeout_exit=True, keepalive=False, keepalive_interval=30, keepalive_type='network', keepalive_pattern='\x05')</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Transport Base Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' attempts to use whatever 'standard'
keepalive mechanisms are available in the selected transport mechanism. Check the
transport documentation for details on what is supported and/or how it is
implemented for any given transport driver</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transport(ABC):
    def __init__(
        self,
        host: str = &#34;&#34;,
        port: int = 22,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;network&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        Transport Base Object

        Args:
            host: host ip/name to connect to
            port: port to connect to
            timeout_socket: timeout for establishing socket in seconds
            timeout_transport: timeout for ssh|telnet transport in seconds
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; attempts to use whatever &#39;standard&#39;
                keepalive mechanisms are available in the selected transport mechanism. Check the
                transport documentation for details on what is supported and/or how it is
                implemented for any given transport driver
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.host: str = host
        self.port: int = port
        self.timeout_socket: int = timeout_socket
        self.timeout_transport: int = timeout_transport
        self.timeout_exit: bool = timeout_exit
        self.keepalive: bool = keepalive
        self.keepalive_interval: int = keepalive_interval
        self.keepalive_type: str = keepalive_type
        self.keepalive_pattern: str = keepalive_pattern

        self.session_lock: Lock = Lock()

    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;
        Magic bool method for Socket

        Args:
            N/A

        Returns:
            bool: True/False if socket is alive or not

        Raises:
            N/A

        &#34;&#34;&#34;
        return self.isalive()

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Magic str method for Transport

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        return f&#34;Transport Object for host {self.host}&#34;

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Magic repr method for Transport

        Args:
            N/A

        Returns:
            str: repr for class object

        Raises:
            N/A

        &#34;&#34;&#34;
        class_dict = self.__dict__.copy()
        class_dict[&#34;auth_password&#34;] = &#34;********&#34;
        return f&#34;Transport {class_dict}&#34;

    @abstractmethod
    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if socket is alive and session is authenticated

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    @abstractmethod
    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def _session_keepalive(self) -&gt; None:
        &#34;&#34;&#34;
        Spawn keepalive thread for transport session

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if not self.keepalive:
            return
        pool = ThreadPoolExecutor()
        if self.keepalive_type == &#34;network&#34;:
            pool.submit(self._keepalive_network)
        else:
            pool.submit(self._keepalive_standard)

    def _keepalive_network(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;in band&#34; keepalives to devices.

        Generally used with &#34;network&#34; devices which do not have native keepalive support. This will
        try to acquire a session lock and send an innocuous character -- such as CTRL+E -- to keep
        the device &#34;exec-timeout&#34; (in network-y words) from expiring.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliKeepaliveFailure: if scrapli cant unlock and send keepalive in less than 3 *
                the keepalive_interval

        &#34;&#34;&#34;
        lock_counter = 0
        last_keepalive = datetime.now()
        while True:
            if not self.isalive():
                return
            diff = datetime.now() - last_keepalive
            if diff.seconds &gt;= self.keepalive_interval:
                if not self.session_lock.locked():
                    LOG.debug(
                        f&#34;Sending &#39;network&#39; keepalive with pattern {repr(self.keepalive_pattern)}.&#34;
                    )
                    lock_counter = 0
                    self.session_lock.acquire()
                    self.write(self.keepalive_pattern)
                    self.session_lock.release()
                    last_keepalive = datetime.now()
                else:
                    lock_counter += 1
                    if lock_counter &gt;= 3:
                        LOG.info(f&#34;Keepalive thread missed {lock_counter} consecutive keepalives.&#34;)
            if diff.seconds &gt; self.keepalive_interval * 3:
                msg = (
                    &#34;Keepalive thread has failed to send a keepalive in greater than three &#34;
                    &#34;times the keepalive interval!&#34;
                )
                LOG.critical(msg)
                raise ScrapliKeepaliveFailure(msg)
            time.sleep(self.keepalive_interval / 10)

    @abstractmethod
    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli.transport.cssh2.SSH2Transport" href="cssh2.html#scrapli.transport.cssh2.SSH2Transport">SSH2Transport</a></li>
<li><a title="scrapli.transport.miko.MikoTransport" href="miko.html#scrapli.transport.miko.MikoTransport">MikoTransport</a></li>
<li><a title="scrapli.transport.systemssh.SystemSSHTransport" href="systemssh.html#scrapli.transport.systemssh.SystemSSHTransport">SystemSSHTransport</a></li>
<li><a title="scrapli.transport.telnet.TelnetTransport" href="telnet.html#scrapli.transport.telnet.TelnetTransport">TelnetTransport</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.Transport.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Close session and socket</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def close(self) -&gt; None:
    &#34;&#34;&#34;
    Close session and socket

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.Transport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if socket is alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if socket is alive and session is authenticated

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.Transport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Open channel, acquire pty, request interactive shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open channel, acquire pty, request interactive shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.Transport.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Read data from the channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read(self) -&gt; bytes:
    &#34;&#34;&#34;
    Read data from the channel

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.Transport.set_timeout"><code class="name flex">
<span>def <span class="ident">set_timeout</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Set session timeout</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Set session timeout

    Args:
        timeout: timeout in seconds

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.Transport.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, channel_input)</span>
</code></dt>
<dd>
<section class="desc"><p>Write data to the channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_input</code></strong></dt>
<dd>string to send to channel</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def write(self, channel_input: str) -&gt; None:
    &#34;&#34;&#34;
    Write data to the channel

    Args:
        channel_input: string to send to channel

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli" href="../index.html">scrapli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli.transport.cssh2" href="cssh2.html">scrapli.transport.cssh2</a></code></li>
<li><code><a title="scrapli.transport.miko" href="miko.html">scrapli.transport.miko</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess" href="ptyprocess.html">scrapli.transport.ptyprocess</a></code></li>
<li><code><a title="scrapli.transport.socket" href="socket.html">scrapli.transport.socket</a></code></li>
<li><code><a title="scrapli.transport.systemssh" href="systemssh.html">scrapli.transport.systemssh</a></code></li>
<li><code><a title="scrapli.transport.telnet" href="telnet.html">scrapli.transport.telnet</a></code></li>
<li><code><a title="scrapli.transport.transport" href="transport.html">scrapli.transport.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.transport.MikoTransport" href="#scrapli.transport.MikoTransport">MikoTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.MikoTransport.authenticate" href="#scrapli.transport.MikoTransport.authenticate">authenticate</a></code></li>
<li><code><a title="scrapli.transport.MikoTransport.isalive" href="#scrapli.transport.MikoTransport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.MikoTransport.isauthenticated" href="#scrapli.transport.MikoTransport.isauthenticated">isauthenticated</a></code></li>
<li><code><a title="scrapli.transport.MikoTransport.open" href="#scrapli.transport.MikoTransport.open">open</a></code></li>
<li><code><a title="scrapli.transport.MikoTransport.read" href="#scrapli.transport.MikoTransport.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.SSH2Transport" href="#scrapli.transport.SSH2Transport">SSH2Transport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.SSH2Transport.authenticate" href="#scrapli.transport.SSH2Transport.authenticate">authenticate</a></code></li>
<li><code><a title="scrapli.transport.SSH2Transport.isalive" href="#scrapli.transport.SSH2Transport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.SSH2Transport.isauthenticated" href="#scrapli.transport.SSH2Transport.isauthenticated">isauthenticated</a></code></li>
<li><code><a title="scrapli.transport.SSH2Transport.open" href="#scrapli.transport.SSH2Transport.open">open</a></code></li>
<li><code><a title="scrapli.transport.SSH2Transport.read" href="#scrapli.transport.SSH2Transport.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.SystemSSHTransport" href="#scrapli.transport.SystemSSHTransport">SystemSSHTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.SystemSSHTransport.isalive" href="#scrapli.transport.SystemSSHTransport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.SystemSSHTransport.open" href="#scrapli.transport.SystemSSHTransport.open">open</a></code></li>
<li><code><a title="scrapli.transport.SystemSSHTransport.set_timeout" href="#scrapli.transport.SystemSSHTransport.set_timeout">set_timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.TelnetTransport" href="#scrapli.transport.TelnetTransport">TelnetTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.TelnetTransport.isalive" href="#scrapli.transport.TelnetTransport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.TelnetTransport.open" href="#scrapli.transport.TelnetTransport.open">open</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.Transport" href="#scrapli.transport.Transport">Transport</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli.transport.Transport.close" href="#scrapli.transport.Transport.close">close</a></code></li>
<li><code><a title="scrapli.transport.Transport.isalive" href="#scrapli.transport.Transport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.Transport.open" href="#scrapli.transport.Transport.open">open</a></code></li>
<li><code><a title="scrapli.transport.Transport.read" href="#scrapli.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.Transport.set_timeout" href="#scrapli.transport.Transport.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.Transport.write" href="#scrapli.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>