<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>scrapli.transport.ptyprocess API documentation</title>
<meta name="description" content="Ptyprocess is under the ISC license, as code derived from Pexpect.
http://opensource.org/licenses/ISC â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.transport.ptyprocess</code></h1>
</header>
<section id="section-intro">
<p>Ptyprocess is under the ISC license, as code derived from Pexpect.
<a href="http://opensource.org/licenses/ISC">http://opensource.org/licenses/ISC</a></p>
<p>Copyright (c) 2013-2014, Pexpect development team
Copyright (c) 2012, Noah Spurrier <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#110;&#111;&#97;&#104;&#64;&#110;&#111;&#97;&#104;&#46;&#111;&#114;&#103;">&#110;&#111;&#97;&#104;&#64;&#110;&#111;&#97;&#104;&#46;&#111;&#114;&#103;</a></p>
<p>PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY PURPOSE
WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE COPYRIGHT NOTICE
AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES. THE SOFTWARE IS PROVIDED
"AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</p>
<p>Thank you to the folks who create and maintain pexpect, vendoring this here
has been ridiculously helpful! -CM</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Ptyprocess is under the ISC license, as code derived from Pexpect.
    http://opensource.org/licenses/ISC

Copyright (c) 2013-2014, Pexpect development team
Copyright (c) 2012, Noah Spurrier &lt;noah@noah.org&gt;

PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY PURPOSE
WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE COPYRIGHT NOTICE
AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES. THE SOFTWARE IS PROVIDED
&#34;AS IS&#34; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Thank you to the folks who create and maintain pexpect, vendoring this here
has been ridiculously helpful! -CM
&#34;&#34;&#34;

import builtins
import errno
import io
import os
import signal
import struct
import sys
import time
from shutil import which
from typing import Type, TypeVar


class PtyProcessError(Exception):
    &#34;&#34;&#34;Generic error class for this package.&#34;&#34;&#34;


PtyProcessType = TypeVar(&#34;PtyProcessType&#34;, bound=&#34;PtyProcess&#34;)


def _byte(i):
    return bytes([i])


_EOF, _INTR = None, None


def _make_eof_intr():
    &#34;&#34;&#34;Set constants _EOF and _INTR.

    This avoids doing potentially costly operations on module load.
    &#34;&#34;&#34;
    import termios

    global _EOF, _INTR
    if (_EOF is not None) and (_INTR is not None):
        return

    # inherit EOF and INTR definitions from controlling process.
    try:
        from termios import VEOF, VINTR

        fd = None
        for name in &#34;stdin&#34;, &#34;stdout&#34;:
            stream = getattr(sys, &#34;__%s__&#34; % name, None)
            if stream is None or not hasattr(stream, &#34;fileno&#34;):
                continue
            try:
                fd = stream.fileno()
            except ValueError:
                continue
        if fd is None:
            # no fd, raise ValueError to fallback on CEOF, CINTR
            raise ValueError(&#34;No stream has a fileno&#34;)
        intr = ord(termios.tcgetattr(fd)[6][VINTR])
        eof = ord(termios.tcgetattr(fd)[6][VEOF])
    except (ImportError, OSError, IOError, ValueError, termios.error):
        # unless the controlling process is also not a terminal,
        # such as cron(1), or when stdin and stdout are both closed.
        # Fall-back to using CEOF and CINTR. There
        try:
            from termios import CEOF, CINTR

            (intr, eof) = (CINTR, CEOF)
        except ImportError:
            (intr, eof) = (3, 4)

    _INTR = _byte(intr)
    _EOF = _byte(eof)


def _setecho(fd, state):
    import termios

    errmsg = &#34;setecho() may not be called on this platform (it may still be possible to enable/disable echo when spawning the child process)&#34;

    try:
        attr = termios.tcgetattr(fd)
    except termios.error as err:
        if err.args[0] == errno.EINVAL:
            raise IOError(err.args[0], &#34;%s: %s.&#34; % (err.args[1], errmsg))
        raise

    if state:
        attr[3] = attr[3] | termios.ECHO
    else:
        attr[3] = attr[3] &amp; ~termios.ECHO

    try:
        # I tried TCSADRAIN and TCSAFLUSH, but these were inconsistent and
        # blocked on some platforms. TCSADRAIN would probably be ideal.
        termios.tcsetattr(fd, termios.TCSANOW, attr)
    except IOError as err:
        if err.args[0] == errno.EINVAL:
            raise IOError(err.args[0], &#34;%s: %s.&#34; % (err.args[1], errmsg))
        raise


def _setwinsize(fd, rows, cols):
    # Some very old platforms have a bug that causes the value for
    # termios.TIOCSWINSZ to be truncated. There was a hack here to work
    # around this, but it caused problems with newer platforms so has been
    # removed. For details see https://github.com/pexpect/pexpect/issues/39
    import termios
    import fcntl

    TIOCSWINSZ = getattr(termios, &#34;TIOCSWINSZ&#34;, -2146929561)
    # Note, assume ws_xpixel and ws_ypixel are zero.
    s = struct.pack(&#34;HHHH&#34;, rows, cols, 0, 0)
    fcntl.ioctl(fd, TIOCSWINSZ, s)


class PtyProcess(object):
    &#34;&#34;&#34;This class represents a process running in a pseudoterminal.

    The main constructor is the :meth:`spawn` classmethod.
    &#34;&#34;&#34;

    string_type = bytes
    linesep = os.linesep.encode(&#34;ascii&#34;)
    crlf = &#34;\r\n&#34;.encode(&#34;ascii&#34;)

    @staticmethod
    def write_to_stdout(b):
        try:
            return sys.stdout.buffer.write(b)
        except AttributeError:
            # If stdout has been replaced, it may not have .buffer
            return sys.stdout.write(b.decode(&#34;ascii&#34;, &#34;replace&#34;))

    encoding = None
    argv = None
    env = None
    launch_dir = None

    def __init__(self, pid, fd):
        _make_eof_intr()  # Ensure _EOF and _INTR are calculated
        self.pid = pid
        self.fd = fd
        readf = io.open(fd, &#34;rb&#34;, buffering=0)
        writef = io.open(fd, &#34;wb&#34;, buffering=0, closefd=False)
        self.fileobj = io.BufferedRWPair(readf, writef)

        self.terminated = False
        self.closed = False
        self.exitstatus = None
        self.signalstatus = None
        # status returned by os.waitpid
        self.status = None
        self.flag_eof = False
        # Used by close() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterclose = 0.1
        # Used by terminate() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterterminate = 0.1

    @classmethod
    def spawn(
        cls: Type[PtyProcessType],
        argv,
        cwd=None,
        env=None,
        echo=True,
        preexec_fn=None,
        dimensions=(24, 80),
        pass_fds=(),
    ) -&gt; PtyProcessType:
        &#34;&#34;&#34;Start the given command in a child process in a pseudo terminal.

        This does all the fork/exec type of stuff for a pty, and returns an
        instance of PtyProcess.

        If preexec_fn is supplied, it will be called with no arguments in the
        child process before exec-ing the specified command.
        It may, for instance, set signal handlers to SIG_DFL or SIG_IGN.

        Dimensions of the psuedoterminal used for the subprocess can be
        specified as a tuple (rows, cols), or the default (24, 80) will be used.

        By default, all file descriptors except 0, 1 and 2 are closed. This
        behavior can be overridden with pass_fds, a list of file descriptors to
        keep open between the parent and the child.
        &#34;&#34;&#34;
        # Note that it is difficult for this method to fail.
        # You cannot detect if the child process cannot start.
        # So the only way you can tell if the child process started
        # or not is to try to read from the file descriptor. If you get
        # EOF immediately then it means that the child is already dead.
        # That may not necessarily be bad because you may have spawned a child
        # that performs some task; creates no stdout output; and then dies.

        import fcntl
        import pty
        import termios
        import resource
        from pty import CHILD, STDIN_FILENO

        if not isinstance(argv, (list, tuple)):
            raise TypeError(&#34;Expected a list or tuple for argv, got %r&#34; % argv)

        # Shallow copy of argv so we can modify it
        argv = argv[:]
        command = argv[0]

        command_with_path = which(command)
        if command_with_path is None:
            raise FileNotFoundError(
                &#34;The command was not found or was not &#34; + &#34;executable: %s.&#34; % command
            )
        command = command_with_path
        argv[0] = command

        # [issue #119] To prevent the case where exec fails and the user is
        # stuck interacting with a python child process instead of whatever
        # was expected, we implement the solution from
        # http://stackoverflow.com/a/3703179 to pass the exception to the
        # parent process

        # [issue #119] 1. Before forking, open a pipe in the parent process.
        exec_err_pipe_read, exec_err_pipe_write = os.pipe()

        pid, fd = pty.fork()

        # Some platforms must call setwinsize() and setecho() from the
        # child process, and others from the master process. We do both,
        # allowing IOError for either.

        if pid == CHILD:
            # set window size
            try:
                _setwinsize(STDIN_FILENO, *dimensions)
            except IOError as err:
                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                    raise

            # disable echo if spawn argument echo was unset
            if not echo:
                try:
                    _setecho(STDIN_FILENO, False)
                except (IOError, termios.error) as err:
                    if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                        raise

            # [issue #119] 3. The child closes the reading end and sets the
            # close-on-exec flag for the writing end.
            os.close(exec_err_pipe_read)
            fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)

            # Do not allow child to inherit open file descriptors from parent,
            # with the exception of the exec_err_pipe_write of the pipe
            # and pass_fds.
            # Impose ceiling on max_fd: AIX bugfix for users with unlimited
            # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()
            # occasionally raises out of range error
            max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])
            spass_fds = sorted(set(pass_fds) | {exec_err_pipe_write})
            for pair in zip([2] + spass_fds, spass_fds + [max_fd]):
                os.closerange(pair[0] + 1, pair[1])

            if cwd is not None:
                os.chdir(cwd)

            if preexec_fn is not None:
                try:
                    preexec_fn()
                except Exception as e:
                    ename = type(e).__name__
                    tosend = &#34;{}:0:{}&#34;.format(ename, str(e))
                    tosend = tosend.encode(&#34;utf-8&#34;)

                    os.write(exec_err_pipe_write, tosend)
                    os.close(exec_err_pipe_write)
                    os._exit(1)

            try:
                if env is None:
                    os.execv(command, argv)
                else:
                    os.execvpe(command, argv, env)
            except OSError as err:
                # [issue #119] 5. If exec fails, the child writes the error
                # code back to the parent using the pipe, then exits.
                tosend = &#34;OSError:{}:{}&#34;.format(err.errno, str(err))
                tosend = tosend.encode(&#34;utf-8&#34;)
                os.write(exec_err_pipe_write, tosend)
                os.close(exec_err_pipe_write)
                os._exit(os.EX_OSERR)

        # Parent
        inst = cls(pid, fd)

        # Set some informational attributes
        inst.argv = argv
        if env is not None:
            inst.env = env
        if cwd is not None:
            inst.launch_dir = cwd

        # [issue #119] 2. After forking, the parent closes the writing end
        # of the pipe and reads from the reading end.
        os.close(exec_err_pipe_write)
        exec_err_data = os.read(exec_err_pipe_read, 4096)
        os.close(exec_err_pipe_read)

        # [issue #119] 6. The parent reads eof (a zero-length read) if the
        # child successfully performed exec, since close-on-exec made
        # successful exec close the writing end of the pipe. Or, if exec
        # failed, the parent reads the error code and can proceed
        # accordingly. Either way, the parent blocks until the child calls
        # exec.
        if len(exec_err_data) != 0:
            try:
                errclass, errno_s, errmsg = exec_err_data.split(b&#34;:&#34;, 2)
                exctype = getattr(builtins, errclass.decode(&#34;ascii&#34;), Exception)

                exception = exctype(errmsg.decode(&#34;utf-8&#34;, &#34;replace&#34;))
                if exctype is OSError:
                    exception.errno = int(errno_s)
            except:
                raise Exception(&#34;Subprocess failed, got bad error data: %r&#34; % exec_err_data)
            else:
                raise exception

        try:
            inst.setwinsize(*dimensions)
        except IOError as err:
            if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):
                raise

        return inst

    def __repr__(self):
        clsname = type(self).__name__
        if self.argv is not None:
            args = [repr(self.argv)]
            if self.env is not None:
                args.append(&#34;env=%r&#34; % self.env)
            if self.launch_dir is not None:
                args.append(&#34;cwd=%r&#34; % self.launch_dir)

            return &#34;{}.spawn({})&#34;.format(clsname, &#34;, &#34;.join(args))

        else:
            return &#34;{}(pid={}, fd={})&#34;.format(clsname, self.pid, self.fd)

    @staticmethod
    def _coerce_send_string(s):
        if not isinstance(s, bytes):
            return s.encode(&#34;utf-8&#34;)
        return s

    @staticmethod
    def _coerce_read_string(s):
        return s

    def __del__(self):
        &#34;&#34;&#34;This makes sure that no system resources are left open. Python only
        garbage collects Python objects. OS file descriptors are not Python
        objects, so they must be handled explicitly. If the child file
        descriptor was opened outside of this class (passed to the constructor)
        then this does not close it. &#34;&#34;&#34;

        if not self.closed:
            # It is possible for __del__ methods to execute during the
            # teardown of the Python VM itself. Thus self.close() may
            # trigger an exception because os.close may be None.
            try:
                self.close()
            # which exception, shouldn&#39;t we catch explicitly .. ?
            except:
                pass

    def fileno(self):
        &#34;&#34;&#34;This returns the file descriptor of the pty for the child.
        &#34;&#34;&#34;
        return self.fd

    def close(self, force=True):
        &#34;&#34;&#34;This closes the connection with the child application. Note that
        calling close() more than once is valid. This emulates standard Python
        behavior with files. Set force to True if you want to make sure that
        the child is terminated (SIGKILL is sent if the child ignores SIGHUP
        and SIGINT). &#34;&#34;&#34;
        if not self.closed:
            self.flush()
            self.fileobj.close()  # Closes the file descriptor
            # Give kernel time to update process status.
            time.sleep(self.delayafterclose)
            if self.isalive():
                if not self.terminate(force):
                    raise PtyProcessError(&#34;Could not terminate the child.&#34;)
            self.fd = -1
            self.closed = True
            # self.pid = None

    def flush(self) -&gt; None:
        &#34;&#34;&#34;This does nothing. It is here to support the interface for a
        File-like object. &#34;&#34;&#34;

        pass

    def isatty(self):
        &#34;&#34;&#34;This returns True if the file descriptor is open and connected to a
        tty(-like) device, else False.

        On SVR4-style platforms implementing streams, such as SunOS and HP-UX,
        the child pty may not appear as a terminal device.  This means
        methods such as setecho(), setwinsize(), getwinsize() may raise an
        IOError. &#34;&#34;&#34;

        return os.isatty(self.fd)

    def waitnoecho(self, timeout=None):
        &#34;&#34;&#34;This waits until the terminal ECHO flag is set False. This returns
        True if the echo mode is off. This returns False if the ECHO flag was
        not set False before the timeout. This can be used to detect when the
        child is waiting for a password. Usually a child application will turn
        off echo mode when it is waiting for the user to enter a password. For
        example, instead of expecting the &#34;password:&#34; prompt you can wait for
        the child to set ECHO off::

            p = pexpect.spawn(&#39;ssh user@example.com&#39;)
            p.waitnoecho()
            p.sendline(mypassword)

        If timeout==None then this method to block until ECHO flag is False.
        &#34;&#34;&#34;

        if timeout is not None:
            end_time = time.time() + timeout
        while True:
            if not self.getecho():
                return True
            if timeout &lt; 0 and timeout is not None:
                return False
            if timeout is not None:
                timeout = end_time - time.time()
            time.sleep(0.1)

    def getecho(self):
        &#34;&#34;&#34;This returns the terminal echo mode. This returns True if echo is
        on or False if echo is off. Child applications that are expecting you
        to enter a password often set ECHO False. See waitnoecho().

        Not supported on platforms where ``isatty()`` returns False.  &#34;&#34;&#34;

        try:
            attr = termios.tcgetattr(self.fd)
        except termios.error as err:
            errmsg = &#34;getecho() may not be called on this platform&#34;
            if err.args[0] == errno.EINVAL:
                raise IOError(err.args[0], &#34;%s: %s.&#34; % (err.args[1], errmsg))
            raise

        self.echo = bool(attr[3] &amp; termios.ECHO)
        return self.echo

    def setecho(self, state):
        &#34;&#34;&#34;This sets the terminal echo mode on or off. Note that anything the
        child sent before the echo will be lost, so you should be sure that
        your input buffer is empty before you call setecho(). For example, the
        following will work as expected::

            p = pexpect.spawn(&#39;cat&#39;) # Echo is on by default.
            p.sendline(&#39;1234&#39;) # We expect see this twice from the child...
            p.expect([&#39;1234&#39;]) # ... once from the tty echo...
            p.expect([&#39;1234&#39;]) # ... and again from cat itself.
            p.setecho(False) # Turn off tty echo
            p.sendline(&#39;abcd&#39;) # We will set this only once (echoed by cat).
            p.sendline(&#39;wxyz&#39;) # We will set this only once (echoed by cat)
            p.expect([&#39;abcd&#39;])
            p.expect([&#39;wxyz&#39;])

        The following WILL NOT WORK because the lines sent before the setecho
        will be lost::

            p = pexpect.spawn(&#39;cat&#39;)
            p.sendline(&#39;1234&#39;)
            p.setecho(False) # Turn off tty echo
            p.sendline(&#39;abcd&#39;) # We will set this only once (echoed by cat).
            p.sendline(&#39;wxyz&#39;) # We will set this only once (echoed by cat)
            p.expect([&#39;1234&#39;])
            p.expect([&#39;1234&#39;])
            p.expect([&#39;abcd&#39;])
            p.expect([&#39;wxyz&#39;])


        Not supported on platforms where ``isatty()`` returns False.
        &#34;&#34;&#34;
        _setecho(self.fd, state)

        self.echo = state

    def read(self, size=1024) -&gt; bytes:
        &#34;&#34;&#34;Read and return at most ``size`` bytes from the pty.

        Can block if there is nothing to read. Raises :exc:`EOFError` if the
        terminal was closed.

        Unlike Pexpect&#39;s ``read_nonblocking`` method, this doesn&#39;t try to deal
        with the vagaries of EOF on platforms that do strange things, like IRIX
        or older Solaris systems. It handles the errno=EIO pattern used on
        Linux, and the empty-string return used on BSD platforms and (seemingly)
        on recent Solaris.
        &#34;&#34;&#34;
        try:
            s = self.fileobj.read1(size)
        except (OSError, IOError) as err:
            if err.args[0] == errno.EIO:
                # Linux-style EOF
                self.flag_eof = True
                raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
            raise
        if s == b&#34;&#34;:
            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

        return s

    def readline(self):
        &#34;&#34;&#34;Read one line from the pseudoterminal, and return it as unicode.

        Can block if there is nothing to read. Raises :exc:`EOFError` if the
        terminal was closed.
        &#34;&#34;&#34;
        try:
            s = self.fileobj.readline()
        except (OSError, IOError) as err:
            if err.args[0] == errno.EIO:
                # Linux-style EOF
                self.flag_eof = True
                raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
            raise
        if s == b&#34;&#34;:
            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

        return s

    def _writeb(self, b, flush=True):
        n = self.fileobj.write(b)
        if flush:
            self.fileobj.flush()
        return n

    def write(self, s, flush=True) -&gt; int:
        &#34;&#34;&#34;Write bytes to the pseudoterminal.

        Returns the number of bytes written.
        &#34;&#34;&#34;
        return self._writeb(s, flush=flush)

    def sendcontrol(self, char):
        &#34;&#34;&#34;Helper method that wraps send() with mnemonic access for sending control
        character to the child (such as Ctrl-C or Ctrl-D).  For example, to send
        Ctrl-G (ASCII 7, bell, &#39;\a&#39;)::

            child.sendcontrol(&#39;g&#39;)

        See also, sendintr() and sendeof().
        &#34;&#34;&#34;
        char = char.lower()
        a = ord(char)
        if 97 &lt;= a &lt;= 122:
            a = a - ord(&#34;a&#34;) + 1
            byte = _byte(a)
            return self._writeb(byte), byte
        d = {
            &#34;@&#34;: 0,
            &#34;`&#34;: 0,
            &#34;[&#34;: 27,
            &#34;{&#34;: 27,
            &#34;\\&#34;: 28,
            &#34;|&#34;: 28,
            &#34;]&#34;: 29,
            &#34;}&#34;: 29,
            &#34;^&#34;: 30,
            &#34;~&#34;: 30,
            &#34;_&#34;: 31,
            &#34;?&#34;: 127,
        }
        if char not in d:
            return 0, b&#34;&#34;

        byte = _byte(d[char])
        return self._writeb(byte), byte

    def sendeof(self):
        &#34;&#34;&#34;This sends an EOF to the child. This sends a character which causes
        the pending parent output buffer to be sent to the waiting child
        program without waiting for end-of-line. If it is the first character
        of the line, the read() in the user program returns 0, which signifies
        end-of-file. This means to work as expected a sendeof() has to be
        called at the beginning of a line. This method does not send a newline.
        It is the responsibility of the caller to ensure the eof is sent at the
        beginning of a line. &#34;&#34;&#34;

        return self._writeb(_EOF), _EOF

    def sendintr(self):
        &#34;&#34;&#34;This sends a SIGINT to the child. It does not require
        the SIGINT to be the first character on a line. &#34;&#34;&#34;

        return self._writeb(_INTR), _INTR

    def eof(self) -&gt; bool:
        &#34;&#34;&#34;This returns True if the EOF exception was ever raised.
        &#34;&#34;&#34;

        return self.flag_eof

    def terminate(self, force=False):
        &#34;&#34;&#34;This forces a child process to terminate. It starts nicely with
        SIGHUP and SIGINT. If &#34;force&#34; is True then moves onto SIGKILL. This
        returns True if the child was terminated. This returns False if the
        child could not be terminated. &#34;&#34;&#34;

        if not self.isalive():
            return True
        try:
            self.kill(signal.SIGHUP)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGCONT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGINT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            if force:
                self.kill(signal.SIGKILL)
                time.sleep(self.delayafterterminate)
                if not self.isalive():
                    return True
                else:
                    return False
            return False
        except OSError:
            # I think there are kernel timing issues that sometimes cause
            # this to happen. I think isalive() reports True, but the
            # process is dead to the kernel.
            # Make one last attempt to see if the kernel is up to date.
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            else:
                return False

    def wait(self):
        &#34;&#34;&#34;This waits until the child exits. This is a blocking call. This will
        not read any data from the child, so this will block forever if the
        child has unread output and has terminated. In other words, the child
        may have printed output then called exit(), but, the child is
        technically still alive until its output is read by the parent. &#34;&#34;&#34;

        if self.isalive():
            pid, status = os.waitpid(self.pid, 0)
        else:
            return self.exitstatus
        self.exitstatus = os.WEXITSTATUS(status)
        if os.WIFEXITED(status):
            self.status = status
            self.exitstatus = os.WEXITSTATUS(status)
            self.signalstatus = None
            self.terminated = True
        elif os.WIFSIGNALED(status):
            self.status = status
            self.exitstatus = None
            self.signalstatus = os.WTERMSIG(status)
            self.terminated = True
        elif os.WIFSTOPPED(status):  # pragma: no cover
            # You can&#39;t call wait() on a child process in the stopped state.
            raise PtyProcessError(
                &#34;Called wait() on a stopped child &#34;
                + &#34;process. This is not supported. Is some other &#34;
                + &#34;process attempting job control with our child pid?&#34;
            )
        return self.exitstatus

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;This tests if the child process is running or not. This is
        non-blocking. If the child was terminated then this will read the
        exitstatus or signalstatus of the child. This returns True if the child
        process appears to be running or False if not. It can take literally
        SECONDS for Solaris to return the right status. &#34;&#34;&#34;

        if self.terminated:
            return False

        if self.flag_eof:
            # This is for Linux, which requires the blocking form
            # of waitpid to get the status of a defunct process.
            # This is super-lame. The flag_eof would have been set
            # in read_nonblocking(), so this should be safe.
            waitpid_options = 0
        else:
            waitpid_options = os.WNOHANG

        try:
            pid, status = os.waitpid(self.pid, waitpid_options)
        except OSError as e:
            # No child processes
            if e.errno == errno.ECHILD:
                raise PtyProcessError(
                    &#34;isalive() encountered condition &#34;
                    + &#39;where &#34;terminated&#34; is 0, but there was no child &#39;
                    + &#34;process. Did someone else call waitpid() &#34;
                    + &#34;on our process?&#34;
                )
            else:
                raise

        # I have to do this twice for Solaris.
        # I can&#39;t even believe that I figured this out...
        # If waitpid() returns 0 it means that no child process
        # wishes to report, and the value of status is undefined.
        if pid == 0:
            try:
                ### os.WNOHANG) # Solaris!
                pid, status = os.waitpid(self.pid, waitpid_options)
            except OSError as e:  # pragma: no cover
                # This should never happen...
                if e.errno == errno.ECHILD:
                    raise PtyProcessError(
                        &#34;isalive() encountered condition &#34;
                        + &#34;that should never happen. There was no child &#34;
                        + &#34;process. Did someone else call waitpid() &#34;
                        + &#34;on our process?&#34;
                    )
                else:
                    raise

            # If pid is still 0 after two calls to waitpid() then the process
            # really is alive. This seems to work on all platforms, except for
            # Irix which seems to require a blocking call on waitpid or select,
            # so I let read_nonblocking take care of this situation
            # (unfortunately, this requires waiting through the timeout).
            if pid == 0:
                return True

        if pid == 0:
            return True

        if os.WIFEXITED(status):
            self.status = status
            self.exitstatus = os.WEXITSTATUS(status)
            self.signalstatus = None
            self.terminated = True
        elif os.WIFSIGNALED(status):
            self.status = status
            self.exitstatus = None
            self.signalstatus = os.WTERMSIG(status)
            self.terminated = True
        elif os.WIFSTOPPED(status):
            raise PtyProcessError(
                &#34;isalive() encountered condition &#34;
                + &#34;where child process is stopped. This is not &#34;
                + &#34;supported. Is some other process attempting &#34;
                + &#34;job control with our child pid?&#34;
            )
        return False

    def kill(self, sig) -&gt; None:
        &#34;&#34;&#34;Send the given signal to the child application.

        In keeping with UNIX tradition it has a misleading name. It does not
        necessarily kill the child unless you send the right signal. See the
        :mod:`signal` module for constants representing signal numbers.
        &#34;&#34;&#34;

        # Same as os.kill, but the pid is given for you.
        if self.isalive():
            os.kill(self.pid, sig)

    def setwinsize(self, rows, cols):
        &#34;&#34;&#34;Set the terminal window size of the child tty.

        This will cause a SIGWINCH signal to be sent to the child. This does not
        change the physical window size. It changes the size reported to
        TTY-aware applications like vi or curses -- applications that respond to
        the SIGWINCH signal.
        &#34;&#34;&#34;
        return _setwinsize(self.fd, rows, cols)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.transport.ptyprocess.PtyProcess"><code class="flex name class">
<span>class <span class="ident">PtyProcess</span></span>
<span>(</span><span>pid, fd)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a process running in a pseudoterminal.</p>
<p>The main constructor is the :meth:<code>spawn</code> classmethod.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PtyProcess(object):
    &#34;&#34;&#34;This class represents a process running in a pseudoterminal.

    The main constructor is the :meth:`spawn` classmethod.
    &#34;&#34;&#34;

    string_type = bytes
    linesep = os.linesep.encode(&#34;ascii&#34;)
    crlf = &#34;\r\n&#34;.encode(&#34;ascii&#34;)

    @staticmethod
    def write_to_stdout(b):
        try:
            return sys.stdout.buffer.write(b)
        except AttributeError:
            # If stdout has been replaced, it may not have .buffer
            return sys.stdout.write(b.decode(&#34;ascii&#34;, &#34;replace&#34;))

    encoding = None
    argv = None
    env = None
    launch_dir = None

    def __init__(self, pid, fd):
        _make_eof_intr()  # Ensure _EOF and _INTR are calculated
        self.pid = pid
        self.fd = fd
        readf = io.open(fd, &#34;rb&#34;, buffering=0)
        writef = io.open(fd, &#34;wb&#34;, buffering=0, closefd=False)
        self.fileobj = io.BufferedRWPair(readf, writef)

        self.terminated = False
        self.closed = False
        self.exitstatus = None
        self.signalstatus = None
        # status returned by os.waitpid
        self.status = None
        self.flag_eof = False
        # Used by close() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterclose = 0.1
        # Used by terminate() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterterminate = 0.1

    @classmethod
    def spawn(
        cls: Type[PtyProcessType],
        argv,
        cwd=None,
        env=None,
        echo=True,
        preexec_fn=None,
        dimensions=(24, 80),
        pass_fds=(),
    ) -&gt; PtyProcessType:
        &#34;&#34;&#34;Start the given command in a child process in a pseudo terminal.

        This does all the fork/exec type of stuff for a pty, and returns an
        instance of PtyProcess.

        If preexec_fn is supplied, it will be called with no arguments in the
        child process before exec-ing the specified command.
        It may, for instance, set signal handlers to SIG_DFL or SIG_IGN.

        Dimensions of the psuedoterminal used for the subprocess can be
        specified as a tuple (rows, cols), or the default (24, 80) will be used.

        By default, all file descriptors except 0, 1 and 2 are closed. This
        behavior can be overridden with pass_fds, a list of file descriptors to
        keep open between the parent and the child.
        &#34;&#34;&#34;
        # Note that it is difficult for this method to fail.
        # You cannot detect if the child process cannot start.
        # So the only way you can tell if the child process started
        # or not is to try to read from the file descriptor. If you get
        # EOF immediately then it means that the child is already dead.
        # That may not necessarily be bad because you may have spawned a child
        # that performs some task; creates no stdout output; and then dies.

        import fcntl
        import pty
        import termios
        import resource
        from pty import CHILD, STDIN_FILENO

        if not isinstance(argv, (list, tuple)):
            raise TypeError(&#34;Expected a list or tuple for argv, got %r&#34; % argv)

        # Shallow copy of argv so we can modify it
        argv = argv[:]
        command = argv[0]

        command_with_path = which(command)
        if command_with_path is None:
            raise FileNotFoundError(
                &#34;The command was not found or was not &#34; + &#34;executable: %s.&#34; % command
            )
        command = command_with_path
        argv[0] = command

        # [issue #119] To prevent the case where exec fails and the user is
        # stuck interacting with a python child process instead of whatever
        # was expected, we implement the solution from
        # http://stackoverflow.com/a/3703179 to pass the exception to the
        # parent process

        # [issue #119] 1. Before forking, open a pipe in the parent process.
        exec_err_pipe_read, exec_err_pipe_write = os.pipe()

        pid, fd = pty.fork()

        # Some platforms must call setwinsize() and setecho() from the
        # child process, and others from the master process. We do both,
        # allowing IOError for either.

        if pid == CHILD:
            # set window size
            try:
                _setwinsize(STDIN_FILENO, *dimensions)
            except IOError as err:
                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                    raise

            # disable echo if spawn argument echo was unset
            if not echo:
                try:
                    _setecho(STDIN_FILENO, False)
                except (IOError, termios.error) as err:
                    if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                        raise

            # [issue #119] 3. The child closes the reading end and sets the
            # close-on-exec flag for the writing end.
            os.close(exec_err_pipe_read)
            fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)

            # Do not allow child to inherit open file descriptors from parent,
            # with the exception of the exec_err_pipe_write of the pipe
            # and pass_fds.
            # Impose ceiling on max_fd: AIX bugfix for users with unlimited
            # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()
            # occasionally raises out of range error
            max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])
            spass_fds = sorted(set(pass_fds) | {exec_err_pipe_write})
            for pair in zip([2] + spass_fds, spass_fds + [max_fd]):
                os.closerange(pair[0] + 1, pair[1])

            if cwd is not None:
                os.chdir(cwd)

            if preexec_fn is not None:
                try:
                    preexec_fn()
                except Exception as e:
                    ename = type(e).__name__
                    tosend = &#34;{}:0:{}&#34;.format(ename, str(e))
                    tosend = tosend.encode(&#34;utf-8&#34;)

                    os.write(exec_err_pipe_write, tosend)
                    os.close(exec_err_pipe_write)
                    os._exit(1)

            try:
                if env is None:
                    os.execv(command, argv)
                else:
                    os.execvpe(command, argv, env)
            except OSError as err:
                # [issue #119] 5. If exec fails, the child writes the error
                # code back to the parent using the pipe, then exits.
                tosend = &#34;OSError:{}:{}&#34;.format(err.errno, str(err))
                tosend = tosend.encode(&#34;utf-8&#34;)
                os.write(exec_err_pipe_write, tosend)
                os.close(exec_err_pipe_write)
                os._exit(os.EX_OSERR)

        # Parent
        inst = cls(pid, fd)

        # Set some informational attributes
        inst.argv = argv
        if env is not None:
            inst.env = env
        if cwd is not None:
            inst.launch_dir = cwd

        # [issue #119] 2. After forking, the parent closes the writing end
        # of the pipe and reads from the reading end.
        os.close(exec_err_pipe_write)
        exec_err_data = os.read(exec_err_pipe_read, 4096)
        os.close(exec_err_pipe_read)

        # [issue #119] 6. The parent reads eof (a zero-length read) if the
        # child successfully performed exec, since close-on-exec made
        # successful exec close the writing end of the pipe. Or, if exec
        # failed, the parent reads the error code and can proceed
        # accordingly. Either way, the parent blocks until the child calls
        # exec.
        if len(exec_err_data) != 0:
            try:
                errclass, errno_s, errmsg = exec_err_data.split(b&#34;:&#34;, 2)
                exctype = getattr(builtins, errclass.decode(&#34;ascii&#34;), Exception)

                exception = exctype(errmsg.decode(&#34;utf-8&#34;, &#34;replace&#34;))
                if exctype is OSError:
                    exception.errno = int(errno_s)
            except:
                raise Exception(&#34;Subprocess failed, got bad error data: %r&#34; % exec_err_data)
            else:
                raise exception

        try:
            inst.setwinsize(*dimensions)
        except IOError as err:
            if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):
                raise

        return inst

    def __repr__(self):
        clsname = type(self).__name__
        if self.argv is not None:
            args = [repr(self.argv)]
            if self.env is not None:
                args.append(&#34;env=%r&#34; % self.env)
            if self.launch_dir is not None:
                args.append(&#34;cwd=%r&#34; % self.launch_dir)

            return &#34;{}.spawn({})&#34;.format(clsname, &#34;, &#34;.join(args))

        else:
            return &#34;{}(pid={}, fd={})&#34;.format(clsname, self.pid, self.fd)

    @staticmethod
    def _coerce_send_string(s):
        if not isinstance(s, bytes):
            return s.encode(&#34;utf-8&#34;)
        return s

    @staticmethod
    def _coerce_read_string(s):
        return s

    def __del__(self):
        &#34;&#34;&#34;This makes sure that no system resources are left open. Python only
        garbage collects Python objects. OS file descriptors are not Python
        objects, so they must be handled explicitly. If the child file
        descriptor was opened outside of this class (passed to the constructor)
        then this does not close it. &#34;&#34;&#34;

        if not self.closed:
            # It is possible for __del__ methods to execute during the
            # teardown of the Python VM itself. Thus self.close() may
            # trigger an exception because os.close may be None.
            try:
                self.close()
            # which exception, shouldn&#39;t we catch explicitly .. ?
            except:
                pass

    def fileno(self):
        &#34;&#34;&#34;This returns the file descriptor of the pty for the child.
        &#34;&#34;&#34;
        return self.fd

    def close(self, force=True):
        &#34;&#34;&#34;This closes the connection with the child application. Note that
        calling close() more than once is valid. This emulates standard Python
        behavior with files. Set force to True if you want to make sure that
        the child is terminated (SIGKILL is sent if the child ignores SIGHUP
        and SIGINT). &#34;&#34;&#34;
        if not self.closed:
            self.flush()
            self.fileobj.close()  # Closes the file descriptor
            # Give kernel time to update process status.
            time.sleep(self.delayafterclose)
            if self.isalive():
                if not self.terminate(force):
                    raise PtyProcessError(&#34;Could not terminate the child.&#34;)
            self.fd = -1
            self.closed = True
            # self.pid = None

    def flush(self) -&gt; None:
        &#34;&#34;&#34;This does nothing. It is here to support the interface for a
        File-like object. &#34;&#34;&#34;

        pass

    def isatty(self):
        &#34;&#34;&#34;This returns True if the file descriptor is open and connected to a
        tty(-like) device, else False.

        On SVR4-style platforms implementing streams, such as SunOS and HP-UX,
        the child pty may not appear as a terminal device.  This means
        methods such as setecho(), setwinsize(), getwinsize() may raise an
        IOError. &#34;&#34;&#34;

        return os.isatty(self.fd)

    def waitnoecho(self, timeout=None):
        &#34;&#34;&#34;This waits until the terminal ECHO flag is set False. This returns
        True if the echo mode is off. This returns False if the ECHO flag was
        not set False before the timeout. This can be used to detect when the
        child is waiting for a password. Usually a child application will turn
        off echo mode when it is waiting for the user to enter a password. For
        example, instead of expecting the &#34;password:&#34; prompt you can wait for
        the child to set ECHO off::

            p = pexpect.spawn(&#39;ssh user@example.com&#39;)
            p.waitnoecho()
            p.sendline(mypassword)

        If timeout==None then this method to block until ECHO flag is False.
        &#34;&#34;&#34;

        if timeout is not None:
            end_time = time.time() + timeout
        while True:
            if not self.getecho():
                return True
            if timeout &lt; 0 and timeout is not None:
                return False
            if timeout is not None:
                timeout = end_time - time.time()
            time.sleep(0.1)

    def getecho(self):
        &#34;&#34;&#34;This returns the terminal echo mode. This returns True if echo is
        on or False if echo is off. Child applications that are expecting you
        to enter a password often set ECHO False. See waitnoecho().

        Not supported on platforms where ``isatty()`` returns False.  &#34;&#34;&#34;

        try:
            attr = termios.tcgetattr(self.fd)
        except termios.error as err:
            errmsg = &#34;getecho() may not be called on this platform&#34;
            if err.args[0] == errno.EINVAL:
                raise IOError(err.args[0], &#34;%s: %s.&#34; % (err.args[1], errmsg))
            raise

        self.echo = bool(attr[3] &amp; termios.ECHO)
        return self.echo

    def setecho(self, state):
        &#34;&#34;&#34;This sets the terminal echo mode on or off. Note that anything the
        child sent before the echo will be lost, so you should be sure that
        your input buffer is empty before you call setecho(). For example, the
        following will work as expected::

            p = pexpect.spawn(&#39;cat&#39;) # Echo is on by default.
            p.sendline(&#39;1234&#39;) # We expect see this twice from the child...
            p.expect([&#39;1234&#39;]) # ... once from the tty echo...
            p.expect([&#39;1234&#39;]) # ... and again from cat itself.
            p.setecho(False) # Turn off tty echo
            p.sendline(&#39;abcd&#39;) # We will set this only once (echoed by cat).
            p.sendline(&#39;wxyz&#39;) # We will set this only once (echoed by cat)
            p.expect([&#39;abcd&#39;])
            p.expect([&#39;wxyz&#39;])

        The following WILL NOT WORK because the lines sent before the setecho
        will be lost::

            p = pexpect.spawn(&#39;cat&#39;)
            p.sendline(&#39;1234&#39;)
            p.setecho(False) # Turn off tty echo
            p.sendline(&#39;abcd&#39;) # We will set this only once (echoed by cat).
            p.sendline(&#39;wxyz&#39;) # We will set this only once (echoed by cat)
            p.expect([&#39;1234&#39;])
            p.expect([&#39;1234&#39;])
            p.expect([&#39;abcd&#39;])
            p.expect([&#39;wxyz&#39;])


        Not supported on platforms where ``isatty()`` returns False.
        &#34;&#34;&#34;
        _setecho(self.fd, state)

        self.echo = state

    def read(self, size=1024) -&gt; bytes:
        &#34;&#34;&#34;Read and return at most ``size`` bytes from the pty.

        Can block if there is nothing to read. Raises :exc:`EOFError` if the
        terminal was closed.

        Unlike Pexpect&#39;s ``read_nonblocking`` method, this doesn&#39;t try to deal
        with the vagaries of EOF on platforms that do strange things, like IRIX
        or older Solaris systems. It handles the errno=EIO pattern used on
        Linux, and the empty-string return used on BSD platforms and (seemingly)
        on recent Solaris.
        &#34;&#34;&#34;
        try:
            s = self.fileobj.read1(size)
        except (OSError, IOError) as err:
            if err.args[0] == errno.EIO:
                # Linux-style EOF
                self.flag_eof = True
                raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
            raise
        if s == b&#34;&#34;:
            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

        return s

    def readline(self):
        &#34;&#34;&#34;Read one line from the pseudoterminal, and return it as unicode.

        Can block if there is nothing to read. Raises :exc:`EOFError` if the
        terminal was closed.
        &#34;&#34;&#34;
        try:
            s = self.fileobj.readline()
        except (OSError, IOError) as err:
            if err.args[0] == errno.EIO:
                # Linux-style EOF
                self.flag_eof = True
                raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
            raise
        if s == b&#34;&#34;:
            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

        return s

    def _writeb(self, b, flush=True):
        n = self.fileobj.write(b)
        if flush:
            self.fileobj.flush()
        return n

    def write(self, s, flush=True) -&gt; int:
        &#34;&#34;&#34;Write bytes to the pseudoterminal.

        Returns the number of bytes written.
        &#34;&#34;&#34;
        return self._writeb(s, flush=flush)

    def sendcontrol(self, char):
        &#34;&#34;&#34;Helper method that wraps send() with mnemonic access for sending control
        character to the child (such as Ctrl-C or Ctrl-D).  For example, to send
        Ctrl-G (ASCII 7, bell, &#39;\a&#39;)::

            child.sendcontrol(&#39;g&#39;)

        See also, sendintr() and sendeof().
        &#34;&#34;&#34;
        char = char.lower()
        a = ord(char)
        if 97 &lt;= a &lt;= 122:
            a = a - ord(&#34;a&#34;) + 1
            byte = _byte(a)
            return self._writeb(byte), byte
        d = {
            &#34;@&#34;: 0,
            &#34;`&#34;: 0,
            &#34;[&#34;: 27,
            &#34;{&#34;: 27,
            &#34;\\&#34;: 28,
            &#34;|&#34;: 28,
            &#34;]&#34;: 29,
            &#34;}&#34;: 29,
            &#34;^&#34;: 30,
            &#34;~&#34;: 30,
            &#34;_&#34;: 31,
            &#34;?&#34;: 127,
        }
        if char not in d:
            return 0, b&#34;&#34;

        byte = _byte(d[char])
        return self._writeb(byte), byte

    def sendeof(self):
        &#34;&#34;&#34;This sends an EOF to the child. This sends a character which causes
        the pending parent output buffer to be sent to the waiting child
        program without waiting for end-of-line. If it is the first character
        of the line, the read() in the user program returns 0, which signifies
        end-of-file. This means to work as expected a sendeof() has to be
        called at the beginning of a line. This method does not send a newline.
        It is the responsibility of the caller to ensure the eof is sent at the
        beginning of a line. &#34;&#34;&#34;

        return self._writeb(_EOF), _EOF

    def sendintr(self):
        &#34;&#34;&#34;This sends a SIGINT to the child. It does not require
        the SIGINT to be the first character on a line. &#34;&#34;&#34;

        return self._writeb(_INTR), _INTR

    def eof(self) -&gt; bool:
        &#34;&#34;&#34;This returns True if the EOF exception was ever raised.
        &#34;&#34;&#34;

        return self.flag_eof

    def terminate(self, force=False):
        &#34;&#34;&#34;This forces a child process to terminate. It starts nicely with
        SIGHUP and SIGINT. If &#34;force&#34; is True then moves onto SIGKILL. This
        returns True if the child was terminated. This returns False if the
        child could not be terminated. &#34;&#34;&#34;

        if not self.isalive():
            return True
        try:
            self.kill(signal.SIGHUP)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGCONT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGINT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            if force:
                self.kill(signal.SIGKILL)
                time.sleep(self.delayafterterminate)
                if not self.isalive():
                    return True
                else:
                    return False
            return False
        except OSError:
            # I think there are kernel timing issues that sometimes cause
            # this to happen. I think isalive() reports True, but the
            # process is dead to the kernel.
            # Make one last attempt to see if the kernel is up to date.
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            else:
                return False

    def wait(self):
        &#34;&#34;&#34;This waits until the child exits. This is a blocking call. This will
        not read any data from the child, so this will block forever if the
        child has unread output and has terminated. In other words, the child
        may have printed output then called exit(), but, the child is
        technically still alive until its output is read by the parent. &#34;&#34;&#34;

        if self.isalive():
            pid, status = os.waitpid(self.pid, 0)
        else:
            return self.exitstatus
        self.exitstatus = os.WEXITSTATUS(status)
        if os.WIFEXITED(status):
            self.status = status
            self.exitstatus = os.WEXITSTATUS(status)
            self.signalstatus = None
            self.terminated = True
        elif os.WIFSIGNALED(status):
            self.status = status
            self.exitstatus = None
            self.signalstatus = os.WTERMSIG(status)
            self.terminated = True
        elif os.WIFSTOPPED(status):  # pragma: no cover
            # You can&#39;t call wait() on a child process in the stopped state.
            raise PtyProcessError(
                &#34;Called wait() on a stopped child &#34;
                + &#34;process. This is not supported. Is some other &#34;
                + &#34;process attempting job control with our child pid?&#34;
            )
        return self.exitstatus

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;This tests if the child process is running or not. This is
        non-blocking. If the child was terminated then this will read the
        exitstatus or signalstatus of the child. This returns True if the child
        process appears to be running or False if not. It can take literally
        SECONDS for Solaris to return the right status. &#34;&#34;&#34;

        if self.terminated:
            return False

        if self.flag_eof:
            # This is for Linux, which requires the blocking form
            # of waitpid to get the status of a defunct process.
            # This is super-lame. The flag_eof would have been set
            # in read_nonblocking(), so this should be safe.
            waitpid_options = 0
        else:
            waitpid_options = os.WNOHANG

        try:
            pid, status = os.waitpid(self.pid, waitpid_options)
        except OSError as e:
            # No child processes
            if e.errno == errno.ECHILD:
                raise PtyProcessError(
                    &#34;isalive() encountered condition &#34;
                    + &#39;where &#34;terminated&#34; is 0, but there was no child &#39;
                    + &#34;process. Did someone else call waitpid() &#34;
                    + &#34;on our process?&#34;
                )
            else:
                raise

        # I have to do this twice for Solaris.
        # I can&#39;t even believe that I figured this out...
        # If waitpid() returns 0 it means that no child process
        # wishes to report, and the value of status is undefined.
        if pid == 0:
            try:
                ### os.WNOHANG) # Solaris!
                pid, status = os.waitpid(self.pid, waitpid_options)
            except OSError as e:  # pragma: no cover
                # This should never happen...
                if e.errno == errno.ECHILD:
                    raise PtyProcessError(
                        &#34;isalive() encountered condition &#34;
                        + &#34;that should never happen. There was no child &#34;
                        + &#34;process. Did someone else call waitpid() &#34;
                        + &#34;on our process?&#34;
                    )
                else:
                    raise

            # If pid is still 0 after two calls to waitpid() then the process
            # really is alive. This seems to work on all platforms, except for
            # Irix which seems to require a blocking call on waitpid or select,
            # so I let read_nonblocking take care of this situation
            # (unfortunately, this requires waiting through the timeout).
            if pid == 0:
                return True

        if pid == 0:
            return True

        if os.WIFEXITED(status):
            self.status = status
            self.exitstatus = os.WEXITSTATUS(status)
            self.signalstatus = None
            self.terminated = True
        elif os.WIFSIGNALED(status):
            self.status = status
            self.exitstatus = None
            self.signalstatus = os.WTERMSIG(status)
            self.terminated = True
        elif os.WIFSTOPPED(status):
            raise PtyProcessError(
                &#34;isalive() encountered condition &#34;
                + &#34;where child process is stopped. This is not &#34;
                + &#34;supported. Is some other process attempting &#34;
                + &#34;job control with our child pid?&#34;
            )
        return False

    def kill(self, sig) -&gt; None:
        &#34;&#34;&#34;Send the given signal to the child application.

        In keeping with UNIX tradition it has a misleading name. It does not
        necessarily kill the child unless you send the right signal. See the
        :mod:`signal` module for constants representing signal numbers.
        &#34;&#34;&#34;

        # Same as os.kill, but the pid is given for you.
        if self.isalive():
            os.kill(self.pid, sig)

    def setwinsize(self, rows, cols):
        &#34;&#34;&#34;Set the terminal window size of the child tty.

        This will cause a SIGWINCH signal to be sent to the child. This does not
        change the physical window size. It changes the size reported to
        TTY-aware applications like vi or curses -- applications that respond to
        the SIGWINCH signal.
        &#34;&#34;&#34;
        return _setwinsize(self.fd, rows, cols)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="scrapli.transport.ptyprocess.PtyProcess.argv"><code class="name">var <span class="ident">argv</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.crlf"><code class="name">var <span class="ident">crlf</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.encoding"><code class="name">var <span class="ident">encoding</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.env"><code class="name">var <span class="ident">env</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.launch_dir"><code class="name">var <span class="ident">launch_dir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.linesep"><code class="name">var <span class="ident">linesep</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.string_type"><code class="name">var <span class="ident">string_type</span></code></dt>
<dd>
<div class="desc"><p>bytes(iterable_of_ints) -&gt; bytes
bytes(string, encoding[, errors]) -&gt; bytes
bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer
bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes
bytes() -&gt; empty bytes object</p>
<p>Construct an immutable array of bytes from:
- an iterable yielding integers in range(256)
- a text string encoded using the specified encoding
- any object implementing the buffer API.
- an integer</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scrapli.transport.ptyprocess.PtyProcess.spawn"><code class="name flex">
<span>def <span class="ident">spawn</span></span>(<span>argv, cwd=None, env=None, echo=True, preexec_fn=None, dimensions=(24, 80), pass_fds=()) ->Â ~PtyProcessType</span>
</code></dt>
<dd>
<div class="desc"><p>Start the given command in a child process in a pseudo terminal.</p>
<p>This does all the fork/exec type of stuff for a pty, and returns an
instance of PtyProcess.</p>
<p>If preexec_fn is supplied, it will be called with no arguments in the
child process before exec-ing the specified command.
It may, for instance, set signal handlers to SIG_DFL or SIG_IGN.</p>
<p>Dimensions of the psuedoterminal used for the subprocess can be
specified as a tuple (rows, cols), or the default (24, 80) will be used.</p>
<p>By default, all file descriptors except 0, 1 and 2 are closed. This
behavior can be overridden with pass_fds, a list of file descriptors to
keep open between the parent and the child.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def spawn(
    cls: Type[PtyProcessType],
    argv,
    cwd=None,
    env=None,
    echo=True,
    preexec_fn=None,
    dimensions=(24, 80),
    pass_fds=(),
) -&gt; PtyProcessType:
    &#34;&#34;&#34;Start the given command in a child process in a pseudo terminal.

    This does all the fork/exec type of stuff for a pty, and returns an
    instance of PtyProcess.

    If preexec_fn is supplied, it will be called with no arguments in the
    child process before exec-ing the specified command.
    It may, for instance, set signal handlers to SIG_DFL or SIG_IGN.

    Dimensions of the psuedoterminal used for the subprocess can be
    specified as a tuple (rows, cols), or the default (24, 80) will be used.

    By default, all file descriptors except 0, 1 and 2 are closed. This
    behavior can be overridden with pass_fds, a list of file descriptors to
    keep open between the parent and the child.
    &#34;&#34;&#34;
    # Note that it is difficult for this method to fail.
    # You cannot detect if the child process cannot start.
    # So the only way you can tell if the child process started
    # or not is to try to read from the file descriptor. If you get
    # EOF immediately then it means that the child is already dead.
    # That may not necessarily be bad because you may have spawned a child
    # that performs some task; creates no stdout output; and then dies.

    import fcntl
    import pty
    import termios
    import resource
    from pty import CHILD, STDIN_FILENO

    if not isinstance(argv, (list, tuple)):
        raise TypeError(&#34;Expected a list or tuple for argv, got %r&#34; % argv)

    # Shallow copy of argv so we can modify it
    argv = argv[:]
    command = argv[0]

    command_with_path = which(command)
    if command_with_path is None:
        raise FileNotFoundError(
            &#34;The command was not found or was not &#34; + &#34;executable: %s.&#34; % command
        )
    command = command_with_path
    argv[0] = command

    # [issue #119] To prevent the case where exec fails and the user is
    # stuck interacting with a python child process instead of whatever
    # was expected, we implement the solution from
    # http://stackoverflow.com/a/3703179 to pass the exception to the
    # parent process

    # [issue #119] 1. Before forking, open a pipe in the parent process.
    exec_err_pipe_read, exec_err_pipe_write = os.pipe()

    pid, fd = pty.fork()

    # Some platforms must call setwinsize() and setecho() from the
    # child process, and others from the master process. We do both,
    # allowing IOError for either.

    if pid == CHILD:
        # set window size
        try:
            _setwinsize(STDIN_FILENO, *dimensions)
        except IOError as err:
            if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                raise

        # disable echo if spawn argument echo was unset
        if not echo:
            try:
                _setecho(STDIN_FILENO, False)
            except (IOError, termios.error) as err:
                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                    raise

        # [issue #119] 3. The child closes the reading end and sets the
        # close-on-exec flag for the writing end.
        os.close(exec_err_pipe_read)
        fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)

        # Do not allow child to inherit open file descriptors from parent,
        # with the exception of the exec_err_pipe_write of the pipe
        # and pass_fds.
        # Impose ceiling on max_fd: AIX bugfix for users with unlimited
        # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()
        # occasionally raises out of range error
        max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])
        spass_fds = sorted(set(pass_fds) | {exec_err_pipe_write})
        for pair in zip([2] + spass_fds, spass_fds + [max_fd]):
            os.closerange(pair[0] + 1, pair[1])

        if cwd is not None:
            os.chdir(cwd)

        if preexec_fn is not None:
            try:
                preexec_fn()
            except Exception as e:
                ename = type(e).__name__
                tosend = &#34;{}:0:{}&#34;.format(ename, str(e))
                tosend = tosend.encode(&#34;utf-8&#34;)

                os.write(exec_err_pipe_write, tosend)
                os.close(exec_err_pipe_write)
                os._exit(1)

        try:
            if env is None:
                os.execv(command, argv)
            else:
                os.execvpe(command, argv, env)
        except OSError as err:
            # [issue #119] 5. If exec fails, the child writes the error
            # code back to the parent using the pipe, then exits.
            tosend = &#34;OSError:{}:{}&#34;.format(err.errno, str(err))
            tosend = tosend.encode(&#34;utf-8&#34;)
            os.write(exec_err_pipe_write, tosend)
            os.close(exec_err_pipe_write)
            os._exit(os.EX_OSERR)

    # Parent
    inst = cls(pid, fd)

    # Set some informational attributes
    inst.argv = argv
    if env is not None:
        inst.env = env
    if cwd is not None:
        inst.launch_dir = cwd

    # [issue #119] 2. After forking, the parent closes the writing end
    # of the pipe and reads from the reading end.
    os.close(exec_err_pipe_write)
    exec_err_data = os.read(exec_err_pipe_read, 4096)
    os.close(exec_err_pipe_read)

    # [issue #119] 6. The parent reads eof (a zero-length read) if the
    # child successfully performed exec, since close-on-exec made
    # successful exec close the writing end of the pipe. Or, if exec
    # failed, the parent reads the error code and can proceed
    # accordingly. Either way, the parent blocks until the child calls
    # exec.
    if len(exec_err_data) != 0:
        try:
            errclass, errno_s, errmsg = exec_err_data.split(b&#34;:&#34;, 2)
            exctype = getattr(builtins, errclass.decode(&#34;ascii&#34;), Exception)

            exception = exctype(errmsg.decode(&#34;utf-8&#34;, &#34;replace&#34;))
            if exctype is OSError:
                exception.errno = int(errno_s)
        except:
            raise Exception(&#34;Subprocess failed, got bad error data: %r&#34; % exec_err_data)
        else:
            raise exception

    try:
        inst.setwinsize(*dimensions)
    except IOError as err:
        if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):
            raise

    return inst</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.write_to_stdout"><code class="name flex">
<span>def <span class="ident">write_to_stdout</span></span>(<span>b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_to_stdout(b):
    try:
        return sys.stdout.buffer.write(b)
    except AttributeError:
        # If stdout has been replaced, it may not have .buffer
        return sys.stdout.write(b.decode(&#34;ascii&#34;, &#34;replace&#34;))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.ptyprocess.PtyProcess.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, force=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This closes the connection with the child application. Note that
calling close() more than once is valid. This emulates standard Python
behavior with files. Set force to True if you want to make sure that
the child is terminated (SIGKILL is sent if the child ignores SIGHUP
and SIGINT).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, force=True):
    &#34;&#34;&#34;This closes the connection with the child application. Note that
    calling close() more than once is valid. This emulates standard Python
    behavior with files. Set force to True if you want to make sure that
    the child is terminated (SIGKILL is sent if the child ignores SIGHUP
    and SIGINT). &#34;&#34;&#34;
    if not self.closed:
        self.flush()
        self.fileobj.close()  # Closes the file descriptor
        # Give kernel time to update process status.
        time.sleep(self.delayafterclose)
        if self.isalive():
            if not self.terminate(force):
                raise PtyProcessError(&#34;Could not terminate the child.&#34;)
        self.fd = -1
        self.closed = True</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.eof"><code class="name flex">
<span>def <span class="ident">eof</span></span>(<span>self) ->Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>This returns True if the EOF exception was ever raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eof(self) -&gt; bool:
    &#34;&#34;&#34;This returns True if the EOF exception was ever raised.
    &#34;&#34;&#34;

    return self.flag_eof</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.fileno"><code class="name flex">
<span>def <span class="ident">fileno</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This returns the file descriptor of the pty for the child.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fileno(self):
    &#34;&#34;&#34;This returns the file descriptor of the pty for the child.
    &#34;&#34;&#34;
    return self.fd</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self) ->Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This does nothing. It is here to support the interface for a
File-like object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self) -&gt; None:
    &#34;&#34;&#34;This does nothing. It is here to support the interface for a
    File-like object. &#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.getecho"><code class="name flex">
<span>def <span class="ident">getecho</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This returns the terminal echo mode. This returns True if echo is
on or False if echo is off. Child applications that are expecting you
to enter a password often set ECHO False. See waitnoecho().</p>
<p>Not supported on platforms where <code>isatty()</code> returns False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getecho(self):
    &#34;&#34;&#34;This returns the terminal echo mode. This returns True if echo is
    on or False if echo is off. Child applications that are expecting you
    to enter a password often set ECHO False. See waitnoecho().

    Not supported on platforms where ``isatty()`` returns False.  &#34;&#34;&#34;

    try:
        attr = termios.tcgetattr(self.fd)
    except termios.error as err:
        errmsg = &#34;getecho() may not be called on this platform&#34;
        if err.args[0] == errno.EINVAL:
            raise IOError(err.args[0], &#34;%s: %s.&#34; % (err.args[1], errmsg))
        raise

    self.echo = bool(attr[3] &amp; termios.ECHO)
    return self.echo</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self) ->Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>This tests if the child process is running or not. This is
non-blocking. If the child was terminated then this will read the
exitstatus or signalstatus of the child. This returns True if the child
process appears to be running or False if not. It can take literally
SECONDS for Solaris to return the right status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;This tests if the child process is running or not. This is
    non-blocking. If the child was terminated then this will read the
    exitstatus or signalstatus of the child. This returns True if the child
    process appears to be running or False if not. It can take literally
    SECONDS for Solaris to return the right status. &#34;&#34;&#34;

    if self.terminated:
        return False

    if self.flag_eof:
        # This is for Linux, which requires the blocking form
        # of waitpid to get the status of a defunct process.
        # This is super-lame. The flag_eof would have been set
        # in read_nonblocking(), so this should be safe.
        waitpid_options = 0
    else:
        waitpid_options = os.WNOHANG

    try:
        pid, status = os.waitpid(self.pid, waitpid_options)
    except OSError as e:
        # No child processes
        if e.errno == errno.ECHILD:
            raise PtyProcessError(
                &#34;isalive() encountered condition &#34;
                + &#39;where &#34;terminated&#34; is 0, but there was no child &#39;
                + &#34;process. Did someone else call waitpid() &#34;
                + &#34;on our process?&#34;
            )
        else:
            raise

    # I have to do this twice for Solaris.
    # I can&#39;t even believe that I figured this out...
    # If waitpid() returns 0 it means that no child process
    # wishes to report, and the value of status is undefined.
    if pid == 0:
        try:
            ### os.WNOHANG) # Solaris!
            pid, status = os.waitpid(self.pid, waitpid_options)
        except OSError as e:  # pragma: no cover
            # This should never happen...
            if e.errno == errno.ECHILD:
                raise PtyProcessError(
                    &#34;isalive() encountered condition &#34;
                    + &#34;that should never happen. There was no child &#34;
                    + &#34;process. Did someone else call waitpid() &#34;
                    + &#34;on our process?&#34;
                )
            else:
                raise

        # If pid is still 0 after two calls to waitpid() then the process
        # really is alive. This seems to work on all platforms, except for
        # Irix which seems to require a blocking call on waitpid or select,
        # so I let read_nonblocking take care of this situation
        # (unfortunately, this requires waiting through the timeout).
        if pid == 0:
            return True

    if pid == 0:
        return True

    if os.WIFEXITED(status):
        self.status = status
        self.exitstatus = os.WEXITSTATUS(status)
        self.signalstatus = None
        self.terminated = True
    elif os.WIFSIGNALED(status):
        self.status = status
        self.exitstatus = None
        self.signalstatus = os.WTERMSIG(status)
        self.terminated = True
    elif os.WIFSTOPPED(status):
        raise PtyProcessError(
            &#34;isalive() encountered condition &#34;
            + &#34;where child process is stopped. This is not &#34;
            + &#34;supported. Is some other process attempting &#34;
            + &#34;job control with our child pid?&#34;
        )
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.isatty"><code class="name flex">
<span>def <span class="ident">isatty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This returns True if the file descriptor is open and connected to a
tty(-like) device, else False.</p>
<p>On SVR4-style platforms implementing streams, such as SunOS and HP-UX,
the child pty may not appear as a terminal device.
This means
methods such as setecho(), setwinsize(), getwinsize() may raise an
IOError.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isatty(self):
    &#34;&#34;&#34;This returns True if the file descriptor is open and connected to a
    tty(-like) device, else False.

    On SVR4-style platforms implementing streams, such as SunOS and HP-UX,
    the child pty may not appear as a terminal device.  This means
    methods such as setecho(), setwinsize(), getwinsize() may raise an
    IOError. &#34;&#34;&#34;

    return os.isatty(self.fd)</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self, sig) ->Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Send the given signal to the child application.</p>
<p>In keeping with UNIX tradition it has a misleading name. It does not
necessarily kill the child unless you send the right signal. See the
:mod:<code>signal</code> module for constants representing signal numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self, sig) -&gt; None:
    &#34;&#34;&#34;Send the given signal to the child application.

    In keeping with UNIX tradition it has a misleading name. It does not
    necessarily kill the child unless you send the right signal. See the
    :mod:`signal` module for constants representing signal numbers.
    &#34;&#34;&#34;

    # Same as os.kill, but the pid is given for you.
    if self.isalive():
        os.kill(self.pid, sig)</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size=1024) ->Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Read and return at most <code>size</code> bytes from the pty.</p>
<p>Can block if there is nothing to read. Raises :exc:<code>EOFError</code> if the
terminal was closed.</p>
<p>Unlike Pexpect's <code>read_nonblocking</code> method, this doesn't try to deal
with the vagaries of EOF on platforms that do strange things, like IRIX
or older Solaris systems. It handles the errno=EIO pattern used on
Linux, and the empty-string return used on BSD platforms and (seemingly)
on recent Solaris.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size=1024) -&gt; bytes:
    &#34;&#34;&#34;Read and return at most ``size`` bytes from the pty.

    Can block if there is nothing to read. Raises :exc:`EOFError` if the
    terminal was closed.

    Unlike Pexpect&#39;s ``read_nonblocking`` method, this doesn&#39;t try to deal
    with the vagaries of EOF on platforms that do strange things, like IRIX
    or older Solaris systems. It handles the errno=EIO pattern used on
    Linux, and the empty-string return used on BSD platforms and (seemingly)
    on recent Solaris.
    &#34;&#34;&#34;
    try:
        s = self.fileobj.read1(size)
    except (OSError, IOError) as err:
        if err.args[0] == errno.EIO:
            # Linux-style EOF
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
        raise
    if s == b&#34;&#34;:
        # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
        self.flag_eof = True
        raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

    return s</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.readline"><code class="name flex">
<span>def <span class="ident">readline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read one line from the pseudoterminal, and return it as unicode.</p>
<p>Can block if there is nothing to read. Raises :exc:<code>EOFError</code> if the
terminal was closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readline(self):
    &#34;&#34;&#34;Read one line from the pseudoterminal, and return it as unicode.

    Can block if there is nothing to read. Raises :exc:`EOFError` if the
    terminal was closed.
    &#34;&#34;&#34;
    try:
        s = self.fileobj.readline()
    except (OSError, IOError) as err:
        if err.args[0] == errno.EIO:
            # Linux-style EOF
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
        raise
    if s == b&#34;&#34;:
        # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
        self.flag_eof = True
        raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

    return s</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.sendcontrol"><code class="name flex">
<span>def <span class="ident">sendcontrol</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper method that wraps send() with mnemonic access for sending control
character to the child (such as Ctrl-C or Ctrl-D).
For example, to send
Ctrl-G (ASCII 7, bell, '')::</p>
<pre><code>child.sendcontrol('g')
</code></pre>
<p>See also, sendintr() and sendeof().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendcontrol(self, char):
    &#34;&#34;&#34;Helper method that wraps send() with mnemonic access for sending control
    character to the child (such as Ctrl-C or Ctrl-D).  For example, to send
    Ctrl-G (ASCII 7, bell, &#39;\a&#39;)::

        child.sendcontrol(&#39;g&#39;)

    See also, sendintr() and sendeof().
    &#34;&#34;&#34;
    char = char.lower()
    a = ord(char)
    if 97 &lt;= a &lt;= 122:
        a = a - ord(&#34;a&#34;) + 1
        byte = _byte(a)
        return self._writeb(byte), byte
    d = {
        &#34;@&#34;: 0,
        &#34;`&#34;: 0,
        &#34;[&#34;: 27,
        &#34;{&#34;: 27,
        &#34;\\&#34;: 28,
        &#34;|&#34;: 28,
        &#34;]&#34;: 29,
        &#34;}&#34;: 29,
        &#34;^&#34;: 30,
        &#34;~&#34;: 30,
        &#34;_&#34;: 31,
        &#34;?&#34;: 127,
    }
    if char not in d:
        return 0, b&#34;&#34;

    byte = _byte(d[char])
    return self._writeb(byte), byte</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.sendeof"><code class="name flex">
<span>def <span class="ident">sendeof</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This sends an EOF to the child. This sends a character which causes
the pending parent output buffer to be sent to the waiting child
program without waiting for end-of-line. If it is the first character
of the line, the read() in the user program returns 0, which signifies
end-of-file. This means to work as expected a sendeof() has to be
called at the beginning of a line. This method does not send a newline.
It is the responsibility of the caller to ensure the eof is sent at the
beginning of a line.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendeof(self):
    &#34;&#34;&#34;This sends an EOF to the child. This sends a character which causes
    the pending parent output buffer to be sent to the waiting child
    program without waiting for end-of-line. If it is the first character
    of the line, the read() in the user program returns 0, which signifies
    end-of-file. This means to work as expected a sendeof() has to be
    called at the beginning of a line. This method does not send a newline.
    It is the responsibility of the caller to ensure the eof is sent at the
    beginning of a line. &#34;&#34;&#34;

    return self._writeb(_EOF), _EOF</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.sendintr"><code class="name flex">
<span>def <span class="ident">sendintr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This sends a SIGINT to the child. It does not require
the SIGINT to be the first character on a line.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendintr(self):
    &#34;&#34;&#34;This sends a SIGINT to the child. It does not require
    the SIGINT to be the first character on a line. &#34;&#34;&#34;

    return self._writeb(_INTR), _INTR</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.setecho"><code class="name flex">
<span>def <span class="ident">setecho</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>This sets the terminal echo mode on or off. Note that anything the
child sent before the echo will be lost, so you should be sure that
your input buffer is empty before you call setecho(). For example, the
following will work as expected::</p>
<pre><code>p = pexpect.spawn('cat') # Echo is on by default.
p.sendline('1234') # We expect see this twice from the child...
p.expect(['1234']) # ... once from the tty echo...
p.expect(['1234']) # ... and again from cat itself.
p.setecho(False) # Turn off tty echo
p.sendline('abcd') # We will set this only once (echoed by cat).
p.sendline('wxyz') # We will set this only once (echoed by cat)
p.expect(['abcd'])
p.expect(['wxyz'])
</code></pre>
<p>The following WILL NOT WORK because the lines sent before the setecho
will be lost::</p>
<pre><code>p = pexpect.spawn('cat')
p.sendline('1234')
p.setecho(False) # Turn off tty echo
p.sendline('abcd') # We will set this only once (echoed by cat).
p.sendline('wxyz') # We will set this only once (echoed by cat)
p.expect(['1234'])
p.expect(['1234'])
p.expect(['abcd'])
p.expect(['wxyz'])
</code></pre>
<p>Not supported on platforms where <code>isatty()</code> returns False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setecho(self, state):
    &#34;&#34;&#34;This sets the terminal echo mode on or off. Note that anything the
    child sent before the echo will be lost, so you should be sure that
    your input buffer is empty before you call setecho(). For example, the
    following will work as expected::

        p = pexpect.spawn(&#39;cat&#39;) # Echo is on by default.
        p.sendline(&#39;1234&#39;) # We expect see this twice from the child...
        p.expect([&#39;1234&#39;]) # ... once from the tty echo...
        p.expect([&#39;1234&#39;]) # ... and again from cat itself.
        p.setecho(False) # Turn off tty echo
        p.sendline(&#39;abcd&#39;) # We will set this only once (echoed by cat).
        p.sendline(&#39;wxyz&#39;) # We will set this only once (echoed by cat)
        p.expect([&#39;abcd&#39;])
        p.expect([&#39;wxyz&#39;])

    The following WILL NOT WORK because the lines sent before the setecho
    will be lost::

        p = pexpect.spawn(&#39;cat&#39;)
        p.sendline(&#39;1234&#39;)
        p.setecho(False) # Turn off tty echo
        p.sendline(&#39;abcd&#39;) # We will set this only once (echoed by cat).
        p.sendline(&#39;wxyz&#39;) # We will set this only once (echoed by cat)
        p.expect([&#39;1234&#39;])
        p.expect([&#39;1234&#39;])
        p.expect([&#39;abcd&#39;])
        p.expect([&#39;wxyz&#39;])


    Not supported on platforms where ``isatty()`` returns False.
    &#34;&#34;&#34;
    _setecho(self.fd, state)

    self.echo = state</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.setwinsize"><code class="name flex">
<span>def <span class="ident">setwinsize</span></span>(<span>self, rows, cols)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the terminal window size of the child tty.</p>
<p>This will cause a SIGWINCH signal to be sent to the child. This does not
change the physical window size. It changes the size reported to
TTY-aware applications like vi or curses &ndash; applications that respond to
the SIGWINCH signal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setwinsize(self, rows, cols):
    &#34;&#34;&#34;Set the terminal window size of the child tty.

    This will cause a SIGWINCH signal to be sent to the child. This does not
    change the physical window size. It changes the size reported to
    TTY-aware applications like vi or curses -- applications that respond to
    the SIGWINCH signal.
    &#34;&#34;&#34;
    return _setwinsize(self.fd, rows, cols)</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.terminate"><code class="name flex">
<span>def <span class="ident">terminate</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This forces a child process to terminate. It starts nicely with
SIGHUP and SIGINT. If "force" is True then moves onto SIGKILL. This
returns True if the child was terminated. This returns False if the
child could not be terminated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminate(self, force=False):
    &#34;&#34;&#34;This forces a child process to terminate. It starts nicely with
    SIGHUP and SIGINT. If &#34;force&#34; is True then moves onto SIGKILL. This
    returns True if the child was terminated. This returns False if the
    child could not be terminated. &#34;&#34;&#34;

    if not self.isalive():
        return True
    try:
        self.kill(signal.SIGHUP)
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
        self.kill(signal.SIGCONT)
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
        self.kill(signal.SIGINT)
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
        if force:
            self.kill(signal.SIGKILL)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            else:
                return False
        return False
    except OSError:
        # I think there are kernel timing issues that sometimes cause
        # this to happen. I think isalive() reports True, but the
        # process is dead to the kernel.
        # Make one last attempt to see if the kernel is up to date.
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This waits until the child exits. This is a blocking call. This will
not read any data from the child, so this will block forever if the
child has unread output and has terminated. In other words, the child
may have printed output then called exit(), but, the child is
technically still alive until its output is read by the parent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self):
    &#34;&#34;&#34;This waits until the child exits. This is a blocking call. This will
    not read any data from the child, so this will block forever if the
    child has unread output and has terminated. In other words, the child
    may have printed output then called exit(), but, the child is
    technically still alive until its output is read by the parent. &#34;&#34;&#34;

    if self.isalive():
        pid, status = os.waitpid(self.pid, 0)
    else:
        return self.exitstatus
    self.exitstatus = os.WEXITSTATUS(status)
    if os.WIFEXITED(status):
        self.status = status
        self.exitstatus = os.WEXITSTATUS(status)
        self.signalstatus = None
        self.terminated = True
    elif os.WIFSIGNALED(status):
        self.status = status
        self.exitstatus = None
        self.signalstatus = os.WTERMSIG(status)
        self.terminated = True
    elif os.WIFSTOPPED(status):  # pragma: no cover
        # You can&#39;t call wait() on a child process in the stopped state.
        raise PtyProcessError(
            &#34;Called wait() on a stopped child &#34;
            + &#34;process. This is not supported. Is some other &#34;
            + &#34;process attempting job control with our child pid?&#34;
        )
    return self.exitstatus</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.waitnoecho"><code class="name flex">
<span>def <span class="ident">waitnoecho</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This waits until the terminal ECHO flag is set False. This returns
True if the echo mode is off. This returns False if the ECHO flag was
not set False before the timeout. This can be used to detect when the
child is waiting for a password. Usually a child application will turn
off echo mode when it is waiting for the user to enter a password. For
example, instead of expecting the "password:" prompt you can wait for
the child to set ECHO off::</p>
<pre><code>p = pexpect.spawn('ssh user@example.com')
p.waitnoecho()
p.sendline(mypassword)
</code></pre>
<p>If timeout==None then this method to block until ECHO flag is False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitnoecho(self, timeout=None):
    &#34;&#34;&#34;This waits until the terminal ECHO flag is set False. This returns
    True if the echo mode is off. This returns False if the ECHO flag was
    not set False before the timeout. This can be used to detect when the
    child is waiting for a password. Usually a child application will turn
    off echo mode when it is waiting for the user to enter a password. For
    example, instead of expecting the &#34;password:&#34; prompt you can wait for
    the child to set ECHO off::

        p = pexpect.spawn(&#39;ssh user@example.com&#39;)
        p.waitnoecho()
        p.sendline(mypassword)

    If timeout==None then this method to block until ECHO flag is False.
    &#34;&#34;&#34;

    if timeout is not None:
        end_time = time.time() + timeout
    while True:
        if not self.getecho():
            return True
        if timeout &lt; 0 and timeout is not None:
            return False
        if timeout is not None:
            timeout = end_time - time.time()
        time.sleep(0.1)</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, s, flush=True) ->Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Write bytes to the pseudoterminal.</p>
<p>Returns the number of bytes written.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, s, flush=True) -&gt; int:
    &#34;&#34;&#34;Write bytes to the pseudoterminal.

    Returns the number of bytes written.
    &#34;&#34;&#34;
    return self._writeb(s, flush=flush)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcessError"><code class="flex name class">
<span>class <span class="ident">PtyProcessError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic error class for this package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PtyProcessError(Exception):
    &#34;&#34;&#34;Generic error class for this package.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.transport" href="index.html">scrapli.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.transport.ptyprocess.PtyProcess" href="#scrapli.transport.ptyprocess.PtyProcess">PtyProcess</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.argv" href="#scrapli.transport.ptyprocess.PtyProcess.argv">argv</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.close" href="#scrapli.transport.ptyprocess.PtyProcess.close">close</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.crlf" href="#scrapli.transport.ptyprocess.PtyProcess.crlf">crlf</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.encoding" href="#scrapli.transport.ptyprocess.PtyProcess.encoding">encoding</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.env" href="#scrapli.transport.ptyprocess.PtyProcess.env">env</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.eof" href="#scrapli.transport.ptyprocess.PtyProcess.eof">eof</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.fileno" href="#scrapli.transport.ptyprocess.PtyProcess.fileno">fileno</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.flush" href="#scrapli.transport.ptyprocess.PtyProcess.flush">flush</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.getecho" href="#scrapli.transport.ptyprocess.PtyProcess.getecho">getecho</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.isalive" href="#scrapli.transport.ptyprocess.PtyProcess.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.isatty" href="#scrapli.transport.ptyprocess.PtyProcess.isatty">isatty</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.kill" href="#scrapli.transport.ptyprocess.PtyProcess.kill">kill</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.launch_dir" href="#scrapli.transport.ptyprocess.PtyProcess.launch_dir">launch_dir</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.linesep" href="#scrapli.transport.ptyprocess.PtyProcess.linesep">linesep</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.read" href="#scrapli.transport.ptyprocess.PtyProcess.read">read</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.readline" href="#scrapli.transport.ptyprocess.PtyProcess.readline">readline</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.sendcontrol" href="#scrapli.transport.ptyprocess.PtyProcess.sendcontrol">sendcontrol</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.sendeof" href="#scrapli.transport.ptyprocess.PtyProcess.sendeof">sendeof</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.sendintr" href="#scrapli.transport.ptyprocess.PtyProcess.sendintr">sendintr</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.setecho" href="#scrapli.transport.ptyprocess.PtyProcess.setecho">setecho</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.setwinsize" href="#scrapli.transport.ptyprocess.PtyProcess.setwinsize">setwinsize</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.spawn" href="#scrapli.transport.ptyprocess.PtyProcess.spawn">spawn</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.string_type" href="#scrapli.transport.ptyprocess.PtyProcess.string_type">string_type</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.terminate" href="#scrapli.transport.ptyprocess.PtyProcess.terminate">terminate</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.wait" href="#scrapli.transport.ptyprocess.PtyProcess.wait">wait</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.waitnoecho" href="#scrapli.transport.ptyprocess.PtyProcess.waitnoecho">waitnoecho</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.write" href="#scrapli.transport.ptyprocess.PtyProcess.write">write</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.write_to_stdout" href="#scrapli.transport.ptyprocess.PtyProcess.write_to_stdout">write_to_stdout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.ptyprocess.PtyProcessError" href="#scrapli.transport.ptyprocess.PtyProcessError">PtyProcessError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>