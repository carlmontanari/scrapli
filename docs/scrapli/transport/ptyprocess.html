<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>scrapli.transport.ptyprocess API documentation</title>
<meta name="description" content="Ptyprocess is under the ISC license, as code derived from Pexpect.
http://opensource.org/licenses/ISC â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.transport.ptyprocess</code></h1>
</header>
<section id="section-intro">
<p>Ptyprocess is under the ISC license, as code derived from Pexpect.
<a href="http://opensource.org/licenses/ISC">http://opensource.org/licenses/ISC</a></p>
<p>Copyright (c) 2013-2014, Pexpect development team
Copyright (c) 2012, Noah Spurrier <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#110;&#111;&#97;&#104;&#64;&#110;&#111;&#97;&#104;&#46;&#111;&#114;&#103;">&#110;&#111;&#97;&#104;&#64;&#110;&#111;&#97;&#104;&#46;&#111;&#114;&#103;</a></p>
<p>PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY PURPOSE
WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE COPYRIGHT NOTICE
AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES. THE SOFTWARE IS PROVIDED
"AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</p>
<p>Thank you to the folks who create and maintain pexpect, vendoring this here
has been ridiculously helpful! -CM</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Ptyprocess is under the ISC license, as code derived from Pexpect.
    http://opensource.org/licenses/ISC

Copyright (c) 2013-2014, Pexpect development team
Copyright (c) 2012, Noah Spurrier &lt;noah@noah.org&gt;

PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY PURPOSE
WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE COPYRIGHT NOTICE
AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES. THE SOFTWARE IS PROVIDED
&#34;AS IS&#34; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Thank you to the folks who create and maintain pexpect, vendoring this here
has been ridiculously helpful! -CM
&#34;&#34;&#34;

import builtins
import errno
import io
import os
import signal
import struct
import sys
import time
from shutil import which
from typing import List, Optional, Type, TypeVar

from scrapli.exceptions import SSHNotFound


class PtyProcessError(Exception):
    &#34;&#34;&#34;Generic error class for this package.&#34;&#34;&#34;


PtyProcessType = TypeVar(&#34;PtyProcessType&#34;, bound=&#34;PtyProcess&#34;)


_EOF, _INTR = None, None


def _make_eof_intr() -&gt; None:
    &#34;&#34;&#34;
    Set constants _EOF and _INTR.

    This avoids doing potentially costly operations on module load.

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    import termios

    global _EOF, _INTR
    if (_EOF is not None) and (_INTR is not None):
        return

    # inherit EOF and INTR definitions from controlling process.
    try:
        from termios import VEOF, VINTR

        fd = None
        for name in &#34;stdin&#34;, &#34;stdout&#34;:
            stream = getattr(sys, &#34;__%s__&#34; % name, None)
            if stream is None or not hasattr(stream, &#34;fileno&#34;):
                continue
            try:
                fd = stream.fileno()
            except ValueError:
                continue
        if fd is None:
            # no fd, raise ValueError to fallback on CEOF, CINTR
            raise ValueError(&#34;No stream has a fileno&#34;)
        intr = ord(termios.tcgetattr(fd)[6][VINTR])
        eof = ord(termios.tcgetattr(fd)[6][VEOF])
    except (ImportError, OSError, IOError, ValueError, termios.error):
        # unless the controlling process is also not a terminal,
        # such as cron(1), or when stdin and stdout are both closed.
        # Fall-back to using CEOF and CINTR. There
        try:
            from termios import CEOF, CINTR

            (intr, eof) = (CINTR, CEOF)
        except ImportError:
            (intr, eof) = (3, 4)

    _INTR = bytes([intr])
    _EOF = bytes([eof])


def _setwinsize(fd: int, rows: int, cols: int) -&gt; None:
    &#34;&#34;&#34;
    Set window size.

    Some very old platforms have a bug that causes the value for termios.TIOCSWINSZ to be truncated.
    There was a hack here to work around this, but it caused problems with newer platforms so has
    been removed. For details see https://github.com/pexpect/pexpect/issues/39

    Args:
        fd: file descriptor
        rows: int number of rows for terminal
        cols: int number of cols for terminal

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    import termios
    import fcntl

    TIOCSWINSZ = getattr(termios, &#34;TIOCSWINSZ&#34;, -2146929561)
    # Note, assume ws_xpixel and ws_ypixel are zero.
    s = struct.pack(&#34;HHHH&#34;, rows, cols, 0, 0)
    fcntl.ioctl(fd, TIOCSWINSZ, s)


class PtyProcess:
    def __init__(self, pid: int, fd: int) -&gt; None:
        &#34;&#34;&#34;
        This class represents a process running in a pseudoterminal.

        The main constructor is the `spawn` method.

        Args:
            pid: integer value of pid
            fd: integer value of fd

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        _make_eof_intr()  # Ensure _EOF and _INTR are calculated
        self.pid = pid
        self.fd = fd
        readf = io.open(fd, &#34;rb&#34;, buffering=0)
        writef = io.open(fd, &#34;wb&#34;, buffering=0, closefd=False)
        self.fileobj = io.BufferedRWPair(readf, writef)  # type: ignore

        self.terminated = False
        self.closed = False
        self.exitstatus: Optional[int] = None
        self.signalstatus: Optional[int] = None
        # status returned by os.waitpid
        self.status: Optional[int] = None
        self.flag_eof = False
        # Used by close() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterclose = 0.1
        # Used by terminate() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterterminate = 0.1

    @classmethod
    def spawn(cls: Type[PtyProcessType], spawn_command: List[str]) -&gt; PtyProcessType:
        &#34;&#34;&#34;Start the given command in a child process in a pseudo terminal.

        This does all the fork/exec type of stuff for a pty, and returns an
        instance of PtyProcess.
        &#34;&#34;&#34;
        # Note that it is difficult for this method to fail.
        # You cannot detect if the child process cannot start.
        # So the only way you can tell if the child process started
        # or not is to try to read from the file descriptor. If you get
        # EOF immediately then it means that the child is already dead.
        # That may not necessarily be bad because you may have spawned a child
        # that performs some task; creates no stdout output; and then dies.

        import fcntl
        import pty
        import resource
        from pty import CHILD, STDIN_FILENO

        spawn_executable = which(spawn_command[0])
        if spawn_executable is None:
            raise SSHNotFound(&#34;ssh executable not found!&#34;)
        spawn_command[0] = spawn_executable

        # [issue #119] To prevent the case where exec fails and the user is
        # stuck interacting with a python child process instead of whatever
        # was expected, we implement the solution from
        # http://stackoverflow.com/a/3703179 to pass the exception to the
        # parent process
        # [issue #119] 1. Before forking, open a pipe in the parent process.
        exec_err_pipe_read, exec_err_pipe_write = os.pipe()

        pid, fd = pty.fork()

        # Some platforms must call setwinsize() and setecho() from the
        # child process, and others from the master process. We do both,
        # allowing IOError for either.
        if pid == CHILD:
            try:
                _setwinsize(fd=STDIN_FILENO, rows=24, cols=80)
            except IOError as err:
                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                    raise

            # [issue #119] 3. The child closes the reading end and sets the
            # close-on-exec flag for the writing end.
            os.close(exec_err_pipe_read)
            fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)

            # Do not allow child to inherit open file descriptors from parent,
            # with the exception of the exec_err_pipe_write of the pipe.
            # Impose ceiling on max_fd: AIX bugfix for users with unlimited
            # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()
            # occasionally raises out of range error
            max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])
            pass_fds = sorted({exec_err_pipe_write})
            for pair in zip([2] + pass_fds, pass_fds + [max_fd]):
                os.closerange(pair[0] + 1, pair[1])

            try:
                os.execv(spawn_executable, spawn_command)
            except OSError as err:
                # [issue #119] 5. If exec fails, the child writes the error
                # code back to the parent using the pipe, then exits.
                tosend = f&#34;OSError:{err.errno}:{str(err)}&#34;.encode()
                os.write(exec_err_pipe_write, tosend)
                os.close(exec_err_pipe_write)
                os._exit(os.EX_OSERR)

        # Parent
        inst = cls(pid, fd)

        # [issue #119] 2. After forking, the parent closes the writing end
        # of the pipe and reads from the reading end.
        os.close(exec_err_pipe_write)
        exec_err_data = os.read(exec_err_pipe_read, 4096)
        os.close(exec_err_pipe_read)

        # [issue #119] 6. The parent reads eof (a zero-length read) if the
        # child successfully performed exec, since close-on-exec made
        # successful exec close the writing end of the pipe. Or, if exec
        # failed, the parent reads the error code and can proceed
        # accordingly. Either way, the parent blocks until the child calls
        # exec.
        if len(exec_err_data) != 0:
            try:
                errclass, errno_s, errmsg = exec_err_data.split(b&#34;:&#34;, 2)
                exctype = getattr(builtins, errclass.decode(&#34;ascii&#34;), Exception)

                exception = exctype(errmsg.decode(&#34;utf-8&#34;, &#34;replace&#34;))
                if exctype is OSError:
                    exception.errno = int(errno_s)
            except Exception:
                raise Exception(&#34;Subprocess failed, got bad error data: %r&#34; % exec_err_data)
            else:
                raise exception

        try:
            inst.setwinsize(rows=24, cols=80)
        except IOError as err:
            if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):
                raise

        return inst

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Magic repr method for PtyProcess

        Args:
            N/A

        Returns:
            str: str repr of object

        Raises:
            N/A

        &#34;&#34;&#34;
        return f&#34;{type(self).__name__}(pid={self.pid}, fd={self.fd})&#34;

    def __del__(self) -&gt; None:
        &#34;&#34;&#34;
        Magic delete method for PtyProcess

        This makes sure that no system resources are left open. Python only
        garbage collects Python objects. OS file descriptors are not Python
        objects, so they must be handled explicitly. If the child file
        descriptor was opened outside of this class (passed to the constructor)
        then this does not close it.

        Args:
            N/A

        Returns:
            N/A

        Raises:
            N/A

        &#34;&#34;&#34;
        if not self.closed:
            # It is possible for __del__ methods to execute during the
            # teardown of the Python VM itself. Thus self.close() may
            # trigger an exception because os.close may be None.
            try:
                self.close()
            # which exception, shouldn&#39;t we catch explicitly .. ?
            except Exception:
                pass

    def close(self, force: bool = True) -&gt; None:
        &#34;&#34;&#34;This closes the connection with the child application. Note that
        calling close() more than once is valid. This emulates standard Python
        behavior with files. Set force to True if you want to make sure that
        the child is terminated (SIGKILL is sent if the child ignores SIGHUP
        and SIGINT). &#34;&#34;&#34;
        if not self.closed:
            self.flush()
            self.fileobj.close()  # Closes the file descriptor
            # Give kernel time to update process status.
            time.sleep(self.delayafterclose)
            if self.isalive():
                if not self.terminate(force):
                    raise PtyProcessError(&#34;Could not terminate the child.&#34;)
            self.fd = -1
            self.closed = True
            # self.pid = None

    def flush(self) -&gt; None:
        &#34;&#34;&#34;
        This does nothing.

        It is here to support the interface for a File-like object.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def read(self, size: int = 1024) -&gt; bytes:
        &#34;&#34;&#34;Read and return at most ``size`` bytes from the pty.

        Can block if there is nothing to read. Raises :exc:`EOFError` if the
        terminal was closed.

        Unlike Pexpect&#39;s ``read_nonblocking`` method, this doesn&#39;t try to deal
        with the vagaries of EOF on platforms that do strange things, like IRIX
        or older Solaris systems. It handles the errno=EIO pattern used on
        Linux, and the empty-string return used on BSD platforms and (seemingly)
        on recent Solaris.
        &#34;&#34;&#34;
        try:
            s = self.fileobj.read1(size)
        except (OSError, IOError) as err:
            if err.args[0] == errno.EIO:
                # Linux-style EOF
                self.flag_eof = True
                raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
            raise
        if s == b&#34;&#34;:
            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

        return s

    def write(self, bytes_to_write: bytes, flush: bool = True) -&gt; int:
        &#34;&#34;&#34;Write bytes to the pseudoterminal.

        Returns the number of bytes written.
        &#34;&#34;&#34;
        n = self.fileobj.write(bytes_to_write)
        if flush:
            self.fileobj.flush()
        return n

    def eof(self) -&gt; bool:
        &#34;&#34;&#34;This returns True if the EOF exception was ever raised.
        &#34;&#34;&#34;

        return self.flag_eof

    def terminate(self, force: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        This forces a child process to terminate.

        It starts nicely with SIGHUP and SIGINT. If &#34;force&#34; is True then moves onto SIGKILL. This
        returns True if the child was terminated. This returns False if the child could not be
        terminated.

        Args:
            force: bool; force termination

        Returns:
            bool: terminate succeeded or failed

        Raises:
            N/A

        &#34;&#34;&#34;
        if not self.isalive():
            return True
        try:
            self.kill(signal.SIGHUP)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGCONT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGINT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            if force:
                self.kill(signal.SIGKILL)
                time.sleep(self.delayafterterminate)
                if not self.isalive():
                    return True
        except OSError:
            # I think there are kernel timing issues that sometimes cause
            # this to happen. I think isalive() reports True, but the
            # process is dead to the kernel.
            # Make one last attempt to see if the kernel is up to date.
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
        return False

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;This tests if the child process is running or not. This is
        non-blocking. If the child was terminated then this will read the
        exitstatus or signalstatus of the child. This returns True if the child
        process appears to be running or False if not. It can take literally
        SECONDS for Solaris to return the right status. &#34;&#34;&#34;

        if self.terminated:
            return False

        if self.flag_eof:
            # This is for Linux, which requires the blocking form
            # of waitpid to get the status of a defunct process.
            # This is super-lame. The flag_eof would have been set
            # in read_nonblocking(), so this should be safe.
            waitpid_options = 0
        else:
            waitpid_options = os.WNOHANG

        try:
            pid, status = os.waitpid(self.pid, waitpid_options)
        except OSError as e:
            # No child processes
            if e.errno == errno.ECHILD:
                raise PtyProcessError(
                    &#34;isalive() encountered condition &#34;
                    + &#39;where &#34;terminated&#34; is 0, but there was no child &#39;
                    + &#34;process. Did someone else call waitpid() &#34;
                    + &#34;on our process?&#34;
                )
            raise

        # I have to do this twice for Solaris.
        # I can&#39;t even believe that I figured this out...
        # If waitpid() returns 0 it means that no child process
        # wishes to report, and the value of status is undefined.
        if pid == 0:
            try:
                ### os.WNOHANG) # Solaris!
                pid, status = os.waitpid(self.pid, waitpid_options)
            except OSError as e:  # pragma: no cover
                # This should never happen...
                if e.errno == errno.ECHILD:
                    raise PtyProcessError(
                        &#34;isalive() encountered condition &#34;
                        + &#34;that should never happen. There was no child &#34;
                        + &#34;process. Did someone else call waitpid() &#34;
                        + &#34;on our process?&#34;
                    )
                raise

            # If pid is still 0 after two calls to waitpid() then the process
            # really is alive. This seems to work on all platforms, except for
            # Irix which seems to require a blocking call on waitpid or select,
            # so I let read_nonblocking take care of this situation
            # (unfortunately, this requires waiting through the timeout).
            if pid == 0:
                return True

        if pid == 0:
            return True

        if os.WIFEXITED(status):
            self.status = status
            self.exitstatus = os.WEXITSTATUS(status)
            self.signalstatus = None
            self.terminated = True
        elif os.WIFSIGNALED(status):
            self.status = status
            self.exitstatus = None
            self.signalstatus = os.WTERMSIG(status)
            self.terminated = True
        elif os.WIFSTOPPED(status):
            raise PtyProcessError(
                &#34;isalive() encountered condition &#34;
                + &#34;where child process is stopped. This is not &#34;
                + &#34;supported. Is some other process attempting &#34;
                + &#34;job control with our child pid?&#34;
            )
        return False

    def kill(self, sig: int) -&gt; None:
        &#34;&#34;&#34;Send the given signal to the child application.

        In keeping with UNIX tradition it has a misleading name. It does not
        necessarily kill the child unless you send the right signal. See the
        :mod:`signal` module for constants representing signal numbers.
        &#34;&#34;&#34;

        # Same as os.kill, but the pid is given for you.
        if self.isalive():
            os.kill(self.pid, sig)

    def setwinsize(self, rows: int = 24, cols: int = 80) -&gt; None:
        &#34;&#34;&#34;
        Set window size.

        This will cause a SIGWINCH signal to be sent to the child. This does not change the physical
        window size. It changes the size reported to TTY-aware applications like vi or curses --
        applications that respond to the SIGWINCH signal.

        Args:
            rows: int number of rows for terminal
            cols: int number of cols for terminal

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        return _setwinsize(self.fd, rows, cols)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.transport.ptyprocess.PtyProcess"><code class="flex name class">
<span>class <span class="ident">PtyProcess</span></span>
<span>(</span><span>pid:Â int, fd:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a process running in a pseudoterminal.</p>
<p>The main constructor is the <code>spawn</code> method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong></dt>
<dd>integer value of pid</dd>
<dt><strong><code>fd</code></strong></dt>
<dd>integer value of fd</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PtyProcess:
    def __init__(self, pid: int, fd: int) -&gt; None:
        &#34;&#34;&#34;
        This class represents a process running in a pseudoterminal.

        The main constructor is the `spawn` method.

        Args:
            pid: integer value of pid
            fd: integer value of fd

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        _make_eof_intr()  # Ensure _EOF and _INTR are calculated
        self.pid = pid
        self.fd = fd
        readf = io.open(fd, &#34;rb&#34;, buffering=0)
        writef = io.open(fd, &#34;wb&#34;, buffering=0, closefd=False)
        self.fileobj = io.BufferedRWPair(readf, writef)  # type: ignore

        self.terminated = False
        self.closed = False
        self.exitstatus: Optional[int] = None
        self.signalstatus: Optional[int] = None
        # status returned by os.waitpid
        self.status: Optional[int] = None
        self.flag_eof = False
        # Used by close() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterclose = 0.1
        # Used by terminate() to give kernel time to update process status.
        # Time in seconds.
        self.delayafterterminate = 0.1

    @classmethod
    def spawn(cls: Type[PtyProcessType], spawn_command: List[str]) -&gt; PtyProcessType:
        &#34;&#34;&#34;Start the given command in a child process in a pseudo terminal.

        This does all the fork/exec type of stuff for a pty, and returns an
        instance of PtyProcess.
        &#34;&#34;&#34;
        # Note that it is difficult for this method to fail.
        # You cannot detect if the child process cannot start.
        # So the only way you can tell if the child process started
        # or not is to try to read from the file descriptor. If you get
        # EOF immediately then it means that the child is already dead.
        # That may not necessarily be bad because you may have spawned a child
        # that performs some task; creates no stdout output; and then dies.

        import fcntl
        import pty
        import resource
        from pty import CHILD, STDIN_FILENO

        spawn_executable = which(spawn_command[0])
        if spawn_executable is None:
            raise SSHNotFound(&#34;ssh executable not found!&#34;)
        spawn_command[0] = spawn_executable

        # [issue #119] To prevent the case where exec fails and the user is
        # stuck interacting with a python child process instead of whatever
        # was expected, we implement the solution from
        # http://stackoverflow.com/a/3703179 to pass the exception to the
        # parent process
        # [issue #119] 1. Before forking, open a pipe in the parent process.
        exec_err_pipe_read, exec_err_pipe_write = os.pipe()

        pid, fd = pty.fork()

        # Some platforms must call setwinsize() and setecho() from the
        # child process, and others from the master process. We do both,
        # allowing IOError for either.
        if pid == CHILD:
            try:
                _setwinsize(fd=STDIN_FILENO, rows=24, cols=80)
            except IOError as err:
                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                    raise

            # [issue #119] 3. The child closes the reading end and sets the
            # close-on-exec flag for the writing end.
            os.close(exec_err_pipe_read)
            fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)

            # Do not allow child to inherit open file descriptors from parent,
            # with the exception of the exec_err_pipe_write of the pipe.
            # Impose ceiling on max_fd: AIX bugfix for users with unlimited
            # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()
            # occasionally raises out of range error
            max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])
            pass_fds = sorted({exec_err_pipe_write})
            for pair in zip([2] + pass_fds, pass_fds + [max_fd]):
                os.closerange(pair[0] + 1, pair[1])

            try:
                os.execv(spawn_executable, spawn_command)
            except OSError as err:
                # [issue #119] 5. If exec fails, the child writes the error
                # code back to the parent using the pipe, then exits.
                tosend = f&#34;OSError:{err.errno}:{str(err)}&#34;.encode()
                os.write(exec_err_pipe_write, tosend)
                os.close(exec_err_pipe_write)
                os._exit(os.EX_OSERR)

        # Parent
        inst = cls(pid, fd)

        # [issue #119] 2. After forking, the parent closes the writing end
        # of the pipe and reads from the reading end.
        os.close(exec_err_pipe_write)
        exec_err_data = os.read(exec_err_pipe_read, 4096)
        os.close(exec_err_pipe_read)

        # [issue #119] 6. The parent reads eof (a zero-length read) if the
        # child successfully performed exec, since close-on-exec made
        # successful exec close the writing end of the pipe. Or, if exec
        # failed, the parent reads the error code and can proceed
        # accordingly. Either way, the parent blocks until the child calls
        # exec.
        if len(exec_err_data) != 0:
            try:
                errclass, errno_s, errmsg = exec_err_data.split(b&#34;:&#34;, 2)
                exctype = getattr(builtins, errclass.decode(&#34;ascii&#34;), Exception)

                exception = exctype(errmsg.decode(&#34;utf-8&#34;, &#34;replace&#34;))
                if exctype is OSError:
                    exception.errno = int(errno_s)
            except Exception:
                raise Exception(&#34;Subprocess failed, got bad error data: %r&#34; % exec_err_data)
            else:
                raise exception

        try:
            inst.setwinsize(rows=24, cols=80)
        except IOError as err:
            if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):
                raise

        return inst

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Magic repr method for PtyProcess

        Args:
            N/A

        Returns:
            str: str repr of object

        Raises:
            N/A

        &#34;&#34;&#34;
        return f&#34;{type(self).__name__}(pid={self.pid}, fd={self.fd})&#34;

    def __del__(self) -&gt; None:
        &#34;&#34;&#34;
        Magic delete method for PtyProcess

        This makes sure that no system resources are left open. Python only
        garbage collects Python objects. OS file descriptors are not Python
        objects, so they must be handled explicitly. If the child file
        descriptor was opened outside of this class (passed to the constructor)
        then this does not close it.

        Args:
            N/A

        Returns:
            N/A

        Raises:
            N/A

        &#34;&#34;&#34;
        if not self.closed:
            # It is possible for __del__ methods to execute during the
            # teardown of the Python VM itself. Thus self.close() may
            # trigger an exception because os.close may be None.
            try:
                self.close()
            # which exception, shouldn&#39;t we catch explicitly .. ?
            except Exception:
                pass

    def close(self, force: bool = True) -&gt; None:
        &#34;&#34;&#34;This closes the connection with the child application. Note that
        calling close() more than once is valid. This emulates standard Python
        behavior with files. Set force to True if you want to make sure that
        the child is terminated (SIGKILL is sent if the child ignores SIGHUP
        and SIGINT). &#34;&#34;&#34;
        if not self.closed:
            self.flush()
            self.fileobj.close()  # Closes the file descriptor
            # Give kernel time to update process status.
            time.sleep(self.delayafterclose)
            if self.isalive():
                if not self.terminate(force):
                    raise PtyProcessError(&#34;Could not terminate the child.&#34;)
            self.fd = -1
            self.closed = True
            # self.pid = None

    def flush(self) -&gt; None:
        &#34;&#34;&#34;
        This does nothing.

        It is here to support the interface for a File-like object.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def read(self, size: int = 1024) -&gt; bytes:
        &#34;&#34;&#34;Read and return at most ``size`` bytes from the pty.

        Can block if there is nothing to read. Raises :exc:`EOFError` if the
        terminal was closed.

        Unlike Pexpect&#39;s ``read_nonblocking`` method, this doesn&#39;t try to deal
        with the vagaries of EOF on platforms that do strange things, like IRIX
        or older Solaris systems. It handles the errno=EIO pattern used on
        Linux, and the empty-string return used on BSD platforms and (seemingly)
        on recent Solaris.
        &#34;&#34;&#34;
        try:
            s = self.fileobj.read1(size)
        except (OSError, IOError) as err:
            if err.args[0] == errno.EIO:
                # Linux-style EOF
                self.flag_eof = True
                raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
            raise
        if s == b&#34;&#34;:
            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

        return s

    def write(self, bytes_to_write: bytes, flush: bool = True) -&gt; int:
        &#34;&#34;&#34;Write bytes to the pseudoterminal.

        Returns the number of bytes written.
        &#34;&#34;&#34;
        n = self.fileobj.write(bytes_to_write)
        if flush:
            self.fileobj.flush()
        return n

    def eof(self) -&gt; bool:
        &#34;&#34;&#34;This returns True if the EOF exception was ever raised.
        &#34;&#34;&#34;

        return self.flag_eof

    def terminate(self, force: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        This forces a child process to terminate.

        It starts nicely with SIGHUP and SIGINT. If &#34;force&#34; is True then moves onto SIGKILL. This
        returns True if the child was terminated. This returns False if the child could not be
        terminated.

        Args:
            force: bool; force termination

        Returns:
            bool: terminate succeeded or failed

        Raises:
            N/A

        &#34;&#34;&#34;
        if not self.isalive():
            return True
        try:
            self.kill(signal.SIGHUP)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGCONT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            self.kill(signal.SIGINT)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
            if force:
                self.kill(signal.SIGKILL)
                time.sleep(self.delayafterterminate)
                if not self.isalive():
                    return True
        except OSError:
            # I think there are kernel timing issues that sometimes cause
            # this to happen. I think isalive() reports True, but the
            # process is dead to the kernel.
            # Make one last attempt to see if the kernel is up to date.
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
        return False

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;This tests if the child process is running or not. This is
        non-blocking. If the child was terminated then this will read the
        exitstatus or signalstatus of the child. This returns True if the child
        process appears to be running or False if not. It can take literally
        SECONDS for Solaris to return the right status. &#34;&#34;&#34;

        if self.terminated:
            return False

        if self.flag_eof:
            # This is for Linux, which requires the blocking form
            # of waitpid to get the status of a defunct process.
            # This is super-lame. The flag_eof would have been set
            # in read_nonblocking(), so this should be safe.
            waitpid_options = 0
        else:
            waitpid_options = os.WNOHANG

        try:
            pid, status = os.waitpid(self.pid, waitpid_options)
        except OSError as e:
            # No child processes
            if e.errno == errno.ECHILD:
                raise PtyProcessError(
                    &#34;isalive() encountered condition &#34;
                    + &#39;where &#34;terminated&#34; is 0, but there was no child &#39;
                    + &#34;process. Did someone else call waitpid() &#34;
                    + &#34;on our process?&#34;
                )
            raise

        # I have to do this twice for Solaris.
        # I can&#39;t even believe that I figured this out...
        # If waitpid() returns 0 it means that no child process
        # wishes to report, and the value of status is undefined.
        if pid == 0:
            try:
                ### os.WNOHANG) # Solaris!
                pid, status = os.waitpid(self.pid, waitpid_options)
            except OSError as e:  # pragma: no cover
                # This should never happen...
                if e.errno == errno.ECHILD:
                    raise PtyProcessError(
                        &#34;isalive() encountered condition &#34;
                        + &#34;that should never happen. There was no child &#34;
                        + &#34;process. Did someone else call waitpid() &#34;
                        + &#34;on our process?&#34;
                    )
                raise

            # If pid is still 0 after two calls to waitpid() then the process
            # really is alive. This seems to work on all platforms, except for
            # Irix which seems to require a blocking call on waitpid or select,
            # so I let read_nonblocking take care of this situation
            # (unfortunately, this requires waiting through the timeout).
            if pid == 0:
                return True

        if pid == 0:
            return True

        if os.WIFEXITED(status):
            self.status = status
            self.exitstatus = os.WEXITSTATUS(status)
            self.signalstatus = None
            self.terminated = True
        elif os.WIFSIGNALED(status):
            self.status = status
            self.exitstatus = None
            self.signalstatus = os.WTERMSIG(status)
            self.terminated = True
        elif os.WIFSTOPPED(status):
            raise PtyProcessError(
                &#34;isalive() encountered condition &#34;
                + &#34;where child process is stopped. This is not &#34;
                + &#34;supported. Is some other process attempting &#34;
                + &#34;job control with our child pid?&#34;
            )
        return False

    def kill(self, sig: int) -&gt; None:
        &#34;&#34;&#34;Send the given signal to the child application.

        In keeping with UNIX tradition it has a misleading name. It does not
        necessarily kill the child unless you send the right signal. See the
        :mod:`signal` module for constants representing signal numbers.
        &#34;&#34;&#34;

        # Same as os.kill, but the pid is given for you.
        if self.isalive():
            os.kill(self.pid, sig)

    def setwinsize(self, rows: int = 24, cols: int = 80) -&gt; None:
        &#34;&#34;&#34;
        Set window size.

        This will cause a SIGWINCH signal to be sent to the child. This does not change the physical
        window size. It changes the size reported to TTY-aware applications like vi or curses --
        applications that respond to the SIGWINCH signal.

        Args:
            rows: int number of rows for terminal
            cols: int number of cols for terminal

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        return _setwinsize(self.fd, rows, cols)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="scrapli.transport.ptyprocess.PtyProcess.spawn"><code class="name flex">
<span>def <span class="ident">spawn</span></span>(<span>spawn_command:Â List[str]) â€‘>Â ~PtyProcessType</span>
</code></dt>
<dd>
<div class="desc"><p>Start the given command in a child process in a pseudo terminal.</p>
<p>This does all the fork/exec type of stuff for a pty, and returns an
instance of PtyProcess.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def spawn(cls: Type[PtyProcessType], spawn_command: List[str]) -&gt; PtyProcessType:
    &#34;&#34;&#34;Start the given command in a child process in a pseudo terminal.

    This does all the fork/exec type of stuff for a pty, and returns an
    instance of PtyProcess.
    &#34;&#34;&#34;
    # Note that it is difficult for this method to fail.
    # You cannot detect if the child process cannot start.
    # So the only way you can tell if the child process started
    # or not is to try to read from the file descriptor. If you get
    # EOF immediately then it means that the child is already dead.
    # That may not necessarily be bad because you may have spawned a child
    # that performs some task; creates no stdout output; and then dies.

    import fcntl
    import pty
    import resource
    from pty import CHILD, STDIN_FILENO

    spawn_executable = which(spawn_command[0])
    if spawn_executable is None:
        raise SSHNotFound(&#34;ssh executable not found!&#34;)
    spawn_command[0] = spawn_executable

    # [issue #119] To prevent the case where exec fails and the user is
    # stuck interacting with a python child process instead of whatever
    # was expected, we implement the solution from
    # http://stackoverflow.com/a/3703179 to pass the exception to the
    # parent process
    # [issue #119] 1. Before forking, open a pipe in the parent process.
    exec_err_pipe_read, exec_err_pipe_write = os.pipe()

    pid, fd = pty.fork()

    # Some platforms must call setwinsize() and setecho() from the
    # child process, and others from the master process. We do both,
    # allowing IOError for either.
    if pid == CHILD:
        try:
            _setwinsize(fd=STDIN_FILENO, rows=24, cols=80)
        except IOError as err:
            if err.args[0] not in (errno.EINVAL, errno.ENOTTY):
                raise

        # [issue #119] 3. The child closes the reading end and sets the
        # close-on-exec flag for the writing end.
        os.close(exec_err_pipe_read)
        fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)

        # Do not allow child to inherit open file descriptors from parent,
        # with the exception of the exec_err_pipe_write of the pipe.
        # Impose ceiling on max_fd: AIX bugfix for users with unlimited
        # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()
        # occasionally raises out of range error
        max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])
        pass_fds = sorted({exec_err_pipe_write})
        for pair in zip([2] + pass_fds, pass_fds + [max_fd]):
            os.closerange(pair[0] + 1, pair[1])

        try:
            os.execv(spawn_executable, spawn_command)
        except OSError as err:
            # [issue #119] 5. If exec fails, the child writes the error
            # code back to the parent using the pipe, then exits.
            tosend = f&#34;OSError:{err.errno}:{str(err)}&#34;.encode()
            os.write(exec_err_pipe_write, tosend)
            os.close(exec_err_pipe_write)
            os._exit(os.EX_OSERR)

    # Parent
    inst = cls(pid, fd)

    # [issue #119] 2. After forking, the parent closes the writing end
    # of the pipe and reads from the reading end.
    os.close(exec_err_pipe_write)
    exec_err_data = os.read(exec_err_pipe_read, 4096)
    os.close(exec_err_pipe_read)

    # [issue #119] 6. The parent reads eof (a zero-length read) if the
    # child successfully performed exec, since close-on-exec made
    # successful exec close the writing end of the pipe. Or, if exec
    # failed, the parent reads the error code and can proceed
    # accordingly. Either way, the parent blocks until the child calls
    # exec.
    if len(exec_err_data) != 0:
        try:
            errclass, errno_s, errmsg = exec_err_data.split(b&#34;:&#34;, 2)
            exctype = getattr(builtins, errclass.decode(&#34;ascii&#34;), Exception)

            exception = exctype(errmsg.decode(&#34;utf-8&#34;, &#34;replace&#34;))
            if exctype is OSError:
                exception.errno = int(errno_s)
        except Exception:
            raise Exception(&#34;Subprocess failed, got bad error data: %r&#34; % exec_err_data)
        else:
            raise exception

    try:
        inst.setwinsize(rows=24, cols=80)
    except IOError as err:
        if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):
            raise

    return inst</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.ptyprocess.PtyProcess.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, force:Â boolÂ =Â True) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This closes the connection with the child application. Note that
calling close() more than once is valid. This emulates standard Python
behavior with files. Set force to True if you want to make sure that
the child is terminated (SIGKILL is sent if the child ignores SIGHUP
and SIGINT).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, force: bool = True) -&gt; None:
    &#34;&#34;&#34;This closes the connection with the child application. Note that
    calling close() more than once is valid. This emulates standard Python
    behavior with files. Set force to True if you want to make sure that
    the child is terminated (SIGKILL is sent if the child ignores SIGHUP
    and SIGINT). &#34;&#34;&#34;
    if not self.closed:
        self.flush()
        self.fileobj.close()  # Closes the file descriptor
        # Give kernel time to update process status.
        time.sleep(self.delayafterclose)
        if self.isalive():
            if not self.terminate(force):
                raise PtyProcessError(&#34;Could not terminate the child.&#34;)
        self.fd = -1
        self.closed = True</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.eof"><code class="name flex">
<span>def <span class="ident">eof</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>This returns True if the EOF exception was ever raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eof(self) -&gt; bool:
    &#34;&#34;&#34;This returns True if the EOF exception was ever raised.
    &#34;&#34;&#34;

    return self.flag_eof</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>This does nothing.</p>
<p>It is here to support the interface for a File-like object.</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self) -&gt; None:
    &#34;&#34;&#34;
    This does nothing.

    It is here to support the interface for a File-like object.

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>This tests if the child process is running or not. This is
non-blocking. If the child was terminated then this will read the
exitstatus or signalstatus of the child. This returns True if the child
process appears to be running or False if not. It can take literally
SECONDS for Solaris to return the right status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;This tests if the child process is running or not. This is
    non-blocking. If the child was terminated then this will read the
    exitstatus or signalstatus of the child. This returns True if the child
    process appears to be running or False if not. It can take literally
    SECONDS for Solaris to return the right status. &#34;&#34;&#34;

    if self.terminated:
        return False

    if self.flag_eof:
        # This is for Linux, which requires the blocking form
        # of waitpid to get the status of a defunct process.
        # This is super-lame. The flag_eof would have been set
        # in read_nonblocking(), so this should be safe.
        waitpid_options = 0
    else:
        waitpid_options = os.WNOHANG

    try:
        pid, status = os.waitpid(self.pid, waitpid_options)
    except OSError as e:
        # No child processes
        if e.errno == errno.ECHILD:
            raise PtyProcessError(
                &#34;isalive() encountered condition &#34;
                + &#39;where &#34;terminated&#34; is 0, but there was no child &#39;
                + &#34;process. Did someone else call waitpid() &#34;
                + &#34;on our process?&#34;
            )
        raise

    # I have to do this twice for Solaris.
    # I can&#39;t even believe that I figured this out...
    # If waitpid() returns 0 it means that no child process
    # wishes to report, and the value of status is undefined.
    if pid == 0:
        try:
            ### os.WNOHANG) # Solaris!
            pid, status = os.waitpid(self.pid, waitpid_options)
        except OSError as e:  # pragma: no cover
            # This should never happen...
            if e.errno == errno.ECHILD:
                raise PtyProcessError(
                    &#34;isalive() encountered condition &#34;
                    + &#34;that should never happen. There was no child &#34;
                    + &#34;process. Did someone else call waitpid() &#34;
                    + &#34;on our process?&#34;
                )
            raise

        # If pid is still 0 after two calls to waitpid() then the process
        # really is alive. This seems to work on all platforms, except for
        # Irix which seems to require a blocking call on waitpid or select,
        # so I let read_nonblocking take care of this situation
        # (unfortunately, this requires waiting through the timeout).
        if pid == 0:
            return True

    if pid == 0:
        return True

    if os.WIFEXITED(status):
        self.status = status
        self.exitstatus = os.WEXITSTATUS(status)
        self.signalstatus = None
        self.terminated = True
    elif os.WIFSIGNALED(status):
        self.status = status
        self.exitstatus = None
        self.signalstatus = os.WTERMSIG(status)
        self.terminated = True
    elif os.WIFSTOPPED(status):
        raise PtyProcessError(
            &#34;isalive() encountered condition &#34;
            + &#34;where child process is stopped. This is not &#34;
            + &#34;supported. Is some other process attempting &#34;
            + &#34;job control with our child pid?&#34;
        )
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self, sig:Â int) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Send the given signal to the child application.</p>
<p>In keeping with UNIX tradition it has a misleading name. It does not
necessarily kill the child unless you send the right signal. See the
:mod:<code>signal</code> module for constants representing signal numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self, sig: int) -&gt; None:
    &#34;&#34;&#34;Send the given signal to the child application.

    In keeping with UNIX tradition it has a misleading name. It does not
    necessarily kill the child unless you send the right signal. See the
    :mod:`signal` module for constants representing signal numbers.
    &#34;&#34;&#34;

    # Same as os.kill, but the pid is given for you.
    if self.isalive():
        os.kill(self.pid, sig)</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size:Â intÂ =Â 1024) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Read and return at most <code>size</code> bytes from the pty.</p>
<p>Can block if there is nothing to read. Raises :exc:<code>EOFError</code> if the
terminal was closed.</p>
<p>Unlike Pexpect's <code>read_nonblocking</code> method, this doesn't try to deal
with the vagaries of EOF on platforms that do strange things, like IRIX
or older Solaris systems. It handles the errno=EIO pattern used on
Linux, and the empty-string return used on BSD platforms and (seemingly)
on recent Solaris.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size: int = 1024) -&gt; bytes:
    &#34;&#34;&#34;Read and return at most ``size`` bytes from the pty.

    Can block if there is nothing to read. Raises :exc:`EOFError` if the
    terminal was closed.

    Unlike Pexpect&#39;s ``read_nonblocking`` method, this doesn&#39;t try to deal
    with the vagaries of EOF on platforms that do strange things, like IRIX
    or older Solaris systems. It handles the errno=EIO pattern used on
    Linux, and the empty-string return used on BSD platforms and (seemingly)
    on recent Solaris.
    &#34;&#34;&#34;
    try:
        s = self.fileobj.read1(size)
    except (OSError, IOError) as err:
        if err.args[0] == errno.EIO:
            # Linux-style EOF
            self.flag_eof = True
            raise EOFError(&#34;End Of File (EOF). Exception style platform.&#34;)
        raise
    if s == b&#34;&#34;:
        # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))
        self.flag_eof = True
        raise EOFError(&#34;End Of File (EOF). Empty string style platform.&#34;)

    return s</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.setwinsize"><code class="name flex">
<span>def <span class="ident">setwinsize</span></span>(<span>self, rows:Â intÂ =Â 24, cols:Â intÂ =Â 80) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set window size.</p>
<p>This will cause a SIGWINCH signal to be sent to the child. This does not change the physical
window size. It changes the size reported to TTY-aware applications like vi or curses &ndash;
applications that respond to the SIGWINCH signal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rows</code></strong></dt>
<dd>int number of rows for terminal</dd>
<dt><strong><code>cols</code></strong></dt>
<dd>int number of cols for terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setwinsize(self, rows: int = 24, cols: int = 80) -&gt; None:
    &#34;&#34;&#34;
    Set window size.

    This will cause a SIGWINCH signal to be sent to the child. This does not change the physical
    window size. It changes the size reported to TTY-aware applications like vi or curses --
    applications that respond to the SIGWINCH signal.

    Args:
        rows: int number of rows for terminal
        cols: int number of cols for terminal

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    return _setwinsize(self.fd, rows, cols)</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.terminate"><code class="name flex">
<span>def <span class="ident">terminate</span></span>(<span>self, force:Â boolÂ =Â False) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>This forces a child process to terminate.</p>
<p>It starts nicely with SIGHUP and SIGINT. If "force" is True then moves onto SIGKILL. This
returns True if the child was terminated. This returns False if the child could not be
terminated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>force</code></strong></dt>
<dd>bool; force termination</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>terminate succeeded or failed</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminate(self, force: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    This forces a child process to terminate.

    It starts nicely with SIGHUP and SIGINT. If &#34;force&#34; is True then moves onto SIGKILL. This
    returns True if the child was terminated. This returns False if the child could not be
    terminated.

    Args:
        force: bool; force termination

    Returns:
        bool: terminate succeeded or failed

    Raises:
        N/A

    &#34;&#34;&#34;
    if not self.isalive():
        return True
    try:
        self.kill(signal.SIGHUP)
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
        self.kill(signal.SIGCONT)
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
        self.kill(signal.SIGINT)
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
        if force:
            self.kill(signal.SIGKILL)
            time.sleep(self.delayafterterminate)
            if not self.isalive():
                return True
    except OSError:
        # I think there are kernel timing issues that sometimes cause
        # this to happen. I think isalive() reports True, but the
        # process is dead to the kernel.
        # Make one last attempt to see if the kernel is up to date.
        time.sleep(self.delayafterterminate)
        if not self.isalive():
            return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcess.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, bytes_to_write:Â bytes, flush:Â boolÂ =Â True) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Write bytes to the pseudoterminal.</p>
<p>Returns the number of bytes written.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, bytes_to_write: bytes, flush: bool = True) -&gt; int:
    &#34;&#34;&#34;Write bytes to the pseudoterminal.

    Returns the number of bytes written.
    &#34;&#34;&#34;
    n = self.fileobj.write(bytes_to_write)
    if flush:
        self.fileobj.flush()
    return n</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrapli.transport.ptyprocess.PtyProcessError"><code class="flex name class">
<span>class <span class="ident">PtyProcessError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic error class for this package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PtyProcessError(Exception):
    &#34;&#34;&#34;Generic error class for this package.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.transport" href="index.html">scrapli.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.transport.ptyprocess.PtyProcess" href="#scrapli.transport.ptyprocess.PtyProcess">PtyProcess</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.close" href="#scrapli.transport.ptyprocess.PtyProcess.close">close</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.eof" href="#scrapli.transport.ptyprocess.PtyProcess.eof">eof</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.flush" href="#scrapli.transport.ptyprocess.PtyProcess.flush">flush</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.isalive" href="#scrapli.transport.ptyprocess.PtyProcess.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.kill" href="#scrapli.transport.ptyprocess.PtyProcess.kill">kill</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.read" href="#scrapli.transport.ptyprocess.PtyProcess.read">read</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.setwinsize" href="#scrapli.transport.ptyprocess.PtyProcess.setwinsize">setwinsize</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.spawn" href="#scrapli.transport.ptyprocess.PtyProcess.spawn">spawn</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.terminate" href="#scrapli.transport.ptyprocess.PtyProcess.terminate">terminate</a></code></li>
<li><code><a title="scrapli.transport.ptyprocess.PtyProcess.write" href="#scrapli.transport.ptyprocess.PtyProcess.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli.transport.ptyprocess.PtyProcessError" href="#scrapli.transport.ptyprocess.PtyProcessError">PtyProcessError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>