<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>scrapli.transport.telnet API documentation</title>
<meta name="description" content="scrapli.transport.telnet" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.transport.telnet</code></h1>
</header>
<section id="section-intro">
<p>scrapli.transport.telnet</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.transport.telnet&#34;&#34;&#34;
import re
from datetime import datetime
from select import select
from telnetlib import Telnet
from typing import Optional

from scrapli.decorators import operation_timeout, requires_open_session
from scrapli.exceptions import ScrapliAuthenticationFailed
from scrapli.helper import get_prompt_pattern, strip_ansi
from scrapli.transport.transport import Transport

TELNET_TRANSPORT_ARGS = (
    &#34;auth_username&#34;,
    &#34;auth_password&#34;,
    &#34;auth_bypass&#34;,
    &#34;comms_prompt_pattern&#34;,
    &#34;comms_return_char&#34;,
    &#34;comms_ansi&#34;,
    &#34;timeout_ops&#34;,
)


class ScrapliTelnet(Telnet):
    def __init__(self, host: str, port: int, timeout: int) -&gt; None:
        &#34;&#34;&#34;
        ScrapliTelnet class for typing purposes

        Args:
            host: string of host
            port: integer port to connect to
            timeout: timeout value in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.eof: bool
        self.timeout: int
        super().__init__(host, port, timeout)


class TelnetTransport(Transport):
    def __init__(
        self,
        host: str,
        port: int = 23,
        auth_username: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_bypass: bool = False,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_ops: int = 10,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
    ) -&gt; None:
        r&#34;&#34;&#34;
        TelnetTransport Object

        Inherit from Transport ABC
        TelnetTransport &lt;- Transport (ABC)

        Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
        handle &#34;in channel&#34; authentication required by SystemSSH -- these are assigned to private
        attributes in this class and ignored after authentication. If you wish to modify these
        values on a &#34;live&#34; scrapli connection, modify them in the Channel object, i.e.
        `conn.channel.comms_prompt_pattern`. Additionally timeout_ops is passed and assigned to
        _timeout_ops to use the same timeout_ops that is used in Channel to decorate the
        authentication methods here.

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_password: password for authentication
            auth_bypass: bypass authentication process
            timeout_socket: timeout for establishing socket in seconds -- since this is not directly
                exposed in telnetlib, this is just the initial timeout for the telnet connection.
                After the connection is established, the timeout is modified to the value of
                `timeout_transport`.
            timeout_transport: timeout for telnet transport in seconds
            timeout_ops: timeout for telnet channel operations in seconds -- this is also the
                timeout for finding and responding to username and password prompts at initial
                login. This is assigned to a private attribute and is ignored after authentication
                is completed.
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#34;standard&#34; keepalive mechanisms. &#39;standard&#39; is not currently implemented for telnet
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- telnet needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
                is ignored after authentication is completed.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- telnet needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class. This is assigned to a private attribute and is ignored after authentication
                is completed.
            comms_ansi: True/False strip comms_ansi characters from output; this value is assigned
                self._comms_ansi and is ignored after authentication. We only need it for transport
                on the off chance (maybe never, especially here in telnet land?) that
                username/password prompts contain ansi characters, otherwise &#34;comms_ansi&#34; is really
                a channel attribute and is treated as such. This is assigned to a private attribute
                and is ignored after authentication is completed.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )
        self.auth_username: str = auth_username
        self.auth_password: str = auth_password
        self.auth_bypass: bool = auth_bypass

        self._timeout_ops: int = timeout_ops
        # timeout_ops_auth is only used for authentication; base ops timeout * 2 as we are doing
        # two operations -- entering username and entering password (in most cases at least)
        self._timeout_ops_auth: int = timeout_ops * 2

        self._comms_prompt_pattern: str = comms_prompt_pattern
        self._comms_return_char: str = comms_return_char
        self._comms_ansi: bool = comms_ansi

        self.username_prompt: str = &#34;Username:&#34;
        self.password_prompt: str = &#34;Password:&#34;

        self.session: ScrapliTelnet
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open telnet channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if cant successfully authenticate

        &#34;&#34;&#34;
        self.session_lock.acquire()
        # establish session with &#34;socket&#34; timeout, then reset timeout to &#34;transport&#34; timeout
        try:
            telnet_session = ScrapliTelnet(
                host=self.host, port=self.port, timeout=self.timeout_socket
            )
        except ConnectionError as exc:
            msg = f&#34;Failed to open telnet session to host {self.host}&#34;
            if &#34;connection refused&#34; in str(exc).lower():
                msg = f&#34;Failed to open telnet session to host {self.host}, connection refused&#34;
            raise ScrapliAuthenticationFailed(msg)
        telnet_session.timeout = self.timeout_transport
        self.logger.debug(f&#34;Session to host {self.host} spawned&#34;)
        self.session_lock.release()

        if not self.auth_bypass:
            self._authenticate(telnet_session=telnet_session)
        else:
            self.logger.info(&#34;`auth_bypass` is True, bypassing authentication&#34;)
            # if we skip auth, we&#39;ll manually set _isauthenticated to True
            self._isauthenticated = True

        if not self._isauthenticated and not self._telnet_isauthenticated(
            telnet_session=telnet_session
        ):
            raise ScrapliAuthenticationFailed(
                f&#34;Could not authenticate over telnet to host: {self.host}&#34;
            )

        self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)
        self.session = telnet_session

    @operation_timeout(&#34;_timeout_ops_auth&#34;, &#34;Timed out looking for telnet login prompts&#34;)
    def _authenticate(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Parent private method to handle telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        output = b&#34;&#34;

        # capture the start time of the authentication event; we also set a &#34;return_interval&#34; which
        # is 1/10 the timout_ops value, we will send a return character at roughly this interval if
        # there is no output on the channel. we do this because sometimes telnet needs a kick to get
        # it to prompt for auth -- particularity when connecting to terminal server/console port
        auth_start_time = datetime.now().timestamp()
        return_interval = self._timeout_ops / 10
        return_attempts = 1

        while True:
            output += telnet_session.read_eager()
            if self.username_prompt.lower().encode() in output.lower():
                # if/when we see username, reset the output to empty byte string
                output = b&#34;&#34;
                telnet_session.write(self.auth_username.encode())
                telnet_session.write(self._comms_return_char.encode())
            elif self.password_prompt.lower().encode() in output.lower():
                telnet_session.write(self.auth_password.encode())
                telnet_session.write(self._comms_return_char.encode())
                self.session_lock.release()
                break
            elif not output:
                current_iteration_time = datetime.now().timestamp()
                if (current_iteration_time - auth_start_time) &gt; (return_interval * return_attempts):
                    telnet_session.write(self._comms_return_char.encode())
                    return_attempts += 1

    @operation_timeout(&#34;_timeout_ops_auth&#34;, &#34;Timed determining if telnet session is authenticated&#34;)
    def _telnet_isauthenticated(self, telnet_session: ScrapliTelnet) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the sub process is alive and has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            telnet_session: Telnet session object

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Attempting to determine if telnet authentication was successful&#34;)
        if not telnet_session.eof:
            prompt_pattern = get_prompt_pattern(prompt=&#34;&#34;, class_prompt=self._comms_prompt_pattern)
            telnet_session_fd = telnet_session.fileno()
            self.session_lock.acquire()
            telnet_session.write(self._comms_return_char.encode())
            while True:
                # almost all of the time we don&#39;t need a while loop here, but every once in a while
                # fd won&#39;t be ready which causes a failure without an obvious root cause,
                # loop/logging to hopefully help with that
                fd_ready, _, _ = select([telnet_session_fd], [], [], 0)
                if telnet_session_fd in fd_ready:
                    break
                self.logger.debug(&#34;PTY fd not ready yet...&#34;)
            output = b&#34;&#34;
            while True:
                output += telnet_session.read_eager()
                # we do not need to deal w/ line replacement for the actual output, only for
                # parsing if a prompt-like thing is at the end of the output
                output = output.replace(b&#34;\r&#34;, b&#34;&#34;)
                if self._comms_ansi:
                    output = strip_ansi(output=output)
                channel_match = re.search(pattern=prompt_pattern, string=output)
                if channel_match:
                    self.session_lock.release()
                    self._isauthenticated = True
                    return True
                if b&#34;password:&#34; in output.lower():
                    # if we see &#34;password&#34; auth failed... hopefully true in all scenarios!
                    self.session_lock.release()
                    return False
        self.session_lock.release()
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        self.logger.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if alive, False otherwise.

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._isauthenticated and not self.session.eof:
            return True
        return False

    @requires_open_session()
    @operation_timeout(&#34;timeout_transport&#34;, &#34;Timed out reading from transport&#34;)
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes read from the telnet channel

        Raises:
            N/A

        &#34;&#34;&#34;
        return self.session.read_eager()

    @requires_open_session()
    @operation_timeout(&#34;timeout_transport&#34;, &#34;Timed out writing to transport&#34;)
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.write(channel_input.encode())

    @requires_open_session()
    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        self.session.timeout = set_timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: always, because this is not implemented for telnet

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for telnet.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.transport.telnet.ScrapliTelnet"><code class="flex name class">
<span>class <span class="ident">ScrapliTelnet</span></span>
<span>(</span><span>host: str, port: int, timeout: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Telnet interface class.</p>
<p>An instance of this class represents a connection to a telnet
server.
The instance is initially not connected; the open()
method must be used to establish a connection.
Alternatively, the
host name and optional port number can be passed to the
constructor, too.</p>
<p>Don't try to reopen an already connected instance.</p>
<p>This class has many read_*() methods.
Note that some of them
raise EOFError when the end of the connection is read, because
they can return an empty string for other reasons.
See the
individual doc strings.</p>
<p>read_until(expected, [timeout])
Read until the expected string has been seen, or a timeout is
hit (default is no timeout); may block.</p>
<p>read_all()
Read all data until EOF; may block.</p>
<p>read_some()
Read at least one byte or EOF; may block.</p>
<p>read_very_eager()
Read all data available already queued or on the socket,
without blocking.</p>
<p>read_eager()
Read either data already queued or some data available on the
socket, without blocking.</p>
<p>read_lazy()
Read all data in the raw queue (processing it first), without
doing any socket I/O.</p>
<p>read_very_lazy()
Reads all data in the cooked queue, without doing any socket
I/O.</p>
<p>read_sb_data()
Reads available data between SB &hellip; SE sequence. Don't block.</p>
<p>set_option_negotiation_callback(callback)
Each time a telnet option is read on the input flow, this callback
(if set) is called with the following parameters :
callback(telnet socket, command, option)
option will be chr(0) when there is no option.
No other action is done afterwards by telnetlib.</p>
<p>ScrapliTelnet class for typing purposes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>string of host</dd>
<dt><strong><code>port</code></strong></dt>
<dd>integer port to connect to</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout value in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScrapliTelnet(Telnet):
    def __init__(self, host: str, port: int, timeout: int) -&gt; None:
        &#34;&#34;&#34;
        ScrapliTelnet class for typing purposes

        Args:
            host: string of host
            port: integer port to connect to
            timeout: timeout value in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.eof: bool
        self.timeout: int
        super().__init__(host, port, timeout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>telnetlib.Telnet</li>
</ul>
</dd>
<dt id="scrapli.transport.telnet.TelnetTransport"><code class="flex name class">
<span>class <span class="ident">TelnetTransport</span></span>
<span>(</span><span>host: str, port: int = 23, auth_username: str = '', auth_password: str = '', auth_bypass: bool = False, timeout_socket: int = 5, timeout_transport: int = 5, timeout_ops: int = 10, timeout_exit: bool = True, keepalive: bool = False, keepalive_interval: int = 30, keepalive_type: str = '', keepalive_pattern: str = '\x05', comms_prompt_pattern: str = &#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$&#x27;, comms_return_char: str = '\n', comms_ansi: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>TelnetTransport Object</p>
<p>Inherit from Transport ABC
TelnetTransport &lt;- Transport (ABC)</p>
<p>Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
handle "in channel" authentication required by SystemSSH &ndash; these are assigned to private
attributes in this class and ignored after authentication. If you wish to modify these
values on a "live" scrapli connection, modify them in the Channel object, i.e.
<code>conn.channel.comms_prompt_pattern</code>. Additionally timeout_ops is passed and assigned to
_timeout_ops to use the same timeout_ops that is used in Channel to decorate the
authentication methods here.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_bypass</code></strong></dt>
<dd>bypass authentication process</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds &ndash; since this is not directly
exposed in telnetlib, this is just the initial timeout for the telnet connection.
After the connection is established, the timeout is modified to the value of
<code>timeout_transport</code>.</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for telnet channel operations in seconds &ndash; this is also the
timeout for finding and responding to username and password prompts at initial
login. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
"standard" keepalive mechanisms. 'standard' is not currently implemented for telnet</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'\005' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>prompt pattern expected for device, same as the one provided to
channel &ndash; telnet needs to know this to know how to decide if we are properly
sending/receiving data &ndash; i.e. we are not stuck at some password prompt or some
other failure scenario. If using driver, this should be passed from driver (Scrape,
or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
is ignored after authentication is completed.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>return character to use on the channel, same as the one provided to
channel &ndash; telnet needs to know this to know what to send so that we can probe
the channel to make sure we are authenticated and sending/receiving data. If using
driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
class. This is assigned to a private attribute and is ignored after authentication
is completed.</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output; this value is assigned
self._comms_ansi and is ignored after authentication. We only need it for transport
on the off chance (maybe never, especially here in telnet land?) that
username/password prompts contain ansi characters, otherwise "comms_ansi" is really
a channel attribute and is treated as such. This is assigned to a private attribute
and is ignored after authentication is completed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TelnetTransport(Transport):
    def __init__(
        self,
        host: str,
        port: int = 23,
        auth_username: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_bypass: bool = False,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_ops: int = 10,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
    ) -&gt; None:
        r&#34;&#34;&#34;
        TelnetTransport Object

        Inherit from Transport ABC
        TelnetTransport &lt;- Transport (ABC)

        Note that comms_prompt_pattern, comms_return_char and comms_ansi are only passed here to
        handle &#34;in channel&#34; authentication required by SystemSSH -- these are assigned to private
        attributes in this class and ignored after authentication. If you wish to modify these
        values on a &#34;live&#34; scrapli connection, modify them in the Channel object, i.e.
        `conn.channel.comms_prompt_pattern`. Additionally timeout_ops is passed and assigned to
        _timeout_ops to use the same timeout_ops that is used in Channel to decorate the
        authentication methods here.

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_password: password for authentication
            auth_bypass: bypass authentication process
            timeout_socket: timeout for establishing socket in seconds -- since this is not directly
                exposed in telnetlib, this is just the initial timeout for the telnet connection.
                After the connection is established, the timeout is modified to the value of
                `timeout_transport`.
            timeout_transport: timeout for telnet transport in seconds
            timeout_ops: timeout for telnet channel operations in seconds -- this is also the
                timeout for finding and responding to username and password prompts at initial
                login. This is assigned to a private attribute and is ignored after authentication
                is completed.
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#34;standard&#34; keepalive mechanisms. &#39;standard&#39; is not currently implemented for telnet
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- telnet needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class. This is assigned to a private attribute and
                is ignored after authentication is completed.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- telnet needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class. This is assigned to a private attribute and is ignored after authentication
                is completed.
            comms_ansi: True/False strip comms_ansi characters from output; this value is assigned
                self._comms_ansi and is ignored after authentication. We only need it for transport
                on the off chance (maybe never, especially here in telnet land?) that
                username/password prompts contain ansi characters, otherwise &#34;comms_ansi&#34; is really
                a channel attribute and is treated as such. This is assigned to a private attribute
                and is ignored after authentication is completed.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )
        self.auth_username: str = auth_username
        self.auth_password: str = auth_password
        self.auth_bypass: bool = auth_bypass

        self._timeout_ops: int = timeout_ops
        # timeout_ops_auth is only used for authentication; base ops timeout * 2 as we are doing
        # two operations -- entering username and entering password (in most cases at least)
        self._timeout_ops_auth: int = timeout_ops * 2

        self._comms_prompt_pattern: str = comms_prompt_pattern
        self._comms_return_char: str = comms_return_char
        self._comms_ansi: bool = comms_ansi

        self.username_prompt: str = &#34;Username:&#34;
        self.password_prompt: str = &#34;Password:&#34;

        self.session: ScrapliTelnet
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open telnet channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if cant successfully authenticate

        &#34;&#34;&#34;
        self.session_lock.acquire()
        # establish session with &#34;socket&#34; timeout, then reset timeout to &#34;transport&#34; timeout
        try:
            telnet_session = ScrapliTelnet(
                host=self.host, port=self.port, timeout=self.timeout_socket
            )
        except ConnectionError as exc:
            msg = f&#34;Failed to open telnet session to host {self.host}&#34;
            if &#34;connection refused&#34; in str(exc).lower():
                msg = f&#34;Failed to open telnet session to host {self.host}, connection refused&#34;
            raise ScrapliAuthenticationFailed(msg)
        telnet_session.timeout = self.timeout_transport
        self.logger.debug(f&#34;Session to host {self.host} spawned&#34;)
        self.session_lock.release()

        if not self.auth_bypass:
            self._authenticate(telnet_session=telnet_session)
        else:
            self.logger.info(&#34;`auth_bypass` is True, bypassing authentication&#34;)
            # if we skip auth, we&#39;ll manually set _isauthenticated to True
            self._isauthenticated = True

        if not self._isauthenticated and not self._telnet_isauthenticated(
            telnet_session=telnet_session
        ):
            raise ScrapliAuthenticationFailed(
                f&#34;Could not authenticate over telnet to host: {self.host}&#34;
            )

        self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)
        self.session = telnet_session

    @operation_timeout(&#34;_timeout_ops_auth&#34;, &#34;Timed out looking for telnet login prompts&#34;)
    def _authenticate(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Parent private method to handle telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        output = b&#34;&#34;

        # capture the start time of the authentication event; we also set a &#34;return_interval&#34; which
        # is 1/10 the timout_ops value, we will send a return character at roughly this interval if
        # there is no output on the channel. we do this because sometimes telnet needs a kick to get
        # it to prompt for auth -- particularity when connecting to terminal server/console port
        auth_start_time = datetime.now().timestamp()
        return_interval = self._timeout_ops / 10
        return_attempts = 1

        while True:
            output += telnet_session.read_eager()
            if self.username_prompt.lower().encode() in output.lower():
                # if/when we see username, reset the output to empty byte string
                output = b&#34;&#34;
                telnet_session.write(self.auth_username.encode())
                telnet_session.write(self._comms_return_char.encode())
            elif self.password_prompt.lower().encode() in output.lower():
                telnet_session.write(self.auth_password.encode())
                telnet_session.write(self._comms_return_char.encode())
                self.session_lock.release()
                break
            elif not output:
                current_iteration_time = datetime.now().timestamp()
                if (current_iteration_time - auth_start_time) &gt; (return_interval * return_attempts):
                    telnet_session.write(self._comms_return_char.encode())
                    return_attempts += 1

    @operation_timeout(&#34;_timeout_ops_auth&#34;, &#34;Timed determining if telnet session is authenticated&#34;)
    def _telnet_isauthenticated(self, telnet_session: ScrapliTelnet) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the sub process is alive and has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            telnet_session: Telnet session object

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Attempting to determine if telnet authentication was successful&#34;)
        if not telnet_session.eof:
            prompt_pattern = get_prompt_pattern(prompt=&#34;&#34;, class_prompt=self._comms_prompt_pattern)
            telnet_session_fd = telnet_session.fileno()
            self.session_lock.acquire()
            telnet_session.write(self._comms_return_char.encode())
            while True:
                # almost all of the time we don&#39;t need a while loop here, but every once in a while
                # fd won&#39;t be ready which causes a failure without an obvious root cause,
                # loop/logging to hopefully help with that
                fd_ready, _, _ = select([telnet_session_fd], [], [], 0)
                if telnet_session_fd in fd_ready:
                    break
                self.logger.debug(&#34;PTY fd not ready yet...&#34;)
            output = b&#34;&#34;
            while True:
                output += telnet_session.read_eager()
                # we do not need to deal w/ line replacement for the actual output, only for
                # parsing if a prompt-like thing is at the end of the output
                output = output.replace(b&#34;\r&#34;, b&#34;&#34;)
                if self._comms_ansi:
                    output = strip_ansi(output=output)
                channel_match = re.search(pattern=prompt_pattern, string=output)
                if channel_match:
                    self.session_lock.release()
                    self._isauthenticated = True
                    return True
                if b&#34;password:&#34; in output.lower():
                    # if we see &#34;password&#34; auth failed... hopefully true in all scenarios!
                    self.session_lock.release()
                    return False
        self.session_lock.release()
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        self.logger.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if alive, False otherwise.

        Raises:
            N/A

        &#34;&#34;&#34;
        if self._isauthenticated and not self.session.eof:
            return True
        return False

    @requires_open_session()
    @operation_timeout(&#34;timeout_transport&#34;, &#34;Timed out reading from transport&#34;)
    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes read from the telnet channel

        Raises:
            N/A

        &#34;&#34;&#34;
        return self.session.read_eager()

    @requires_open_session()
    @operation_timeout(&#34;timeout_transport&#34;, &#34;Timed out writing to transport&#34;)
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.write(channel_input.encode())

    @requires_open_session()
    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        self.session.timeout = set_timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#34;out of band&#34; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: always, because this is not implemented for telnet

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for telnet.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li><a title="scrapli.transport.base_transport.TransportBase" href="base_transport.html#scrapli.transport.base_transport.TransportBase">TransportBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.telnet.TelnetTransport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if alive, False otherwise.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if alive and session is authenticated

    Args:
        N/A

    Returns:
        bool: True if alive, False otherwise.

    Raises:
        N/A

    &#34;&#34;&#34;
    if self._isauthenticated and not self.session.eof:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="scrapli.transport.telnet.TelnetTransport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open telnet channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ScrapliAuthenticationFailed</code></dt>
<dd>if cant successfully authenticate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open telnet channel

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        ScrapliAuthenticationFailed: if cant successfully authenticate

    &#34;&#34;&#34;
    self.session_lock.acquire()
    # establish session with &#34;socket&#34; timeout, then reset timeout to &#34;transport&#34; timeout
    try:
        telnet_session = ScrapliTelnet(
            host=self.host, port=self.port, timeout=self.timeout_socket
        )
    except ConnectionError as exc:
        msg = f&#34;Failed to open telnet session to host {self.host}&#34;
        if &#34;connection refused&#34; in str(exc).lower():
            msg = f&#34;Failed to open telnet session to host {self.host}, connection refused&#34;
        raise ScrapliAuthenticationFailed(msg)
    telnet_session.timeout = self.timeout_transport
    self.logger.debug(f&#34;Session to host {self.host} spawned&#34;)
    self.session_lock.release()

    if not self.auth_bypass:
        self._authenticate(telnet_session=telnet_session)
    else:
        self.logger.info(&#34;`auth_bypass` is True, bypassing authentication&#34;)
        # if we skip auth, we&#39;ll manually set _isauthenticated to True
        self._isauthenticated = True

    if not self._isauthenticated and not self._telnet_isauthenticated(
        telnet_session=telnet_session
    ):
        raise ScrapliAuthenticationFailed(
            f&#34;Could not authenticate over telnet to host: {self.host}&#34;
        )

    self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)
    self.session = telnet_session</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="base_transport.html#scrapli.transport.base_transport.TransportBase.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.read" href="transport.html#scrapli.transport.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_timeout" href="base_transport.html#scrapli.transport.base_transport.TransportBase.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.transport" href="index.html">scrapli.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.transport.telnet.ScrapliTelnet" href="#scrapli.transport.telnet.ScrapliTelnet">ScrapliTelnet</a></code></h4>
</li>
<li>
<h4><code><a title="scrapli.transport.telnet.TelnetTransport" href="#scrapli.transport.telnet.TelnetTransport">TelnetTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.telnet.TelnetTransport.isalive" href="#scrapli.transport.telnet.TelnetTransport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.telnet.TelnetTransport.open" href="#scrapli.transport.telnet.TelnetTransport.open">open</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>