<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>scrapli.transport.telnet API documentation</title>
<meta name="description" content="scrapli.transport.telnet" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.transport.telnet</code></h1>
</header>
<section id="section-intro">
<p>scrapli.transport.telnet</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.transport.telnet&#34;&#34;&#34;
import re
import time
from logging import getLogger
from select import select
from telnetlib import Telnet
from threading import Lock
from typing import Optional

from scrapli.exceptions import ScrapliAuthenticationFailed
from scrapli.helper import get_prompt_pattern
from scrapli.transport.transport import Transport

LOG = getLogger(&#34;transport&#34;)

TELNET_TRANSPORT_ARGS = (
    &#34;host&#34;,
    &#34;port&#34;,
    &#34;timeout_ssh&#34;,
    &#34;timeout_socket&#34;,
    &#34;auth_username&#34;,
    &#34;auth_public_key&#34;,
    &#34;auth_password&#34;,
    &#34;comms_prompt_pattern&#34;,
    &#34;comms_return_char&#34;,
)


class ScrapliTelnet(Telnet):
    def __init__(self, host: str, port: int) -&gt; None:
        self.eof: bool
        super().__init__(host, port)


class TelnetTransport(Transport):
    def __init__(
        self,
        host: str,
        port: int = 23,
        auth_username: str = &#34;&#34;,
        auth_public_key: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        timeout_ssh: int = 5000,
        timeout_socket: int = 5,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
    ):  # pylint: disable=W0231
        &#34;&#34;&#34;
        TelnetTransport Object

        Inherit from Transport ABC and Socket base class:
        TelnetTransport &lt;- Transport (ABC)
        TelnetTransport &lt;- Socket

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_public_key: path to public key for authentication
            auth_password: password for authentication
            timeout_socket: timeout for establishing socket in seconds
            timeout_ssh: timeout for ssh transport in milliseconds
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- system ssh needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- system ssh needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.host: str = host
        self.port: int = port
        self.timeout_ssh: int = timeout_ssh
        self.timeout_socket: int = timeout_socket
        self.session_lock: Lock = Lock()
        self.auth_username: str = auth_username
        self.auth_public_key: str = auth_public_key
        self.auth_password: str = auth_password
        self.comms_prompt_pattern: str = comms_prompt_pattern
        self.comms_return_char: str = comms_return_char

        self.session: ScrapliTelnet
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if cant successfully authenticate

        &#34;&#34;&#34;
        self.session_lock.acquire()
        telnet_session = ScrapliTelnet(host=self.host, port=self.port)
        LOG.debug(f&#34;Session to host {self.host} spawned&#34;)
        self.session_lock.release()
        self._authenticate(telnet_session)
        if not self._telnet_isauthenticated(telnet_session):
            raise ScrapliAuthenticationFailed(
                f&#34;Could not authenticate over telnet to host: {self.host}&#34;
            )
        LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
        print(&#34;SUCH GOOD SUCCESS&#34;)
        self.session = telnet_session

    def _authenticate(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Parent private method to handle telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._authenticate_username(telnet_session)
        self._authenticate_password(telnet_session)

    def _authenticate_username(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Private method to enter username for telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        self.session_lock.acquire()
        try:
            attempt_count = 0
            while True:
                output = telnet_session.read_eager()
                if b&#34;username:&#34; in output.lower():
                    telnet_session.write(self.auth_username.encode())
                    telnet_session.write(self.comms_return_char.encode())
                    break
                attempt_count += 1
                if attempt_count &gt; 1000:
                    break
        except self.lib_auth_exception as exc:
            LOG.critical(f&#34;Did not see username prompt from {self.host} failed. Exception: {exc}.&#34;)
            raise exc
        finally:
            self.session_lock.release()

    def _authenticate_password(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Private method to enter password for telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        self.session_lock.acquire()
        try:
            attempt_count = 0
            while True:
                output = telnet_session.read_eager()
                if b&#34;password&#34; in output.lower():
                    telnet_session.write(self.auth_password.encode())
                    telnet_session.write(self.comms_return_char.encode())
                    break
                attempt_count += 1
                if attempt_count &gt; 1000:
                    break
        except self.lib_auth_exception as exc:
            LOG.critical(f&#34;Password authentication with host {self.host} failed. Exception: {exc}.&#34;)
        except Exception as exc:
            LOG.critical(
                &#34;Unknown error occurred during password authentication with host &#34;
                f&#34;{self.host}; Exception: {exc}&#34;
            )
            raise exc
        finally:
            self.session_lock.release()

    def _telnet_isauthenticated(self, telnet_session: ScrapliTelnet) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the sub process is alive and has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            telnet_session: Telnet session object

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if not telnet_session.eof:
            prompt_pattern = get_prompt_pattern(&#34;&#34;, self.comms_prompt_pattern)
            telnet_session_fd = telnet_session.fileno()
            self.session_lock.acquire()
            telnet_session.write(self.comms_return_char.encode())
            time.sleep(0.25)
            fd_ready, _, _ = select([telnet_session_fd], [], [], 0)
            if telnet_session_fd in fd_ready:
                output = telnet_session.read_eager()
                # we do not need to deal w/ line replacement for the actual output, only for
                # parsing if a prompt-like thing is at the end of the output
                output = re.sub(b&#34;\r&#34;, b&#34;\n&#34;, output.strip())
                channel_match = re.search(prompt_pattern, output)
                if channel_match:
                    self.session_lock.release()
                    self._isauthenticated = True
                    return True
        self.session_lock.release()
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        LOG.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if socket is alive and session is authenticated

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        return self.session.read_eager()

    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.write(channel_input.encode())

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def set_blocking(self, blocking: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Set session blocking configuration

        Args:
            blocking: True/False set session to blocking

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.transport.telnet.ScrapliTelnet"><code class="flex name class">
<span>class <span class="ident">ScrapliTelnet</span></span>
<span>(</span><span>host, port)</span>
</code></dt>
<dd>
<section class="desc"><p>Telnet interface class.</p>
<p>An instance of this class represents a connection to a telnet
server.
The instance is initially not connected; the open()
method must be used to establish a connection.
Alternatively, the
host name and optional port number can be passed to the
constructor, too.</p>
<p>Don't try to reopen an already connected instance.</p>
<p>This class has many read_*() methods.
Note that some of them
raise EOFError when the end of the connection is read, because
they can return an empty string for other reasons.
See the
individual doc strings.</p>
<p>read_until(expected, [timeout])
Read until the expected string has been seen, or a timeout is
hit (default is no timeout); may block.</p>
<p>read_all()
Read all data until EOF; may block.</p>
<p>read_some()
Read at least one byte or EOF; may block.</p>
<p>read_very_eager()
Read all data available already queued or on the socket,
without blocking.</p>
<p>read_eager()
Read either data already queued or some data available on the
socket, without blocking.</p>
<p>read_lazy()
Read all data in the raw queue (processing it first), without
doing any socket I/O.</p>
<p>read_very_lazy()
Reads all data in the cooked queue, without doing any socket
I/O.</p>
<p>read_sb_data()
Reads available data between SB &hellip; SE sequence. Don't block.</p>
<p>set_option_negotiation_callback(callback)
Each time a telnet option is read on the input flow, this callback
(if set) is called with the following parameters :
callback(telnet socket, command, option)
option will be chr(0) when there is no option.
No other action is done afterwards by telnetlib.</p>
<p>Constructor.</p>
<p>When called without arguments, create an unconnected instance.
With a hostname argument, it connects the instance; port number
and timeout are optional.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScrapliTelnet(Telnet):
    def __init__(self, host: str, port: int) -&gt; None:
        self.eof: bool
        super().__init__(host, port)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>telnetlib.Telnet</li>
</ul>
</dd>
<dt id="scrapli.transport.telnet.TelnetTransport"><code class="flex name class">
<span>class <span class="ident">TelnetTransport</span></span>
<span>(</span><span>host, port=23, auth_username='', auth_public_key='', auth_password='', timeout_ssh=5000, timeout_socket=5, comms_prompt_pattern=&#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$&#x27;, comms_return_char='\n')</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>TelnetTransport Object</p>
<p>Inherit from Transport ABC and Socket base class:
TelnetTransport &lt;- Transport (ABC)
TelnetTransport &lt;- Socket</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_public_key</code></strong></dt>
<dd>path to public key for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_ssh</code></strong></dt>
<dd>timeout for ssh transport in milliseconds</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>prompt pattern expected for device, same as the one provided to
channel &ndash; system ssh needs to know this to know how to decide if we are properly
sending/receiving data &ndash; i.e. we are not stuck at some password prompt or some
other failure scenario. If using driver, this should be passed from driver (Scrape,
or IOSXE, etc.) to this Transport class.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>return character to use on the channel, same as the one provided to
channel &ndash; system ssh needs to know this to know what to send so that we can probe
the channel to make sure we are authenticated and sending/receiving data. If using
driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N</code>/<code>A</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TelnetTransport(Transport):
    def __init__(
        self,
        host: str,
        port: int = 23,
        auth_username: str = &#34;&#34;,
        auth_public_key: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        timeout_ssh: int = 5000,
        timeout_socket: int = 5,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,32}[#&gt;$]$&#34;,
        comms_return_char: str = &#34;\n&#34;,
    ):  # pylint: disable=W0231
        &#34;&#34;&#34;
        TelnetTransport Object

        Inherit from Transport ABC and Socket base class:
        TelnetTransport &lt;- Transport (ABC)
        TelnetTransport &lt;- Socket

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_public_key: path to public key for authentication
            auth_password: password for authentication
            timeout_socket: timeout for establishing socket in seconds
            timeout_ssh: timeout for ssh transport in milliseconds
            comms_prompt_pattern: prompt pattern expected for device, same as the one provided to
                channel -- system ssh needs to know this to know how to decide if we are properly
                sending/receiving data -- i.e. we are not stuck at some password prompt or some
                other failure scenario. If using driver, this should be passed from driver (Scrape,
                or IOSXE, etc.) to this Transport class.
            comms_return_char: return character to use on the channel, same as the one provided to
                channel -- system ssh needs to know this to know what to send so that we can probe
                the channel to make sure we are authenticated and sending/receiving data. If using
                driver, this should be passed from driver (Scrape, or IOSXE, etc.) to this Transport
                class.

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.host: str = host
        self.port: int = port
        self.timeout_ssh: int = timeout_ssh
        self.timeout_socket: int = timeout_socket
        self.session_lock: Lock = Lock()
        self.auth_username: str = auth_username
        self.auth_public_key: str = auth_public_key
        self.auth_password: str = auth_password
        self.comms_prompt_pattern: str = comms_prompt_pattern
        self.comms_return_char: str = comms_return_char

        self.session: ScrapliTelnet
        self.lib_auth_exception = ScrapliAuthenticationFailed
        self._isauthenticated = False

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open channel, acquire pty, request interactive shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if cant successfully authenticate

        &#34;&#34;&#34;
        self.session_lock.acquire()
        telnet_session = ScrapliTelnet(host=self.host, port=self.port)
        LOG.debug(f&#34;Session to host {self.host} spawned&#34;)
        self.session_lock.release()
        self._authenticate(telnet_session)
        if not self._telnet_isauthenticated(telnet_session):
            raise ScrapliAuthenticationFailed(
                f&#34;Could not authenticate over telnet to host: {self.host}&#34;
            )
        LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
        print(&#34;SUCH GOOD SUCCESS&#34;)
        self.session = telnet_session

    def _authenticate(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Parent private method to handle telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self._authenticate_username(telnet_session)
        self._authenticate_password(telnet_session)

    def _authenticate_username(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Private method to enter username for telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        self.session_lock.acquire()
        try:
            attempt_count = 0
            while True:
                output = telnet_session.read_eager()
                if b&#34;username:&#34; in output.lower():
                    telnet_session.write(self.auth_username.encode())
                    telnet_session.write(self.comms_return_char.encode())
                    break
                attempt_count += 1
                if attempt_count &gt; 1000:
                    break
        except self.lib_auth_exception as exc:
            LOG.critical(f&#34;Did not see username prompt from {self.host} failed. Exception: {exc}.&#34;)
            raise exc
        finally:
            self.session_lock.release()

    def _authenticate_password(self, telnet_session: ScrapliTelnet) -&gt; None:
        &#34;&#34;&#34;
        Private method to enter password for telnet authentication

        Args:
            telnet_session: Telnet session object

        Returns:
            N/A  # noqa: DAR202

        Raises:
            exc: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        self.session_lock.acquire()
        try:
            attempt_count = 0
            while True:
                output = telnet_session.read_eager()
                if b&#34;password&#34; in output.lower():
                    telnet_session.write(self.auth_password.encode())
                    telnet_session.write(self.comms_return_char.encode())
                    break
                attempt_count += 1
                if attempt_count &gt; 1000:
                    break
        except self.lib_auth_exception as exc:
            LOG.critical(f&#34;Password authentication with host {self.host} failed. Exception: {exc}.&#34;)
        except Exception as exc:
            LOG.critical(
                &#34;Unknown error occurred during password authentication with host &#34;
                f&#34;{self.host}; Exception: {exc}&#34;
            )
            raise exc
        finally:
            self.session_lock.release()

    def _telnet_isauthenticated(self, telnet_session: ScrapliTelnet) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        This is very naive -- it only knows if the sub process is alive and has not received an EOF.
        Beyond that we lock the session and send the return character and re-read the channel.

        Args:
            telnet_session: Telnet session object

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        if not telnet_session.eof:
            prompt_pattern = get_prompt_pattern(&#34;&#34;, self.comms_prompt_pattern)
            telnet_session_fd = telnet_session.fileno()
            self.session_lock.acquire()
            telnet_session.write(self.comms_return_char.encode())
            time.sleep(0.25)
            fd_ready, _, _ = select([telnet_session_fd], [], [], 0)
            if telnet_session_fd in fd_ready:
                output = telnet_session.read_eager()
                # we do not need to deal w/ line replacement for the actual output, only for
                # parsing if a prompt-like thing is at the end of the output
                output = re.sub(b&#34;\r&#34;, b&#34;\n&#34;, output.strip())
                channel_match = re.search(prompt_pattern, output)
                if channel_match:
                    self.session_lock.release()
                    self._isauthenticated = True
                    return True
        self.session_lock.release()
        return False

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        LOG.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if socket is alive and session is authenticated

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        return self.session.read_eager()

    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session.write(channel_input.encode())

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;

    def set_blocking(self, blocking: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Set session blocking configuration

        Args:
            blocking: True/False set session to blocking

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli.transport.telnet.TelnetTransport.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Open channel, acquire pty, request interactive shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N</code>/<code>A</code>
# <code>noqa</code>: <code>DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ScrapliAuthenticationFailed</code></strong></dt>
<dd>if cant successfully authenticate</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open channel, acquire pty, request interactive shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        ScrapliAuthenticationFailed: if cant successfully authenticate

    &#34;&#34;&#34;
    self.session_lock.acquire()
    telnet_session = ScrapliTelnet(host=self.host, port=self.port)
    LOG.debug(f&#34;Session to host {self.host} spawned&#34;)
    self.session_lock.release()
    self._authenticate(telnet_session)
    if not self._telnet_isauthenticated(telnet_session):
        raise ScrapliAuthenticationFailed(
            f&#34;Could not authenticate over telnet to host: {self.host}&#34;
        )
    LOG.debug(f&#34;Authenticated to host {self.host} with password&#34;)
    print(&#34;SUCH GOOD SUCCESS&#34;)
    self.session = telnet_session</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.transport.transport.Transport" href="transport.html#scrapli.transport.transport.Transport">Transport</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.transport.transport.Transport.close" href="transport.html#scrapli.transport.transport.Transport.close">close</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.isalive" href="transport.html#scrapli.transport.transport.Transport.isalive">isalive</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.read" href="transport.html#scrapli.transport.transport.Transport.read">read</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_blocking" href="transport.html#scrapli.transport.transport.Transport.set_blocking">set_blocking</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.set_timeout" href="transport.html#scrapli.transport.transport.Transport.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli.transport.transport.Transport.write" href="transport.html#scrapli.transport.transport.Transport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli.transport" href="index.html">scrapli.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.transport.telnet.ScrapliTelnet" href="#scrapli.transport.telnet.ScrapliTelnet">ScrapliTelnet</a></code></h4>
</li>
<li>
<h4><code><a title="scrapli.transport.telnet.TelnetTransport" href="#scrapli.transport.telnet.TelnetTransport">TelnetTransport</a></code></h4>
<ul class="">
<li><code><a title="scrapli.transport.telnet.TelnetTransport.open" href="#scrapli.transport.telnet.TelnetTransport.open">open</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>