<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>scrapli.factory API documentation</title>
<meta name="description" content="scrapli.factory" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli.factory</code></h1>
</header>
<section id="section-intro">
<p>scrapli.factory</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli.factory&#34;&#34;&#34;
import importlib
from copy import deepcopy
from logging import getLogger
from typing import Any, Dict, Optional, Tuple, Type, Union

from scrapli.driver import AsyncGenericDriver, AsyncNetworkDriver, GenericDriver, NetworkDriver
from scrapli.driver.base_driver import ASYNCIO_TRANSPORTS
from scrapli.driver.core import (
    AsyncEOSDriver,
    AsyncIOSXEDriver,
    AsyncIOSXRDriver,
    AsyncJunosDriver,
    AsyncNXOSDriver,
    EOSDriver,
    IOSXEDriver,
    IOSXRDriver,
    JunosDriver,
    NXOSDriver,
)
from scrapli.exceptions import ScrapliException

LOG = getLogger(&#34;scrapli.factory&#34;)

ASYNC_CORE_PLATFORM_MAP = {
    &#34;arista_eos&#34;: AsyncEOSDriver,
    &#34;cisco_iosxe&#34;: AsyncIOSXEDriver,
    &#34;cisco_iosxr&#34;: AsyncIOSXRDriver,
    &#34;cisco_nxos&#34;: AsyncNXOSDriver,
    &#34;juniper_junos&#34;: AsyncJunosDriver,
}
SYNC_CORE_PLATFORM_MAP = {
    &#34;arista_eos&#34;: EOSDriver,
    &#34;cisco_iosxe&#34;: IOSXEDriver,
    &#34;cisco_iosxr&#34;: IOSXRDriver,
    &#34;cisco_nxos&#34;: NXOSDriver,
    &#34;juniper_junos&#34;: JunosDriver,
}
ASYNC_DRIVER_MAP = {&#34;network&#34;: AsyncNetworkDriver, &#34;generic&#34;: AsyncGenericDriver}
SYNC_DRIVER_MAP = {&#34;network&#34;: NetworkDriver, &#34;generic&#34;: GenericDriver}


def _get_community_platform_details(community_platform_name: str) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Parent get driver method

    Args:
        community_platform_name: name of community

    Returns:
        platform_details: dict of details about community platform from scrapli_community library

    Raises:
        ModuleNotFoundError: if scrapli_community is not importable
        ScrapliException: if community platform is missing &#34;SCRAPLI_PLATFORM&#34; attribute
        ScrapliException: for any unknown exception during community platform import

    &#34;&#34;&#34;
    try:
        # replace any underscores in platform name with &#34;.&#34;; should support any future platforms
        # that dont have &#34;child&#34; os types -- i.e. just &#34;cisco&#34; instead of &#34;cisco_iosxe&#34;
        scrapli_community_platform = importlib.import_module(
            name=f&#34;scrapli_community.{community_platform_name.replace(&#39;_&#39;, &#39;.&#39;)}&#34;
        )
    except ModuleNotFoundError as exc:
        err = f&#34;Module &#39;{exc.name}&#39; not found!&#34;
        msg = f&#34;***** {err} {&#39;*&#39; * (80 - len(err))}&#34;
        fix = (
            &#34;To resolve this issue, ensure you have the scrapli community package installed.&#34;
            &#34; You can install this with pip: `pip install scrapli_community`.&#34;
        )
        warning = &#34;\n&#34; + msg + &#34;\n&#34; + fix + &#34;\n&#34; + msg
        raise ModuleNotFoundError(warning)
    except Exception as exc:
        msg = f&#34;Unknown error occurred, exception: {exc}&#34;
        raise ScrapliException(msg)

    platform_details_original = getattr(scrapli_community_platform, &#34;SCRAPLI_PLATFORM&#34;, {})
    if not platform_details_original:
        msg = &#34;Community platform missing required attribute `SCRAPLI_PLATFORM`&#34;
        raise ScrapliException(msg)
    platform_details: Dict[str, Any] = deepcopy(platform_details_original)
    return platform_details


def _get_community_driver(
    community_platform_name: str, variant: Optional[str], _async: bool = False
) -&gt; Tuple[
    Union[
        Type[AsyncNetworkDriver], Type[AsyncGenericDriver], Type[NetworkDriver], Type[GenericDriver]
    ],
    Dict[str, Any],
]:
    &#34;&#34;&#34;
    Parent get driver method

    Args:
        community_platform_name: name of community
        variant: optional name of variant of community platform
        _async: True/False this is for an asyncio transport driver

    Returns:
        NetworkDriver: final driver class

    Raises:
        ScrapliException: if scrapli_community platform has an invalid value for &#34;driver_type&#34;

    &#34;&#34;&#34;
    platform_details = _get_community_platform_details(
        community_platform_name=community_platform_name
    )

    driver_type = platform_details[&#34;driver_type&#34;]
    if _async is False:
        final_driver = SYNC_DRIVER_MAP.get(driver_type, None)
    else:
        final_driver = ASYNC_DRIVER_MAP.get(driver_type, None)
    if not final_driver:
        raise ScrapliException(&#34;Invalid driver type provided in community platform data&#34;)

    platform_kwargs = platform_details[&#34;defaults&#34;]

    if variant:
        variant_kwargs = platform_details[&#34;variants&#34;][variant]
        final_platform_kwargs = {**platform_kwargs, **variant_kwargs}
    else:
        final_platform_kwargs = platform_kwargs

    if not _async:
        # remove unnecessary asyncio things
        final_platform_kwargs.pop(&#34;async_on_open&#34;)
        final_platform_kwargs.pop(&#34;async_on_close&#34;)
        # rename sync_on_(open|close) keys to just &#34;on_open&#34;/&#34;on_close&#34;
        final_platform_kwargs[&#34;on_open&#34;] = final_platform_kwargs.pop(&#34;sync_on_open&#34;)
        final_platform_kwargs[&#34;on_close&#34;] = final_platform_kwargs.pop(&#34;sync_on_close&#34;)
    else:
        # remove unnecessary sync things
        final_platform_kwargs.pop(&#34;sync_on_open&#34;)
        final_platform_kwargs.pop(&#34;sync_on_close&#34;)
        # rename sync_on_(open|close) keys to just &#34;on_open&#34;/&#34;on_close&#34;
        final_platform_kwargs[&#34;on_open&#34;] = final_platform_kwargs.pop(&#34;async_on_open&#34;)
        final_platform_kwargs[&#34;on_close&#34;] = final_platform_kwargs.pop(&#34;async_on_close&#34;)

    return final_driver, final_platform_kwargs


def _get_driver(
    platform: str, variant: Optional[str], _async: bool = False
) -&gt; Tuple[Union[Type[NetworkDriver], Type[GenericDriver]], Dict[str, Any]]:
    &#34;&#34;&#34;
    Parent get driver method

    Args:
        platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.
        variant: name of the target paltform variant
        _async: True/False this is for an asyncio transport driver

    Returns:
        NetworkDriver: final driver class; generally NetworkDriver, but for some community platforms
            could be GenericDriver

    Raises:
        N/A

    &#34;&#34;&#34;
    additional_kwargs: Dict[str, Any] = {}

    if platform in SYNC_CORE_PLATFORM_MAP:
        if _async is False:
            final_driver = SYNC_CORE_PLATFORM_MAP[platform]
        else:
            final_driver = ASYNC_CORE_PLATFORM_MAP[platform]
        msg = f&#34;Driver `{final_driver}` selected from scrapli core drivers&#34;
    else:
        final_driver, additional_kwargs = _get_community_driver(
            community_platform_name=platform, variant=variant, _async=_async
        )
        msg = (
            f&#34;Driver `{final_driver}` selected from scrapli community platforms, with the following&#34;
            f&#34; platform arguments: `{additional_kwargs}`&#34;
        )

    LOG.info(msg)
    return final_driver, additional_kwargs


class Scrapli(NetworkDriver):
    def __new__(
        cls, platform: str, variant: Optional[str] = None, **kwargs: Dict[Any, Any]
    ) -&gt; &#34;Scrapli&#34;:
        &#34;&#34;&#34;
        Scrapli Factory method for synchronous drivers

        Args:
            cls: class object
            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.
            variant: optional name of variant of community platform
            **kwargs: keyword arguments to pass to selected driver class

        Returns:
            final_driver: synchronous driver class for provided driver

        Raises:
            ScrapliException: if provided transport is asyncio
            ScrapliException: if `platform` not in keyword arguments

        &#34;&#34;&#34;
        LOG.debug(&#34;Scrapli factory initialized&#34;)

        if kwargs.get(&#34;transport&#34;, &#34;system&#34;) in ASYNCIO_TRANSPORTS:
            raise ScrapliException(&#34;Use `AsyncScrapli` if using an async transport!&#34;)

        if not isinstance(platform, str):
            raise ScrapliException(f&#34;Argument `platform` must be `str` got `{type(platform)}`&#34;)

        final_driver, additional_kwargs = _get_driver(
            platform=platform, variant=variant, _async=False
        )

        # at this point will need to merge the additional kwargs in (for community drivers),
        # ensure that kwargs passed by user supersede the ones coming from community platform
        if additional_kwargs:
            final_kwargs = {**additional_kwargs, **kwargs}
        else:
            final_kwargs = kwargs

        # mypy was displeased about NetworkDriver not being callable, fix later probably :)
        final_conn: &#34;Scrapli&#34; = final_driver(**final_kwargs)  # type: ignore
        return final_conn


class AsyncScrapli(AsyncNetworkDriver):
    def __new__(
        cls, platform: str, variant: Optional[str] = None, **kwargs: Dict[Any, Any]
    ) -&gt; &#34;AsyncScrapli&#34;:
        &#34;&#34;&#34;
        Scrapli Factory method for asynchronous drivers

        Args:
            cls: class object
            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.
            variant: optional name of variant of community platform
            **kwargs: keyword arguments to pass to selected driver class

        Returns:
            final_driver: synchronous driver class for provided driver

        Raises:
            ScrapliException: if provided transport is not asyncio
            ScrapliException: if `platform` not in keyword arguments

        &#34;&#34;&#34;
        LOG.debug(&#34;Scrapli factory initialized&#34;)

        if kwargs.get(&#34;transport&#34;, &#34;system&#34;) not in ASYNCIO_TRANSPORTS:
            raise ScrapliException(&#34;Use `Scrapli` if using a synchronous transport!&#34;)

        if not isinstance(platform, str):
            raise ScrapliException(f&#34;Argument `platform` must be `str` got `{type(platform)}`&#34;)

        final_driver, additional_kwargs = _get_driver(
            platform=platform, variant=variant, _async=True
        )

        # at this point will need to merge the additional kwargs in (for community drivers),
        # ensure that kwargs passed by user supersede the ones coming from community platform
        if additional_kwargs:
            final_kwargs = {**additional_kwargs, **kwargs}
        else:
            final_kwargs = kwargs

        # mypy was displeased about NetworkDriver not being callable, fix later probably :)
        final_conn: &#34;AsyncScrapli&#34; = final_driver(**final_kwargs)  # type: ignore
        return final_conn</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli.factory.AsyncScrapli"><code class="flex name class">
<span>class <span class="ident">AsyncScrapli</span></span>
<span>(</span><span>platform: str, variant: Union[str, NoneType] = None, **kwargs: Dict[Any, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code>Scrape</code> object from that perspective.</p>
<p>AsyncNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>Dict of privilege levels for a given platform</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that indicate a command/configuration has failed</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of platform to use for textfsm parsing</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of platform to use for genie parsing</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncScrapli(AsyncNetworkDriver):
    def __new__(
        cls, platform: str, variant: Optional[str] = None, **kwargs: Dict[Any, Any]
    ) -&gt; &#34;AsyncScrapli&#34;:
        &#34;&#34;&#34;
        Scrapli Factory method for asynchronous drivers

        Args:
            cls: class object
            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.
            variant: optional name of variant of community platform
            **kwargs: keyword arguments to pass to selected driver class

        Returns:
            final_driver: synchronous driver class for provided driver

        Raises:
            ScrapliException: if provided transport is not asyncio
            ScrapliException: if `platform` not in keyword arguments

        &#34;&#34;&#34;
        LOG.debug(&#34;Scrapli factory initialized&#34;)

        if kwargs.get(&#34;transport&#34;, &#34;system&#34;) not in ASYNCIO_TRANSPORTS:
            raise ScrapliException(&#34;Use `Scrapli` if using a synchronous transport!&#34;)

        if not isinstance(platform, str):
            raise ScrapliException(f&#34;Argument `platform` must be `str` got `{type(platform)}`&#34;)

        final_driver, additional_kwargs = _get_driver(
            platform=platform, variant=variant, _async=True
        )

        # at this point will need to merge the additional kwargs in (for community drivers),
        # ensure that kwargs passed by user supersede the ones coming from community platform
        if additional_kwargs:
            final_kwargs = {**additional_kwargs, **kwargs}
        else:
            final_kwargs = kwargs

        # mypy was displeased about NetworkDriver not being callable, fix later probably :)
        final_conn: &#34;AsyncScrapli&#34; = final_driver(**final_kwargs)  # type: ignore
        return final_conn</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></li>
<li><a title="scrapli.driver.async_generic_driver.AsyncGenericDriver" href="driver/async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver">AsyncGenericDriver</a></li>
<li><a title="scrapli.driver.async_driver.AsyncScrape" href="driver/async_driver.html#scrapli.driver.async_driver.AsyncScrape">AsyncScrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="driver/base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver">AsyncNetworkDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.acquire_priv" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.close" href="driver/async_driver.html#scrapli.driver.async_driver.AsyncScrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.get_prompt" href="driver/async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.isalive" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.open" href="driver/async_driver.html#scrapli.driver.async_driver.AsyncScrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.register_configuration_session" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session">register_configuration_session</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_command" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_commands_from_file" href="driver/async_generic_driver.html#scrapli.driver.async_generic_driver.AsyncGenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_config" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs_from_file" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.send_interactive" href="driver/async_network_driver.html#scrapli.driver.async_network_driver.AsyncNetworkDriver.send_interactive">send_interactive</a></code></li>
<li><code><a title="scrapli.driver.async_network_driver.AsyncNetworkDriver.update_privilege_levels" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli.factory.Scrapli"><code class="flex name class">
<span>class <span class="ident">Scrapli</span></span>
<span>(</span><span>platform: str, variant: Union[str, NoneType] = None, **kwargs: Dict[Any, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>GenericDriverBase Object</p>
<p>A generic network driver that will <em>hopefully</em> work for a broad variety of devices with
minimal to no modifications and provide a normal NetworkDriver type experience with
<code>send_command(s)</code>, <code>get_prompt</code> and <code>send_interactive</code> methods instead of forcing users to
call Channel methods directly.</p>
<p>This driver doesn't know anything about privilege levels (or any type of "config modes",
disabling paging, gracefully exiting, or anything like that, and as such should be treated
similar to the base <code>Scrape</code> object from that perspective.</p>
<p>BaseNetworkDriver Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>privilege_levels</code></strong></dt>
<dd>Dict of privilege levels for a given platform</dd>
<dt><strong><code>default_desired_privilege_level</code></strong></dt>
<dd>string of name of default desired priv, this is the
priv level that is generally used to disable paging/set terminal width and things
like that upon first login, and is also the priv level scrapli will try to acquire
for normal "command" operations (<code>send_command</code>, <code>send_commands</code>)</dd>
<dt><strong><code>auth_secondary</code></strong></dt>
<dd>password to use for secondary authentication (enable)</dd>
<dt><strong><code>failed_when_contains</code></strong></dt>
<dd>list of strings that indicate a command/configuration has failed</dd>
<dt><strong><code>textfsm_platform</code></strong></dt>
<dd>string name of platform to use for textfsm parsing</dd>
<dt><strong><code>genie_platform</code></strong></dt>
<dd>string name of platform to use for genie parsing</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword args to pass to inherited class(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scrapli(NetworkDriver):
    def __new__(
        cls, platform: str, variant: Optional[str] = None, **kwargs: Dict[Any, Any]
    ) -&gt; &#34;Scrapli&#34;:
        &#34;&#34;&#34;
        Scrapli Factory method for synchronous drivers

        Args:
            cls: class object
            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.
            variant: optional name of variant of community platform
            **kwargs: keyword arguments to pass to selected driver class

        Returns:
            final_driver: synchronous driver class for provided driver

        Raises:
            ScrapliException: if provided transport is asyncio
            ScrapliException: if `platform` not in keyword arguments

        &#34;&#34;&#34;
        LOG.debug(&#34;Scrapli factory initialized&#34;)

        if kwargs.get(&#34;transport&#34;, &#34;system&#34;) in ASYNCIO_TRANSPORTS:
            raise ScrapliException(&#34;Use `AsyncScrapli` if using an async transport!&#34;)

        if not isinstance(platform, str):
            raise ScrapliException(f&#34;Argument `platform` must be `str` got `{type(platform)}`&#34;)

        final_driver, additional_kwargs = _get_driver(
            platform=platform, variant=variant, _async=False
        )

        # at this point will need to merge the additional kwargs in (for community drivers),
        # ensure that kwargs passed by user supersede the ones coming from community platform
        if additional_kwargs:
            final_kwargs = {**additional_kwargs, **kwargs}
        else:
            final_kwargs = kwargs

        # mypy was displeased about NetworkDriver not being callable, fix later probably :)
        final_conn: &#34;Scrapli&#34; = final_driver(**final_kwargs)  # type: ignore
        return final_conn</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli.driver.network_driver.NetworkDriver" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></li>
<li><a title="scrapli.driver.generic_driver.GenericDriver" href="driver/generic_driver.html#scrapli.driver.generic_driver.GenericDriver">GenericDriver</a></li>
<li><a title="scrapli.driver.driver.Scrape" href="driver/driver.html#scrapli.driver.driver.Scrape">Scrape</a></li>
<li><a title="scrapli.driver.base_driver.ScrapeBase" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase">ScrapeBase</a></li>
<li><a title="scrapli.driver.base_generic_driver.GenericDriverBase" href="driver/base_generic_driver.html#scrapli.driver.base_generic_driver.GenericDriverBase">GenericDriverBase</a></li>
<li><a title="scrapli.driver.base_network_driver.NetworkDriverBase" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase">NetworkDriverBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli.driver.network_driver.NetworkDriver" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver">NetworkDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.acquire_priv" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.acquire_priv">acquire_priv</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.close" href="driver/driver.html#scrapli.driver.driver.Scrape.close">close</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.get_prompt" href="driver/generic_driver.html#scrapli.driver.generic_driver.GenericDriver.get_prompt">get_prompt</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.isalive" href="driver/base_driver.html#scrapli.driver.base_driver.ScrapeBase.isalive">isalive</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.open" href="driver/driver.html#scrapli.driver.driver.Scrape.open">open</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.register_configuration_session" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.register_configuration_session">register_configuration_session</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_command" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_command">send_command</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_commands" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_commands">send_commands</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_commands_from_file" href="driver/generic_driver.html#scrapli.driver.generic_driver.GenericDriver.send_commands_from_file">send_commands_from_file</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_config" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_config">send_config</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_configs" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_configs">send_configs</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_configs_from_file" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_configs_from_file">send_configs_from_file</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.send_interactive" href="driver/network_driver.html#scrapli.driver.network_driver.NetworkDriver.send_interactive">send_interactive</a></code></li>
<li><code><a title="scrapli.driver.network_driver.NetworkDriver.update_privilege_levels" href="driver/base_network_driver.html#scrapli.driver.base_network_driver.NetworkDriverBase.update_privilege_levels">update_privilege_levels</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli" href="index.html">scrapli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli.factory.AsyncScrapli" href="#scrapli.factory.AsyncScrapli">AsyncScrapli</a></code></h4>
</li>
<li>
<h4><code><a title="scrapli.factory.Scrapli" href="#scrapli.factory.Scrapli">Scrapli</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>