{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"scrapli","text":"<p>scrapli -- scrap(e c)li --  is a python library focused on connecting to devices, specifically network devices  (routers/switches/firewalls/etc.) via SSH or Telnet. The name scrapli -- is just \"scrape cli\" (as in screen scrape)  squished together! scrapli's goal is to be as fast and flexible as possible, while providing a thoroughly tested, well   typed, well documented, simple API that supports both synchronous and asynchronous usage.</p> <p>Feel free to join the very awesome networktocode slack workspace here, where you  will find a <code>scrapli</code> channel where you can discuss anything about scrapli, as well as tons of other channels covering   all sorts of network/network-automation topics!</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#20230730-in-development","title":"2023.07.30 (in development)","text":"<ul> <li>Expand channel auth patterns to include \"no matching host key\"</li> </ul>"},{"location":"changelog/#20230130","title":"2023.01.30","text":"<ul> <li>Expanded ANSII escape sequence handling in #265 thanks to @erwinkinn</li> <li>Improved handling of \"preferred_auth\" and ssh agent bits in the asyncssh transport thanks to @alekshi work in #266</li> <li>The usual keeping up with bumping dev pins for linters, docs and the like</li> <li>Remove NULL bytes left in telnet transports</li> <li>Run telnet and asynctelnet tests on cisco_nxos (functional tests)</li> </ul>"},{"location":"changelog/#20220730post1","title":"2022.07.30.post1","text":"<ul> <li>Big thanks once again to @haccht (and to @egreenspan2 for raising an issue on this as well) for fixing up some    broken telnet control character handling, and for porting that to async side of things as well!</li> </ul>"},{"location":"changelog/#20220730","title":"2022.07.30","text":"<ul> <li>Added MANIFEST.in to make sure requirements files are in source distribution see #216</li> <li>Move weekly build to develop branch so weekly build doesn't fail for \"stale\" main branch reasons</li> <li><code>textfsm_parse</code> now supports passing in a file or URL to load as the template file -- thank you to @haccht for    this one -- see #215</li> <li>Fixed some mypy/typing challenges around the scrapli \"factory\" context manager -- thank you to @erwinkinn for    working on this</li> <li>With lots of help from @netixx tracked down some silliness with timeout decorators not behaving how they should --    check out #233 for details on this</li> <li>Overhauled the functional testing to align more closely with scrapligo and to remove all the old unnecessary    dockerfile bits, replacing that completely with containerlab</li> </ul>"},{"location":"changelog/#20220130post1","title":"2022.01.30.post1","text":"<ul> <li>Remove newline anchor in in-channel auth password pattern. Felt like a good/smart idea but Cisco in their infinite    wisdom have some awful banner on IOL (CML/VIRL) things that doesn't end with a newline and too many people will    hit that.</li> <li>Move decorators back to function style -- fixes possible timeout issues as seen in #233</li> <li>Modified <code>escalate_priv</code> methods to check for password prompt and desired prompt patterns and the current prompt   pattern. There was an issue in scrapligo/containerlab where a cEOS device would not let you auth past enable until   it is done \"booting\" up, and scrapli would just simply timeout as it didn't expect to see the exec prompt again.    Thanks to @hellt for helping track this one down!</li> <li>Replaced standard library telnetlib transport with custom telnet transport (still no external requirements) in    very early preparation for telnetlib's deprecation.</li> </ul>"},{"location":"changelog/#20220130","title":"2022.01.30","text":"<ul> <li>Removed deprecated <code>comms_ansi</code> argument</li> <li>Improved error handling/error message for insufficient permissions when opening ssh config/known hosts file    (system transport)</li> <li>Added support for hashed entries in known hosts file thanks to @kangtastic work in #174</li> <li>Improved \"in channel\" SSH and Telnet authentication handling; better consistency between sync and async, patterns    are now compiled only if/when needed</li> <li>Added option to enable echo in PTYProcess (was originally removed from vendor'd code) -- should only be    useful/necessary with netconf #165</li> <li>Allow users to build their own <code>open_cmd</code> for system transport -- users can override this to do things like    <code>kubectl exec -it args args args</code> or <code>docker exec -it args args args</code> to connect to containers in k8s/docker #166</li> <li>Updated/fixed(?) Juniper shell patterns for \"normal\" and root shells #170</li> <li>Support transport options being passed to asyncssh transport thanks to @cuong-nguyenduy work in #178 and #183</li> <li>A handful of nice readability/simplicity improvements throughout the codebase thanks to @yezz123 in #188</li> <li>Fix (add) missing kwarg for <code>channel_log_mode</code> in the driver layers \"above\" base driver</li> <li>Update NXOS config pattern to include \"+\" to not break when entering TACACS config mode</li> <li>Added support for encrypted SSH keys with ssh2 transport in #192 thanks to @shnurty</li> <li>Fix/improve in channel SSH auth password prompt pattern to match scrapligo (which handles user@host password: strings)</li> <li>Update ssh2-python requirements now that 3.10/Darwin release is available</li> <li>Better exception/exception message for auth failures escalating privilege (network drivers)</li> <li>Added a global <code>Settings</code> object -- for now only has an attribute for \"SUPPRESS_USER_WARNINGS\" to... suppress user    warnings</li> <li>Added <code>read_callback</code> method to <code>GenericDriver</code>/<code>AsyncGenericDriver</code> -- basically this is a fancier version of    send interactive that lets you assign callbacks to things that scrapli reads rather than having to follow prompts    in a linear fashion.</li> <li>Dropped Python3.6 support as it is now EOL! Of course, scrapli probably still works just fine with 3.6 (if you    install the old 3.6 requirements), but we won't test/support it anymore.</li> <li>Added <code>enable_rsa2</code> setting to paramiko transport options -- basically 2.9.0+ paramiko enables rsa2 support by    default which causes key auth to fail on the test network devices, so we disable that by default, but exposet his    flag so users can enable it if desired!</li> </ul>"},{"location":"changelog/#20210730","title":"2021.07.30","text":"<ul> <li>Added \"% Unavailable command\" to EOS <code>failed_when_contains</code></li> <li>Moved core platform <code>failed_when_contains</code> to base to not have to duplicate them in sync and async platforms</li> <li>Add <code>file_mode</code> to the <code>enable_basic_logging</code> function, can now choose \"append\" or \"write\" for logfile</li> <li>Add <code>channel_log_mode</code> to the base driver arguments; you can now choose \"append\" or \"write\" for this as well!</li> <li>Improve reading until prompt methods; no longer use re.search on the entire received byte string, now only checks    for prompt on the last N chars where N is governed by the base channel args <code>comms_prompt_search_depth</code> attribute..   . this fixes an issue where scrapli could be wayyyyyy slow for very very large outputs (like full tables show bgp)</li> <li>Fix bug (or just terrible initial idea!?) in asynctelnet that reset a timer back to a very small value that was used    for testing; most people shouldn't have noticed an issue here, but if you had slow devices this could cause    issues that \"looked\" like an authentication issue due to scrapli not having responded to all telnet control    characters before punting to auth</li> <li>Added <code>commandeer</code> to driver object; this is used to \"commandeer\" an existing connection but treat it like the new    connection object (prompt patterns, methods, etc.) -- generally this would be used for using <code>GenericDriver</code> to    connect to a console server, then \"commandeering\" that connection and turning it into an IOSXR/IOSXE/etc.    connection object so you have all the \"normal\" behavior of scrapli</li> <li>Add missing timeout on the asynctelnet open method</li> <li>Add py.typed to hopefully do typing more correctly :P</li> <li>BUGFIX: network drivers aborted configuration sessions if responses were failed even if the <code>stop_on_failed</code> arg    was set to False; this has been fixed now so that sessions are only aborted if the response is failed and</li> <li>Improved typing for <code>send_interactive</code></li> <li>Remove napalm dev requirement -- switch to scrapli-cfg for dev environment config management; something something    eating dog food or whatever.</li> <li>Deprecate <code>comms_ansi</code> -- if there is an ANSI escape sequence we will now just strip it out automagically; this is    not currently a breaking change, but will be -- there is a deprecation warning now and <code>comms_ansi</code> will be    fully removed in the 2022.01.30 release (and pre-releases).</li> <li>Removed a sleep that was in the default <code>on_open</code> for IOSXR devices... this has been there a while and I think    it was just a hold over from early early versions of scrapli that perhaps had a less robust in channel    authentication handler. 1 second faster IOSXR for free! Yay!</li> <li>Fixed an issue with system transport where the transport would get closed twice causing an unhandled exception --    thank you to Alex Lardschneider for finding this!</li> <li>Added an example for the <code>enable_basic_logging</code> function as well as the <code>commandeer</code> method</li> <li>Improved priv level handling -- if you try to acquire \"parallel\" privileges (ex. configuration and configuration    exclusive in IOSXR) previously we would say things worked, but we would just stay in configuration mode. This has    been fixed (hopefully)!</li> <li>Move ansi escape pattern to compile globally, so it only compiles once (why it was never like that before... who knows)</li> <li>Simplify the <code>collect</code> bits for integration tests... this is still not used heavily but hopefully will be soon!</li> <li>Replace vrnetlab creds in examples with scrapli (felt confusing to have vrnetlab creds everywhere, plus functional    testing is moving away from (but still supporting) vrnetlab test environment)</li> <li>Crank up the rows/cols for system transport -&gt; 80 rows, 256 cols -- this to align with scrapligo and to make it    less common that users need to modify these values.</li> <li>BUGFIX: fixed blocking read in async channel telnet authentication (thank you Dmitry Figol!)</li> <li>Added <code>not_contains</code> field to privilege levels... this will help greatly simplify the necessary regex patterns, as    well as allow us to ditch look arounds which go does not support... step one to a standardized community platform    that works with python -or- go!</li> <li>Simplified (at least a little... more would be good) patterns for privilege levels for core platforms.</li> <li>Added <code>_generic_driver_mode</code> to  the <code>NetworkDriver</code> classes -- this is a private mode as it should probably be used    cautiously -- the idea here is that you can send any strings you want and scrapli will not care about privilege   levels at all. See the discussion about this here.</li> <li>BUGFIX: fixed asynctelnet issue with control character handling, thank you to @davaeron    -- see #147</li> <li>BREAKING CHANGE removed the <code>transport.username_prompt</code> and <code>transport.password_prompt</code> attributes of the telnet    transports. All authentication has been moved into the channel, so it made no sense to leave these attributes on    the transports. This may cause an issue for users that had explicitly set their prompts to something non-standard.</li> <li>Finally added logic to auto set port to 23 for telnet :)</li> <li>BUGFIX: fixed a rare issue where decoding bytes received from the channel (in the response object) would raise a    <code>UnicodedecodEerror</code>; we now catch this exception and decode with <code>ISO-8859-1</code> encoding which seems to be much    less picky about what it decodes. Thanks to Alex Lardschneider for yet another good catch and fix!</li> <li>Added <code>interaction_complete_patterns</code> to all \"interactive\" methods -- this argument accepts a list of    strings/patterns; will be re-escape'd if each string does not start with and end with \"^\" and \"$\" (line anchors),   otherwise will be compiled with the standard scrapli case-insensitive and multiline flags. If the interactive    event finds any of these pattenrs during the course of the interacting it will terminate the interactive session.    Note that this is entirely optional and is a keyword only argument so no changes are necessary to any existing    scrapli programs.</li> </ul>"},{"location":"changelog/#20210130","title":"2021.01.30","text":"<ul> <li>BREAKING CHANGE <code>PrivilegeLevel</code> import location changed -- this will break things! </li> <li><code>timeout_exit</code> deprecated; will always close connection on timeout now</li> <li>All exceptions rationalized/changed -- all exceptions now rooted in <code>ScrapliException</code> and scrapli should not    raise any exception that is not rooted in this! It is of course possible that non-scrapli exceptions will get    raised at some point, but all \"common\" exceptions will now follow this pattern.</li> <li>Added opinionated logging option -- should be used only for debugging/testing, otherwise use your own logging setup!</li> <li>Moved \"in channel\" auth into channel (for telnet/system ssh authentication)</li> <li>Added <code>channel_lock</code> option, defaults to false</li> <li>Added <code>channel_log</code> option</li> <li>Decorators got reswizzled a little, no more requires open as the transports handle this. There is now a dedicated    ChannelTimeout and TransportTimeout to keep things simpler.</li> <li>All transport plugins are now in scrapli \"core\"</li> <li>All (ok, most...) channel and transport args are now properties of the driver class -- this should remove    confusion about where to update what timeout/value</li> <li><code>Response._record_response</code> is now public but only for linting reasons, people generally should ignore this anyway!</li> <li>Python 3.6 will now require dataclasses backport</li> <li>All driver methods now have only the \"main\" argument as an allowable positional argument, the rest of the    arguments are keyword-only! For example, <code>send_command</code> you can pass a positional argument for <code>command</code>, but    <code>strip_prompt</code> and any additional arguments must be keyword arguments!</li> <li>BREAKING CHANGE <code>Scrape</code>/<code>AsyncScrape</code> renamed --&gt; <code>Driver</code>/<code>AsyncDriver</code> -- given most folks should not be using    these directly there will be no alias for this, just a hard change!</li> <li>More improvements to IOSXE tclsh pattern handling; handles tclsh in exec or privilege exec mode now</li> <li><code>read_until_prompt_or_time</code> now supports regex patterns in the <code>channel_outputs</code> list (pass as a string, will be    compiled for you)</li> <li>Big improvements to Factory for users of IDEs -- factories now have proper typing data so you will have nice auto    completion things there/typing will be much happier</li> </ul>"},{"location":"changelog/#20201231","title":"2020.12.31","text":"<ul> <li>Make log messages for textfsm and genie parsers failing to parse consistent as <code>log.warning</code></li> <li>Add factory example</li> <li>Add \"root\" priv level to junos driver -- probably should be considered experimental for now :)</li> <li>Fix issue where <code>send_config</code> unified result did not have finish time set</li> <li>POSSIBLY BREAKING CHANGE: logger names have changed to be easier to get/make more sense -- the logger for each    instance used to look like: \"scrapli-channel-{{ HOST }}\" which kinda was not really smart :). Loggers now look    like: \"scrapli.{{ HOST }}:{{ PORT }}.channel\" -- can be channel|driver|transport!</li> <li>Changes to test environment:</li> <li>~~Support running devices on localhost w/ nat'd management ports -- in \"vrouter\" mode (poorly named) -- this is      enabled with the <code>SCRAPLI_VROUTER</code> environment variable set to on/true/something~~ Update 2022.01.30 - renamed      to <code>SCRAPLI_BOXEN</code> but does the same thing!</li> <li>Added bootvar into nxos base config -- when missing causes qemu nxosv to boot into loader prompt so thats no good</li> <li>Replace resource settings in vdc in nxos to account for nxos instances with differing resources (memory/cpu)</li> <li>Got rid of static license udi in iosxe config, replaced more certificate stuff so show run comparisons are      easier on iosxe</li> <li>NEW TRANSPORT <code>asynctelnet</code> transport is built using standard library asyncio, as such it is part of scrapli core</li> <li>Should be considered beta for a while :)</li> <li>Added a bunch of tests mocking streamreader/writer to ensure that this driver is well tested</li> <li>Added asynctelnet support in nxos and juniper drivers (to change prompt for those platforms)</li> <li>Support asynctelnet in base driver</li> <li><code>auth_bypass</code> for both telnet drivers completely bypasses not only auth (as it did previously) but also the auth    validation where we confirm we got logged in successfully -- reason being is that for console servers and such you    may not care about that, you may just want to log in and read data.</li> <li>Removed unnecessary re-checking/verifying of ssh config file in system transport (was basically duplicated from    base transport, so was pointless!)</li> <li>Bumped all the default timeout values up as they were probably a bit on the aggressive side</li> <li>Added <code>eager</code> argument to send commands/commands from file and config/configs/configs from file methods --    basically this <code>eager</code> mode will not look for a prompt between lines of commands/configs. This means that things    have a tiny potential to get out of whack because we will just send things as fast as possible. In order to not    totally break things we will (whether you like it or not!) wait and find the prompt on the last command/config    in the list though -- that way we dont get too out of whack. This now means we can use <code>eager</code> to configure    banners and macros and things and we no longer need to do the dirty send interactive workaround.</li> <li>Added <code>ScrapliConnectionLost</code> exception and raise it if we get EOF in system transport -- with a message that is    more clear than just \"EOF\" and some obscure line in ptyprocess!</li> <li>Added <code>tclsh</code> privilege level for IOSXE</li> <li>Fixed a bug that would prevent going to \"parallel\" privilege levels -- i.e. going from tclsh to configuration or    visa versa in IOSXE or from configuration to configuration_exclusive in IOSXR</li> <li>If no <code>failed_when_contains</code> is passed to <code>send_interactive</code> network drivers will now use the network drivers    <code>failed_when_contains</code> attribute to bring it inline with the normal command/config methods</li> <li>Added <code>timeout_ops</code> to <code>send_interactive</code> and wrap those methods with the <code>TimeoutModifier</code> decorator</li> <li>Add logic to properly fetch socket address family type so we can handle IPv6 hosts (w/ scrapli-ssh2/scrapli-paramiko)</li> <li>Added <code>tclsh</code> privilege level for NXOS, didn't even know that existed before!</li> </ul>"},{"location":"changelog/#20201115","title":"2020.11.15","text":"<ul> <li>Fix a regex that sometimes caused a failed functional IOSXR test</li> <li>Add <code>ptyprocess</code> transport options for system transport -- sounds like this may be needed for huawei community  platform to be able to set the pty process terminal size -- also added some basic testing for this</li> <li>Update scrapli-ssh2 pin to latest version -- now supports keyboard interactive auth; also un-skipped all related  EOS tests now that this works</li> <li>Fix missing acquire priv in default on_open methods for nxos and eos async version</li> <li>Fix incorrect <code>textfsm_platform</code> for iosxr (was cisco_iosxr, now is cisco_xr)</li> <li>Remove unnecessary decorator on write operations for systemssh and telnet -- this operation shouldn't block so this  was unnecessary; any issue here should raise some exception from the lower level library.</li> <li>Playing around w/ adding coverage reports with Codecov</li> </ul>"},{"location":"changelog/#20201010","title":"2020.10.10","text":"<ul> <li>Improve logging in helper functions - especially around resolving ssh config/known hosts</li> <li>Add <code>ttp_parse_output</code> method to Response object; add <code>ttp_parse</code> function in helper</li> <li>Load requirements from requirements files and parse them for setup.py -- stop me from forgetting to update in one  place or another!</li> <li>Slacken the IOSXE configuration prompt pattern -- <code>hostname(ipsec-profile)</code> was not being caught by the pattern as  it was expecting the part in parenthesis to start with \"conf\" - thank you Talha Javaid for bringing this up on ntc   slack, and Alex Lardschneider for confirming the \"fix\" should be good to go!</li> <li>Add <code>community</code> pip extra to install scrapli community</li> <li>Minor README house keeping!</li> <li>Made transport <code>set_timeout</code> saner -- I genuinely don't know what I was doing with that before... this included the  base class as well as updating telnet and systemssh... in theory this could be a breaking change if you were just   calling <code>set_timeout</code> for some reason without passing an argument... you probably weren't doing that... because why    would you? There was some precedent for doing it like this before but it isn't worth caring about now :)</li> <li>Did smarter things with imports in helper, added tests to make sure the warnings are correct</li> <li>Dramatically simplified session locking... this had just gotten out of hand over time... now only the channel locks . This means that basically all inputs/outputs should go through the channel and/or you should acquire the lock  yourself if you wish to read/write directly to the transport. Critically this means that all the external transport   plugins AND scrapli-netconf need to be updated as well -- this means that you must update all of these if you are    using this release! (requirements are of course pinned to make sure this is the case)</li> <li>BREAKING CHANGE: removed ALL keepalive stuff... for now. This will probably get added back, but AFAIK nobody  uses it right now and the implementation of it is frankly not very good... keeping it around right now added complexity   for little gain. Keepalives will be back and improved hopefully in the next release. If you need them, please just    pin to 2020.09.26!</li> </ul>"},{"location":"changelog/#20200926","title":"2020.09.26","text":"<ul> <li>Improved error handling/exceptions for scrapli <code>Factory</code></li> <li>Fixed issue where <code>system</code> transport did not properly close/kill SSH connections</li> <li>Added 3.9-dev testing to GitHub Actions</li> <li>Added initial testing/support of <code>on_init</code> callable to base driver -- the idea for <code>on_init</code> is mostly to allow  <code>scrapli_community</code> platform creators to be able to add an additional callable to be executed after initialization   of the scrapli object, but before any <code>open</code> method is called</li> <li>Added initial testing/support of <code>scrapli_community</code> driver classes -- this would allow <code>scrapli_community</code> platform creators to create driver classes so that they can implement custom methods for each platform type if  desired</li> <li>Minor improvements to <code>telnet</code> transport to improve logging as well as authentication validation (are we  authenticated); this also makes <code>telnet</code> look/feel a lot more like <code>system</code> which is nice for consistency reasons</li> <li>Fix regression that caused scrapli to spam a bajillion log entries -- now a filter gets applied in both <code>Channel</code> and <code>Transport</code> base classes to snag the filter from the root <code>scrapli</code> logger and apply it to the base/channel  loggers</li> <li>Fully give into the warm embrace of dependabot and pin all the dev requirements to specific versions... dependabot  can keep us up to date and this lets us not worry about builds failing because of dev requirements getting changed   around</li> <li>Fix ptyprocess file object closing issue</li> </ul>"},{"location":"changelog/#20200828","title":"2020.08.28","text":"<ul> <li>Added Packet Pushers scrapli episode to the README!!</li> <li>Added NXOS and Junos mock ssh servers and created tests for open/close methods (silly tests but just ensures we  send what we think we should be sending)</li> <li>Created a property <code>timeout_ops</code> on the driver class -- this property will also set the <code>timeout_ops</code> value of the  channel as well, this is just to make it so users don't have to do <code>conn.channel.timeout_ops</code> to set the timeout   value... that was not super intuitive!</li> <li>Update dev/test requirements to finally have pylama 2.6! This means that isort can be unpinned and free to update!</li> <li>Add <code>send_and_read</code> method to <code>GenericDriver</code> -- this method allows you to send an input (at the current priv level ) and wait for a prompt, an expected output, or a duration.</li> <li>Add <code>eager</code> flag to the channel <code>send_input</code> method -- this probably should not be used by many folks, but can be  used to not read until the prompt pattern is seen. In other words, this will send an input, read the input off the   channel and then return.</li> <li>All exceptions that are raised due to catching an internal exception should now be raising \"from\" the caught  exception -- mostly this is to appease Pylama, but may end up being nicer on the eyes/easier to see whats going on   in some scenarios. </li> <li>IOSXE now catches \"Enable password:\" for an escalation pattern from exec to privilege exec -- fixes #45</li> <li>The \"requires open\" decorator has been updated/fixed to play nice with asyncio</li> <li><code>timeout_ops</code> has been converted from an int to a float to allow for more granular timeout control (the other  timeouts remain as integers)</li> <li>Few minor docstring fixes from copypasta issues :)</li> <li>Update black pin/re-run black</li> </ul>"},{"location":"changelog/#20200726","title":"2020.07.26","text":"<ul> <li>Fixed the same <code>get_prompt</code> issue from the last release, but this time managed to actually fix it in async version!</li> <li>Better handling of <code>read_until_input</code> -- stripping some characters out that may get inserted (backspace char), and  compares a normalized whitespace version of the read output to the a normalized whitespace version of the input  , fixes #36.</li> <li>Improved system transport ssh error handling -- catch cipher/kex errors better, catch bad configuration messages.</li> <li>Now raise an exception if trying to use an invalid transport class for the base driver type -- i.e. if using  asyncssh transport plugin with the \"normal\" sync driver class.</li> <li>Added links to the other projects in the scrapli \"family\" to the readme.</li> <li>Created first draft of the scrapli \"factory\" -- this will allow users to provide the platform name as a string to a  single <code>Scrapli</code> or <code>AsyncScrapli</code> class and it will automagically get the right platform driver selected and such  . This is also the first support for <code>scrapli_community</code>, which will allow users to contribute non \"core\" platforms   and have them be usable in scrapli just like \"normal\".</li> <li>Overhaul decorators for timeouts into a single class (for sync and async), prefer to use signals timeout method  where possible, fall back to multiprocessing timeout where required (multiprocessing is slower/more cpu intensive so   dont use it if we dont have to).</li> </ul>"},{"location":"changelog/#20200712","title":"2020.07.12","text":"<ul> <li>Fixed a silly issue where <code>get_prompt</code> was setting the transport timeout to 10s causing user defined timeouts to be  effectively ignored.</li> <li>Improved telnet authentication handling -- previously if a return character was needed to get the auth prompts to  kick into gear this could break auth.</li> <li>Added \"auth_bypass\" to telnet transport.</li> <li>Probably BUGFIX -- async functions were being decorated by the \"normal\" <code>operation_timeout</code> decorator -- created a  mostly duplicated async version of the timeout decorator to wrap the <code>AsyncChannel</code> methods. </li> <li>Fixed a maybe regression that caused drivers to try to authenticate (via interactive methods) even if a  <code>auth_secondary</code> is not set. Added tests to make sure that we raise a warning if there is no secondary password set  , but try to increase privilege without authentication, and of course if there is an auth secondary set, we   obviously try to auth in the normal fashion.</li> <li>Started thinning down the PtyProcess stuff to simplify and and remove all unnecessary parts, as well as add typing  and docstrings... not done yet, but some progress!</li> <li>Added additional asyncio example</li> <li>Added blurb about versioning in README</li> <li>Fixed a few README issues (incorrect methods/typos)</li> <li>Updated notes about auth_bypass to include telnet support</li> <li>Added <code>SSHNotFound</code> exception for system SSH/PtyProcess if ssh binary can't be found</li> </ul>"},{"location":"changelog/#20200704","title":"2020.07.04","text":"<ul> <li>Updated IOSXE base config to include netconf setup for consistency w/ scrapli_netconf</li> <li>Removed \"pipes\" authentication for system ssh -- this is mostly an internal change that simplifies the way that  system transport authenticates. We lose the ability to very easily read out of stderr what is going on so even if we   auth with a key now we have to \"confirm\" that we are authenticated, but this removes a fair bit of code and unifies    things as well as allows for the next line item...</li> <li>Added support for <code>auth_private_key_passphrase</code> to system transport -- allows for entering ssh key passphrase to  decrypt ssh keys</li> <li>Added an example on how to deal with \"weird\" things like banners and macros -- these types of things change how the  ssh channel works in that they are pseudo \"interactive\" -- meaning the prompt is modified/removed so scrapli can't   ever \"know\" when a command is done inserting. It would be possible to support these types of config items more    \"natively\" but doing so would lose some of the smarts about how scrapli enters/confirms inputs sent, so for now     (and probably for forever) these will need to be configured in a \"special\" fashion</li> <li>Updated IOSXE for functional tests to use 16.12.03 -- this includes updates to the base config/expected configs ... AFAIK there is some better netconf/restconf support in this version which may be handy for tests for scrapli-netconf</li> <li>Update channel/drivers to never decode bytes -- this now only happens in the response object; primary motivation  for this is to not have to decode/re-encode in general, and in scrapli-netconf in particular</li> </ul>"},{"location":"changelog/#20200606","title":"2020.06.06","text":"<ul> <li>Converted all priv levels to be kwargs instead of just args for setup -- simple thing but makes it more readable IMO.</li> <li>Added to the Juniper prompt pattern to include matching the RE prompt that is on the line \"above\" the \"normal \" prompt as this was getting included in command output instead of being seen as part of the prompt by scrapli.</li> <li>Convert driver privilege escalation prompts to use regex to match upper and lower case \"P\" in password prompt</li> <li>Fix core drivers to actually allow for users to pass <code>failed_when_contains</code>, <code>textfsm_platform</code>, <code>genie_platform</code>, and <code>default_desired_privilege_level</code></li> <li>Add better exception/message for attempting to send command/config to a connection object that has not been opened</li> <li>Add testing for on open/close methods of core drivers</li> <li>Add <code>send_config</code> method to send a single configuration string -- this will automagically handle sending a full  configuration, breaking it into a list of configs, sending that list with <code>send_configs</code> and then joining the   responses into a single <code>Response</code> object... or of course you can just send a single config line with it too!</li> <li>Add better handling/logging for <code>SystemSSH</code> transport when key exchange cannot be negotiated</li> <li>Convert the <code>_failed()</code> method of <code>MultiResponse</code> to be a property so users can check <code>.failed</code> on a <code>MultiResponse</code>  object more intuitively/sanely</li> <li>ASYNC ALL THE THINGS... basically only an internal change, but hugely modified the guts of scrapli to try to be  able to best support asyncio while still having the same api for sync and async. Again, if you dont care about   aysncio this probably doesnt matter at all as all the \"public\" stuff has not changed for sync versions of things.</li> <li>Completely overhaul unit tests -- unit tests now spin up an SSH server using asyncssh, this server is a very basic  implementation of an IOSXE device. This fake IOSXE device allows for connecting/sending commands/handling log on   stuff like disabling paging all in as close to the real thing as possible while being completely self contained and    completely in python. Additionally since there was a lot of changes to break things out to be more granular with the     async implementation the testing has evolved to support this.</li> <li>Increased all hostname patterns to match up to 63 characters -- this is the hostname length limit for Cisco IOSXE  at least and should be a reasonable value that hopefully doesnt really ever need to be changed/expanded now</li> <li>Changing logging to create a logger associated with each object instance and include the name/ip of the host in the  log name -- should make things a lot nicer with threads/asyncio/etc.</li> <li>Moved from tox to using nox for handling tests/linting; originally this was because of some of the unit testing  failing when ran via tox (now I believe this was because there was no TERM env var set in tox), but at this point   nox is quite nice so we'll stick with it!</li> <li>Added exception to be raised when users try to use system transport on Windows</li> <li>BUGFIX: Added underscores to hostname patterns for IOSXE, IOSXR, NXOS, and Junos (not valid in EOS at least in my  testing)</li> <li>No more Windows testing, not worth the effort</li> <li>BUGFIX: Added functionality to merge less specific (but matching) host entry data for ssh config file hosts  -- meaning that we can now merge attributes from a \"*\" entry into a more specific host entry (see #21)</li> <li>Add dependabot to see how we like having that friend around...</li> </ul>"},{"location":"changelog/#20200509","title":"2020.05.09","text":"<ul> <li>Add underscores to EOS config prompt matching</li> <li>Actually fixed on_close methods that I could have sworn were fixed.... gremlins! (was sending prompt pattern  instead of a return char... for copypasta reasons probably)</li> <li>No longer \"exit\" config mode... given that send_command like methods already check to ensure they are in the right  priv level there is no reason to exit config mode... just leave it when you need to. Should be a minor speed up if   using send_configs more than once in a row, and otherwise should be basically exactly the same.</li> <li>For NetworkDrivers we no longer set the channel prompt pattern depending on the priv level -- it is now *always</li> <li>the combined pattern that matches all priv levels... this should make doing manual things where you change  privileges and don't use scrapli's built in methods a little easier. Scrapli still checks that the current prompt   matches where it thinks it should be (i.e. config mode vs privileged exec) though, so nothing should change from a    user perspective.</li> <li>Improve (fix?) the abort config setup for IOSXR/Junos</li> <li>Add more helpful exception if ssh key permissions are too open</li> <li>Convert PrivilegeLevel from a namedtuple to a class with slots... better for typing and is also mutable so users  can more easily update the pattern for a given privilege level if so desired</li> <li>Minor clean up stuff for all the core platforms and network driver, all internal, mostly just about organization!</li> <li>Add \"configuration_exclusive\" privilege level for IOSXRDriver, add \"configuration_private\" and  \"configuration_exclusive\" for JunosDriver, modify some of the privilege handling to support these modes -- these can   be accessed by simply passing <code>privilege_level=\"configuration_exclusive\"</code> when using <code>send_configs</code> method</li> <li>Add support for configuration sessions for EOS/NXOS. At this time sessions need to be \"registered\" as a privilege  level, and then are requestable like any other privilege level, and can be used when sending configs by passing   the name of your session as the privilege level argument for send config methods</li> <li>Add a space to EOS prompts -- it seems its very easy to add one to the prompts and scrapli did not enjoy that  previously!</li> <li>Give users the option to pass in their own privilege levels for network drivers, and also throw a warning if users  try to pass <code>comms_prompt_pattern</code> when using network drivers (as this should all be handled by priv levels)</li> <li>Created <code>MultiResponse</code> object to use instead of a generic list for grouping multiple <code>Response</code> objects </li> <li>Added <code>raise_for_status</code> methods to <code>Response</code> and <code>MultiResponse</code> -- copying the <code>requests</code> style method here to  raise an exception if any elements were failed</li> <li>BUGFIX: fixed an issue with IOSXEDriver not matching the config mode pattern for ssh pub key entries.</li> </ul>"},{"location":"changelog/#20200430","title":"2020.04.30","text":"<ul> <li>Continued improvement around <code>SystemSSHTransport</code> connection/auth failure logging</li> <li>Fix for very intermittent issue where pty fd is not available for reading on SystemSSH/Telnet connections, now we  loop over the select statement checking the fd instead of failing if it isn't immediately readable</li> <li>Implement atexit function if keepalives are enabled -- this originally just lived in the ssh2 transport, but needs  to be here in the base <code>Transport</code> class as the issue affected all transport types</li> <li>Added <code>send_commands_from_file</code> method... does what it sounds like it does...</li> <li>Added <code>send_configs_from_file</code> method (<code>NetworkDriver</code> and sub-classes)... also does what it sounds like it does</li> <li>Simplified privilege levels and overhauled how auth escalation/deescalation works. Its still probably a bit more  complex than it should be, but its a bit more efficient and at least a little simpler/more flexible.</li> <li>Removed <code>comms_prompt_pattern</code> from Network drivers and now build this as a big pattern matching all of the priv  levels for that device type. This is used only for initial connection/finding prompt then scrapli still sets the   explicit prompt for the particular privilege level.</li> <li>Implemented lru_cache on some places where we have repetitive tasks... probably unmeasurable difference, but in  theory its a little faster now in some places</li> <li>Moved some Network driver things into the  base <code>NetworkDriver</code> class to clean things up a bit.</li> <li>Added an <code>_abort_config</code> method to abort configurations for IOSXR/Juniper, this is ignored on the other core platforms</li> <li>BREAKING CHANGE: (minor) Removed now unneeded exception <code>CouldNotAcquirePrivLevel</code></li> <li>Made the <code>get_prompt_pattern</code> helper a little worse... should revisit to improve/make its use more clear</li> <li>Fixed a screw up that had ridiculous transport timeouts -- at one point timeouts were in seconds, then milliseconds ... went back to seconds, but left things setting millisecond values... fixed :D </li> <li>Added <code>transport_options</code> to base <code>Scrape</code> class -- this is a dict of arguments that can be passed down to your  selected transport class... for now this is very limited and is just for passing additional \"open_cmd\" arguments to   <code>SystemSSHTransport</code>. The current use case is adding args such as ciphers/kex to your ssh command so you don't need    to rely on having this in an ssh config file.</li> </ul>"},{"location":"changelog/#20200419","title":"2020.04.19","text":"<ul> <li>Increase character count for base prompt pattern for <code>Scrape</code>, <code>GenericDriver</code>, and core drivers. Example: <code>r\"^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$\"</code> for the base <code>IOSXEDriver</code> <code>comms_prompt_pattern</code> has been increased to: <code>r\"^[a-z0-9.\\-@()/:]{1,48}[#&gt;$]$\"</code></li> <li>Improve the logging for <code>SystemSSHTransport</code> authentication</li> <li>Fixed an issue where <code>SystemSSHTransport</code> auth would fail due to a login banner having the word <code>password</code> in the  banner/text</li> <li>Significantly increase the base <code>timeout_ops</code> value -- as this is not a timer that is going to cause things to  block, it may as well be much higher for the default value to help prevent issues</li> <li>Fixed an issue w/ ssh config file not parsing the last host entry</li> <li>Added super basic tests for most of the examples -- just making sure they don't blow up... in general that should  keep them in decent shape!</li> <li>Removed cssh2 and miko transports from scrapli core. These have been migrated to their own repositories. From a  users perspective nothing really should change -- you can still <code>pip install scrapli[paramiko]</code> to install the   paramiko transport and the requirements (paramiko), and the actual usage (setting <code>\"transport\" = \"paramiko   \"</code>) remains the same! This is mostly about keeping the core of scrapli as simple as possible, and also will    hopefully help to illustrate that <code>SystemSSH</code> is the development priority for scrapli.</li> <li>Convert many function calls to use keyword args for better readability throughout</li> <li>Add a <code>comms_auto_expand</code> argument to the <code>Channel</code>; for now this is mostly not used, but may be useful in the  future. The purpose of this is to handle devices that auto expand input commands to their full canonical name.</li> <li>Hopefully(?) fixed a bit of an idiosyncrasy where the <code>timeout_transport</code> was being used to decorate read/write  operations for telnet/system transports. This is no longer the case, the read/write methods are NOT decorated now  , instead we rely on the <code>timeout_ops</code> to time these operations out OR the <code>timeout_transport</code> being set to the   timeout value (telnet) or <code>ServerAliveInterval</code> value for system ssh.</li> </ul>"},{"location":"changelog/#20200411","title":"2020.04.11","text":"<ul> <li>BREAKING CHANGE: modify <code>send_interact</code> to just make more sense in general... now it supports 1-&gt;N \"events\" to  interact with -- see the \"handling prompts\" section of README for updated example</li> <li>Moved <code>record_response</code> of <code>Response</code> object to be a private method, shouldn't really be needed publicly</li> <li>Moved <code>authenticate</code> and <code>isauthenticated</code> methods of ssh2/paramiko transports to private methods</li> <li>Add <code>auth_bypass</code> option to ignore ssh auth for weird devices such as Cisco WLC -- currently only supported on  system transport.</li> <li>Bump timeout_transport up to 10 seconds after finding some issues for some users.</li> <li>Add example for \"non-standard\" device type (Cisco WLC) demo-ing the auth_bypass, custom on_open method, custom  comms_prompt_pattern and just general non-standard device stuff.</li> <li>Add option (and make it the default) to have textfsm data returned in list of dict form with the headers being the  keys and of course the row values as the values, should be much nicer on the eyes this way!</li> <li>Added terminal width settings for the core drivers to set things as wide as possible so long commands don't have  issues</li> <li>Teeny tiny improvements that may make things a tick faster in Channel by using str methods instead of re</li> <li>Create a draft of public api status doc -- this should be useful on a quick glance to see if/when any public  methods change, obviously as development simmers down things should be stable but inevitably stuff will change  , so the goal here is to just document when methods were introduced and the last time they were changed</li> <li>Move some imports around so that scrapli works on windows (with paramiko/ssh2 transports)</li> </ul>"},{"location":"changelog/#20200329","title":"2020.03.29","text":"<ul> <li>Add support for <code>parse_genie</code> to Response object; obviously really only for Cisco devices at this point unless  there are parsers floating around out there for other platforms I don't know about!</li> <li>Add an <code>atexit</code> function for the ssh2 transport which forcibly closes the connection. This fixes a bug where if a  user did not manually close the connection (or use a context manager for the connection) the script would hang open   until an interrupt.</li> <li>Added a <code>GenericDriver</code> for those with non-core platforms. The <code>GenericDriver</code> has a really broad prompt pattern  match, doesn't know about privilege levels or any other device specific stuff, but does provide the <code>send_command</code>, <code>send_commands</code>, <code>send_interact</code>, and <code>get_prompt</code> methods just like the \"core\" drivers do. This should be a   decent starting point for anyone working on non-core platforms!</li> <li>Minor unit test improvement to cover send_commands (plural) and to cover the new <code>GenericDriver</code></li> <li>Improved auth failure handling for systemssh using pty auth (username/pass auth)</li> <li>Add \"failed_when\" strings to the core drivers; these are used in the response object to help indicate if the  channel input failed or succeeded. For scrapli not super super helpful, but nornir_scrapli will benefit from this as   well!</li> <li>Modify <code>NetworkDriver</code> to inherit from <code>GenericDriver</code> -- this allowed for some clean up of how/where <code>Response</code> objects get created/returned from. <code>Channel</code> now is much more de-coupled from whatever sits on top of it (this will  be important for some netconf testing happening soon!). </li> <li>Minor test de-duplication around ssh config/known hosts file gathering.</li> <li>Added a few simple examples for structured data (textfsm/genie) and updated existing examples a bit.</li> </ul>"},{"location":"public_api_status/","title":"Public API Status","text":"<p>Note that all public methods, unless otherwise noted, are available in sync and async form depending on the driver  you have selected.</p>"},{"location":"public_api_status/#drivers","title":"Drivers","text":""},{"location":"public_api_status/#driver","title":"Driver","text":"Method Implemented Last Change Notes open 2020.03.29 close 2020.03.29 isalive 2020.03.29"},{"location":"public_api_status/#asyncdriver","title":"AsyncDriver","text":"Method Implemented Last Change Notes open 2020.06.06 close 2020.06.06 isalive 2020.06.06"},{"location":"public_api_status/#genericdriver-and-networkdriver-sub-classes-unless-overridden","title":"GenericDriver (and NetworkDriver sub-classes unless overridden)","text":"Method Implemented Last Change Notes get_prompt 2020.03.29 send_command 2020.03.29 2020.08.09 added <code>timeout_ops</code> keyword argument to modify timeout send_commands 2020.03.29 2020.12.31 added <code>eager</code> keyword argument send_commands_from_file 2020.04.30 2020.12.31 added <code>eager</code> keyword argument send_interactive 2020.03.29 2021.01.30 added <code>interaction_complete_patterns</code> keyword argument send_and_read 2020.08.28 send_callback 2022.01.30"},{"location":"public_api_status/#asyncgenericdriver-and-networkdriver-sub-classes-unless-overridden","title":"AsyncGenericDriver (and NetworkDriver sub-classes unless overridden)","text":"Method Implemented Last Change Notes get_prompt 2020.06.06 send_command 2020.06.06 2020.08.09 added <code>timeout_ops</code> keyword argument to modify timeout send_commands 2020.06.06 2020.12.31 added <code>eager</code> keyword argument send_commands_from_file 2020.06.06 2020.12.31 added <code>eager</code> keyword argument send_interactive 2020.06.06 2021.01.30 added <code>interaction_complete_patterns</code> keyword argument send_and_read 2020.08.28 send_callback 2022.01.30"},{"location":"public_api_status/#networkdriver-and-platform-driver-sub-classes-unless-overridden","title":"NetworkDriver (and Platform driver sub-classes unless overridden)","text":"Method Implemented Last Change Notes update_privilege_levels 2020.05.09 update priv map/all prompt pattern if adding/modifying privs acquire_priv 2020.03.29 register_configuration_session 2020.05.09 register a config session so the priv level can be tracked send_config 2020.05.09 2020.12.31 added <code>eager</code> keyword argument send_configs 2020.03.29 2020.12.31 added <code>eager</code> keyword argument send_configs_from_file 2020.04.30 2020.12.31 added <code>eager</code> keyword argument send_interactive 2020.03.29 2021.01.30 added <code>interaction_complete_patterns</code> keyword argument"},{"location":"public_api_status/#asyncnetworkdriver-and-platform-driver-sub-classes-unless-overridden","title":"AsyncNetworkDriver (and Platform driver sub-classes unless overridden)","text":"Method Implemented Last Change Notes update_privilege_levels 2020.06.06 acquire_priv 2020.06.06 register_configuration_session 2020.06.06 send_config 2020.06.06 2020.12.31 added <code>eager</code> keyword argument send_configs 2020.06.06 2020.12.31 added <code>eager</code> keyword argument send_configs_from_file 2020.06.06 2020.12.31 added <code>eager</code> keyword argument send_interactive 2020.06.06 2021.01.30 added <code>interaction_complete_patterns</code> keyword argument"},{"location":"public_api_status/#channel","title":"Channel","text":"Method Implemented Last Change Notes get_prompt 2020.03.29 send_input 2020.03.29 2020.12.31 added <code>eager</code> keyword argument send_inputs_interact 2020.03.29 2020.04.11 changed to support list of \"events\" to interact with send_input_and_read 2020.08.28"},{"location":"public_api_status/#asyncchannel","title":"AsyncChannel","text":"Method Implemented Last Change Notes get_prompt 2020.06.06 send_input 2020.06.06 2020.12.31 added <code>eager</code> keyword argument send_inputs_interact 2020.06.06 send_input_and_read 2020.08.28"},{"location":"public_api_status/#transport","title":"Transport","text":""},{"location":"public_api_status/#transport-abc-and-transport-sub-classes-unless-overridden","title":"Transport ABC (and Transport sub-classes unless overridden)","text":"Method Implemented Last Change Notes open 2020.03.29 close 2020.03.29 isalive 2020.03.29 read 2020.03.29 write 2020.03.29 set_timeout 2020.03.29"},{"location":"public_api_status/#asynctransport-abc-and-transport-sub-classes-unless-overridden","title":"AsyncTransport ABC (and Transport sub-classes unless overridden)","text":"Method Implemented Last Change Notes open 2020.06.06 close 2020.06.06 isalive 2020.06.06 read 2020.06.06 write 2020.06.06 set_timeout 2020.06.06"},{"location":"public_api_status/#response","title":"Response","text":"Method Implemented Last Change Notes genie_parse_output 2020.03.29 textfsm_parse_output 2020.03.29 ttp_parse_output 2020.10.10 Unlike other parse methods, requires a template argument raise_for_status 2020.05.09"},{"location":"public_api_status/#multiresponse","title":"MultiResponse","text":"Method Implemented Last Change Notes raise_for_status 2020.05.09"},{"location":"public_api_status/#sshconfig","title":"SSHConfig","text":"Method Implemented Last Change Notes lookup 2020.03.29"},{"location":"about/code_of_conduct/","title":"Code of Conduct","text":"<p>Be excellent to each other!</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>Thanks for thinking about contributing! Contributions are not expected, but are quite welcome.</p> <p>Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds.</p> <p>Some notes on contributing:</p> <ul> <li>Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR,   this way everyone has a chance to chime in and make sure we're all on the same page!</li> <li>Please open an issue to discuss any bugs/bug fixes prior to opening a PR.</li> <li>Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated!</li> <li>All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing.</li> <li>Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future    don't break functionality or make things act in unexpected ways!</li> </ul>"},{"location":"about/thank_you/","title":"Thank You!","text":"<p>Thank you to the following people who have made contributions other than (and maybe in addition to) code that have  helped make scrapli what it is!</p> <ul> <li>Kevin Landreth for helping with the vision for the system transport driver , and putting up with lots of annoying Slack messages while troubleshooting things</li> <li>Dmitry Figol for really helpful guidance on how best to build the API/overall  structure of things very early on, and continued support/guidance</li> <li>Javin Craig for very early testing help and extra eyes on loads of readme/docs</li> <li>John (IPvZero) McGovern for loads of testing, encouraging the nornir plugin along, and  lots of great discussions</li> <li>Ryan Bradshaw for early testing and discussions on disabling paging, dealing with  interactive inputs, and making the paramiko/ssh2-python transports plugins</li> <li>Eric Tedor for some interesting and challenging use cases that helped to improve some  of the prompt matching decisions</li> <li>Ron Frederick for building the very awesome asyncssh library!</li> <li>Brett Canter for building the very first <code>scrapli_community</code> platform! (ruckus_fastiron)</li> <li>Alex Lardschneider for great conversation, many contributions to  <code>scrapli_community</code>, and helping to improve various pieces of <code>scrapli</code> with great testing and troubleshooting! </li> <li>Marion for loads of testing hard to track down issues with the async transports!</li> <li>Roman Dodin for inspiration to make the docs much better and for adding the doc    testing to keep them looking good!</li> <li>netixx for helping unravel some particularly fun decorator timeout shenanigans!</li> </ul> <p>The following people have helped identify and report bugs in scrapli, thank you all!</p> <ul> <li>Kirill Pletnev<ul> <li>IOSXEDriver configuration mode prompt pattern missed pub key config mode</li> </ul> </li> <li>Michal D<ul> <li>SSH Config not Merging Attributes</li> </ul> </li> <li>artyomovs<ul> <li>Prompt patterns not matching \"tacacs+\"</li> <li>get_prompt Resetting timeout_ops inadvertently</li> <li>telnet authentication when requiring a return char/telnet auth bypass</li> </ul> </li> <li>Dave P<ul> <li>Additional enable password prompt format IOSXE</li> </ul> </li> <li>Natasha Samoylenko<ul> <li>Missing open timeout on <code>asynctelnet</code> transport</li> </ul> </li> </ul> <p>This list has not been kept up as well as it should, apologies for that! Thank you to everyone else who has  contributed in any way to scrapli!</p> <p>Last, but very much not least, a huge shoutout to JetBrains for building awesome tools and providing licenses for their  pro tools to open source developers (like me)! If you would like to use JetBrains awesome products, check out their  open source support page here for me info.</p> <p></p>"},{"location":"more_scrapli/nornir_scrapli/","title":"Nornir scrapli","text":"<p>If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The  nornir_scrapli plugin allows you to use scrapli (and scrapli netconf  and scrapli cfg) within the Nornir framework!</p>"},{"location":"more_scrapli/scrapli_cfg/","title":"Scrapli Cfg","text":"<p>scrapli_cfg (docs)  is utility that accepts a scrapli Telnet or SSH connection and provides configuration management capabilities.  scrapli_cfg allows you to load candidate configurations for merge or replace operations, generate diffs of the  current vs candidate, and of course commit or abort the candidate configuration.</p>"},{"location":"more_scrapli/scrapli_community/","title":"Scrapli Community","text":"<p>If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli  platforms, you should check out scrapli_community! This is the place  for users to share \"non-core\" scrapli platforms.</p>"},{"location":"more_scrapli/scrapli_netconf/","title":"Scrapli Netconf","text":"<p>scrapli_netconf (docs)  is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible,  thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage.  Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when  automating devices over telnet, SSH, or netconf (over SSH).</p>"},{"location":"more_scrapli/scrapli_replay/","title":"Scrapli Replay","text":"<p>scrapli_replay (docs)  is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command  input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that  patches and records and replays session data (like vcr.py) for scrapli connections. </p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>channel<ul> <li>async_channel</li> <li>base_channel</li> <li>sync_channel</li> </ul> </li> <li>decorators</li> <li>driver<ul> <li>base<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> <li>core<ul> <li>arista_eos<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> <li>cisco_iosxe<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> <li>cisco_iosxr<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> <li>cisco_nxos<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> <li>juniper_junos<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> </ul> </li> <li>generic<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> <li>network<ul> <li>async_driver</li> <li>base_driver</li> <li>sync_driver</li> </ul> </li> </ul> </li> <li>exceptions</li> <li>factory</li> <li>helper</li> <li>logging</li> <li>response</li> <li>settings</li> <li>ssh_config</li> <li>transport<ul> <li>base<ul> <li>async_transport</li> <li>base_socket</li> <li>base_transport</li> <li>sync_transport</li> <li>telnet_common</li> </ul> </li> <li>plugins<ul> <li>asyncssh<ul> <li>transport</li> </ul> </li> <li>asynctelnet<ul> <li>transport</li> </ul> </li> <li>paramiko<ul> <li>transport</li> </ul> </li> <li>ssh2<ul> <li>transport</li> </ul> </li> <li>system<ul> <li>ptyprocess</li> <li>transport</li> </ul> </li> <li>telnet<ul> <li>transport</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/decorators/","title":"decorators","text":"<p>scrapli.decorators</p>"},{"location":"reference/decorators/#decorators.timeout_modifier","title":"<code>timeout_modifier(wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]</code>","text":"<p>Decorate an \"operation\" to modify the timeout_ops value for duration of that operation</p> <p>This decorator wraps send command/config ops and is used to allow users to set a <code>timeout_ops</code> value for the duration of a single method call -- this makes it so users don't need to manually set/reset the value</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_func</code> <code>Callable[..., Any]</code> <p>function being decorated</p> required <p>Returns:</p> Name Type Description <code>decorate</code> <code>Callable[..., Any]</code> <p>decorated func</p> Source code in <code>scrapli/decorators.py</code> <pre><code>def timeout_modifier(wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:\n\"\"\"\n    Decorate an \"operation\" to modify the timeout_ops value for duration of that operation\n\n    This decorator wraps send command/config ops and is used to allow users to set a\n    `timeout_ops` value for the duration of a single method call -- this makes it so users don't\n    need to manually set/reset the value\n\n    Args:\n        wrapped_func: function being decorated\n\n    Returns:\n        decorate: decorated func\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if asyncio.iscoroutinefunction(wrapped_func):\n\n        async def decorate(*args: Any, **kwargs: Any) -&gt; Any:\n            driver_instance: \"AsyncGenericDriver\" = args[0]\n            driver_logger = driver_instance.logger\n\n            timeout_ops_kwarg = kwargs.get(\"timeout_ops\", None)\n\n            if timeout_ops_kwarg is None or timeout_ops_kwarg == driver_instance.timeout_ops:\n                result = await wrapped_func(*args, **kwargs)\n            else:\n                driver_logger.info(\n                    \"modifying driver timeout for current operation, temporary timeout_ops \"\n                    f\"value: '{timeout_ops_kwarg}'\"\n                )\n                base_timeout_ops = driver_instance.timeout_ops\n                driver_instance.timeout_ops = kwargs[\"timeout_ops\"]\n                result = await wrapped_func(*args, **kwargs)\n                driver_instance.timeout_ops = base_timeout_ops\n            return result\n\n    else:\n        # ignoring type error:\n        # \"All conditional function variants must have identical signatures\"\n        # one is sync one is async so never going to be identical here!\n        def decorate(*args: Any, **kwargs: Any) -&gt; Any:  # type: ignore\n            driver_instance: \"GenericDriver\" = args[0]\n            driver_logger = driver_instance.logger\n\n            timeout_ops_kwarg = kwargs.get(\"timeout_ops\", None)\n\n            if timeout_ops_kwarg is None or timeout_ops_kwarg == driver_instance.timeout_ops:\n                result = wrapped_func(*args, **kwargs)\n            else:\n                driver_logger.info(\n                    \"modifying driver timeout for current operation, temporary timeout_ops \"\n                    f\"value: '{timeout_ops_kwarg}'\"\n                )\n                base_timeout_ops = driver_instance.timeout_ops\n                driver_instance.timeout_ops = kwargs[\"timeout_ops\"]\n                result = wrapped_func(*args, **kwargs)\n                driver_instance.timeout_ops = base_timeout_ops\n            return result\n\n    # ensures that the wrapped function is updated w/ the original functions docs/etc. --\n    # necessary for introspection for the auto gen docs to work!\n    update_wrapper(wrapper=decorate, wrapped=wrapped_func)\n    return decorate\n</code></pre>"},{"location":"reference/decorators/#decorators.timeout_wrapper","title":"<code>timeout_wrapper(wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]</code>","text":"<p>Timeout wrapper for transports</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_func</code> <code>Callable[..., Any]</code> <p>function being wrapped -- must be a method of Channel or Transport</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Callable[..., Any]</code> <p>result of wrapped function</p> Source code in <code>scrapli/decorators.py</code> <pre><code>def timeout_wrapper(wrapped_func: Callable[..., Any]) -&gt; Callable[..., Any]:\n\"\"\"\n    Timeout wrapper for transports\n\n    Args:\n        wrapped_func: function being wrapped -- must be a method of Channel or Transport\n\n    Returns:\n        Any: result of wrapped function\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if asyncio.iscoroutinefunction(wrapped_func):\n\n        async def decorate(*args: Any, **kwargs: Any) -&gt; Any:\n            transport, logger, timeout = _get_transport_logger_timeout(cls=args[0])\n\n            if not timeout:\n                return await wrapped_func(*args, **kwargs)\n\n            try:\n                return await asyncio.wait_for(wrapped_func(*args, **kwargs), timeout=timeout)\n            except asyncio.TimeoutError:\n                _handle_timeout(\n                    transport=transport,\n                    logger=logger,\n                    message=_get_timeout_message(func_name=wrapped_func.__name__),\n                )\n\n    else:\n        # ignoring type error:\n        # \"All conditional function variants must have identical signatures\"\n        # one is sync one is async so never going to be identical here!\n        def decorate(*args: Any, **kwargs: Any) -&gt; Any:  # type: ignore\n            transport, logger, timeout = _get_transport_logger_timeout(cls=args[0])\n\n            if not timeout:\n                return wrapped_func(*args, **kwargs)\n\n            cls_name = transport.__class__.__name__\n\n            if (\n                cls_name in (\"SystemTransport\", \"TelnetTransport\")\n                or _IS_WINDOWS\n                or threading.current_thread() is not threading.main_thread()\n            ):\n                return _multiprocessing_timeout(\n                    transport=transport,\n                    logger=logger,\n                    timeout=timeout,\n                    wrapped_func=wrapped_func,\n                    args=args,\n                    kwargs=kwargs,\n                )\n\n            callback = partial(\n                _signal_raise_exception,\n                transport=transport,\n                logger=logger,\n                message=_get_timeout_message(wrapped_func.__name__),\n            )\n\n            old = signal.signal(signal.SIGALRM, callback)\n            signal.setitimer(signal.ITIMER_REAL, timeout)\n            try:\n                return wrapped_func(*args, **kwargs)\n            finally:\n                if timeout:\n                    signal.setitimer(signal.ITIMER_REAL, 0)\n                    signal.signal(signal.SIGALRM, old)\n\n    # ensures that the wrapped function is updated w/ the original functions docs/etc. --\n    # necessary for introspection for the auto gen docs to work!\n    update_wrapper(wrapper=decorate, wrapped=wrapped_func)\n    return decorate\n</code></pre>"},{"location":"reference/exceptions/","title":"exceptions","text":"<p>scrapli.exceptions</p>"},{"location":"reference/exceptions/#exceptions.ScrapliAuthenticationFailed","title":"<code>ScrapliAuthenticationFailed</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for scrapli authentication issues</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliAuthenticationFailed(ScrapliException):\n\"\"\"Exception for scrapli authentication issues\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliCommandFailure","title":"<code>ScrapliCommandFailure</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for scrapli command/config failures</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliCommandFailure(ScrapliException):\n\"\"\"Exception for scrapli command/config failures\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliConnectionError","title":"<code>ScrapliConnectionError</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for underlying connection issues</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliConnectionError(ScrapliException):\n\"\"\"Exception for underlying connection issues\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliConnectionNotOpened","title":"<code>ScrapliConnectionNotOpened</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for trying to operate on a transport which has not been opened</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliConnectionNotOpened(ScrapliException):\n\"\"\"Exception for trying to operate on a transport which has not been opened\"\"\"\n\n    def __init__(\n        self,\n        message: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"\n        Scrapli connection not opened exception\n\n        Args:\n            message: optional message\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not message:\n            self.message = (\n                \"connection not opened, but attempting to call a method that requires an open \"\n                \"connection, do you need to call 'open()'?\"\n            )\n        else:\n            self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliConnectionNotOpened.__init__","title":"<code>__init__(message: Optional[str] = None) -&gt; None</code>","text":"<p>Scrapli connection not opened exception</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>optional message</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n    Scrapli connection not opened exception\n\n    Args:\n        message: optional message\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if not message:\n        self.message = (\n            \"connection not opened, but attempting to call a method that requires an open \"\n            \"connection, do you need to call 'open()'?\"\n        )\n    else:\n        self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliException","title":"<code>ScrapliException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base Exception for all scrapli exceptions</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliException(Exception):\n\"\"\"Base Exception for all scrapli exceptions\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliModuleNotFound","title":"<code>ScrapliModuleNotFound</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>ModuleNotFound but for scrapli related issues</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliModuleNotFound(ScrapliException):\n\"\"\"ModuleNotFound but for scrapli related issues\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliPrivilegeError","title":"<code>ScrapliPrivilegeError</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for all privilege related scrapli issues</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliPrivilegeError(ScrapliException):\n\"\"\"Exception for all privilege related scrapli issues\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliTimeout","title":"<code>ScrapliTimeout</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for any scrapli timeouts</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliTimeout(ScrapliException):\n\"\"\"Exception for any scrapli timeouts\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliTransportPluginError","title":"<code>ScrapliTransportPluginError</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for transport plugin issues</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliTransportPluginError(ScrapliException):\n\"\"\"Exception for transport plugin issues\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliTypeError","title":"<code>ScrapliTypeError</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>TypeError but for scrapli related typing issues</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliTypeError(ScrapliException):\n\"\"\"TypeError but for scrapli related typing issues\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliUnsupportedPlatform","title":"<code>ScrapliUnsupportedPlatform</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Exception for unsupported platform; i.e. using system transport on windows</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliUnsupportedPlatform(ScrapliException):\n\"\"\"Exception for unsupported platform; i.e. using system transport on windows\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliValueError","title":"<code>ScrapliValueError</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>ValueError but for scrapli related value issues</p> Source code in <code>scrapli/exceptions.py</code> <pre><code>class ScrapliValueError(ScrapliException):\n\"\"\"ValueError but for scrapli related value issues\"\"\"\n</code></pre>"},{"location":"reference/factory/","title":"factory","text":"<p>scrapli.factory</p>"},{"location":"reference/factory/#factory.AsyncScrapli","title":"<code>AsyncScrapli</code>","text":"<p>         Bases: <code>AsyncNetworkDriver</code></p> Source code in <code>scrapli/factory.py</code> <pre><code>class AsyncScrapli(AsyncNetworkDriver):\n    CORE_PLATFORM_MAP = {\n        \"arista_eos\": AsyncEOSDriver,\n        \"cisco_iosxe\": AsyncIOSXEDriver,\n        \"cisco_iosxr\": AsyncIOSXRDriver,\n        \"cisco_nxos\": AsyncNXOSDriver,\n        \"juniper_junos\": AsyncJunosDriver,\n    }\n    DRIVER_MAP = {\"network\": AsyncNetworkDriver, \"generic\": AsyncGenericDriver}\n\n    @classmethod\n    def _get_driver_class(\n        cls, platform_details: Dict[str, Any], variant: Optional[str]\n    ) -&gt; Union[Type[AsyncNetworkDriver], Type[AsyncGenericDriver]]:\n\"\"\"\n        Fetch community driver class based on platform details\n\n        Args:\n            platform_details: dict of details about community platform from scrapli_community\n                library\n            variant: optional name of variant of community platform\n\n        Returns:\n            NetworkDriver: final driver class\n\n        Raises:\n            N/A\n\n        \"\"\"\n        final_driver: Union[\n            Type[AsyncNetworkDriver],\n            Type[AsyncGenericDriver],\n        ]\n\n        if variant and platform_details[\"variants\"][variant].get(\"driver_type\"):\n            variant_driver_data = platform_details[\"variants\"][variant].pop(\"driver_type\")\n            final_driver = variant_driver_data[\"async\"]\n            return final_driver\n\n        if isinstance(platform_details[\"driver_type\"], str):\n            driver_type = platform_details[\"driver_type\"]\n            standard_final_driver = cls.DRIVER_MAP.get(driver_type, None)\n            if standard_final_driver:\n                return standard_final_driver\n\n        final_driver = platform_details[\"driver_type\"][\"async\"]\n        return final_driver\n\n    @classmethod\n    def _get_community_driver(\n        cls, community_platform_name: str, variant: Optional[str]\n    ) -&gt; Tuple[Union[Type[AsyncNetworkDriver], Type[AsyncGenericDriver]], Dict[str, Any]]:\n\"\"\"\n        Get community driver\n\n        Args:\n            community_platform_name: name of community\n            variant: optional name of variant of community platform\n\n        Returns:\n            NetworkDriver: final driver class\n\n        Raises:\n            N/A\n\n        \"\"\"\n        platform_details = _get_community_platform_details(\n            community_platform_name=community_platform_name\n        )\n\n        final_driver = cls._get_driver_class(platform_details=platform_details, variant=variant)\n        final_platform_kwargs = _get_driver_kwargs(\n            platform_details=platform_details, variant=variant, _async=True\n        )\n\n        return final_driver, final_platform_kwargs\n\n    @classmethod\n    def _get_driver(\n        cls, platform: str, variant: Optional[str]\n    ) -&gt; Tuple[Union[Type[AsyncNetworkDriver], Type[AsyncGenericDriver]], Dict[str, Any]]:\n\"\"\"\n        Parent get driver method for sync Scrapli\n\n        Args:\n            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.\n            variant: name of the target platform variant\n\n        Returns:\n            NetworkDriver: final driver class; generally NetworkDriver, but for some community\n                platforms could be GenericDriver, also returns any additional kwargs comming from\n                the community platform (if any)\n\n        Raises:\n            N/A\n\n        \"\"\"\n        additional_kwargs: Dict[str, Any] = {}\n        final_driver: Union[Type[AsyncGenericDriver], Type[AsyncNetworkDriver]]\n\n        if platform in cls.CORE_PLATFORM_MAP:\n            final_driver = cls.CORE_PLATFORM_MAP[platform]\n            msg = f\"Driver '{final_driver}' selected from scrapli core drivers\"\n        else:\n            final_driver, additional_kwargs = cls._get_community_driver(\n                community_platform_name=platform, variant=variant\n            )\n            msg = (\n                f\"Driver '{final_driver}' selected from scrapli community platforms, with the \"\n                f\"following platform arguments: '{additional_kwargs}'\"\n            )\n\n        logger.info(msg)\n        return final_driver, additional_kwargs\n\n    def __new__(  # pylint: disable=R0914\n        cls,\n        platform: str,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: Optional[str] = None,\n        port: Optional[int] = None,\n        auth_username: Optional[str] = None,\n        auth_password: Optional[str] = None,\n        auth_private_key: Optional[str] = None,\n        auth_private_key_passphrase: Optional[str] = None,\n        auth_strict_key: Optional[bool] = None,\n        auth_bypass: Optional[bool] = None,\n        timeout_socket: Optional[float] = None,\n        timeout_transport: Optional[float] = None,\n        timeout_ops: Optional[float] = None,\n        comms_return_char: Optional[str] = None,\n        ssh_config_file: Optional[Union[str, bool]] = None,\n        ssh_known_hosts_file: Optional[Union[str, bool]] = None,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: Optional[str] = None,\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Optional[Union[str, bool, BytesIO]] = None,\n        channel_log_mode: Optional[str] = None,\n        channel_lock: Optional[bool] = None,\n        logging_uid: Optional[str] = None,\n        auth_secondary: Optional[str] = None,\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: Optional[str] = None,\n        genie_platform: Optional[str] = None,\n        variant: Optional[str] = None,\n        **kwargs: Dict[Any, Any],\n    ) -&gt; \"AsyncScrapli\":\nr\"\"\"\n        Scrapli Factory method for asynchronous drivers\n\n        Args:\n            platform: name of the scrapli platform to return a connection object for; should be\n                one of the \"core\" platforms or a valid community platform name\n            host: host ip/name to connect to\n            port: port to connect to\n            auth_username: username for authentication\n            auth_private_key: path to private key for authentication\n            auth_private_key_passphrase: passphrase for decrypting ssh key if necessary\n            auth_password: password for authentication\n            auth_strict_key: strict host checking or not\n            auth_bypass: bypass \"in channel\" authentication -- only supported with telnet,\n                asynctelnet, and system transport plugins\n            timeout_socket: timeout for establishing socket/initial connection in seconds\n            timeout_transport: timeout for ssh|telnet transport in seconds\n            timeout_ops: timeout for ssh channel operations\n            comms_return_char: character to use to send returns to host\n            ssh_config_file: string to path for ssh config file, True to use default ssh config file\n                or False to ignore default ssh config file\n            ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known\n                file locations. Only applicable/needed if `auth_strict_key` is set to True\n            on_init: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed as the last step of object instantiation -- its purpose is\n                primarily to provide a mechanism for scrapli community platforms to have an easy way\n                to modify initialization arguments/object attributes without needing to create a\n                class that extends the driver, instead allowing the community platforms to simply\n                build from the GenericDriver or NetworkDriver classes, and pass this callable to do\n                things such as appending to a username (looking at you RouterOS!!). Note that this\n                is *always* a synchronous function (even for asyncio drivers)!\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar\n            transport: name of the transport plugin to use for the actual telnet/ssh/netconf\n                connection. Available \"core\" transports are:\n                    - system\n                    - telnet\n                    - asynctelnet\n                    - ssh2\n                    - paramiko\n                    - asyncssh\n                Please see relevant transport plugin section for details. Additionally third party\n                transport plugins may be available.\n            transport_options: dictionary of options to pass to selected transport class; see\n                docs for given transport class for details of what to pass here\n            channel_lock: True/False to lock the channel (threading.Lock/asyncio.Lock) during\n                any channel operations, defaults to False\n            channel_log: True/False or a string path to a file of where to write out channel logs --\n                these are not \"logs\" in the normal logging module sense, but only the output that is\n                read from the channel. In other words, the output of the channel log should look\n                similar to what you would see as a human connecting to a device\n            channel_log_mode: \"write\"|\"append\", all other values will raise ValueError,\n                does what it sounds like it should by setting the channel log to the provided mode\n            logging_uid: unique identifier (string) to associate to log messages; useful if you have\n                multiple connections to the same device (i.e. one console, one ssh, or one to each\n                supervisor module, etc.)\n            failed_when_contains: list of strings indicating command/config failure\n            textfsm_platform: string to use to fetch ntc-templates templates for textfsm parsing\n            genie_platform: string to use to fetch genie parser templates\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            failed_when_contains: List of strings that indicate a command/config has failed\n            variant: name of the community platform variant if desired\n            **kwargs: should be unused, but here to accept any additional kwargs from users\n\n        Returns:\n            final_driver: asynchronous driver class for provided driver\n\n        Raises:\n            ScrapliValueError: if provided transport is asyncio\n            ScrapliTypeError: if `platform` not in keyword arguments\n\n        \"\"\"\n        logger.debug(\"AsyncScrapli factory initialized\")\n\n        if transport not in ASYNCIO_TRANSPORTS:\n            raise ScrapliValueError(\"Use 'Scrapli' if using a synchronous transport!\")\n\n        if not isinstance(platform, str):\n            raise ScrapliTypeError(f\"Argument 'platform' must be 'str' got '{type(platform)}'\")\n\n        provided_kwargs = _build_provided_kwargs_dict(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n            **kwargs,\n        )\n\n        final_driver, additional_kwargs = cls._get_driver(platform=platform, variant=variant)\n\n        # at this point will need to merge the additional kwargs in (for community drivers),\n        # ensure that kwargs passed by user supersede the ones coming from community platform\n        if additional_kwargs:\n            final_kwargs = {**additional_kwargs, **provided_kwargs}\n        else:\n            final_kwargs = provided_kwargs\n\n        final_conn = final_driver(**final_kwargs)\n        # cast the final conn to type Scrapli to appease mypy -- we know it will be a NetworkDriver\n        # or GenericDriver, but thats ok =)\n        final_conn = cast(AsyncScrapli, final_conn)\n        return final_conn\n</code></pre>"},{"location":"reference/factory/#factory.AsyncScrapli.__new__","title":"<code>__new__(platform: str, host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: Optional[str] = None, port: Optional[int] = None, auth_username: Optional[str] = None, auth_password: Optional[str] = None, auth_private_key: Optional[str] = None, auth_private_key_passphrase: Optional[str] = None, auth_strict_key: Optional[bool] = None, auth_bypass: Optional[bool] = None, timeout_socket: Optional[float] = None, timeout_transport: Optional[float] = None, timeout_ops: Optional[float] = None, comms_return_char: Optional[str] = None, ssh_config_file: Optional[Union[str, bool]] = None, ssh_known_hosts_file: Optional[Union[str, bool]] = None, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: Optional[str] = None, transport_options: Optional[Dict[str, Any]] = None, channel_log: Optional[Union[str, bool, BytesIO]] = None, channel_log_mode: Optional[str] = None, channel_lock: Optional[bool] = None, logging_uid: Optional[str] = None, auth_secondary: Optional[str] = None, failed_when_contains: Optional[List[str]] = None, textfsm_platform: Optional[str] = None, genie_platform: Optional[str] = None, variant: Optional[str] = None, **kwargs: Dict[Any, Any]) -&gt; AsyncScrapli</code>","text":"<p>Scrapli Factory method for asynchronous drivers</p> <p>Parameters:</p> Name Type Description Default <code>platform</code> <code>str</code> <p>name of the scrapli platform to return a connection object for; should be one of the \"core\" platforms or a valid community platform name</p> required <code>host</code> <code>str</code> <p>host ip/name to connect to</p> required <code>port</code> <code>Optional[int]</code> <p>port to connect to</p> <code>None</code> <code>auth_username</code> <code>Optional[str]</code> <p>username for authentication</p> <code>None</code> <code>auth_private_key</code> <code>Optional[str]</code> <p>path to private key for authentication</p> <code>None</code> <code>auth_private_key_passphrase</code> <code>Optional[str]</code> <p>passphrase for decrypting ssh key if necessary</p> <code>None</code> <code>auth_password</code> <code>Optional[str]</code> <p>password for authentication</p> <code>None</code> <code>auth_strict_key</code> <code>Optional[bool]</code> <p>strict host checking or not</p> <code>None</code> <code>auth_bypass</code> <code>Optional[bool]</code> <p>bypass \"in channel\" authentication -- only supported with telnet, asynctelnet, and system transport plugins</p> <code>None</code> <code>timeout_socket</code> <code>Optional[float]</code> <p>timeout for establishing socket/initial connection in seconds</p> <code>None</code> <code>timeout_transport</code> <code>Optional[float]</code> <p>timeout for ssh|telnet transport in seconds</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout for ssh channel operations</p> <code>None</code> <code>comms_return_char</code> <code>Optional[str]</code> <p>character to use to send returns to host</p> <code>None</code> <code>ssh_config_file</code> <code>Optional[Union[str, bool]]</code> <p>string to path for ssh config file, True to use default ssh config file or False to ignore default ssh config file</p> <code>None</code> <code>ssh_known_hosts_file</code> <code>Optional[Union[str, bool]]</code> <p>string to path for ssh known hosts file, True to use default known file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</p> <code>None</code> <code>on_init</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed as the last step of object instantiation -- its purpose is primarily to provide a mechanism for scrapli community platforms to have an easy way to modify initialization arguments/object attributes without needing to create a class that extends the driver, instead allowing the community platforms to simply build from the GenericDriver or NetworkDriver classes, and pass this callable to do things such as appending to a username (looking at you RouterOS!!). Note that this is always a synchronous function (even for asyncio drivers)!</p> <code>None</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar</p> <code>None</code> <code>transport</code> <code>Optional[str]</code> <p>name of the transport plugin to use for the actual telnet/ssh/netconf connection. Available \"core\" transports are:     - system     - telnet     - asynctelnet     - ssh2     - paramiko     - asyncssh Please see relevant transport plugin section for details. Additionally third party transport plugins may be available.</p> <code>None</code> <code>transport_options</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary of options to pass to selected transport class; see docs for given transport class for details of what to pass here</p> <code>None</code> <code>channel_lock</code> <code>Optional[bool]</code> <p>True/False to lock the channel (threading.Lock/asyncio.Lock) during any channel operations, defaults to False</p> <code>None</code> <code>channel_log</code> <code>Optional[Union[str, bool, BytesIO]]</code> <p>True/False or a string path to a file of where to write out channel logs -- these are not \"logs\" in the normal logging module sense, but only the output that is read from the channel. In other words, the output of the channel log should look similar to what you would see as a human connecting to a device</p> <code>None</code> <code>channel_log_mode</code> <code>Optional[str]</code> <p>\"write\"|\"append\", all other values will raise ValueError, does what it sounds like it should by setting the channel log to the provided mode</p> <code>None</code> <code>logging_uid</code> <code>Optional[str]</code> <p>unique identifier (string) to associate to log messages; useful if you have multiple connections to the same device (i.e. one console, one ssh, or one to each supervisor module, etc.)</p> <code>None</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>list of strings indicating command/config failure</p> <code>None</code> <code>textfsm_platform</code> <code>Optional[str]</code> <p>string to use to fetch ntc-templates templates for textfsm parsing</p> <code>None</code> <code>genie_platform</code> <code>Optional[str]</code> <p>string to use to fetch genie parser templates</p> <code>None</code> <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>Optional[str]</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>None</code> <code>auth_secondary</code> <code>Optional[str]</code> <p>password to use for secondary authentication (enable)</p> <code>None</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <code>variant</code> <code>Optional[str]</code> <p>name of the community platform variant if desired</p> <code>None</code> <code>**kwargs</code> <code>Dict[Any, Any]</code> <p>should be unused, but here to accept any additional kwargs from users</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>final_driver</code> <code>AsyncScrapli</code> <p>asynchronous driver class for provided driver</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if provided transport is asyncio</p> <code>ScrapliTypeError</code> <p>if <code>platform</code> not in keyword arguments</p> Source code in <code>scrapli/factory.py</code> <pre><code>def __new__(  # pylint: disable=R0914\n    cls,\n    platform: str,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: Optional[str] = None,\n    port: Optional[int] = None,\n    auth_username: Optional[str] = None,\n    auth_password: Optional[str] = None,\n    auth_private_key: Optional[str] = None,\n    auth_private_key_passphrase: Optional[str] = None,\n    auth_strict_key: Optional[bool] = None,\n    auth_bypass: Optional[bool] = None,\n    timeout_socket: Optional[float] = None,\n    timeout_transport: Optional[float] = None,\n    timeout_ops: Optional[float] = None,\n    comms_return_char: Optional[str] = None,\n    ssh_config_file: Optional[Union[str, bool]] = None,\n    ssh_known_hosts_file: Optional[Union[str, bool]] = None,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: Optional[str] = None,\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Optional[Union[str, bool, BytesIO]] = None,\n    channel_log_mode: Optional[str] = None,\n    channel_lock: Optional[bool] = None,\n    logging_uid: Optional[str] = None,\n    auth_secondary: Optional[str] = None,\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: Optional[str] = None,\n    genie_platform: Optional[str] = None,\n    variant: Optional[str] = None,\n    **kwargs: Dict[Any, Any],\n) -&gt; \"AsyncScrapli\":\nr\"\"\"\n    Scrapli Factory method for asynchronous drivers\n\n    Args:\n        platform: name of the scrapli platform to return a connection object for; should be\n            one of the \"core\" platforms or a valid community platform name\n        host: host ip/name to connect to\n        port: port to connect to\n        auth_username: username for authentication\n        auth_private_key: path to private key for authentication\n        auth_private_key_passphrase: passphrase for decrypting ssh key if necessary\n        auth_password: password for authentication\n        auth_strict_key: strict host checking or not\n        auth_bypass: bypass \"in channel\" authentication -- only supported with telnet,\n            asynctelnet, and system transport plugins\n        timeout_socket: timeout for establishing socket/initial connection in seconds\n        timeout_transport: timeout for ssh|telnet transport in seconds\n        timeout_ops: timeout for ssh channel operations\n        comms_return_char: character to use to send returns to host\n        ssh_config_file: string to path for ssh config file, True to use default ssh config file\n            or False to ignore default ssh config file\n        ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known\n            file locations. Only applicable/needed if `auth_strict_key` is set to True\n        on_init: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed as the last step of object instantiation -- its purpose is\n            primarily to provide a mechanism for scrapli community platforms to have an easy way\n            to modify initialization arguments/object attributes without needing to create a\n            class that extends the driver, instead allowing the community platforms to simply\n            build from the GenericDriver or NetworkDriver classes, and pass this callable to do\n            things such as appending to a username (looking at you RouterOS!!). Note that this\n            is *always* a synchronous function (even for asyncio drivers)!\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar\n        transport: name of the transport plugin to use for the actual telnet/ssh/netconf\n            connection. Available \"core\" transports are:\n                - system\n                - telnet\n                - asynctelnet\n                - ssh2\n                - paramiko\n                - asyncssh\n            Please see relevant transport plugin section for details. Additionally third party\n            transport plugins may be available.\n        transport_options: dictionary of options to pass to selected transport class; see\n            docs for given transport class for details of what to pass here\n        channel_lock: True/False to lock the channel (threading.Lock/asyncio.Lock) during\n            any channel operations, defaults to False\n        channel_log: True/False or a string path to a file of where to write out channel logs --\n            these are not \"logs\" in the normal logging module sense, but only the output that is\n            read from the channel. In other words, the output of the channel log should look\n            similar to what you would see as a human connecting to a device\n        channel_log_mode: \"write\"|\"append\", all other values will raise ValueError,\n            does what it sounds like it should by setting the channel log to the provided mode\n        logging_uid: unique identifier (string) to associate to log messages; useful if you have\n            multiple connections to the same device (i.e. one console, one ssh, or one to each\n            supervisor module, etc.)\n        failed_when_contains: list of strings indicating command/config failure\n        textfsm_platform: string to use to fetch ntc-templates templates for textfsm parsing\n        genie_platform: string to use to fetch genie parser templates\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        failed_when_contains: List of strings that indicate a command/config has failed\n        variant: name of the community platform variant if desired\n        **kwargs: should be unused, but here to accept any additional kwargs from users\n\n    Returns:\n        final_driver: asynchronous driver class for provided driver\n\n    Raises:\n        ScrapliValueError: if provided transport is asyncio\n        ScrapliTypeError: if `platform` not in keyword arguments\n\n    \"\"\"\n    logger.debug(\"AsyncScrapli factory initialized\")\n\n    if transport not in ASYNCIO_TRANSPORTS:\n        raise ScrapliValueError(\"Use 'Scrapli' if using a synchronous transport!\")\n\n    if not isinstance(platform, str):\n        raise ScrapliTypeError(f\"Argument 'platform' must be 'str' got '{type(platform)}'\")\n\n    provided_kwargs = _build_provided_kwargs_dict(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n        **kwargs,\n    )\n\n    final_driver, additional_kwargs = cls._get_driver(platform=platform, variant=variant)\n\n    # at this point will need to merge the additional kwargs in (for community drivers),\n    # ensure that kwargs passed by user supersede the ones coming from community platform\n    if additional_kwargs:\n        final_kwargs = {**additional_kwargs, **provided_kwargs}\n    else:\n        final_kwargs = provided_kwargs\n\n    final_conn = final_driver(**final_kwargs)\n    # cast the final conn to type Scrapli to appease mypy -- we know it will be a NetworkDriver\n    # or GenericDriver, but thats ok =)\n    final_conn = cast(AsyncScrapli, final_conn)\n    return final_conn\n</code></pre>"},{"location":"reference/factory/#factory.Scrapli","title":"<code>Scrapli</code>","text":"<p>         Bases: <code>NetworkDriver</code></p> Source code in <code>scrapli/factory.py</code> <pre><code>class Scrapli(NetworkDriver):\n    CORE_PLATFORM_MAP = {\n        \"arista_eos\": EOSDriver,\n        \"cisco_iosxe\": IOSXEDriver,\n        \"cisco_iosxr\": IOSXRDriver,\n        \"cisco_nxos\": NXOSDriver,\n        \"juniper_junos\": JunosDriver,\n    }\n    DRIVER_MAP = {\"network\": NetworkDriver, \"generic\": GenericDriver}\n\n    @classmethod\n    def _get_driver_class(\n        cls, platform_details: Dict[str, Any], variant: Optional[str]\n    ) -&gt; Union[Type[NetworkDriver], Type[GenericDriver]]:\n\"\"\"\n        Fetch community driver class based on platform details\n\n        Args:\n            platform_details: dict of details about community platform from scrapli_community\n                library\n            variant: optional name of variant of community platform\n\n        Returns:\n            NetworkDriver: final driver class\n\n        Raises:\n            N/A\n\n        \"\"\"\n        final_driver: Union[\n            Type[NetworkDriver],\n            Type[GenericDriver],\n        ]\n\n        if variant and platform_details[\"variants\"][variant].get(\"driver_type\"):\n            variant_driver_data = platform_details[\"variants\"][variant].pop(\"driver_type\")\n            final_driver = variant_driver_data[\"sync\"]\n            return final_driver\n\n        if isinstance(platform_details[\"driver_type\"], str):\n            driver_type = platform_details[\"driver_type\"]\n            standard_final_driver = cls.DRIVER_MAP.get(driver_type, None)\n            if standard_final_driver:\n                return standard_final_driver\n\n        final_driver = platform_details[\"driver_type\"][\"sync\"]\n        return final_driver\n\n    @classmethod\n    def _get_community_driver(\n        cls, community_platform_name: str, variant: Optional[str]\n    ) -&gt; Tuple[Union[Type[NetworkDriver], Type[GenericDriver]], Dict[str, Any]]:\n\"\"\"\n        Get community driver\n\n        Args:\n            community_platform_name: name of community\n            variant: optional name of variant of community platform\n\n        Returns:\n            NetworkDriver: final driver class\n\n        Raises:\n            N/A\n\n        \"\"\"\n        platform_details = _get_community_platform_details(\n            community_platform_name=community_platform_name\n        )\n\n        final_driver = cls._get_driver_class(platform_details=platform_details, variant=variant)\n        final_platform_kwargs = _get_driver_kwargs(\n            platform_details=platform_details, variant=variant, _async=False\n        )\n\n        return final_driver, final_platform_kwargs\n\n    @classmethod\n    def _get_driver(\n        cls, platform: str, variant: Optional[str]\n    ) -&gt; Tuple[Union[Type[NetworkDriver], Type[GenericDriver]], Dict[str, Any]]:\n\"\"\"\n        Parent get driver method for sync Scrapli\n\n        Args:\n            platform: name of target platform; i.e. `cisco_iosxe`, `arista_eos`, etc.\n            variant: name of the target platform variant\n\n        Returns:\n            NetworkDriver: final driver class; generally NetworkDriver, but for some community\n                platforms could be GenericDriver, also returns any additional kwargs comming from\n                the community platform (if any)\n\n        Raises:\n            N/A\n\n        \"\"\"\n        additional_kwargs: Dict[str, Any] = {}\n        final_driver: Union[Type[GenericDriver], Type[NetworkDriver]]\n\n        if platform in cls.CORE_PLATFORM_MAP:\n            final_driver = cls.CORE_PLATFORM_MAP[platform]\n            msg = f\"Driver '{final_driver}' selected from scrapli core drivers\"\n        else:\n            final_driver, additional_kwargs = cls._get_community_driver(\n                community_platform_name=platform, variant=variant\n            )\n            msg = (\n                f\"Driver '{final_driver}' selected from scrapli community platforms, with the \"\n                f\"following platform arguments: '{additional_kwargs}'\"\n            )\n\n        logger.info(msg)\n        return final_driver, additional_kwargs\n\n    def __new__(  # pylint: disable=R0914\n        cls,\n        platform: str,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: Optional[str] = None,\n        port: Optional[int] = None,\n        auth_username: Optional[str] = None,\n        auth_password: Optional[str] = None,\n        auth_private_key: Optional[str] = None,\n        auth_private_key_passphrase: Optional[str] = None,\n        auth_strict_key: Optional[bool] = None,\n        auth_bypass: Optional[bool] = None,\n        timeout_socket: Optional[float] = None,\n        timeout_transport: Optional[float] = None,\n        timeout_ops: Optional[float] = None,\n        comms_return_char: Optional[str] = None,\n        ssh_config_file: Optional[Union[str, bool]] = None,\n        ssh_known_hosts_file: Optional[Union[str, bool]] = None,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: Optional[str] = None,\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Optional[Union[str, bool, BytesIO]] = None,\n        channel_lock: Optional[bool] = None,\n        channel_log_mode: Optional[str] = None,\n        logging_uid: Optional[str] = None,\n        auth_secondary: Optional[str] = None,\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: Optional[str] = None,\n        genie_platform: Optional[str] = None,\n        variant: Optional[str] = None,\n        **kwargs: Dict[Any, Any],\n    ) -&gt; \"Scrapli\":\nr\"\"\"\n        Scrapli Factory method for synchronous drivers\n\n        Args:\n            platform: name of the scrapli platform to return a connection object for; should be\n                one of the \"core\" platforms or a valid community platform name\n            host: host ip/name to connect to\n            port: port to connect to\n            auth_username: username for authentication\n            auth_private_key: path to private key for authentication\n            auth_private_key_passphrase: passphrase for decrypting ssh key if necessary\n            auth_password: password for authentication\n            auth_strict_key: strict host checking or not\n            auth_bypass: bypass \"in channel\" authentication -- only supported with telnet,\n                asynctelnet, and system transport plugins\n            timeout_socket: timeout for establishing socket/initial connection in seconds\n            timeout_transport: timeout for ssh|telnet transport in seconds\n            timeout_ops: timeout for ssh channel operations\n            comms_return_char: character to use to send returns to host\n            ssh_config_file: string to path for ssh config file, True to use default ssh config file\n                or False to ignore default ssh config file\n            ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known\n                file locations. Only applicable/needed if `auth_strict_key` is set to True\n            on_init: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed as the last step of object instantiation -- its purpose is\n                primarily to provide a mechanism for scrapli community platforms to have an easy way\n                to modify initialization arguments/object attributes without needing to create a\n                class that extends the driver, instead allowing the community platforms to simply\n                build from the GenericDriver or NetworkDriver classes, and pass this callable to do\n                things such as appending to a username (looking at you RouterOS!!). Note that this\n                is *always* a synchronous function (even for asyncio drivers)!\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar\n            transport: name of the transport plugin to use for the actual telnet/ssh/netconf\n                connection. Available \"core\" transports are:\n                    - system\n                    - telnet\n                    - asynctelnet\n                    - ssh2\n                    - paramiko\n                    - asyncssh\n                Please see relevant transport plugin section for details. Additionally third party\n                transport plugins may be available.\n            transport_options: dictionary of options to pass to selected transport class; see\n                docs for given transport class for details of what to pass here\n            channel_lock: True/False to lock the channel (threading.Lock/asyncio.Lock) during\n                any channel operations, defaults to False\n            channel_log: True/False or a string path to a file of where to write out channel logs --\n                these are not \"logs\" in the normal logging module sense, but only the output that is\n                read from the channel. In other words, the output of the channel log should look\n                similar to what you would see as a human connecting to a device\n            channel_log_mode: \"write\"|\"append\", all other values will raise ValueError,\n                does what it sounds like it should by setting the channel log to the provided mode\n            logging_uid: unique identifier (string) to associate to log messages; useful if you have\n                multiple connections to the same device (i.e. one console, one ssh, or one to each\n                supervisor module, etc.)\n            failed_when_contains: list of strings indicating command/config failure\n            textfsm_platform: string to use to fetch ntc-templates templates for textfsm parsing\n            genie_platform: string to use to fetch genie parser templates\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            failed_when_contains: List of strings that indicate a command/config has failed\n            variant: name of the community platform variant if desired\n            **kwargs: should be unused, but here to accept any additional kwargs from users\n\n        Returns:\n            final_driver: synchronous driver class for provided driver\n\n        Raises:\n            ScrapliValueError: if provided transport is asyncio\n            ScrapliTypeError: if `platform` not in keyword arguments\n\n        \"\"\"\n        logger.debug(\"Scrapli factory initialized\")\n\n        if transport in ASYNCIO_TRANSPORTS:\n            raise ScrapliValueError(\"Use 'AsyncScrapli' if using an async transport!\")\n\n        if not isinstance(platform, str):\n            raise ScrapliTypeError(f\"Argument 'platform' must be 'str' got '{type(platform)}'\")\n\n        provided_kwargs = _build_provided_kwargs_dict(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n            **kwargs,\n        )\n\n        final_driver, additional_kwargs = cls._get_driver(platform=platform, variant=variant)\n\n        # at this point will need to merge the additional kwargs in (for community drivers),\n        # ensure that kwargs passed by user supersede the ones coming from community platform\n        if additional_kwargs:\n            final_kwargs = {**additional_kwargs, **provided_kwargs}\n        else:\n            final_kwargs = provided_kwargs\n\n        final_conn = final_driver(**final_kwargs)\n        # cast the final conn to type Scrapli to appease mypy -- we know it will be a NetworkDriver\n        # or GenericDriver, but thats ok =)\n        final_conn = cast(Scrapli, final_conn)\n        return final_conn\n</code></pre>"},{"location":"reference/factory/#factory.Scrapli.__new__","title":"<code>__new__(platform: str, host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: Optional[str] = None, port: Optional[int] = None, auth_username: Optional[str] = None, auth_password: Optional[str] = None, auth_private_key: Optional[str] = None, auth_private_key_passphrase: Optional[str] = None, auth_strict_key: Optional[bool] = None, auth_bypass: Optional[bool] = None, timeout_socket: Optional[float] = None, timeout_transport: Optional[float] = None, timeout_ops: Optional[float] = None, comms_return_char: Optional[str] = None, ssh_config_file: Optional[Union[str, bool]] = None, ssh_known_hosts_file: Optional[Union[str, bool]] = None, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: Optional[str] = None, transport_options: Optional[Dict[str, Any]] = None, channel_log: Optional[Union[str, bool, BytesIO]] = None, channel_lock: Optional[bool] = None, channel_log_mode: Optional[str] = None, logging_uid: Optional[str] = None, auth_secondary: Optional[str] = None, failed_when_contains: Optional[List[str]] = None, textfsm_platform: Optional[str] = None, genie_platform: Optional[str] = None, variant: Optional[str] = None, **kwargs: Dict[Any, Any]) -&gt; Scrapli</code>","text":"<p>Scrapli Factory method for synchronous drivers</p> <p>Parameters:</p> Name Type Description Default <code>platform</code> <code>str</code> <p>name of the scrapli platform to return a connection object for; should be one of the \"core\" platforms or a valid community platform name</p> required <code>host</code> <code>str</code> <p>host ip/name to connect to</p> required <code>port</code> <code>Optional[int]</code> <p>port to connect to</p> <code>None</code> <code>auth_username</code> <code>Optional[str]</code> <p>username for authentication</p> <code>None</code> <code>auth_private_key</code> <code>Optional[str]</code> <p>path to private key for authentication</p> <code>None</code> <code>auth_private_key_passphrase</code> <code>Optional[str]</code> <p>passphrase for decrypting ssh key if necessary</p> <code>None</code> <code>auth_password</code> <code>Optional[str]</code> <p>password for authentication</p> <code>None</code> <code>auth_strict_key</code> <code>Optional[bool]</code> <p>strict host checking or not</p> <code>None</code> <code>auth_bypass</code> <code>Optional[bool]</code> <p>bypass \"in channel\" authentication -- only supported with telnet, asynctelnet, and system transport plugins</p> <code>None</code> <code>timeout_socket</code> <code>Optional[float]</code> <p>timeout for establishing socket/initial connection in seconds</p> <code>None</code> <code>timeout_transport</code> <code>Optional[float]</code> <p>timeout for ssh|telnet transport in seconds</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout for ssh channel operations</p> <code>None</code> <code>comms_return_char</code> <code>Optional[str]</code> <p>character to use to send returns to host</p> <code>None</code> <code>ssh_config_file</code> <code>Optional[Union[str, bool]]</code> <p>string to path for ssh config file, True to use default ssh config file or False to ignore default ssh config file</p> <code>None</code> <code>ssh_known_hosts_file</code> <code>Optional[Union[str, bool]]</code> <p>string to path for ssh known hosts file, True to use default known file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</p> <code>None</code> <code>on_init</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed as the last step of object instantiation -- its purpose is primarily to provide a mechanism for scrapli community platforms to have an easy way to modify initialization arguments/object attributes without needing to create a class that extends the driver, instead allowing the community platforms to simply build from the GenericDriver or NetworkDriver classes, and pass this callable to do things such as appending to a username (looking at you RouterOS!!). Note that this is always a synchronous function (even for asyncio drivers)!</p> <code>None</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar</p> <code>None</code> <code>transport</code> <code>Optional[str]</code> <p>name of the transport plugin to use for the actual telnet/ssh/netconf connection. Available \"core\" transports are:     - system     - telnet     - asynctelnet     - ssh2     - paramiko     - asyncssh Please see relevant transport plugin section for details. Additionally third party transport plugins may be available.</p> <code>None</code> <code>transport_options</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary of options to pass to selected transport class; see docs for given transport class for details of what to pass here</p> <code>None</code> <code>channel_lock</code> <code>Optional[bool]</code> <p>True/False to lock the channel (threading.Lock/asyncio.Lock) during any channel operations, defaults to False</p> <code>None</code> <code>channel_log</code> <code>Optional[Union[str, bool, BytesIO]]</code> <p>True/False or a string path to a file of where to write out channel logs -- these are not \"logs\" in the normal logging module sense, but only the output that is read from the channel. In other words, the output of the channel log should look similar to what you would see as a human connecting to a device</p> <code>None</code> <code>channel_log_mode</code> <code>Optional[str]</code> <p>\"write\"|\"append\", all other values will raise ValueError, does what it sounds like it should by setting the channel log to the provided mode</p> <code>None</code> <code>logging_uid</code> <code>Optional[str]</code> <p>unique identifier (string) to associate to log messages; useful if you have multiple connections to the same device (i.e. one console, one ssh, or one to each supervisor module, etc.)</p> <code>None</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>list of strings indicating command/config failure</p> <code>None</code> <code>textfsm_platform</code> <code>Optional[str]</code> <p>string to use to fetch ntc-templates templates for textfsm parsing</p> <code>None</code> <code>genie_platform</code> <code>Optional[str]</code> <p>string to use to fetch genie parser templates</p> <code>None</code> <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>Optional[str]</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>None</code> <code>auth_secondary</code> <code>Optional[str]</code> <p>password to use for secondary authentication (enable)</p> <code>None</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <code>variant</code> <code>Optional[str]</code> <p>name of the community platform variant if desired</p> <code>None</code> <code>**kwargs</code> <code>Dict[Any, Any]</code> <p>should be unused, but here to accept any additional kwargs from users</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>final_driver</code> <code>Scrapli</code> <p>synchronous driver class for provided driver</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if provided transport is asyncio</p> <code>ScrapliTypeError</code> <p>if <code>platform</code> not in keyword arguments</p> Source code in <code>scrapli/factory.py</code> <pre><code>def __new__(  # pylint: disable=R0914\n    cls,\n    platform: str,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: Optional[str] = None,\n    port: Optional[int] = None,\n    auth_username: Optional[str] = None,\n    auth_password: Optional[str] = None,\n    auth_private_key: Optional[str] = None,\n    auth_private_key_passphrase: Optional[str] = None,\n    auth_strict_key: Optional[bool] = None,\n    auth_bypass: Optional[bool] = None,\n    timeout_socket: Optional[float] = None,\n    timeout_transport: Optional[float] = None,\n    timeout_ops: Optional[float] = None,\n    comms_return_char: Optional[str] = None,\n    ssh_config_file: Optional[Union[str, bool]] = None,\n    ssh_known_hosts_file: Optional[Union[str, bool]] = None,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: Optional[str] = None,\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Optional[Union[str, bool, BytesIO]] = None,\n    channel_lock: Optional[bool] = None,\n    channel_log_mode: Optional[str] = None,\n    logging_uid: Optional[str] = None,\n    auth_secondary: Optional[str] = None,\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: Optional[str] = None,\n    genie_platform: Optional[str] = None,\n    variant: Optional[str] = None,\n    **kwargs: Dict[Any, Any],\n) -&gt; \"Scrapli\":\nr\"\"\"\n    Scrapli Factory method for synchronous drivers\n\n    Args:\n        platform: name of the scrapli platform to return a connection object for; should be\n            one of the \"core\" platforms or a valid community platform name\n        host: host ip/name to connect to\n        port: port to connect to\n        auth_username: username for authentication\n        auth_private_key: path to private key for authentication\n        auth_private_key_passphrase: passphrase for decrypting ssh key if necessary\n        auth_password: password for authentication\n        auth_strict_key: strict host checking or not\n        auth_bypass: bypass \"in channel\" authentication -- only supported with telnet,\n            asynctelnet, and system transport plugins\n        timeout_socket: timeout for establishing socket/initial connection in seconds\n        timeout_transport: timeout for ssh|telnet transport in seconds\n        timeout_ops: timeout for ssh channel operations\n        comms_return_char: character to use to send returns to host\n        ssh_config_file: string to path for ssh config file, True to use default ssh config file\n            or False to ignore default ssh config file\n        ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known\n            file locations. Only applicable/needed if `auth_strict_key` is set to True\n        on_init: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed as the last step of object instantiation -- its purpose is\n            primarily to provide a mechanism for scrapli community platforms to have an easy way\n            to modify initialization arguments/object attributes without needing to create a\n            class that extends the driver, instead allowing the community platforms to simply\n            build from the GenericDriver or NetworkDriver classes, and pass this callable to do\n            things such as appending to a username (looking at you RouterOS!!). Note that this\n            is *always* a synchronous function (even for asyncio drivers)!\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar\n        transport: name of the transport plugin to use for the actual telnet/ssh/netconf\n            connection. Available \"core\" transports are:\n                - system\n                - telnet\n                - asynctelnet\n                - ssh2\n                - paramiko\n                - asyncssh\n            Please see relevant transport plugin section for details. Additionally third party\n            transport plugins may be available.\n        transport_options: dictionary of options to pass to selected transport class; see\n            docs for given transport class for details of what to pass here\n        channel_lock: True/False to lock the channel (threading.Lock/asyncio.Lock) during\n            any channel operations, defaults to False\n        channel_log: True/False or a string path to a file of where to write out channel logs --\n            these are not \"logs\" in the normal logging module sense, but only the output that is\n            read from the channel. In other words, the output of the channel log should look\n            similar to what you would see as a human connecting to a device\n        channel_log_mode: \"write\"|\"append\", all other values will raise ValueError,\n            does what it sounds like it should by setting the channel log to the provided mode\n        logging_uid: unique identifier (string) to associate to log messages; useful if you have\n            multiple connections to the same device (i.e. one console, one ssh, or one to each\n            supervisor module, etc.)\n        failed_when_contains: list of strings indicating command/config failure\n        textfsm_platform: string to use to fetch ntc-templates templates for textfsm parsing\n        genie_platform: string to use to fetch genie parser templates\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        failed_when_contains: List of strings that indicate a command/config has failed\n        variant: name of the community platform variant if desired\n        **kwargs: should be unused, but here to accept any additional kwargs from users\n\n    Returns:\n        final_driver: synchronous driver class for provided driver\n\n    Raises:\n        ScrapliValueError: if provided transport is asyncio\n        ScrapliTypeError: if `platform` not in keyword arguments\n\n    \"\"\"\n    logger.debug(\"Scrapli factory initialized\")\n\n    if transport in ASYNCIO_TRANSPORTS:\n        raise ScrapliValueError(\"Use 'AsyncScrapli' if using an async transport!\")\n\n    if not isinstance(platform, str):\n        raise ScrapliTypeError(f\"Argument 'platform' must be 'str' got '{type(platform)}'\")\n\n    provided_kwargs = _build_provided_kwargs_dict(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n        **kwargs,\n    )\n\n    final_driver, additional_kwargs = cls._get_driver(platform=platform, variant=variant)\n\n    # at this point will need to merge the additional kwargs in (for community drivers),\n    # ensure that kwargs passed by user supersede the ones coming from community platform\n    if additional_kwargs:\n        final_kwargs = {**additional_kwargs, **provided_kwargs}\n    else:\n        final_kwargs = provided_kwargs\n\n    final_conn = final_driver(**final_kwargs)\n    # cast the final conn to type Scrapli to appease mypy -- we know it will be a NetworkDriver\n    # or GenericDriver, but thats ok =)\n    final_conn = cast(Scrapli, final_conn)\n    return final_conn\n</code></pre>"},{"location":"reference/helper/","title":"helper","text":"<p>scrapli.helper</p>"},{"location":"reference/helper/#helper.format_user_warning","title":"<code>format_user_warning(title: str, message: str) -&gt; str</code>","text":"<p>Nicely format a warning message for users</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>title of the warning message</p> required <code>message</code> <code>str</code> <p>actual message body</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>nicely formatted warning</p> Source code in <code>scrapli/helper.py</code> <pre><code>def format_user_warning(title: str, message: str) -&gt; str:\n\"\"\"\n    Nicely format a warning message for users\n\n    Args:\n        title: title of the warning message\n        message: actual message body\n\n    Returns:\n        str: nicely formatted warning\n\n    Raises:\n        N/A\n\n    \"\"\"\n    terminal_width = get_terminal_size().columns\n    warning_banner_char = \"*\"\n\n    if len(title) &gt; (terminal_width - 4):\n        warning_header = warning_banner_char * terminal_width\n    else:\n        banner_char_count = terminal_width - len(title) - 2\n        left_banner_char_count = banner_char_count // 2\n        right_banner_char_count = (\n            banner_char_count / 2 if banner_char_count % 2 == 0 else (banner_char_count // 2) + 1\n        )\n        warning_header = (\n            f\"{warning_banner_char:{warning_banner_char}&gt;{left_banner_char_count}}\"\n            f\" {title} \"\n            f\"{warning_banner_char:{warning_banner_char}&lt;{right_banner_char_count}}\"\n        )\n\n    warning_footer = warning_banner_char * terminal_width\n\n    return (\n        \"\\n\\n\"\n        + warning_header\n        + \"\\n\"\n        + message.center(terminal_width)\n        + \"\\n\"\n        + warning_footer\n        + \"\\n\"\n    )\n</code></pre>"},{"location":"reference/helper/#helper.genie_parse","title":"<code>genie_parse(platform: str, command: str, output: str) -&gt; Union[List[Any], Dict[str, Any]]</code>","text":"<p>Parse output with Cisco genie parsers, try to return structured output</p> <p>Parameters:</p> Name Type Description Default <code>platform</code> <code>str</code> <p>genie device type; i.e. iosxe, iosxr, etc.</p> required <code>command</code> <code>str</code> <p>string of command that was executed (to find appropriate parser)</p> required <code>output</code> <code>str</code> <p>unstructured output from device to parse</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>Union[List[Any], Dict[str, Any]]</code> <p>structured data</p> Source code in <code>scrapli/helper.py</code> <pre><code>def genie_parse(platform: str, command: str, output: str) -&gt; Union[List[Any], Dict[str, Any]]:\n\"\"\"\n    Parse output with Cisco genie parsers, try to return structured output\n\n    Args:\n        platform: genie device type; i.e. iosxe, iosxr, etc.\n        command: string of command that was executed (to find appropriate parser)\n        output: unstructured output from device to parse\n\n    Returns:\n        output: structured data\n\n    Raises:\n        N/A\n\n    \"\"\"\n    try:\n        Device = getattr(importlib.import_module(name=\".conf.base\", package=\"genie\"), \"Device\")\n        get_parser = getattr(\n            importlib.import_module(name=\".libs.parser.utils\", package=\"genie\"), \"get_parser\"\n        )\n    except ModuleNotFoundError as exc:\n        title = \"Optional Extra Not Installed!\"\n        message = (\n            \"Optional extra 'genie' is not installed!\\n\"\n            f\"To resolve this issue, install '{exc.name}'. You can do this in one of the following\"\n            \" ways:\\n\"\n            \"1: 'pip install -r requirements-genie.txt'\\n\"\n            \"2: 'pip install scrapli[genie]'\"\n        )\n        user_warning(title=title, message=message)\n        return []\n\n    genie_device = Device(\"scrapli_device\", custom={\"abstraction\": {\"order\": [\"os\"]}}, os=platform)\n\n    try:\n        get_parser(command, genie_device)\n        genie_parsed_result = genie_device.parse(command, output=output)\n        if isinstance(genie_parsed_result, (list, dict)):\n            return genie_parsed_result\n    except Exception as exc:  # pylint: disable=W0703\n        logger.warning(f\"failed to parse data with genie, genie raised exception: `{exc}`\")\n    return []\n</code></pre>"},{"location":"reference/helper/#helper.resolve_file","title":"<code>resolve_file(file: str) -&gt; str</code>","text":"<p>Resolve file from provided string</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>string path to file</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string path to file</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if file cannot be resolved</p> Source code in <code>scrapli/helper.py</code> <pre><code>def resolve_file(file: str) -&gt; str:\n\"\"\"\n    Resolve file from provided string\n\n    Args:\n        file: string path to file\n\n    Returns:\n        str: string path to file\n\n    Raises:\n        ScrapliValueError: if file cannot be resolved\n\n    \"\"\"\n    if Path(file).is_file():\n        return str(Path(file))\n    if Path(file).expanduser().is_file():\n        return str(Path(file).expanduser())\n    raise ScrapliValueError(f\"File path `{file}` could not be resolved\")\n</code></pre>"},{"location":"reference/helper/#helper.textfsm_parse","title":"<code>textfsm_parse(template: Union[str, TextIOWrapper], output: str, to_dict: bool = True) -&gt; Union[List[Any], Dict[str, Any]]</code>","text":"<p>Parse output with TextFSM and ntc-templates, try to return structured output</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>Union[str, TextIOWrapper]</code> <p>TextIOWrapper or string of URL or filesystem path to template to use to parse data</p> required <code>output</code> <code>str</code> <p>unstructured output from device to parse</p> required <code>to_dict</code> <code>bool</code> <p>convert textfsm output from list of lists to list of dicts -- basically create dict from header and row data so it is easier to read/parse the output</p> <code>True</code> <p>Returns:</p> Name Type Description <code>output</code> <code>Union[List[Any], Dict[str, Any]]</code> <p>structured data</p> Source code in <code>scrapli/helper.py</code> <pre><code>def textfsm_parse(\n    template: Union[str, TextIOWrapper], output: str, to_dict: bool = True\n) -&gt; Union[List[Any], Dict[str, Any]]:\n\"\"\"\n    Parse output with TextFSM and ntc-templates, try to return structured output\n\n    Args:\n        template: TextIOWrapper or string of URL or filesystem path to template to use to parse data\n        output: unstructured output from device to parse\n        to_dict: convert textfsm output from list of lists to list of dicts -- basically create dict\n            from header and row data so it is easier to read/parse the output\n\n    Returns:\n        output: structured data\n\n    Raises:\n        N/A\n\n    \"\"\"\n    import textfsm  # pylint: disable=C0415\n\n    if not isinstance(template, TextIOWrapper):\n        if template.startswith(\"http://\") or template.startswith(\"https://\"):\n            with urllib.request.urlopen(template) as response:\n                template_file = TextIOWrapper(\n                    BytesIO(response.read()),\n                    encoding=response.headers.get_content_charset(),\n                )\n        else:\n            template_file = TextIOWrapper(open(template, mode=\"rb\"))  # pylint: disable=R1732\n    else:\n        template_file = template\n    re_table = textfsm.TextFSM(template_file)\n    try:\n        structured_output: Union[List[Any], Dict[str, Any]] = re_table.ParseText(output)\n        if to_dict:\n            structured_output = _textfsm_to_dict(\n                structured_output=structured_output, header=re_table.header\n            )\n        return structured_output\n    except textfsm.parser.TextFSMError:\n        logger.warning(\"failed to parse data with textfsm\")\n    return []\n</code></pre>"},{"location":"reference/helper/#helper.ttp_parse","title":"<code>ttp_parse(template: Union[str, TextIOWrapper], output: str) -&gt; Union[List[Any], Dict[str, Any]]</code>","text":"<p>Parse output with TTP, try to return structured output</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>Union[str, TextIOWrapper]</code> <p>TextIOWrapper or string path to template to use to parse data</p> required <code>output</code> <code>str</code> <p>unstructured output from device to parse</p> required <p>Returns:</p> Name Type Description <code>output</code> <code>Union[List[Any], Dict[str, Any]]</code> <p>structured data</p> Source code in <code>scrapli/helper.py</code> <pre><code>def ttp_parse(template: Union[str, TextIOWrapper], output: str) -&gt; Union[List[Any], Dict[str, Any]]:\n\"\"\"\n    Parse output with TTP, try to return structured output\n\n    Args:\n        template: TextIOWrapper or string path to template to use to parse data\n        output: unstructured output from device to parse\n\n    Returns:\n        output: structured data\n\n    Raises:\n        N/A\n\n    \"\"\"\n    try:\n        ttp = getattr(importlib.import_module(name=\"ttp\"), \"ttp\")\n    except ModuleNotFoundError as exc:\n        title = \"Optional Extra Not Installed!\"\n        message = (\n            \"Optional extra 'ttp' is not installed!\\n\"\n            f\"To resolve this issue, install '{exc.name}'. You can do this in one of the following\"\n            \" ways:\\n\"\n            \"1: 'pip install -r requirements-ttp.txt'\\n\"\n            \"2: 'pip install scrapli[ttp]'\"\n        )\n        user_warning(title=title, message=message)\n        return []\n\n    if not isinstance(template, (str, TextIOWrapper)):\n        logger.info(f\"invalid template `{template}`; template should be string or TextIOWrapper\")\n        return []\n\n    ttp_parser_template_name = \"scrapli_ttp_parse\"\n    ttp_parser = ttp()\n    ttp_parser.add_template(template=template, template_name=ttp_parser_template_name)\n    ttp_parser.add_input(data=output, template_name=ttp_parser_template_name)\n    ttp_parser.parse()\n    ttp_result: Dict[str, List[Any]] = ttp_parser.result(structure=\"dictionary\")\n    return ttp_result[ttp_parser_template_name]\n</code></pre>"},{"location":"reference/helper/#helper.user_warning","title":"<code>user_warning(title: str, message: str) -&gt; None</code>","text":"<p>Nicely raise warning messages for users</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>title of the warning message</p> required <code>message</code> <code>str</code> <p>actual message body</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli/helper.py</code> <pre><code>def user_warning(title: str, message: str) -&gt; None:\n\"\"\"\n    Nicely raise warning messages for users\n\n    Args:\n        title: title of the warning message\n        message: actual message body\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    warning_message = format_user_warning(title=title, message=message)\n    logger.warning(warning_message)\n\n    if Settings.SUPPRESS_USER_WARNINGS is False:\n        warn(warning_message)\n</code></pre>"},{"location":"reference/logging/","title":"logging","text":"<p>scrapli.logging</p>"},{"location":"reference/logging/#logging.ScrapliFileHandler","title":"<code>ScrapliFileHandler</code>","text":"<p>         Bases: <code>FileHandler_</code></p> Source code in <code>scrapli/logging.py</code> <pre><code>class ScrapliFileHandler(FileHandler_):\n    def __init__(\n        self,\n        filename: str,\n        mode: str = \"a\",\n        encoding: Optional[str] = None,\n        delay: bool = False,\n    ) -&gt; None:\n\"\"\"\n        Handle \"buffering\" log read messages for logging.FileHandler\n\n        Args:\n            filename: name of file to create\n            mode: file mode\n            encoding: encoding to use for file\n            delay: actually not sure what this is for :)\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        super().__init__(\n            filename=filename,\n            mode=mode,\n            encoding=encoding,\n            delay=delay,\n        )\n        self._record_buf: Optional[LogRecord_] = None\n        self._record_msg_buf: bytes = b\"\"\n        self._read_msg_prefix = \"read: \"\n        self._read_msg_prefix_len = len(self._read_msg_prefix)\n\n    def emit_buffered(self) -&gt; None:\n\"\"\"\n        Emit a buffered read message to the FileHandler\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliException: should never be raised!\n\n        \"\"\"\n        if not self._record_buf:\n            raise ScrapliException(\n                \"something unexpected happened in the ScrapliFileHandler log handler\"\n            )\n\n        self._record_buf.msg = f\"read : {self._record_msg_buf!r}\"\n        super().emit(record=self._record_buf)\n        self._record_buf = None\n        self._record_msg_buf = b\"\"\n\n    def emit(self, record: LogRecord_) -&gt; None:\n\"\"\"\n        Override standard library FileHandler.emit to \"buffer\" subsequent read messages\n\n        Args:\n            record: log record to check\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not record.msg.startswith(self._read_msg_prefix):\n            # everytime we get a message *not* starting with \"read: \" we check to see if there is\n            # any buffered message ready to send, if so send it. otherwise, treat the message\n            # normally by super'ing to the \"normal\" handler\n            if self._record_buf:\n                self.emit_buffered()\n\n            super().emit(record=record)\n            return\n\n        if self._record_buf is None:\n            # no message in the buffer, set the current record to the _record_buf\n            self._record_buf = record\n            # get the payload of the message after \"read: \" and re-convert it to bytes\n            self._record_msg_buf = literal_eval(record.msg[self._read_msg_prefix_len :])  # noqa\n            return\n\n        # if we get here we know we are getting subsequent read messages we want to buffer -- the\n        # log record data will all be the same, its just the payload that will be new, so add that\n        # current payload to the _record_msg_buf buffer\n        self._record_msg_buf += literal_eval(record.msg[self._read_msg_prefix_len :])  # noqa\n</code></pre>"},{"location":"reference/logging/#logging.ScrapliFileHandler.__init__","title":"<code>__init__(filename: str, mode: str = 'a', encoding: Optional[str] = None, delay: bool = False) -&gt; None</code>","text":"<p>Handle \"buffering\" log read messages for logging.FileHandler</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>name of file to create</p> required <code>mode</code> <code>str</code> <p>file mode</p> <code>'a'</code> <code>encoding</code> <code>Optional[str]</code> <p>encoding to use for file</p> <code>None</code> <code>delay</code> <code>bool</code> <p>actually not sure what this is for :)</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli/logging.py</code> <pre><code>def __init__(\n    self,\n    filename: str,\n    mode: str = \"a\",\n    encoding: Optional[str] = None,\n    delay: bool = False,\n) -&gt; None:\n\"\"\"\n    Handle \"buffering\" log read messages for logging.FileHandler\n\n    Args:\n        filename: name of file to create\n        mode: file mode\n        encoding: encoding to use for file\n        delay: actually not sure what this is for :)\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    super().__init__(\n        filename=filename,\n        mode=mode,\n        encoding=encoding,\n        delay=delay,\n    )\n    self._record_buf: Optional[LogRecord_] = None\n    self._record_msg_buf: bytes = b\"\"\n    self._read_msg_prefix = \"read: \"\n    self._read_msg_prefix_len = len(self._read_msg_prefix)\n</code></pre>"},{"location":"reference/logging/#logging.ScrapliFileHandler.emit","title":"<code>emit(record: LogRecord_) -&gt; None</code>","text":"<p>Override standard library FileHandler.emit to \"buffer\" subsequent read messages</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord_</code> <p>log record to check</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli/logging.py</code> <pre><code>def emit(self, record: LogRecord_) -&gt; None:\n\"\"\"\n    Override standard library FileHandler.emit to \"buffer\" subsequent read messages\n\n    Args:\n        record: log record to check\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if not record.msg.startswith(self._read_msg_prefix):\n        # everytime we get a message *not* starting with \"read: \" we check to see if there is\n        # any buffered message ready to send, if so send it. otherwise, treat the message\n        # normally by super'ing to the \"normal\" handler\n        if self._record_buf:\n            self.emit_buffered()\n\n        super().emit(record=record)\n        return\n\n    if self._record_buf is None:\n        # no message in the buffer, set the current record to the _record_buf\n        self._record_buf = record\n        # get the payload of the message after \"read: \" and re-convert it to bytes\n        self._record_msg_buf = literal_eval(record.msg[self._read_msg_prefix_len :])  # noqa\n        return\n\n    # if we get here we know we are getting subsequent read messages we want to buffer -- the\n    # log record data will all be the same, its just the payload that will be new, so add that\n    # current payload to the _record_msg_buf buffer\n    self._record_msg_buf += literal_eval(record.msg[self._read_msg_prefix_len :])  # noqa\n</code></pre>"},{"location":"reference/logging/#logging.ScrapliFileHandler.emit_buffered","title":"<code>emit_buffered() -&gt; None</code>","text":"<p>Emit a buffered read message to the FileHandler</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliException</code> <p>should never be raised!</p> Source code in <code>scrapli/logging.py</code> <pre><code>def emit_buffered(self) -&gt; None:\n\"\"\"\n    Emit a buffered read message to the FileHandler\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliException: should never be raised!\n\n    \"\"\"\n    if not self._record_buf:\n        raise ScrapliException(\n            \"something unexpected happened in the ScrapliFileHandler log handler\"\n        )\n\n    self._record_buf.msg = f\"read : {self._record_msg_buf!r}\"\n    super().emit(record=self._record_buf)\n    self._record_buf = None\n    self._record_msg_buf = b\"\"\n</code></pre>"},{"location":"reference/logging/#logging.ScrapliFormatter","title":"<code>ScrapliFormatter</code>","text":"<p>         Bases: <code>Formatter_</code></p> Source code in <code>scrapli/logging.py</code> <pre><code>class ScrapliFormatter(Formatter_):\n    def __init__(self, log_header: bool = True, caller_info: bool = False) -&gt; None:\n\"\"\"\n        Scrapli's opinionated custom log formatter class\n\n        Only applied/used when explicitly requested by the user, otherwise we leave logging up to\n        the user as any library should!\n\n        Args:\n            log_header: add the \"header\" row to logging output (or not)\n            caller_info: add caller (module/package/line) info to log output\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        log_format = \"{message_id:&lt;5} | {asctime} | {levelname:&lt;8} | {target: &lt;25} | {message}\"\n        if caller_info:\n            log_format = (\n                \"{message_id:&lt;5} | {asctime} | {levelname:&lt;8} | {target: &lt;25} | \"\n                \"{module:&lt;20} | {funcName:&lt;20} | {lineno:&lt;5} | {message}\"\n            )\n\n        super().__init__(fmt=log_format, style=\"{\")\n\n        self.log_header = log_header\n        self.caller_info = caller_info\n        self.message_id = 1\n\n        self.header_record = ScrapliLogRecord(\n            name=\"header\",\n            level=0,\n            pathname=\"\",\n            lineno=0,\n            msg=\"MESSAGE\",\n            args=(),\n            exc_info=None,\n        )\n        self.header_record.message_id = 0\n        self.header_record.asctime = \"TIMESTAMP\".ljust(23, \" \")\n        self.header_record.levelname = \"LEVEL\"\n        self.header_record.uid = \"(UID:)\"\n        self.header_record.host = \"HOST\"\n        self.header_record.port = \"PORT\"\n        self.header_record.module = \"MODULE\"\n        self.header_record.funcName = \"FUNCNAME\"\n        self.header_record.lineno = 0\n        self.header_record.message = \"MESSAGE\"\n\n    def formatMessage(self, record: LogRecord_) -&gt; str:\n\"\"\"\n        Override standard library logging Formatter.formatMessage\n\n        Args:\n            record: LogRecord to format\n\n        Returns:\n            str: log string to emit\n\n        Raises:\n            N/A\n\n        \"\"\"\n        record = cast(ScrapliLogRecord, record)\n\n        record.message_id = self.message_id\n\n        if not hasattr(record, \"host\"):\n            # if no host/port set, assign to the record so formatting does not fail\n            record.host = \"\"\n            record.port = \"\"\n            _host_port = \"\"\n        else:\n            _host_port = f\"{record.host}:{record.port}\"\n\n        _uid = \"\" if not hasattr(record, \"uid\") else f\"{record.uid}:\"\n        # maybe this name changes... but a uid in the event you have multiple connections to a\n        # single host... w/ this you can assign the uid so you know which is which\n        record.target = f\"{_uid}{_host_port}\"\n        # add colon to the uid so the log messages are pretty\n        record.target = (\n            record.target[:25] if len(record.target) &lt;= 25 else f\"{record.target[:22]}...\"\n        )\n\n        if self.caller_info:\n            record.module = (\n                record.module[:20] if len(record.module) &lt;= 20 else f\"{record.module[:17]}...\"\n            )\n            record.funcName = (\n                record.funcName[:20] if len(record.funcName) &lt;= 20 else f\"{record.funcName[:17]}...\"\n            )\n\n        message = self._style.format(record)\n\n        if self.message_id == 1 and self.log_header:\n            # ignoring type for these fields so we can put \"pretty\" data into the log \"header\" row\n            self.header_record.message_id = \"ID\"  # type: ignore\n            self.header_record.lineno = \"LINE\"  # type: ignore\n            self.header_record.target = \"(UID:)HOST:PORT\".ljust(len(record.target))\n            header_message = self._style.format(self.header_record)\n            message = header_message + \"\\n\" + message\n\n        self.message_id += 1\n\n        return message\n</code></pre>"},{"location":"reference/logging/#logging.ScrapliFormatter.__init__","title":"<code>__init__(log_header: bool = True, caller_info: bool = False) -&gt; None</code>","text":"<p>Scrapli's opinionated custom log formatter class</p> <p>Only applied/used when explicitly requested by the user, otherwise we leave logging up to the user as any library should!</p> <p>Parameters:</p> Name Type Description Default <code>log_header</code> <code>bool</code> <p>add the \"header\" row to logging output (or not)</p> <code>True</code> <code>caller_info</code> <code>bool</code> <p>add caller (module/package/line) info to log output</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli/logging.py</code> <pre><code>def __init__(self, log_header: bool = True, caller_info: bool = False) -&gt; None:\n\"\"\"\n    Scrapli's opinionated custom log formatter class\n\n    Only applied/used when explicitly requested by the user, otherwise we leave logging up to\n    the user as any library should!\n\n    Args:\n        log_header: add the \"header\" row to logging output (or not)\n        caller_info: add caller (module/package/line) info to log output\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    log_format = \"{message_id:&lt;5} | {asctime} | {levelname:&lt;8} | {target: &lt;25} | {message}\"\n    if caller_info:\n        log_format = (\n            \"{message_id:&lt;5} | {asctime} | {levelname:&lt;8} | {target: &lt;25} | \"\n            \"{module:&lt;20} | {funcName:&lt;20} | {lineno:&lt;5} | {message}\"\n        )\n\n    super().__init__(fmt=log_format, style=\"{\")\n\n    self.log_header = log_header\n    self.caller_info = caller_info\n    self.message_id = 1\n\n    self.header_record = ScrapliLogRecord(\n        name=\"header\",\n        level=0,\n        pathname=\"\",\n        lineno=0,\n        msg=\"MESSAGE\",\n        args=(),\n        exc_info=None,\n    )\n    self.header_record.message_id = 0\n    self.header_record.asctime = \"TIMESTAMP\".ljust(23, \" \")\n    self.header_record.levelname = \"LEVEL\"\n    self.header_record.uid = \"(UID:)\"\n    self.header_record.host = \"HOST\"\n    self.header_record.port = \"PORT\"\n    self.header_record.module = \"MODULE\"\n    self.header_record.funcName = \"FUNCNAME\"\n    self.header_record.lineno = 0\n    self.header_record.message = \"MESSAGE\"\n</code></pre>"},{"location":"reference/logging/#logging.ScrapliFormatter.formatMessage","title":"<code>formatMessage(record: LogRecord_) -&gt; str</code>","text":"<p>Override standard library logging Formatter.formatMessage</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord_</code> <p>LogRecord to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>log string to emit</p> Source code in <code>scrapli/logging.py</code> <pre><code>def formatMessage(self, record: LogRecord_) -&gt; str:\n\"\"\"\n    Override standard library logging Formatter.formatMessage\n\n    Args:\n        record: LogRecord to format\n\n    Returns:\n        str: log string to emit\n\n    Raises:\n        N/A\n\n    \"\"\"\n    record = cast(ScrapliLogRecord, record)\n\n    record.message_id = self.message_id\n\n    if not hasattr(record, \"host\"):\n        # if no host/port set, assign to the record so formatting does not fail\n        record.host = \"\"\n        record.port = \"\"\n        _host_port = \"\"\n    else:\n        _host_port = f\"{record.host}:{record.port}\"\n\n    _uid = \"\" if not hasattr(record, \"uid\") else f\"{record.uid}:\"\n    # maybe this name changes... but a uid in the event you have multiple connections to a\n    # single host... w/ this you can assign the uid so you know which is which\n    record.target = f\"{_uid}{_host_port}\"\n    # add colon to the uid so the log messages are pretty\n    record.target = (\n        record.target[:25] if len(record.target) &lt;= 25 else f\"{record.target[:22]}...\"\n    )\n\n    if self.caller_info:\n        record.module = (\n            record.module[:20] if len(record.module) &lt;= 20 else f\"{record.module[:17]}...\"\n        )\n        record.funcName = (\n            record.funcName[:20] if len(record.funcName) &lt;= 20 else f\"{record.funcName[:17]}...\"\n        )\n\n    message = self._style.format(record)\n\n    if self.message_id == 1 and self.log_header:\n        # ignoring type for these fields so we can put \"pretty\" data into the log \"header\" row\n        self.header_record.message_id = \"ID\"  # type: ignore\n        self.header_record.lineno = \"LINE\"  # type: ignore\n        self.header_record.target = \"(UID:)HOST:PORT\".ljust(len(record.target))\n        header_message = self._style.format(self.header_record)\n        message = header_message + \"\\n\" + message\n\n    self.message_id += 1\n\n    return message\n</code></pre>"},{"location":"reference/logging/#logging.enable_basic_logging","title":"<code>enable_basic_logging(file: Union[str, bool] = False, level: str = 'info', caller_info: bool = False, buffer_log: bool = True, mode: str = 'write') -&gt; None</code>","text":"<p>Enable opinionated logging for scrapli</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, bool]</code> <p>True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to</p> <code>False</code> <code>level</code> <code>str</code> <p>string name of logging level to use, i.e. \"info\", \"debug\", etc.</p> <code>'info'</code> <code>caller_info</code> <code>bool</code> <p>add info about module/function/line in the log entry</p> <code>False</code> <code>buffer_log</code> <code>bool</code> <p>buffer log read outputs</p> <code>True</code> <code>mode</code> <code>str</code> <p>string of \"write\" or \"append\"</p> <code>'write'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliException</code> <p>if invalid mode is passed</p> Source code in <code>scrapli/logging.py</code> <pre><code>def enable_basic_logging(\n    file: Union[str, bool] = False,\n    level: str = \"info\",\n    caller_info: bool = False,\n    buffer_log: bool = True,\n    mode: str = \"write\",\n) -&gt; None:\n\"\"\"\n    Enable opinionated logging for scrapli\n\n    Args:\n        file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log\n            file to\n        level: string name of logging level to use, i.e. \"info\", \"debug\", etc.\n        caller_info: add info about module/function/line in the log entry\n        buffer_log: buffer log read outputs\n        mode: string of \"write\" or \"append\"\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliException: if invalid mode is passed\n\n    \"\"\"\n    logger.propagate = False\n    logger.setLevel(level=level.upper())\n\n    scrapli_formatter = ScrapliFormatter(caller_info=caller_info)\n\n    if mode.lower() not in (\n        \"write\",\n        \"append\",\n    ):\n        raise ScrapliException(\"logging file 'mode' must be 'write' or 'append'!\")\n    file_mode = \"a\" if mode.lower() == \"append\" else \"w\"\n\n    if file:\n        filename = \"scrapli.log\" if isinstance(file, bool) else file\n        if not buffer_log:\n            fh = FileHandler_(filename=filename, mode=file_mode)\n        else:\n            fh = ScrapliFileHandler(filename=filename, mode=file_mode)\n\n        fh.setFormatter(scrapli_formatter)\n\n        logger.addHandler(fh)\n</code></pre>"},{"location":"reference/logging/#logging.get_instance_logger","title":"<code>get_instance_logger(instance_name: str, host: str = '', port: int = 0, uid: str = '') -&gt; LoggerAdapterT</code>","text":"<p>Get an adapted logger instance for a given instance (driver/channel/transport)</p> <p>Parameters:</p> Name Type Description Default <code>instance_name</code> <code>str</code> <p>logger/instance name, i.e. \"scrapli.driver\"</p> required <code>host</code> <code>str</code> <p>host to add to logging extras if applicable</p> <code>''</code> <code>port</code> <code>int</code> <p>port to add to logging extras if applicable</p> <code>0</code> <code>uid</code> <code>str</code> <p>unique id for a logging instance</p> <code>''</code> <p>Returns:</p> Name Type Description <code>LoggerAdapterT</code> <code>LoggerAdapterT</code> <p>adapter logger for the instance</p> Source code in <code>scrapli/logging.py</code> <pre><code>def get_instance_logger(\n    instance_name: str, host: str = \"\", port: int = 0, uid: str = \"\"\n) -&gt; LoggerAdapterT:\n\"\"\"\n    Get an adapted logger instance for a given instance (driver/channel/transport)\n\n    Args:\n        instance_name: logger/instance name, i.e. \"scrapli.driver\"\n        host: host to add to logging extras if applicable\n        port: port to add to logging extras if applicable\n        uid: unique id for a logging instance\n\n    Returns:\n        LoggerAdapterT: adapter logger for the instance\n\n    Raises:\n        N/A\n\n    \"\"\"\n    extras = {}\n\n    if host and port:\n        extras[\"host\"] = host\n        extras[\"port\"] = str(port)\n\n    if uid:\n        extras[\"uid\"] = uid\n\n    _logger = getLogger(instance_name)\n    return LoggerAdapter(_logger, extra=extras)\n</code></pre>"},{"location":"reference/response/","title":"response","text":"<p>scrapli.response</p>"},{"location":"reference/response/#response.MultiResponse","title":"<code>MultiResponse</code>","text":"<p>         Bases: <code>ScrapliMultiResponse</code></p> Source code in <code>scrapli/response.py</code> <pre><code>class MultiResponse(ScrapliMultiResponse):\n    def __init__(self, initlist: Optional[Iterable[Any]] = None) -&gt; None:\n\"\"\"\n        Initialize list of responses\n\n        Args:\n            initlist: initial list seed data, if any\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        super().__init__(initlist=initlist)\n\n        self.data: List[Response]\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Magic str method for MultiResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return (\n            f\"{self.__class__.__name__} &lt;Success: {not self.failed}; \"\n            f\"Response Elements: {len(self.data)}&gt;\"\n        )\n\n    @property\n    def host(self) -&gt; str:\n\"\"\"\n        Return the host of the multiresponse\n\n        Args:\n            N/A\n\n        Returns:\n            str: The host of the associated responses\n\n        Raises:\n            N/A\n\n        \"\"\"\n        try:\n            response = self.data[0]\n        except IndexError:\n            return \"\"\n        return response.host\n\n    @property\n    def failed(self) -&gt; bool:\n\"\"\"\n        Determine if any elements of MultiResponse are failed\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True for failed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return any(response.failed for response in self.data)\n\n    @property\n    def result(self) -&gt; str:\n\"\"\"\n        Build a unified result from all elements of MultiResponse\n\n        Args:\n            N/A\n\n        Returns:\n            str: Unified result by combining results of all elements of MultiResponse\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return \"\".join(\n            \"\\n\".join([response.channel_input, response.result]) for response in self.data\n        )\n\n    def raise_for_status(self) -&gt; None:\n\"\"\"\n        Raise a `ScrapliCommandFailure` if any elements are failed\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCommandFailure: if any elements are failed\n\n        \"\"\"\n        if self.failed:\n            raise ScrapliCommandFailure()\n</code></pre>"},{"location":"reference/response/#response.MultiResponse.__init__","title":"<code>__init__(initlist: Optional[Iterable[Any]] = None) -&gt; None</code>","text":"<p>Initialize list of responses</p> <p>Parameters:</p> Name Type Description Default <code>initlist</code> <code>Optional[Iterable[Any]]</code> <p>initial list seed data, if any</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli/response.py</code> <pre><code>def __init__(self, initlist: Optional[Iterable[Any]] = None) -&gt; None:\n\"\"\"\n    Initialize list of responses\n\n    Args:\n        initlist: initial list seed data, if any\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    super().__init__(initlist=initlist)\n\n    self.data: List[Response]\n</code></pre>"},{"location":"reference/response/#response.MultiResponse.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Magic str method for MultiResponse class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>str for class object</p> Source code in <code>scrapli/response.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Magic str method for MultiResponse class\n\n    Args:\n        N/A\n\n    Returns:\n        str: str for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return (\n        f\"{self.__class__.__name__} &lt;Success: {not self.failed}; \"\n        f\"Response Elements: {len(self.data)}&gt;\"\n    )\n</code></pre>"},{"location":"reference/response/#response.MultiResponse.failed","title":"<code>failed() -&gt; bool</code>  <code>property</code>","text":"<p>Determine if any elements of MultiResponse are failed</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True for failed</p> Source code in <code>scrapli/response.py</code> <pre><code>@property\ndef failed(self) -&gt; bool:\n\"\"\"\n    Determine if any elements of MultiResponse are failed\n\n    Args:\n        N/A\n\n    Returns:\n        bool: True for failed\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return any(response.failed for response in self.data)\n</code></pre>"},{"location":"reference/response/#response.MultiResponse.host","title":"<code>host() -&gt; str</code>  <code>property</code>","text":"<p>Return the host of the multiresponse</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The host of the associated responses</p> Source code in <code>scrapli/response.py</code> <pre><code>@property\ndef host(self) -&gt; str:\n\"\"\"\n    Return the host of the multiresponse\n\n    Args:\n        N/A\n\n    Returns:\n        str: The host of the associated responses\n\n    Raises:\n        N/A\n\n    \"\"\"\n    try:\n        response = self.data[0]\n    except IndexError:\n        return \"\"\n    return response.host\n</code></pre>"},{"location":"reference/response/#response.MultiResponse.raise_for_status","title":"<code>raise_for_status() -&gt; None</code>","text":"<p>Raise a <code>ScrapliCommandFailure</code> if any elements are failed</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliCommandFailure</code> <p>if any elements are failed</p> Source code in <code>scrapli/response.py</code> <pre><code>def raise_for_status(self) -&gt; None:\n\"\"\"\n    Raise a `ScrapliCommandFailure` if any elements are failed\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliCommandFailure: if any elements are failed\n\n    \"\"\"\n    if self.failed:\n        raise ScrapliCommandFailure()\n</code></pre>"},{"location":"reference/response/#response.MultiResponse.result","title":"<code>result() -&gt; str</code>  <code>property</code>","text":"<p>Build a unified result from all elements of MultiResponse</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Unified result by combining results of all elements of MultiResponse</p> Source code in <code>scrapli/response.py</code> <pre><code>@property\ndef result(self) -&gt; str:\n\"\"\"\n    Build a unified result from all elements of MultiResponse\n\n    Args:\n        N/A\n\n    Returns:\n        str: Unified result by combining results of all elements of MultiResponse\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return \"\".join(\n        \"\\n\".join([response.channel_input, response.result]) for response in self.data\n    )\n</code></pre>"},{"location":"reference/response/#response.Response","title":"<code>Response</code>","text":"Source code in <code>scrapli/response.py</code> <pre><code>class Response:\n    def __init__(\n        self,\n        host: str,\n        channel_input: str,\n        textfsm_platform: str = \"\",\n        genie_platform: str = \"\",\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n    ):\n\"\"\"\n        Scrapli Response\n\n        Store channel_input, resulting output, and start/end/elapsed time information. Attempt to\n        determine if command was successful or not and reflect that in a failed attribute.\n\n        Args:\n            host: host that was operated on\n            channel_input: input that got sent down the channel\n            textfsm_platform: ntc-templates friendly platform type\n            genie_platform: cisco pyats/genie friendly platform type\n            failed_when_contains: list of strings that, if present in final output, represent a\n                failed command/interaction\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.host = host\n        self.start_time = datetime.now()\n        self.finish_time: Optional[datetime] = None\n        self.elapsed_time: Optional[float] = None\n\n        self.channel_input = channel_input\n        self.textfsm_platform = textfsm_platform\n        self.genie_platform = genie_platform\n        self.raw_result: bytes = b\"\"\n        self.result: str = \"\"\n\n        if isinstance(failed_when_contains, str):\n            failed_when_contains = [failed_when_contains]\n        self.failed_when_contains = failed_when_contains\n        self.failed = True\n\n    def __bool__(self) -&gt; bool:\n\"\"\"\n        Magic bool method based on channel_input being failed or not\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if channel_input failed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self.failed\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Magic repr method for Response class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"host={self.host!r},\"\n            f\"channel_input={self.channel_input!r},\"\n            f\"textfsm_platform={self.textfsm_platform!r},\"\n            f\"genie_platform={self.genie_platform!r},\"\n            f\"failed_when_contains={self.failed_when_contains!r})\"\n        )\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Magic str method for Response class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"{self.__class__.__name__} &lt;Success: {not self.failed}&gt;\"\n\n    def record_response(self, result: bytes) -&gt; None:\n\"\"\"\n        Record channel_input results and elapsed time of channel input/reading output\n\n        Args:\n            result: string result of channel_input\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.finish_time = datetime.now()\n        self.elapsed_time = (self.finish_time - self.start_time).total_seconds()\n        self.raw_result = result\n\n        try:\n            self.result = result.decode()\n        except UnicodeDecodeError:\n            # sometimes we get some \"garbage\" characters, the iso encoding seems to handle these\n            # better but unclear what the other impact is so we'll just catch exceptions and try\n            # this encoding\n            self.result = result.decode(encoding=\"ISO-8859-1\")\n\n        if not self.failed_when_contains:\n            self.failed = False\n        elif all(err not in self.result for err in self.failed_when_contains):\n            self.failed = False\n\n    def textfsm_parse_output(\n        self, template: Union[str, TextIO, None] = None, to_dict: bool = True\n    ) -&gt; Union[Dict[str, Any], List[Any]]:\n\"\"\"\n        Parse results with textfsm, always return structured data\n\n        Returns an empty list if parsing fails!\n\n        Args:\n            template: string path to textfsm template or opened textfsm template file\n            to_dict: convert textfsm output from list of lists to list of dicts -- basically create\n                dict from header and row data so it is easier to read/parse the output\n\n        Returns:\n            structured_result: empty list or parsed data from textfsm\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if template is None:\n            template = _textfsm_get_template(\n                platform=self.textfsm_platform, command=self.channel_input\n            )\n\n        if template is None:\n            return []\n\n        template = cast(Union[str, TextIOWrapper], template)\n        return textfsm_parse(template=template, output=self.result, to_dict=to_dict) or []\n\n    def genie_parse_output(self) -&gt; Union[Dict[str, Any], List[Any]]:\n\"\"\"\n        Parse results with genie, always return structured data\n\n        Returns an empty list if parsing fails!\n\n        Args:\n            N/A\n\n        Returns:\n            structured_result: empty list or parsed data from genie\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return genie_parse(\n            platform=self.genie_platform,\n            command=self.channel_input,\n            output=self.result,\n        )\n\n    def ttp_parse_output(\n        self, template: Union[str, TextIOWrapper]\n    ) -&gt; Union[Dict[str, Any], List[Any]]:\n\"\"\"\n        Parse results with ttp, always return structured data\n\n        Returns an empty list if parsing fails!\n\n        Args:\n            template: string path to ttp template or opened ttp template file\n\n        Returns:\n            structured_result: empty list or parsed data from ttp\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return ttp_parse(template=template, output=self.result) or []\n\n    def raise_for_status(self) -&gt; None:\n\"\"\"\n        Raise a `ScrapliCommandFailure` if command/config failed\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCommandFailure: if command/config failed\n\n        \"\"\"\n        if self.failed:\n            raise ScrapliCommandFailure()\n</code></pre>"},{"location":"reference/response/#response.Response.__bool__","title":"<code>__bool__() -&gt; bool</code>","text":"<p>Magic bool method based on channel_input being failed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True/False if channel_input failed</p> Source code in <code>scrapli/response.py</code> <pre><code>def __bool__(self) -&gt; bool:\n\"\"\"\n    Magic bool method based on channel_input being failed or not\n\n    Args:\n        N/A\n\n    Returns:\n        bool: True/False if channel_input failed\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self.failed\n</code></pre>"},{"location":"reference/response/#response.Response.__init__","title":"<code>__init__(host: str, channel_input: str, textfsm_platform: str = '', genie_platform: str = '', failed_when_contains: Optional[Union[str, List[str]]] = None)</code>","text":"<p>Scrapli Response</p> <p>Store channel_input, resulting output, and start/end/elapsed time information. Attempt to determine if command was successful or not and reflect that in a failed attribute.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>host that was operated on</p> required <code>channel_input</code> <code>str</code> <p>input that got sent down the channel</p> required <code>textfsm_platform</code> <code>str</code> <p>ntc-templates friendly platform type</p> <code>''</code> <code>genie_platform</code> <code>str</code> <p>cisco pyats/genie friendly platform type</p> <code>''</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>list of strings that, if present in final output, represent a failed command/interaction</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>scrapli/response.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    channel_input: str,\n    textfsm_platform: str = \"\",\n    genie_platform: str = \"\",\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n):\n\"\"\"\n    Scrapli Response\n\n    Store channel_input, resulting output, and start/end/elapsed time information. Attempt to\n    determine if command was successful or not and reflect that in a failed attribute.\n\n    Args:\n        host: host that was operated on\n        channel_input: input that got sent down the channel\n        textfsm_platform: ntc-templates friendly platform type\n        genie_platform: cisco pyats/genie friendly platform type\n        failed_when_contains: list of strings that, if present in final output, represent a\n            failed command/interaction\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.host = host\n    self.start_time = datetime.now()\n    self.finish_time: Optional[datetime] = None\n    self.elapsed_time: Optional[float] = None\n\n    self.channel_input = channel_input\n    self.textfsm_platform = textfsm_platform\n    self.genie_platform = genie_platform\n    self.raw_result: bytes = b\"\"\n    self.result: str = \"\"\n\n    if isinstance(failed_when_contains, str):\n        failed_when_contains = [failed_when_contains]\n    self.failed_when_contains = failed_when_contains\n    self.failed = True\n</code></pre>"},{"location":"reference/response/#response.Response.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Magic repr method for Response class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>repr for class object</p> Source code in <code>scrapli/response.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Magic repr method for Response class\n\n    Args:\n        N/A\n\n    Returns:\n        str: repr for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return (\n        f\"{self.__class__.__name__}(\"\n        f\"host={self.host!r},\"\n        f\"channel_input={self.channel_input!r},\"\n        f\"textfsm_platform={self.textfsm_platform!r},\"\n        f\"genie_platform={self.genie_platform!r},\"\n        f\"failed_when_contains={self.failed_when_contains!r})\"\n    )\n</code></pre>"},{"location":"reference/response/#response.Response.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Magic str method for Response class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>str for class object</p> Source code in <code>scrapli/response.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Magic str method for Response class\n\n    Args:\n        N/A\n\n    Returns:\n        str: str for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"{self.__class__.__name__} &lt;Success: {not self.failed}&gt;\"\n</code></pre>"},{"location":"reference/response/#response.Response.genie_parse_output","title":"<code>genie_parse_output() -&gt; Union[Dict[str, Any], List[Any]]</code>","text":"<p>Parse results with genie, always return structured data</p> <p>Returns an empty list if parsing fails!</p> <p>Returns:</p> Name Type Description <code>structured_result</code> <code>Union[Dict[str, Any], List[Any]]</code> <p>empty list or parsed data from genie</p> Source code in <code>scrapli/response.py</code> <pre><code>def genie_parse_output(self) -&gt; Union[Dict[str, Any], List[Any]]:\n\"\"\"\n    Parse results with genie, always return structured data\n\n    Returns an empty list if parsing fails!\n\n    Args:\n        N/A\n\n    Returns:\n        structured_result: empty list or parsed data from genie\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return genie_parse(\n        platform=self.genie_platform,\n        command=self.channel_input,\n        output=self.result,\n    )\n</code></pre>"},{"location":"reference/response/#response.Response.raise_for_status","title":"<code>raise_for_status() -&gt; None</code>","text":"<p>Raise a <code>ScrapliCommandFailure</code> if command/config failed</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliCommandFailure</code> <p>if command/config failed</p> Source code in <code>scrapli/response.py</code> <pre><code>def raise_for_status(self) -&gt; None:\n\"\"\"\n    Raise a `ScrapliCommandFailure` if command/config failed\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliCommandFailure: if command/config failed\n\n    \"\"\"\n    if self.failed:\n        raise ScrapliCommandFailure()\n</code></pre>"},{"location":"reference/response/#response.Response.record_response","title":"<code>record_response(result: bytes) -&gt; None</code>","text":"<p>Record channel_input results and elapsed time of channel input/reading output</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>bytes</code> <p>string result of channel_input</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli/response.py</code> <pre><code>def record_response(self, result: bytes) -&gt; None:\n\"\"\"\n    Record channel_input results and elapsed time of channel input/reading output\n\n    Args:\n        result: string result of channel_input\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.finish_time = datetime.now()\n    self.elapsed_time = (self.finish_time - self.start_time).total_seconds()\n    self.raw_result = result\n\n    try:\n        self.result = result.decode()\n    except UnicodeDecodeError:\n        # sometimes we get some \"garbage\" characters, the iso encoding seems to handle these\n        # better but unclear what the other impact is so we'll just catch exceptions and try\n        # this encoding\n        self.result = result.decode(encoding=\"ISO-8859-1\")\n\n    if not self.failed_when_contains:\n        self.failed = False\n    elif all(err not in self.result for err in self.failed_when_contains):\n        self.failed = False\n</code></pre>"},{"location":"reference/response/#response.Response.textfsm_parse_output","title":"<code>textfsm_parse_output(template: Union[str, TextIO, None] = None, to_dict: bool = True) -&gt; Union[Dict[str, Any], List[Any]]</code>","text":"<p>Parse results with textfsm, always return structured data</p> <p>Returns an empty list if parsing fails!</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>Union[str, TextIO, None]</code> <p>string path to textfsm template or opened textfsm template file</p> <code>None</code> <code>to_dict</code> <code>bool</code> <p>convert textfsm output from list of lists to list of dicts -- basically create dict from header and row data so it is easier to read/parse the output</p> <code>True</code> <p>Returns:</p> Name Type Description <code>structured_result</code> <code>Union[Dict[str, Any], List[Any]]</code> <p>empty list or parsed data from textfsm</p> Source code in <code>scrapli/response.py</code> <pre><code>def textfsm_parse_output(\n    self, template: Union[str, TextIO, None] = None, to_dict: bool = True\n) -&gt; Union[Dict[str, Any], List[Any]]:\n\"\"\"\n    Parse results with textfsm, always return structured data\n\n    Returns an empty list if parsing fails!\n\n    Args:\n        template: string path to textfsm template or opened textfsm template file\n        to_dict: convert textfsm output from list of lists to list of dicts -- basically create\n            dict from header and row data so it is easier to read/parse the output\n\n    Returns:\n        structured_result: empty list or parsed data from textfsm\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if template is None:\n        template = _textfsm_get_template(\n            platform=self.textfsm_platform, command=self.channel_input\n        )\n\n    if template is None:\n        return []\n\n    template = cast(Union[str, TextIOWrapper], template)\n    return textfsm_parse(template=template, output=self.result, to_dict=to_dict) or []\n</code></pre>"},{"location":"reference/response/#response.Response.ttp_parse_output","title":"<code>ttp_parse_output(template: Union[str, TextIOWrapper]) -&gt; Union[Dict[str, Any], List[Any]]</code>","text":"<p>Parse results with ttp, always return structured data</p> <p>Returns an empty list if parsing fails!</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>Union[str, TextIOWrapper]</code> <p>string path to ttp template or opened ttp template file</p> required <p>Returns:</p> Name Type Description <code>structured_result</code> <code>Union[Dict[str, Any], List[Any]]</code> <p>empty list or parsed data from ttp</p> Source code in <code>scrapli/response.py</code> <pre><code>def ttp_parse_output(\n    self, template: Union[str, TextIOWrapper]\n) -&gt; Union[Dict[str, Any], List[Any]]:\n\"\"\"\n    Parse results with ttp, always return structured data\n\n    Returns an empty list if parsing fails!\n\n    Args:\n        template: string path to ttp template or opened ttp template file\n\n    Returns:\n        structured_result: empty list or parsed data from ttp\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return ttp_parse(template=template, output=self.result) or []\n</code></pre>"},{"location":"reference/settings/","title":"settings","text":"<p>scrapli.settings</p>"},{"location":"reference/ssh_config/","title":"ssh_config","text":"<p>scrapli.ssh_config</p>"},{"location":"reference/ssh_config/#ssh_config.Host","title":"<code>Host</code>","text":"Source code in <code>scrapli/ssh_config.py</code> <pre><code>class Host:\n    def __init__(self) -&gt; None:\n\"\"\"\n        Host Object\n\n        Create a Host object based on ssh config file information\n        \"\"\"\n        self.hosts: str = \"\"\n        self.hostname: Optional[str] = None\n        self.port: Optional[int] = None\n        self.user: str = \"\"\n        self.address_family: Optional[str] = None\n        self.bind_address: Optional[str] = None\n        self.connect_timeout: Optional[str] = None\n        self.identities_only: Optional[str] = None\n        self.identity_file: Optional[str] = None\n        self.keyboard_interactive: Optional[str] = None\n        self.password_authentication: Optional[str] = None\n        self.preferred_authentication: Optional[str] = None\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Magic str method for HostEntry class\n\n        Args:\n            N/A\n\n        Returns:\n            str: string for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"Host: {self.hosts}\"\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Magic repr method for HostEntry class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        class_dict = self.__dict__.copy()\n        return f\"Host {class_dict}\"\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.Host.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Host Object</p> <p>Create a Host object based on ssh config file information</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    Host Object\n\n    Create a Host object based on ssh config file information\n    \"\"\"\n    self.hosts: str = \"\"\n    self.hostname: Optional[str] = None\n    self.port: Optional[int] = None\n    self.user: str = \"\"\n    self.address_family: Optional[str] = None\n    self.bind_address: Optional[str] = None\n    self.connect_timeout: Optional[str] = None\n    self.identities_only: Optional[str] = None\n    self.identity_file: Optional[str] = None\n    self.keyboard_interactive: Optional[str] = None\n    self.password_authentication: Optional[str] = None\n    self.preferred_authentication: Optional[str] = None\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.Host.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Magic repr method for HostEntry class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>repr for class object</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Magic repr method for HostEntry class\n\n    Args:\n        N/A\n\n    Returns:\n        str: repr for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    class_dict = self.__dict__.copy()\n    return f\"Host {class_dict}\"\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.Host.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Magic str method for HostEntry class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string for class object</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Magic str method for HostEntry class\n\n    Args:\n        N/A\n\n    Returns:\n        str: string for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"Host: {self.hosts}\"\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHConfig","title":"<code>SSHConfig</code>","text":"Source code in <code>scrapli/ssh_config.py</code> <pre><code>class SSHConfig:\n    _config_files: Dict[str, \"SSHConfig\"] = {}\n\n    def __init__(self, ssh_config_file: str) -&gt; None:\n\"\"\"\n        Initialize SSHConfig Object\n\n        Parse OpenSSH config file\n\n        Try to load the following data for all entries in config file:\n            Host\n            HostName\n            Port\n            User\n            *AddressFamily\n            *BindAddress\n            *ConnectTimeout\n            IdentitiesOnly\n            IdentityFile\n            *KbdInteractiveAuthentication\n            *PasswordAuthentication\n            *PreferredAuthentications\n\n        * items are mostly ready to load but are unused in scrapli right now so are not being set\n        at this point.\n\n        NOTE: this does *not* accept duplicate \"*\" entries -- the final \"*\" entry will overwrite any\n        previous \"*\" entries. In general for system transport this shouldn't matter much because\n        scrapli only cares about parsing the config file to see if a key (any key) exists for a\n        given host (we care about that because ideally we use \"pipes\" auth, but this is only an\n        option if we have a key to auth with).\n\n        Args:\n            ssh_config_file: string path to ssh configuration file\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if non-string value provided for ssh_config_file\n\n        \"\"\"\n        if not isinstance(ssh_config_file, str):\n            raise ScrapliTypeError(f\"`ssh_config_file` expected str, got {type(ssh_config_file)}\")\n\n        self.ssh_config_file = os.path.expanduser(ssh_config_file)\n        if self.ssh_config_file:\n            self.ssh_config = Path(self.ssh_config_file).read_text(encoding=\"utf-8\")\n            self.hosts = self._parse()\n            if not self.hosts:\n                self.hosts = {}\n            if \"*\" not in self.hosts:\n                self.hosts[\"*\"] = Host()\n                self.hosts[\"*\"].hosts = \"*\"\n        else:\n            self.hosts = {}\n            self.hosts[\"*\"] = Host()\n            self.hosts[\"*\"].hosts = \"*\"\n\n        # finally merge all args from less specific hosts into the more specific hosts, preserving\n        # the options from the more specific hosts of course\n        self._merge_hosts()\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Magic str method for SSHConfig class\n\n        Args:\n            N/A\n\n        Returns:\n            str: string representation of object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return \"SSHConfig Object\"\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Magic repr method for SSHConfig class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        class_dict = self.__dict__.copy()\n        del class_dict[\"ssh_config\"]\n        return f\"SSHConfig {class_dict}\"\n\n    def __bool__(self) -&gt; bool:\n\"\"\"\n        Magic bool method; return True if ssh_config_file\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if ssh_config_file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return bool(self.ssh_config)\n\n    @staticmethod\n    def _strip_comments(line: str) -&gt; str:\n\"\"\"\n        Strip out comments from ssh config file lines\n\n        Args:\n            line: to strip comments from\n\n        Returns:\n            str: rejoined ssh config file line after stripping comments\n\n        Raises:\n            N/A\n\n        \"\"\"\n        line = \" \".join(shlex.split(line, comments=True))\n        return line\n\n    def _parse(self) -&gt; Dict[str, \"Host\"]:\n\"\"\"\n        Parse SSH configuration file\n\n        Args:\n            N/A\n\n        Returns:\n            discovered_hosts: dict of host objects discovered in ssh config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # uncomment next line and handle global patterns (stuff before hosts) at some point\n        # global_config_pattern = re.compile(r\"^.*?\\b(?=host)\", flags=re.I | re.S)\n        # use word boundaries with a positive lookahead to get everything between the word host\n        # need to do this as whitespace/formatting is not really a thing in ssh_config file\n        # match host\\s to ensure we don't pick up hostname and split things there accidentally\n        host_pattern = re.compile(r\"\\bhost.*?\\b(?=host\\s|\\s+$|$)\", flags=re.I | re.S)\n        host_entries = re.findall(pattern=host_pattern, string=self.ssh_config)\n\n        discovered_hosts: Dict[str, Host] = {}\n        if not host_entries:\n            return discovered_hosts\n\n        # do we need to add whitespace between match and end of line to ensure we match correctly?\n        hosts_pattern = re.compile(r\"^\\s*host[\\s=]+(.*)$\", flags=re.I | re.M)\n        hostname_pattern = re.compile(r\"^\\s*hostname[\\s=]+([\\w.-]*)$\", flags=re.I | re.M)\n        port_pattern = re.compile(r\"^\\s*port[\\s=]+([\\d]*)$\", flags=re.I | re.M)\n        user_pattern = re.compile(r\"^\\s*user[\\s=]+([\\w]*)$\", flags=re.I | re.M)\n        # address_family_pattern = None\n        # bind_address_pattern = None\n        # connect_timeout_pattern = None\n        identities_only_pattern = re.compile(\n            r\"^\\s*identitiesonly[\\s=]+(yes|no)$\", flags=re.I | re.M\n        )\n        identity_file_pattern = re.compile(\n            r\"^\\s*identityfile[\\s=]+([\\w.\\/\\@~-]*)$\", flags=re.I | re.M\n        )\n        # keyboard_interactive_pattern = None\n        # password_authentication_pattern = None\n        # preferred_authentication_pattern = None\n\n        for host_entry in host_entries:\n            host = Host()\n            host_line = re.search(pattern=hosts_pattern, string=host_entry)\n            if isinstance(host_line, Match):\n                host.hosts = self._strip_comments(host_line.groups()[0])\n            else:\n                host.hosts = \"\"\n            hostname = re.search(pattern=hostname_pattern, string=host_entry)\n            if isinstance(hostname, Match):\n                host.hostname = self._strip_comments(hostname.groups()[0])\n            port = re.search(pattern=port_pattern, string=host_entry)\n            if isinstance(port, Match):\n                host.port = int(self._strip_comments(port.groups()[0]))\n            user = re.search(pattern=user_pattern, string=host_entry)\n            if isinstance(user, Match):\n                host.user = self._strip_comments(user.groups()[0])\n            # address_family = re.search(user_pattern, host_entry[0])\n            # bind_address = re.search(user_pattern, host_entry[0])\n            # connect_timeout = re.search(user_pattern, host_entry[0])\n            identities_only = re.search(pattern=identities_only_pattern, string=host_entry)\n            if isinstance(identities_only, Match):\n                host.identities_only = self._strip_comments(identities_only.groups()[0])\n            identity_file = re.search(pattern=identity_file_pattern, string=host_entry)\n            if isinstance(identity_file, Match):\n                host.identity_file = os.path.expanduser(\n                    self._strip_comments(identity_file.groups()[0])\n                )\n            # keyboard_interactive = re.search(user_pattern, host_entry[0])\n            # password_authentication = re.search(user_pattern, host_entry[0])\n            # preferred_authentication = re.search(user_pattern, host_entry[0])\n            discovered_hosts[host.hosts] = host\n        return discovered_hosts\n\n    def _merge_hosts(self) -&gt; None:\n\"\"\"\n        Merge less specific host pattern data into a given host\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        for host in self.hosts:  # pylint: disable=C0206\n            _current_hosts = deepcopy(self.hosts)\n            while True:\n                fuzzy_match = self._lookup_fuzzy_match(host=host, hosts=_current_hosts)\n                for attr in HOST_ATTRS:\n                    if not getattr(self.hosts[host], attr):\n                        setattr(self.hosts[host], attr, getattr(self.hosts[fuzzy_match], attr))\n                try:\n                    _current_hosts.pop(fuzzy_match)\n                except KeyError:\n                    # this means we hit the \"*\" entry twice and we can bail out\n                    break\n\n    def _lookup_fuzzy_match(self, host: str, hosts: Optional[Dict[str, \"Host\"]] = None) -&gt; str:\n\"\"\"\n        Look up fuzzy matched hosts\n\n        Get the best match ssh config Host entry for a given host; this allows for using\n        the splat and question-mark operators in ssh config file\n\n        Args:\n            host: host to lookup in discovered_hosts dict\n            hosts: hosts dict to operate on; used for passing in partial dict of hosts while\n                performing merge operations\n\n        Returns:\n            str: Nearest match (if applicable) host or `*` if none found\n\n        Raises:\n            N/A\n\n        \"\"\"\n        hosts = hosts or self.hosts\n\n        possible_matches = []\n        for host_entry in hosts.keys():\n            host_list = host_entry.split()\n            for host_pattern in host_list:\n                # replace periods with literal period\n                # replace asterisk (match 0 or more things) with appropriate regex\n                # replace question mark (match one thing) with appropriate regex\n                cleaned_host_pattern = (\n                    host_pattern.replace(\".\", r\"\\.\").replace(\"*\", r\"(.*)\").replace(\"?\", r\"(.)\")\n                )\n                # compile with case insensitive\n                search_pattern = re.compile(cleaned_host_pattern, flags=re.I)\n                result = re.search(pattern=search_pattern, string=host)\n                # if we get a result, append it and the original pattern to the possible matches\n                if result:\n                    possible_matches.append((result, host_entry))\n\n        # initialize a None best match\n        current_match = None\n        for match in possible_matches:\n            if current_match is None:\n                current_match = match\n            # count how many chars were replaced to get regex to work\n            chars_replaced = sum(\n                end_char - start_char for start_char, end_char in match[0].regs[1:]\n            )\n\n            # count how many chars were replaced to get regex to work on best match\n            best_match_chars_replaced = sum(\n                end_char - start_char for start_char, end_char in current_match[0].regs[1:]\n            )\n\n            # if match replaced less chars than \"best_match\" we have a new best match\n            if chars_replaced &lt; best_match_chars_replaced:\n                current_match = match\n        return current_match[1] if current_match is not None else \"*\"\n\n    def lookup(self, host: str) -&gt; \"Host\":\n\"\"\"\n        Lookup a given host\n\n        Args:\n            host: host to lookup in discovered_hosts dict\n\n        Returns:\n            Host: best matched host from parsed ssh config file hosts, \"*\" if no better match found\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # return exact 1:1 match if exists\n        if host in self.hosts:\n            return self.hosts[host]\n        # return match if given host is an exact match for a host entry\n        for host_line, host_entry in self.hosts.items():\n            host_list = host_line.split()\n            if host in host_list:\n                return host_entry\n        # otherwise need to select the most correct host entry\n        fuzzy_match = self._lookup_fuzzy_match(host)\n        return self.hosts[fuzzy_match]\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHConfig.__bool__","title":"<code>__bool__() -&gt; bool</code>","text":"<p>Magic bool method; return True if ssh_config_file</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True/False if ssh_config_file</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __bool__(self) -&gt; bool:\n\"\"\"\n    Magic bool method; return True if ssh_config_file\n\n    Args:\n        N/A\n\n    Returns:\n        bool: True/False if ssh_config_file\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return bool(self.ssh_config)\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHConfig.__init__","title":"<code>__init__(ssh_config_file: str) -&gt; None</code>","text":"<p>Initialize SSHConfig Object</p> <p>Parse OpenSSH config file</p> Try to load the following data for all entries in config file <p>Host HostName Port User AddressFamily BindAddress ConnectTimeout IdentitiesOnly IdentityFile KbdInteractiveAuthentication PasswordAuthentication PreferredAuthentications</p> <ul> <li>items are mostly ready to load but are unused in scrapli right now so are not being set at this point.</li> </ul> <p>NOTE: this does not accept duplicate \"\" entries -- the final \"\" entry will overwrite any previous \"*\" entries. In general for system transport this shouldn't matter much because scrapli only cares about parsing the config file to see if a key (any key) exists for a given host (we care about that because ideally we use \"pipes\" auth, but this is only an option if we have a key to auth with).</p> <p>Parameters:</p> Name Type Description Default <code>ssh_config_file</code> <code>str</code> <p>string path to ssh configuration file</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliTypeError</code> <p>if non-string value provided for ssh_config_file</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __init__(self, ssh_config_file: str) -&gt; None:\n\"\"\"\n    Initialize SSHConfig Object\n\n    Parse OpenSSH config file\n\n    Try to load the following data for all entries in config file:\n        Host\n        HostName\n        Port\n        User\n        *AddressFamily\n        *BindAddress\n        *ConnectTimeout\n        IdentitiesOnly\n        IdentityFile\n        *KbdInteractiveAuthentication\n        *PasswordAuthentication\n        *PreferredAuthentications\n\n    * items are mostly ready to load but are unused in scrapli right now so are not being set\n    at this point.\n\n    NOTE: this does *not* accept duplicate \"*\" entries -- the final \"*\" entry will overwrite any\n    previous \"*\" entries. In general for system transport this shouldn't matter much because\n    scrapli only cares about parsing the config file to see if a key (any key) exists for a\n    given host (we care about that because ideally we use \"pipes\" auth, but this is only an\n    option if we have a key to auth with).\n\n    Args:\n        ssh_config_file: string path to ssh configuration file\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliTypeError: if non-string value provided for ssh_config_file\n\n    \"\"\"\n    if not isinstance(ssh_config_file, str):\n        raise ScrapliTypeError(f\"`ssh_config_file` expected str, got {type(ssh_config_file)}\")\n\n    self.ssh_config_file = os.path.expanduser(ssh_config_file)\n    if self.ssh_config_file:\n        self.ssh_config = Path(self.ssh_config_file).read_text(encoding=\"utf-8\")\n        self.hosts = self._parse()\n        if not self.hosts:\n            self.hosts = {}\n        if \"*\" not in self.hosts:\n            self.hosts[\"*\"] = Host()\n            self.hosts[\"*\"].hosts = \"*\"\n    else:\n        self.hosts = {}\n        self.hosts[\"*\"] = Host()\n        self.hosts[\"*\"].hosts = \"*\"\n\n    # finally merge all args from less specific hosts into the more specific hosts, preserving\n    # the options from the more specific hosts of course\n    self._merge_hosts()\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHConfig.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Magic repr method for SSHConfig class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>repr for class object</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Magic repr method for SSHConfig class\n\n    Args:\n        N/A\n\n    Returns:\n        str: repr for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    class_dict = self.__dict__.copy()\n    del class_dict[\"ssh_config\"]\n    return f\"SSHConfig {class_dict}\"\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHConfig.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Magic str method for SSHConfig class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string representation of object</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Magic str method for SSHConfig class\n\n    Args:\n        N/A\n\n    Returns:\n        str: string representation of object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return \"SSHConfig Object\"\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHConfig.lookup","title":"<code>lookup(host: str) -&gt; Host</code>","text":"<p>Lookup a given host</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>host to lookup in discovered_hosts dict</p> required <p>Returns:</p> Name Type Description <code>Host</code> <code>Host</code> <p>best matched host from parsed ssh config file hosts, \"*\" if no better match found</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def lookup(self, host: str) -&gt; \"Host\":\n\"\"\"\n    Lookup a given host\n\n    Args:\n        host: host to lookup in discovered_hosts dict\n\n    Returns:\n        Host: best matched host from parsed ssh config file hosts, \"*\" if no better match found\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # return exact 1:1 match if exists\n    if host in self.hosts:\n        return self.hosts[host]\n    # return match if given host is an exact match for a host entry\n    for host_line, host_entry in self.hosts.items():\n        host_list = host_line.split()\n        if host in host_list:\n            return host_entry\n    # otherwise need to select the most correct host entry\n    fuzzy_match = self._lookup_fuzzy_match(host)\n    return self.hosts[fuzzy_match]\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHKnownHosts","title":"<code>SSHKnownHosts</code>","text":"Source code in <code>scrapli/ssh_config.py</code> <pre><code>class SSHKnownHosts:\n    def __init__(self, ssh_known_hosts_file: str) -&gt; None:\n\"\"\"\n        Initialize SSHKnownHosts Object\n\n        Parse OpenSSH known hosts file\n\n        Try to load the following data for all entries in known hosts file:\n            Host\n            Key Type\n            Public Key\n\n        Args:\n            ssh_known_hosts_file: string path to ssh known hosts file\n\n        Returns:\n            None\n\n        Raises:\n            TypeError: if non-string value provided for ssh_known_hosts\n\n        \"\"\"\n        if not isinstance(ssh_known_hosts_file, str):\n            raise TypeError(\n                f\"`ssh_known_hosts_file` expected str, got {type(ssh_known_hosts_file)}\"\n            )\n\n        self.ssh_known_hosts_file = os.path.expanduser(ssh_known_hosts_file)\n        if self.ssh_known_hosts_file:\n            self.ssh_known_hosts = Path(self.ssh_known_hosts_file).read_text(encoding=\"utf-8\")\n            self.hosts = self._parse()\n            if not self.hosts:\n                self.hosts = {}\n        else:\n            self.hosts = {}\n\n    def _parse(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Parse OpenSSH known hosts file\n\n        Args:\n            N/A\n\n        Returns:\n            known_hosts: dict of host public keys discovered in known hosts file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # match any non whitespace from start of the line... this should cover v4/v6/names\n        # skip a space and match any word (also w/ hyphen) to get key type, lastly\n        # match any non whitespace to the end of the line to get the public key\n        host_pattern = re.compile(r\"^\\S+\\s[\\w\\-]+\\s\\S+$\", flags=re.I | re.M)\n        host_entries = re.findall(pattern=host_pattern, string=self.ssh_known_hosts)\n\n        known_hosts: Dict[str, Dict[str, str]] = {}\n        for host_entry in host_entries:\n            host, key_type, public_key = host_entry.split()\n            # to simplify lookups down the line, split any list of hosts and just create a unique\n            # entry per host\n            for individual_host in host.split(\",\"):\n                known_hosts[individual_host] = {\"key_type\": key_type, \"public_key\": public_key}\n        return known_hosts\n\n    def lookup(self, host: str) -&gt; Dict[str, str]:\n\"\"\"\n        Lookup a given host's public key\n\n        Args:\n            host: host to lookup in known_hosts dict\n\n        Returns:\n            host_public_key: matched host public key from parsed ssh known hosts file,\n                empty dict if not found\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # return exact 1:1 match if exists\n        if host in self.hosts:\n            return self.hosts[host]\n        # return match if given host is an exact match for a hashed host entry\n        raw_host = host.encode(encoding=\"utf-8\")\n        for host_id, host_public_key in self.hosts.items():\n            if host_id.startswith(\"|1|\"):\n                _, _, encoded_salt, encoded_hashed_host = host_id.split(\"|\")\n                raw_salt = base64.b64decode(encoded_salt)\n                raw_hashed_host = base64.b64decode(encoded_hashed_host)\n                if hmac.HMAC(raw_salt, raw_host, \"sha1\").digest() == raw_hashed_host:\n                    return host_public_key\n        # otherwise return empty dict\n        return {}\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHKnownHosts.__init__","title":"<code>__init__(ssh_known_hosts_file: str) -&gt; None</code>","text":"<p>Initialize SSHKnownHosts Object</p> <p>Parse OpenSSH known hosts file</p> Try to load the following data for all entries in known hosts file <p>Host Key Type Public Key</p> <p>Parameters:</p> Name Type Description Default <code>ssh_known_hosts_file</code> <code>str</code> <p>string path to ssh known hosts file</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if non-string value provided for ssh_known_hosts</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def __init__(self, ssh_known_hosts_file: str) -&gt; None:\n\"\"\"\n    Initialize SSHKnownHosts Object\n\n    Parse OpenSSH known hosts file\n\n    Try to load the following data for all entries in known hosts file:\n        Host\n        Key Type\n        Public Key\n\n    Args:\n        ssh_known_hosts_file: string path to ssh known hosts file\n\n    Returns:\n        None\n\n    Raises:\n        TypeError: if non-string value provided for ssh_known_hosts\n\n    \"\"\"\n    if not isinstance(ssh_known_hosts_file, str):\n        raise TypeError(\n            f\"`ssh_known_hosts_file` expected str, got {type(ssh_known_hosts_file)}\"\n        )\n\n    self.ssh_known_hosts_file = os.path.expanduser(ssh_known_hosts_file)\n    if self.ssh_known_hosts_file:\n        self.ssh_known_hosts = Path(self.ssh_known_hosts_file).read_text(encoding=\"utf-8\")\n        self.hosts = self._parse()\n        if not self.hosts:\n            self.hosts = {}\n    else:\n        self.hosts = {}\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.SSHKnownHosts.lookup","title":"<code>lookup(host: str) -&gt; Dict[str, str]</code>","text":"<p>Lookup a given host's public key</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>host to lookup in known_hosts dict</p> required <p>Returns:</p> Name Type Description <code>host_public_key</code> <code>Dict[str, str]</code> <p>matched host public key from parsed ssh known hosts file, empty dict if not found</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def lookup(self, host: str) -&gt; Dict[str, str]:\n\"\"\"\n    Lookup a given host's public key\n\n    Args:\n        host: host to lookup in known_hosts dict\n\n    Returns:\n        host_public_key: matched host public key from parsed ssh known hosts file,\n            empty dict if not found\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # return exact 1:1 match if exists\n    if host in self.hosts:\n        return self.hosts[host]\n    # return match if given host is an exact match for a hashed host entry\n    raw_host = host.encode(encoding=\"utf-8\")\n    for host_id, host_public_key in self.hosts.items():\n        if host_id.startswith(\"|1|\"):\n            _, _, encoded_salt, encoded_hashed_host = host_id.split(\"|\")\n            raw_salt = base64.b64decode(encoded_salt)\n            raw_hashed_host = base64.b64decode(encoded_hashed_host)\n            if hmac.HMAC(raw_salt, raw_host, \"sha1\").digest() == raw_hashed_host:\n                return host_public_key\n    # otherwise return empty dict\n    return {}\n</code></pre>"},{"location":"reference/ssh_config/#ssh_config.ssh_config_factory","title":"<code>ssh_config_factory(ssh_config_file: str) -&gt; SSHConfig</code>","text":"<p>Sorta kinda make a singleton out of SSHConfig</p> <p>Not exactly a singleton in that its more like a singleton per ssh config file path since a user may elect to use different ssh config files for different things! The only place this should ever be called from is the base driver which has already resolved the ssh config file path -- so we should get only fully qualified paths. We then use this path as the key in the <code>_config_files</code> dict of the SSHConfig object, storing the actual object we instantiate as the value. This allows us to only ever create one instance of SSHConfig for each provided ssh config file!</p> <p>Parameters:</p> Name Type Description Default <code>ssh_config_file</code> <code>str</code> <p>fully qualified string path to ssh config file</p> required <p>Returns:</p> Name Type Description <code>SSHConfig</code> <code>SSHConfig</code> <p>instantiated SSHConfig object</p> Source code in <code>scrapli/ssh_config.py</code> <pre><code>def ssh_config_factory(ssh_config_file: str) -&gt; SSHConfig:\n\"\"\"\n    Sorta kinda make a singleton out of SSHConfig\n\n    Not exactly a singleton in that its more like a singleton *per ssh config file path* since a\n    user may elect to use different ssh config files for different things! The only place this\n    should ever be called from is the base driver which has already resolved the ssh config file\n    path -- so we should get only fully qualified paths. We then use this path as the key in the\n    `_config_files` dict of the SSHConfig object, storing the actual object we instantiate as the\n    value. This allows us to only ever create one instance of SSHConfig for each provided ssh\n    config file!\n\n    Args:\n        ssh_config_file: fully qualified string path to ssh config file\n\n    Returns:\n        SSHConfig: instantiated SSHConfig object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    config_files = SSHConfig._config_files  # pylint: disable=W0212\n\n    if ssh_config_file in config_files:\n        return config_files[ssh_config_file]\n\n    ssh_config = SSHConfig(ssh_config_file=ssh_config_file)\n    config_files[ssh_config_file] = ssh_config\n    return ssh_config\n</code></pre>"},{"location":"reference/channel/","title":"channel","text":"<p>scrapli.channel</p>"},{"location":"reference/channel/async_channel/","title":"async_channel","text":"<p>scrapli.channel.async_channel</p>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel","title":"<code>AsyncChannel</code>","text":"<p>         Bases: <code>BaseChannel</code></p> Source code in <code>channel/async_channel.py</code> <pre><code>class AsyncChannel(BaseChannel):\n    def __init__(\n        self,\n        transport: AsyncTransport,\n        base_channel_args: BaseChannelArgs,\n    ) -&gt; None:\n        super().__init__(\n            transport=transport,\n            base_channel_args=base_channel_args,\n        )\n        self.transport: AsyncTransport\n\n        self.channel_lock: Optional[asyncio.Lock] = None\n        if self._base_channel_args.channel_lock:\n            self.channel_lock = asyncio.Lock()\n\n    @asynccontextmanager\n    async def _channel_lock(self) -&gt; AsyncIterator[None]:\n\"\"\"\n        Lock the channel during public channel operations if channel_lock is enabled\n\n        Args:\n            N/A\n\n        Yields:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.channel_lock:\n            async with self.channel_lock:\n                yield\n        else:\n            yield\n\n    async def read(self) -&gt; bytes:\nr\"\"\"\n        Read chunks of output from the channel\n\n        Replaces any \\r characters that sometimes get stuffed into the output from the devices\n\n        Args:\n            N/A\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = await self.transport.read()\n        buf = buf.replace(b\"\\r\", b\"\")\n\n        self.logger.debug(f\"read: {buf!r}\")\n\n        if self.channel_log:\n            self.channel_log.write(buf)\n\n        if b\"\\x1b\" in buf.lower():\n            buf = self._strip_ansi(buf=buf)\n\n        return buf\n\n    async def _read_until_input(self, channel_input: bytes) -&gt; bytes:\n\"\"\"\n        Read until all channel_input has been read on the channel\n\n        Args:\n            channel_input: bytes that should have been written to the channel\n\n        Returns:\n            bytes: output read from channel while checking for the input in the channel stream\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = b\"\"\n\n        if not channel_input:\n            return buf\n\n        # squish all channel input words together and cast to lower to make comparison easier\n        processed_channel_input = b\"\".join(channel_input.lower().split())\n\n        while True:\n            buf += await self.read()\n\n            # replace any backspace chars (particular problem w/ junos), and remove any added spaces\n            # this is just for comparison of the inputs to what was read from channel\n            if processed_channel_input in b\"\".join(buf.lower().replace(b\"\\x08\", b\"\").split()):\n                return buf\n\n    async def _read_until_prompt(self, buf: bytes = b\"\") -&gt; bytes:\n\"\"\"\n        Read until expected prompt is seen.\n\n        This reads until the \"normal\" `_base_channel_args.comms_prompt_pattern` is seen. The\n        `_read_until_explicit_prompt` method can be used to read until some pattern in an arbitrary\n        list of patterns is seen.\n\n        Args:\n            buf: output from previous reads if needed (used by scrapli netconf)\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        search_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern\n        )\n\n        read_buf = BytesIO(buf)\n\n        while True:\n            b = await self.read()\n            read_buf.write(b)\n\n            search_buf = self._process_read_buf(read_buf=read_buf)\n\n            channel_match = re.search(\n                pattern=search_pattern,\n                string=search_buf,\n            )\n\n            if channel_match:\n                return read_buf.getvalue()\n\n    async def _read_until_explicit_prompt(self, prompts: List[str]) -&gt; bytes:\n\"\"\"\n        Read until expected prompt is seen.\n\n        This method is for *explicit* prompt patterns instead of the \"standard\" prompt patterns\n        contained in the `_base_channel_args.comms_prompt_pattern` attribute. Generally this is\n        only used for `send_interactive` though it could be used elsewhere as well.\n\n        Args:\n            prompts: list of prompt patterns to look for, will return upon seeing any match\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        search_patterns = [\n            self._get_prompt_pattern(\n                class_pattern=self._base_channel_args.comms_prompt_pattern, pattern=prompt\n            )\n            for prompt in prompts\n        ]\n\n        read_buf = BytesIO(b\"\")\n\n        while True:\n            b = await self.read()\n            read_buf.write(b)\n\n            search_buf = self._process_read_buf(read_buf=read_buf)\n\n            for search_pattern in search_patterns:\n                channel_match = re.search(\n                    pattern=search_pattern,\n                    string=search_buf,\n                )\n\n                if channel_match:\n                    return read_buf.getvalue()\n\n    async def _read_until_prompt_or_time(\n        self,\n        buf: bytes = b\"\",\n        channel_outputs: Optional[List[bytes]] = None,\n        read_duration: Optional[float] = None,\n    ) -&gt; bytes:\n\"\"\"\n        Read until expected prompt is seen, outputs are seen, or for duration, whichever comes first\n\n        As transport reading may block, transport timeout is temporarily set to the read_duration\n        and any `ScrapliTimeout` that is raised while reading is ignored.\n\n        Args:\n            buf: bytes from previous reads if needed\n            channel_outputs: List of bytes to search for in channel output, if any are seen, return\n                read output\n            read_duration: duration to read from channel for\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        search_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern,\n        )\n\n        if channel_outputs is None:\n            channel_outputs = []\n        if read_duration is None:\n            read_duration = 2.5\n\n        regex_channel_outputs_pattern = self._join_and_compile(channel_outputs=channel_outputs)\n\n        _transport_args = self.transport._base_transport_args  # pylint: disable=W0212\n        previous_timeout_transport = _transport_args.timeout_transport\n        _transport_args.timeout_transport = int(read_duration)\n\n        read_buf = BytesIO(buf)\n\n        start = time.time()\n        while True:\n            with suppress(ScrapliTimeout):\n                b = await self.read()\n                read_buf.write(b)\n\n            search_buf = self._process_read_buf(read_buf=read_buf)\n\n            if (time.time() - start) &gt; read_duration:\n                break\n            if any((channel_output in search_buf for channel_output in channel_outputs)):\n                break\n            if re.search(pattern=regex_channel_outputs_pattern, string=search_buf):\n                break\n            if re.search(pattern=search_pattern, string=search_buf):\n                break\n\n        _transport_args.timeout_transport = previous_timeout_transport\n\n        return read_buf.getvalue()\n\n    @timeout_wrapper\n    async def channel_authenticate_ssh(\n        self, auth_password: str, auth_private_key_passphrase: str\n    ) -&gt; None:\n\"\"\"\n        Handle SSH Authentication for transports that only operate \"in the channel\" (i.e. system)\n\n        Args:\n            auth_password: password to authenticate with\n            auth_private_key_passphrase: passphrase for ssh key if necessary\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliAuthenticationFailed: if password prompt seen more than twice\n            ScrapliAuthenticationFailed: if passphrase prompt seen more than twice\n\n        \"\"\"\n        self.logger.debug(\"attempting in channel ssh authentication\")\n\n        password_count = 0\n        passphrase_count = 0\n        authenticate_buf = b\"\"\n\n        (\n            password_pattern,\n            passphrase_pattern,\n            prompt_pattern,\n        ) = self._pre_channel_authenticate_ssh()\n\n        async with self._channel_lock():\n            while True:\n                try:\n                    buf = await asyncio.wait_for(self.read(), timeout=1)\n                except asyncio.TimeoutError:\n                    buf = b\"\"\n                authenticate_buf += buf.lower()\n\n                if re.search(\n                    pattern=password_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the password prompt\n                    authenticate_buf = b\"\"\n                    password_count += 1\n                    if password_count &gt; 2:\n                        msg = \"password prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_password, redacted=True)\n                    self.send_return()\n\n                if re.search(\n                    pattern=passphrase_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the passphrase prompt\n                    authenticate_buf = b\"\"\n                    passphrase_count += 1\n                    if passphrase_count &gt; 2:\n                        msg = \"passphrase prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_private_key_passphrase, redacted=True)\n                    self.send_return()\n\n                if re.search(\n                    pattern=prompt_pattern,\n                    string=authenticate_buf,\n                ):\n                    return\n\n    @timeout_wrapper\n    async def channel_authenticate_telnet(  # noqa: C901\n        self, auth_username: str = \"\", auth_password: str = \"\"\n    ) -&gt; None:\n\"\"\"\n        Handle Telnet Authentication\n\n        Args:\n            auth_username: username to use for telnet authentication\n            auth_password: password to use for telnet authentication\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliAuthenticationFailed: if password prompt seen more than twice\n            ScrapliAuthenticationFailed: if login prompt seen more than twice\n\n        \"\"\"\n        self.logger.debug(\"attempting in channel telnet authentication\")\n\n        username_count = 0\n        password_count = 0\n        authenticate_buf = b\"\"\n\n        (\n            username_pattern,\n            password_pattern,\n            prompt_pattern,\n            auth_start_time,\n            return_interval,\n        ) = self._pre_channel_authenticate_telnet()\n\n        read_interval = self._base_channel_args.timeout_ops / 20\n        return_attempts = 1\n\n        async with self._channel_lock():\n            while True:\n                try:\n                    buf = await asyncio.wait_for(self.read(), timeout=read_interval)\n                except asyncio.TimeoutError:\n                    buf = b\"\"\n\n                if not buf:\n                    current_iteration_time = datetime.now().timestamp()\n                    if (current_iteration_time - auth_start_time) &gt; (\n                        return_interval * return_attempts\n                    ):\n                        self.send_return()\n                        return_attempts += 1\n\n                authenticate_buf += buf.lower()\n\n                if re.search(\n                    pattern=username_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the username prompt\n                    authenticate_buf = b\"\"\n                    username_count += 1\n                    if username_count &gt; 2:\n                        msg = \"username/login prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_username)\n                    self.send_return()\n\n                if re.search(\n                    pattern=password_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the password prompt\n                    authenticate_buf = b\"\"\n                    password_count += 1\n                    if password_count &gt; 2:\n                        msg = \"password prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_password, redacted=True)\n                    self.send_return()\n\n                if re.search(\n                    pattern=prompt_pattern,\n                    string=authenticate_buf,\n                ):\n                    return\n\n    @timeout_wrapper\n    async def get_prompt(self) -&gt; str:\n\"\"\"\n        Get current channel prompt\n\n        Args:\n            N/A\n\n        Returns:\n            str: string of the current prompt\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = b\"\"\n\n        search_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern\n        )\n\n        async with self._channel_lock():\n            self.send_return()\n\n            while True:\n                buf += await self.read()\n\n                channel_match = re.search(\n                    pattern=search_pattern,\n                    string=buf,\n                )\n\n                if channel_match:\n                    current_prompt = channel_match.group(0)\n                    return current_prompt.decode().strip()\n\n    @timeout_wrapper\n    async def send_input(\n        self,\n        channel_input: str,\n        *,\n        strip_prompt: bool = True,\n        eager: bool = False,\n    ) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n        Primary entry point to send data to devices in shell mode; accept input and returns result\n\n        Args:\n            channel_input: string input to send to channel\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            eager: eager mode reads and returns the `_read_until_input` value, but does not attempt\n                to read to the prompt pattern -- this should not be used manually! (only used by\n                `send_configs` with the eager flag set)\n\n        Returns:\n            Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_send_input(channel_input=channel_input)\n\n        buf = b\"\"\n        bytes_channel_input = channel_input.encode()\n\n        self.logger.info(\n            f\"sending channel input: {channel_input}; strip_prompt: {strip_prompt}; eager: {eager}\"\n        )\n\n        async with self._channel_lock():\n            self.write(channel_input=channel_input)\n            _buf_until_input = await self._read_until_input(channel_input=bytes_channel_input)\n            self.send_return()\n\n            if not eager:\n                buf += await self._read_until_prompt()\n\n        processed_buf = self._process_output(\n            buf=buf,\n            strip_prompt=strip_prompt,\n        )\n        return buf, processed_buf\n\n    @timeout_wrapper\n    async def send_input_and_read(\n        self,\n        channel_input: str,\n        *,\n        strip_prompt: bool = True,\n        expected_outputs: Optional[List[str]] = None,\n        read_duration: Optional[float] = None,\n    ) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n        Send a command and read until expected prompt is seen, outputs are seen, or for duration\n\n        Args:\n            channel_input: string input to send to channel\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            expected_outputs: list of strings to look for in output; if any of these are seen,\n                return output read up till that read\n            read_duration: float duration to read for\n\n        Returns:\n            Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_send_input(channel_input=channel_input)\n\n        buf = b\"\"\n        bytes_channel_input = channel_input.encode()\n        bytes_channel_outputs = [\n            channel_output.encode() for channel_output in expected_outputs or []\n        ]\n\n        self.logger.info(\n            f\"sending channel input and read: {channel_input}; strip_prompt: {strip_prompt}; \"\n            f\"expected_outputs: {expected_outputs}; read_duration: {read_duration}\"\n        )\n\n        async with self._channel_lock():\n            self.write(channel_input=channel_input)\n            _buf_until_input = await self._read_until_input(channel_input=bytes_channel_input)\n            self.send_return()\n\n            buf += await self._read_until_prompt_or_time(\n                channel_outputs=bytes_channel_outputs, read_duration=read_duration\n            )\n\n        processed_buf = self._process_output(\n            buf=buf,\n            strip_prompt=strip_prompt,\n        )\n\n        return buf, processed_buf\n\n    @timeout_wrapper\n    async def send_inputs_interact(\n        self,\n        interact_events: List[Tuple[str, str, Optional[bool]]],\n        *,\n        interaction_complete_patterns: Optional[List[str]] = None,\n    ) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n        Interact with a device with changing prompts per input.\n\n        Used to interact with devices where prompts change per input, and where inputs may be hidden\n        such as in the case of a password input. This can be used to respond to challenges from\n        devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n        example. You may have as many elements in the \"interact_events\" list as needed, and each\n        element of that list should be a tuple of two or three elements. The first element is always\n        the input to send as a string, the second should be the expected response as a string, and\n        the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n        An example where we need this sort of capability:\n\n        '''\n        3560CX#copy flash: scp:\n        Source filename []? test1.txt\n        Address or name of remote host []? 172.31.254.100\n        Destination username [carl]?\n        Writing test1.txt\n        Password:\n\n        Password:\n         Sink: C0644 639 test1.txt\n        !\n        639 bytes copied in 12.066 secs (53 bytes/sec)\n        3560CX#\n        '''\n\n        To accomplish this we can use the following:\n\n        '''\n        interact = conn.channel.send_inputs_interact(\n            [\n                (\"copy flash: scp:\", \"Source filename []?\", False),\n                (\"test1.txt\", \"Address or name of remote host []?\", False),\n                (\"172.31.254.100\", \"Destination username [carl]?\", False),\n                (\"carl\", \"Password:\", False),\n                (\"super_secure_password\", prompt, True),\n            ]\n        )\n        '''\n\n        If we needed to deal with more prompts we could simply continue adding tuples to the list of\n        interact \"events\".\n\n        Args:\n            interact_events: list of tuples containing the \"interactions\" with the device\n                each list element must have an input and an expected response, and may have an\n                optional bool for the third and final element -- the optional bool specifies if the\n                input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n                not provided it is assumed the input is \"normal\" (not hidden)\n            interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n                \"session\" has ended and we should exit the interactive session.\n\n        Returns:\n            Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning,\n                and the output read from the channel that has been \"cleaned up\"\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_send_inputs_interact(interact_events=interact_events)\n\n        buf = b\"\"\n        processed_buf = b\"\"\n\n        async with self._channel_lock():\n            for interact_event in interact_events:\n                channel_input = interact_event[0]\n                bytes_channel_input = channel_input.encode()\n                channel_response = interact_event[1]\n                prompts = [channel_response]\n\n                if interaction_complete_patterns is not None:\n                    prompts.extend(interaction_complete_patterns)\n\n                try:\n                    hidden_input = interact_event[2]\n                except IndexError:\n                    hidden_input = False\n\n                _channel_input = channel_input if not hidden_input else \"REDACTED\"\n                self.logger.info(\n                    f\"sending interactive input: {_channel_input}; \"\n                    f\"expecting: {channel_response}; \"\n                    f\"hidden_input: {hidden_input}\"\n                )\n\n                self.write(channel_input=channel_input, redacted=bool(hidden_input))\n                if channel_response and hidden_input is not True:\n                    buf += await self._read_until_input(channel_input=bytes_channel_input)\n                self.send_return()\n                buf += await self._read_until_explicit_prompt(prompts=prompts)\n\n        processed_buf += self._process_output(\n            buf=buf,\n            strip_prompt=False,\n        )\n\n        return buf, processed_buf\n</code></pre>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel.channel_authenticate_ssh","title":"<code>channel_authenticate_ssh(auth_password: str, auth_private_key_passphrase: str) -&gt; None</code>  <code>async</code>","text":"<p>Handle SSH Authentication for transports that only operate \"in the channel\" (i.e. system)</p> <p>Parameters:</p> Name Type Description Default <code>auth_password</code> <code>str</code> <p>password to authenticate with</p> required <code>auth_private_key_passphrase</code> <code>str</code> <p>passphrase for ssh key if necessary</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliAuthenticationFailed</code> <p>if password prompt seen more than twice</p> <code>ScrapliAuthenticationFailed</code> <p>if passphrase prompt seen more than twice</p> Source code in <code>channel/async_channel.py</code> <pre><code>@timeout_wrapper\nasync def channel_authenticate_ssh(\n    self, auth_password: str, auth_private_key_passphrase: str\n) -&gt; None:\n\"\"\"\n    Handle SSH Authentication for transports that only operate \"in the channel\" (i.e. system)\n\n    Args:\n        auth_password: password to authenticate with\n        auth_private_key_passphrase: passphrase for ssh key if necessary\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliAuthenticationFailed: if password prompt seen more than twice\n        ScrapliAuthenticationFailed: if passphrase prompt seen more than twice\n\n    \"\"\"\n    self.logger.debug(\"attempting in channel ssh authentication\")\n\n    password_count = 0\n    passphrase_count = 0\n    authenticate_buf = b\"\"\n\n    (\n        password_pattern,\n        passphrase_pattern,\n        prompt_pattern,\n    ) = self._pre_channel_authenticate_ssh()\n\n    async with self._channel_lock():\n        while True:\n            try:\n                buf = await asyncio.wait_for(self.read(), timeout=1)\n            except asyncio.TimeoutError:\n                buf = b\"\"\n            authenticate_buf += buf.lower()\n\n            if re.search(\n                pattern=password_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the password prompt\n                authenticate_buf = b\"\"\n                password_count += 1\n                if password_count &gt; 2:\n                    msg = \"password prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_password, redacted=True)\n                self.send_return()\n\n            if re.search(\n                pattern=passphrase_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the passphrase prompt\n                authenticate_buf = b\"\"\n                passphrase_count += 1\n                if passphrase_count &gt; 2:\n                    msg = \"passphrase prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_private_key_passphrase, redacted=True)\n                self.send_return()\n\n            if re.search(\n                pattern=prompt_pattern,\n                string=authenticate_buf,\n            ):\n                return\n</code></pre>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel.channel_authenticate_telnet","title":"<code>channel_authenticate_telnet(auth_username: str = '', auth_password: str = '') -&gt; None</code>  <code>async</code>","text":"<p>Handle Telnet Authentication</p> <p>Parameters:</p> Name Type Description Default <code>auth_username</code> <code>str</code> <p>username to use for telnet authentication</p> <code>''</code> <code>auth_password</code> <code>str</code> <p>password to use for telnet authentication</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliAuthenticationFailed</code> <p>if password prompt seen more than twice</p> <code>ScrapliAuthenticationFailed</code> <p>if login prompt seen more than twice</p> Source code in <code>channel/async_channel.py</code> <pre><code>@timeout_wrapper\nasync def channel_authenticate_telnet(  # noqa: C901\n    self, auth_username: str = \"\", auth_password: str = \"\"\n) -&gt; None:\n\"\"\"\n    Handle Telnet Authentication\n\n    Args:\n        auth_username: username to use for telnet authentication\n        auth_password: password to use for telnet authentication\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliAuthenticationFailed: if password prompt seen more than twice\n        ScrapliAuthenticationFailed: if login prompt seen more than twice\n\n    \"\"\"\n    self.logger.debug(\"attempting in channel telnet authentication\")\n\n    username_count = 0\n    password_count = 0\n    authenticate_buf = b\"\"\n\n    (\n        username_pattern,\n        password_pattern,\n        prompt_pattern,\n        auth_start_time,\n        return_interval,\n    ) = self._pre_channel_authenticate_telnet()\n\n    read_interval = self._base_channel_args.timeout_ops / 20\n    return_attempts = 1\n\n    async with self._channel_lock():\n        while True:\n            try:\n                buf = await asyncio.wait_for(self.read(), timeout=read_interval)\n            except asyncio.TimeoutError:\n                buf = b\"\"\n\n            if not buf:\n                current_iteration_time = datetime.now().timestamp()\n                if (current_iteration_time - auth_start_time) &gt; (\n                    return_interval * return_attempts\n                ):\n                    self.send_return()\n                    return_attempts += 1\n\n            authenticate_buf += buf.lower()\n\n            if re.search(\n                pattern=username_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the username prompt\n                authenticate_buf = b\"\"\n                username_count += 1\n                if username_count &gt; 2:\n                    msg = \"username/login prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_username)\n                self.send_return()\n\n            if re.search(\n                pattern=password_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the password prompt\n                authenticate_buf = b\"\"\n                password_count += 1\n                if password_count &gt; 2:\n                    msg = \"password prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_password, redacted=True)\n                self.send_return()\n\n            if re.search(\n                pattern=prompt_pattern,\n                string=authenticate_buf,\n            ):\n                return\n</code></pre>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel.get_prompt","title":"<code>get_prompt() -&gt; str</code>  <code>async</code>","text":"<p>Get current channel prompt</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string of the current prompt</p> Source code in <code>channel/async_channel.py</code> <pre><code>@timeout_wrapper\nasync def get_prompt(self) -&gt; str:\n\"\"\"\n    Get current channel prompt\n\n    Args:\n        N/A\n\n    Returns:\n        str: string of the current prompt\n\n    Raises:\n        N/A\n\n    \"\"\"\n    buf = b\"\"\n\n    search_pattern = self._get_prompt_pattern(\n        class_pattern=self._base_channel_args.comms_prompt_pattern\n    )\n\n    async with self._channel_lock():\n        self.send_return()\n\n        while True:\n            buf += await self.read()\n\n            channel_match = re.search(\n                pattern=search_pattern,\n                string=buf,\n            )\n\n            if channel_match:\n                current_prompt = channel_match.group(0)\n                return current_prompt.decode().strip()\n</code></pre>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel.read","title":"<code>read() -&gt; bytes</code>  <code>async</code>","text":"<p>Read chunks of output from the channel</p> <p>Replaces any \\r characters that sometimes get stuffed into the output from the devices</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output read from channel</p> Source code in <code>channel/async_channel.py</code> <pre><code>async def read(self) -&gt; bytes:\nr\"\"\"\n    Read chunks of output from the channel\n\n    Replaces any \\r characters that sometimes get stuffed into the output from the devices\n\n    Args:\n        N/A\n\n    Returns:\n        bytes: output read from channel\n\n    Raises:\n        N/A\n\n    \"\"\"\n    buf = await self.transport.read()\n    buf = buf.replace(b\"\\r\", b\"\")\n\n    self.logger.debug(f\"read: {buf!r}\")\n\n    if self.channel_log:\n        self.channel_log.write(buf)\n\n    if b\"\\x1b\" in buf.lower():\n        buf = self._strip_ansi(buf=buf)\n\n    return buf\n</code></pre>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel.send_input","title":"<code>send_input(channel_input: str, *, strip_prompt: bool = True, eager: bool = False) -&gt; Tuple[bytes, bytes]</code>  <code>async</code>","text":"<p>Primary entry point to send data to devices in shell mode; accept input and returns result</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>str</code> <p>string input to send to channel</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>eager</code> <code>bool</code> <p>eager mode reads and returns the <code>_read_until_input</code> value, but does not attempt to read to the prompt pattern -- this should not be used manually! (only used by <code>send_configs</code> with the eager flag set)</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output</p> Source code in <code>channel/async_channel.py</code> <pre><code>@timeout_wrapper\nasync def send_input(\n    self,\n    channel_input: str,\n    *,\n    strip_prompt: bool = True,\n    eager: bool = False,\n) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n    Primary entry point to send data to devices in shell mode; accept input and returns result\n\n    Args:\n        channel_input: string input to send to channel\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        eager: eager mode reads and returns the `_read_until_input` value, but does not attempt\n            to read to the prompt pattern -- this should not be used manually! (only used by\n            `send_configs` with the eager flag set)\n\n    Returns:\n        Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_send_input(channel_input=channel_input)\n\n    buf = b\"\"\n    bytes_channel_input = channel_input.encode()\n\n    self.logger.info(\n        f\"sending channel input: {channel_input}; strip_prompt: {strip_prompt}; eager: {eager}\"\n    )\n\n    async with self._channel_lock():\n        self.write(channel_input=channel_input)\n        _buf_until_input = await self._read_until_input(channel_input=bytes_channel_input)\n        self.send_return()\n\n        if not eager:\n            buf += await self._read_until_prompt()\n\n    processed_buf = self._process_output(\n        buf=buf,\n        strip_prompt=strip_prompt,\n    )\n    return buf, processed_buf\n</code></pre>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel.send_input_and_read","title":"<code>send_input_and_read(channel_input: str, *, strip_prompt: bool = True, expected_outputs: Optional[List[str]] = None, read_duration: Optional[float] = None) -&gt; Tuple[bytes, bytes]</code>  <code>async</code>","text":"<p>Send a command and read until expected prompt is seen, outputs are seen, or for duration</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>str</code> <p>string input to send to channel</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>expected_outputs</code> <code>Optional[List[str]]</code> <p>list of strings to look for in output; if any of these are seen, return output read up till that read</p> <code>None</code> <code>read_duration</code> <code>Optional[float]</code> <p>float duration to read for</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output</p> Source code in <code>channel/async_channel.py</code> <pre><code>@timeout_wrapper\nasync def send_input_and_read(\n    self,\n    channel_input: str,\n    *,\n    strip_prompt: bool = True,\n    expected_outputs: Optional[List[str]] = None,\n    read_duration: Optional[float] = None,\n) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n    Send a command and read until expected prompt is seen, outputs are seen, or for duration\n\n    Args:\n        channel_input: string input to send to channel\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        expected_outputs: list of strings to look for in output; if any of these are seen,\n            return output read up till that read\n        read_duration: float duration to read for\n\n    Returns:\n        Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_send_input(channel_input=channel_input)\n\n    buf = b\"\"\n    bytes_channel_input = channel_input.encode()\n    bytes_channel_outputs = [\n        channel_output.encode() for channel_output in expected_outputs or []\n    ]\n\n    self.logger.info(\n        f\"sending channel input and read: {channel_input}; strip_prompt: {strip_prompt}; \"\n        f\"expected_outputs: {expected_outputs}; read_duration: {read_duration}\"\n    )\n\n    async with self._channel_lock():\n        self.write(channel_input=channel_input)\n        _buf_until_input = await self._read_until_input(channel_input=bytes_channel_input)\n        self.send_return()\n\n        buf += await self._read_until_prompt_or_time(\n            channel_outputs=bytes_channel_outputs, read_duration=read_duration\n        )\n\n    processed_buf = self._process_output(\n        buf=buf,\n        strip_prompt=strip_prompt,\n    )\n\n    return buf, processed_buf\n</code></pre>"},{"location":"reference/channel/async_channel/#channel.async_channel.AsyncChannel.send_inputs_interact","title":"<code>send_inputs_interact(interact_events: List[Tuple[str, str, Optional[bool]]], *, interaction_complete_patterns: Optional[List[str]] = None) -&gt; Tuple[bytes, bytes]</code>  <code>async</code>","text":"<p>Interact with a device with changing prompts per input.</p> <p>Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)</p> <p>An example where we need this sort of capability:</p> <p>''' 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password:</p> Password <p>Sink: C0644 639 test1.txt</p> <p>! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# '''</p> <p>To accomplish this we can use the following:</p> <p>''' interact = conn.channel.send_inputs_interact(     [         (\"copy flash: scp:\", \"Source filename []?\", False),         (\"test1.txt\", \"Address or name of remote host []?\", False),         (\"172.31.254.100\", \"Destination username [carl]?\", False),         (\"carl\", \"Password:\", False),         (\"super_secure_password\", prompt, True),     ] ) '''</p> <p>If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\".</p> <p>Parameters:</p> Name Type Description Default <code>interact_events</code> <code>List[Tuple[str, str, Optional[bool]]]</code> <p>list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden)</p> required <code>interaction_complete_patterns</code> <code>Optional[List[str]]</code> <p>list of patterns, that if seen, indicate the interactive \"session\" has ended and we should exit the interactive session.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning, and the output read from the channel that has been \"cleaned up\"</p> Source code in <code>channel/async_channel.py</code> <pre><code>@timeout_wrapper\nasync def send_inputs_interact(\n    self,\n    interact_events: List[Tuple[str, str, Optional[bool]]],\n    *,\n    interaction_complete_patterns: Optional[List[str]] = None,\n) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n    Interact with a device with changing prompts per input.\n\n    Used to interact with devices where prompts change per input, and where inputs may be hidden\n    such as in the case of a password input. This can be used to respond to challenges from\n    devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n    example. You may have as many elements in the \"interact_events\" list as needed, and each\n    element of that list should be a tuple of two or three elements. The first element is always\n    the input to send as a string, the second should be the expected response as a string, and\n    the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n    An example where we need this sort of capability:\n\n    '''\n    3560CX#copy flash: scp:\n    Source filename []? test1.txt\n    Address or name of remote host []? 172.31.254.100\n    Destination username [carl]?\n    Writing test1.txt\n    Password:\n\n    Password:\n     Sink: C0644 639 test1.txt\n    !\n    639 bytes copied in 12.066 secs (53 bytes/sec)\n    3560CX#\n    '''\n\n    To accomplish this we can use the following:\n\n    '''\n    interact = conn.channel.send_inputs_interact(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"test1.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"carl\", \"Password:\", False),\n            (\"super_secure_password\", prompt, True),\n        ]\n    )\n    '''\n\n    If we needed to deal with more prompts we could simply continue adding tuples to the list of\n    interact \"events\".\n\n    Args:\n        interact_events: list of tuples containing the \"interactions\" with the device\n            each list element must have an input and an expected response, and may have an\n            optional bool for the third and final element -- the optional bool specifies if the\n            input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n            not provided it is assumed the input is \"normal\" (not hidden)\n        interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n            \"session\" has ended and we should exit the interactive session.\n\n    Returns:\n        Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning,\n            and the output read from the channel that has been \"cleaned up\"\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_send_inputs_interact(interact_events=interact_events)\n\n    buf = b\"\"\n    processed_buf = b\"\"\n\n    async with self._channel_lock():\n        for interact_event in interact_events:\n            channel_input = interact_event[0]\n            bytes_channel_input = channel_input.encode()\n            channel_response = interact_event[1]\n            prompts = [channel_response]\n\n            if interaction_complete_patterns is not None:\n                prompts.extend(interaction_complete_patterns)\n\n            try:\n                hidden_input = interact_event[2]\n            except IndexError:\n                hidden_input = False\n\n            _channel_input = channel_input if not hidden_input else \"REDACTED\"\n            self.logger.info(\n                f\"sending interactive input: {_channel_input}; \"\n                f\"expecting: {channel_response}; \"\n                f\"hidden_input: {hidden_input}\"\n            )\n\n            self.write(channel_input=channel_input, redacted=bool(hidden_input))\n            if channel_response and hidden_input is not True:\n                buf += await self._read_until_input(channel_input=bytes_channel_input)\n            self.send_return()\n            buf += await self._read_until_explicit_prompt(prompts=prompts)\n\n    processed_buf += self._process_output(\n        buf=buf,\n        strip_prompt=False,\n    )\n\n    return buf, processed_buf\n</code></pre>"},{"location":"reference/channel/base_channel/","title":"base_channel","text":"<p>scrapli.channel.base_channel</p>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel","title":"<code>BaseChannel</code>","text":"Source code in <code>channel/base_channel.py</code> <pre><code>class BaseChannel:\n    def __init__(\n        self,\n        transport: Union[AsyncTransport, Transport],\n        base_channel_args: BaseChannelArgs,\n    ):\n\"\"\"\n        BaseChannel Object -- provides convenience methods to both sync and async Channels\n\n        Args:\n            transport: initialized scrapli Transport/AsyncTransport object\n            base_channel_args: BaseChannelArgs object\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.transport = transport\n        self._base_channel_args = base_channel_args\n\n        self.logger = get_instance_logger(\n            instance_name=\"scrapli.channel\",\n            host=self.transport._base_transport_args.host,\n            port=self.transport._base_transport_args.port,\n            uid=self.transport._base_transport_args.logging_uid,\n        )\n\n        self.channel_log: Optional[BinaryIO] = None\n\n        self._auth_telnet_login_pattern = r\"^(.*username:)|(.*login:)\\s?$\"\n        self._auth_password_pattern = r\"(.*@.*)?password:\\s?$\"\n        self._auth_passphrase_pattern = r\"enter passphrase for key\"\n\n    @property\n    def auth_telnet_login_pattern(self) -&gt; Pattern[bytes]:\n\"\"\"\n        Getter for `auth_telnet_login_pattern` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            Pattern: compiled pattern of the set auth_telnet_login_pattern value\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return re.compile(self._auth_telnet_login_pattern.encode(), flags=re.I | re.M)\n\n    @auth_telnet_login_pattern.setter\n    def auth_telnet_login_pattern(self, value: str) -&gt; None:\n\"\"\"\n        Setter for `auth_telnet_login_pattern` attribute\n\n        Args:\n            value: str value for auth_telnet_login_pattern; this value will be compiled withe re.I\n                and re.M flags when the getter is called.\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type str\n\n        \"\"\"\n        self.logger.debug(f\"setting 'auth_telnet_login_pattern' value to '{value}'\")\n\n        if not isinstance(value, str):\n            raise ScrapliTypeError\n\n        self._auth_telnet_login_pattern = value\n\n    @property\n    def auth_password_pattern(self) -&gt; Pattern[bytes]:\n\"\"\"\n        Getter for `auth_password_pattern` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            Pattern: compiled pattern of the set auth_password_pattern value\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return re.compile(self._auth_password_pattern.encode(), flags=re.I | re.M)\n\n    @auth_password_pattern.setter\n    def auth_password_pattern(self, value: str) -&gt; None:\n\"\"\"\n        Setter for `auth_password_pattern` attribute\n\n        Args:\n            value: str value for auth_password_pattern; this value will be compiled withe re.I\n                and re.M flags when the getter is called.\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type str\n\n        \"\"\"\n        self.logger.debug(f\"setting 'auth_password_pattern' value to '{value}'\")\n\n        if not isinstance(value, str):\n            raise ScrapliTypeError\n\n        self._auth_password_pattern = value\n\n    @property\n    def auth_passphrase_pattern(self) -&gt; Pattern[bytes]:\n\"\"\"\n        Getter for `auth_passphrase_pattern` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            Pattern: compiled pattern of the set auth_passphrase_pattern value\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return re.compile(self._auth_passphrase_pattern.encode(), flags=re.I | re.M)\n\n    @auth_passphrase_pattern.setter\n    def auth_passphrase_pattern(self, value: str) -&gt; None:\n\"\"\"\n        Setter for `auth_passphrase_pattern` attribute\n\n        Args:\n            value: str value for auth_passphrase_pattern; this value will be compiled withe re.I\n                and re.M flags when the getter is called.\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type str\n\n        \"\"\"\n        self.logger.debug(f\"setting '_auth_passphrase_pattern' value to '{value}'\")\n\n        if not isinstance(value, str):\n            raise ScrapliTypeError\n\n        self._auth_passphrase_pattern = value\n\n    def open(self) -&gt; None:\n\"\"\"\n        Channel open method\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._base_channel_args.channel_log:\n            if isinstance(self._base_channel_args.channel_log, BytesIO):\n                self.channel_log = self._base_channel_args.channel_log\n            else:\n                channel_log_destination = \"scrapli_channel.log\"\n                if isinstance(self._base_channel_args.channel_log, str):\n                    channel_log_destination = self._base_channel_args.channel_log\n                self.logger.info(\n                    f\"channel log enabled, logging channel output to '{channel_log_destination}'\"\n                )\n                # have to ignore type due to mypy not wanting to read the mode from formatted string\n                # if you change the mode --&gt; \"wb\" or \"ab\" it works as you would hope/expect; those\n                # are the only values it can possibly be at this point though so we can safely\n                # ignore here\n                # note that this will *always* be binary mode, so there doesn't need to be any\n                # encoding, hence ignoring that pylint message!\n                self.channel_log = open(  # pylint: disable=W1514,R1732\n                    channel_log_destination,\n                    mode=f\"{self._base_channel_args.channel_log_mode}b\",  # type: ignore\n                )\n\n    def close(self) -&gt; None:\n\"\"\"\n        Channel close method\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.channel_log:\n            self.channel_log.close()\n\n    def _process_read_buf(self, read_buf: BytesIO) -&gt; bytes:\n\"\"\"\n        Process the read buffer\n\n        Seeks backwards up to search depth then partitions on newlines. Partition is to ensure that\n        the resulting search_buf does not end up with partial lines in the output which can cause\n        prompt patterns to match places they should not match!\n\n        Args:\n            read_buf: bytesio object read from the transport\n\n        Returns:\n            bytes: cleaned up search buffer\n\n        Raises:\n            N/A\n\n        \"\"\"\n        read_buf.seek(-self._base_channel_args.comms_prompt_search_depth, SEEK_END)\n        search_buf = read_buf.read()\n\n        before, _, search_buf = search_buf.partition(b\"\\n\")\n\n        if not search_buf:\n            # didn't split on anything or nothing after partition\n            search_buf = before\n\n        return search_buf\n\n    def write(self, channel_input: str, redacted: bool = False) -&gt; None:\n\"\"\"\n        Write input to the underlying Transport session\n\n        Args:\n            channel_input: string of input to send\n            redacted: redact channel input from log or not\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        log_output = \"REDACTED\" if redacted else repr(channel_input)\n        self.logger.debug(f\"write: {log_output}\")\n\n        self.transport.write(channel_input=channel_input.encode())\n\n    def send_return(self) -&gt; None:\n\"\"\"\n        Convenience method to send return char\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.write(channel_input=self._base_channel_args.comms_return_char)\n\n    @staticmethod\n    def _join_and_compile(channel_outputs: Optional[List[bytes]]) -&gt; Pattern[bytes]:\n\"\"\"\n        Convenience method for read_until_prompt_or_time to join channel inputs into a regex pattern\n\n        Args:\n            channel_outputs: list of bytes channel inputs to join into a regex pattern\n\n        Returns:\n            Pattern: joined regex pattern or an empty pattern (empty bytes)\n\n        Raises:\n            N/A\n\n        \"\"\"\n        regex_channel_outputs = b\"\"\n        if channel_outputs:\n            regex_channel_outputs = b\"|\".join(\n                [b\"(\" + channel_output + b\")\" for channel_output in channel_outputs]\n            )\n        regex_channel_outputs_pattern = re.compile(pattern=regex_channel_outputs, flags=re.I | re.M)\n\n        return regex_channel_outputs_pattern\n\n    def _ssh_message_handler(self, output: bytes) -&gt; None:  # noqa: C901\n\"\"\"\n        Parse EOF messages from _pty_authenticate and create log/stack exception message\n\n        Args:\n            output: bytes output from _pty_authenticate\n\n        Returns:\n            N/A  # noqa: DAR202\n\n        Raises:\n            ScrapliAuthenticationFailed: if any errors are read in the output\n\n        \"\"\"\n        msg = \"\"\n        if b\"host key verification failed\" in output.lower():\n            msg = \"Host key verification failed\"\n        elif b\"operation timed out\" in output.lower() or b\"connection timed out\" in output.lower():\n            msg = \"Timed out connecting to host\"\n        elif b\"no route to host\" in output.lower():\n            msg = \"No route to host\"\n        elif b\"no matching host key\" in output.lower():\n            msg = \"No matching host key type found for host\"\n            key_exchange_pattern = re.compile(\n                pattern=rb\"their offer: ([a-z0-9\\-,]*)\", flags=re.M | re.I\n            )\n            offered_key_exchanges_match = re.search(pattern=key_exchange_pattern, string=output)\n            if offered_key_exchanges_match:\n                offered_key_exchanges = offered_key_exchanges_match.group(1).decode()\n                msg += f\", their offer: {offered_key_exchanges}\"\n        elif b\"no matching key exchange\" in output.lower():\n            msg = \"No matching key exchange found for host\"\n            key_exchange_pattern = re.compile(\n                pattern=rb\"their offer: ([a-z0-9\\-,]*)\", flags=re.M | re.I\n            )\n            offered_key_exchanges_match = re.search(pattern=key_exchange_pattern, string=output)\n            if offered_key_exchanges_match:\n                offered_key_exchanges = offered_key_exchanges_match.group(1).decode()\n                msg += f\", their offer: {offered_key_exchanges}\"\n        elif b\"no matching cipher\" in output.lower():\n            msg = \"No matching cipher found for host\"\n            ciphers_pattern = re.compile(pattern=rb\"their offer: ([a-z0-9\\-,]*)\", flags=re.M | re.I)\n            offered_ciphers_match = re.search(pattern=ciphers_pattern, string=output)\n            if offered_ciphers_match:\n                offered_ciphers = offered_ciphers_match.group(1).decode()\n                msg += f\", their offer: {offered_ciphers}\"\n        elif b\"bad configuration\" in output.lower():\n            msg = \"Bad SSH configuration option(s) for host\"\n            configuration_pattern = re.compile(\n                pattern=rb\"bad configuration option: ([a-z0-9\\+\\=,]*)\", flags=re.M | re.I\n            )\n            configuration_issue_match = re.search(pattern=configuration_pattern, string=output)\n            if configuration_issue_match:\n                configuration_issues = configuration_issue_match.group(1).decode()\n                msg += f\", bad option(s): {configuration_issues}\"\n        elif b\"WARNING: UNPROTECTED PRIVATE KEY FILE!\" in output:\n            msg = \"Permissions for private key are too open, authentication failed!\"\n        elif b\"could not resolve hostname\" in output.lower():\n            msg = \"Could not resolve address for host\"\n        elif b\"permission denied\" in output.lower():\n            msg = str(output)\n        if msg:\n            self.logger.critical(msg)\n            raise ScrapliAuthenticationFailed(msg)\n\n    @staticmethod\n    @lru_cache()\n    def _get_prompt_pattern(class_pattern: str, pattern: Optional[str] = None) -&gt; Pattern[bytes]:\n\"\"\"\n        Return compiled prompt pattern\n\n        Given a potential prompt and the Channel class' prompt, return compiled prompt pattern\n\n        Args:\n            class_pattern: comms_prompt_pattern from the class itself; must be passed so that the\n                arguments are recognized in lru cache; this way if a user changes the pattern during\n                normal scrapli operations the lru cache can \"notice\" the pattern changed!\n            pattern: optional regex pattern to compile, if not provided we use the class' pattern\n\n        Returns:\n            pattern: compiled regex pattern to use to search for a prompt in output data\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not pattern:\n            return re.compile(class_pattern.encode(), flags=re.M | re.I)\n\n        bytes_pattern = pattern.encode()\n        if bytes_pattern.startswith(b\"^\") and bytes_pattern.endswith(b\"$\"):\n            return re.compile(bytes_pattern, flags=re.M | re.I)\n        return re.compile(re.escape(bytes_pattern))\n\n    def _pre_channel_authenticate_ssh(\n        self,\n    ) -&gt; Tuple[Pattern[bytes], Pattern[bytes], Pattern[bytes]]:\n\"\"\"\n        Handle pre ssh authentication work for parity between sync and sync versions.\n\n        Args:\n            N/A\n\n        Returns:\n            tuple: tuple of pass/passphrase/prompt patterns\n\n        Raises:\n            N/A\n\n        \"\"\"\n        prompt_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern\n        )\n\n        return self.auth_password_pattern, self.auth_passphrase_pattern, prompt_pattern\n\n    def _pre_channel_authenticate_telnet(\n        self,\n    ) -&gt; Tuple[Pattern[bytes], Pattern[bytes], Pattern[bytes], float, float]:\n\"\"\"\n        Handle pre telnet authentication work for parity between sync and sync versions.\n\n        Args:\n            N/A\n\n        Returns:\n            tuple: tuple of user/pass/prompt patterns, start timestamp and return interval\n\n        Raises:\n            N/A\n\n        \"\"\"\n        prompt_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern\n        )\n\n        # capture the start time of the authentication event; we also set a \"return_interval\" which\n        # is 1/10 the timout_ops value, we will send a return character at roughly this interval if\n        # there is no output on the channel. we do this because sometimes telnet needs a kick to get\n        # it to prompt for auth -- particularity when connecting to terminal server/console port\n        auth_start_time = datetime.now().timestamp()\n        return_interval = self._base_channel_args.timeout_ops / 10\n\n        return (\n            self.auth_telnet_login_pattern,\n            self.auth_password_pattern,\n            prompt_pattern,\n            auth_start_time,\n            return_interval,\n        )\n\n    def _process_output(self, buf: bytes, strip_prompt: bool) -&gt; bytes:\n\"\"\"\n        Process output received form the device\n\n        Remove inputs and prompts if desired\n\n        Args:\n            buf: bytes output from the device\n            strip_prompt: True/False strip the prompt from the device output\n\n        Returns:\n            bytes: cleaned up byte string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = b\"\\n\".join([line.rstrip() for line in buf.splitlines()])\n\n        if strip_prompt:\n            prompt_pattern = self._get_prompt_pattern(\n                class_pattern=self._base_channel_args.comms_prompt_pattern\n            )\n            buf = re.sub(pattern=prompt_pattern, repl=b\"\", string=buf)\n\n        buf = buf.lstrip(self._base_channel_args.comms_return_char.encode()).rstrip()\n        return buf\n\n    @staticmethod\n    def _strip_ansi(buf: bytes) -&gt; bytes:\n\"\"\"\n        Strip ansi characters from output\n\n        Args:\n            buf: bytes from previous reads if needed\n\n        Returns:\n            bytes: bytes output read from channel with ansi characters removed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = re.sub(pattern=ANSI_ESCAPE_PATTERN, repl=b\"\", string=buf)\n        return buf\n\n    @staticmethod\n    def _pre_send_input(channel_input: str) -&gt; None:\n\"\"\"\n        Handle pre \"send_input\" tasks for consistency between sync/async versions\n\n        Args:\n            channel_input: string input to send to channel\n\n        Returns:\n            bytes: current channel buffer\n\n        Raises:\n            ScrapliTypeError: if input is anything but a string\n\n        \"\"\"\n        if not isinstance(channel_input, str):\n            raise ScrapliTypeError(\n                f\"`send_input` expects a single string, got {type(channel_input)}.\"\n            )\n\n    @staticmethod\n    def _pre_send_inputs_interact(interact_events: List[Tuple[str, str, Optional[bool]]]) -&gt; None:\n\"\"\"\n        Handle pre \"send_inputs_interact\" tasks for consistency between sync/async versions\n\n        Args:\n            interact_events: interact events passed to `send_inputs_interact`\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if input is anything but a string\n\n        \"\"\"\n        if not isinstance(interact_events, list):\n            raise ScrapliTypeError(f\"`interact_events` expects a List, got {type(interact_events)}\")\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.__init__","title":"<code>__init__(transport: Union[AsyncTransport, Transport], base_channel_args: BaseChannelArgs)</code>","text":"<p>BaseChannel Object -- provides convenience methods to both sync and async Channels</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>Union[AsyncTransport, Transport]</code> <p>initialized scrapli Transport/AsyncTransport object</p> required <code>base_channel_args</code> <code>BaseChannelArgs</code> <p>BaseChannelArgs object</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>channel/base_channel.py</code> <pre><code>def __init__(\n    self,\n    transport: Union[AsyncTransport, Transport],\n    base_channel_args: BaseChannelArgs,\n):\n\"\"\"\n    BaseChannel Object -- provides convenience methods to both sync and async Channels\n\n    Args:\n        transport: initialized scrapli Transport/AsyncTransport object\n        base_channel_args: BaseChannelArgs object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.transport = transport\n    self._base_channel_args = base_channel_args\n\n    self.logger = get_instance_logger(\n        instance_name=\"scrapli.channel\",\n        host=self.transport._base_transport_args.host,\n        port=self.transport._base_transport_args.port,\n        uid=self.transport._base_transport_args.logging_uid,\n    )\n\n    self.channel_log: Optional[BinaryIO] = None\n\n    self._auth_telnet_login_pattern = r\"^(.*username:)|(.*login:)\\s?$\"\n    self._auth_password_pattern = r\"(.*@.*)?password:\\s?$\"\n    self._auth_passphrase_pattern = r\"enter passphrase for key\"\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.auth_passphrase_pattern","title":"<code>auth_passphrase_pattern() -&gt; Pattern[bytes]</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>auth_passphrase_pattern</code> attribute</p> <p>Returns:</p> Name Type Description <code>Pattern</code> <code>Pattern[bytes]</code> <p>compiled pattern of the set auth_passphrase_pattern value</p> Source code in <code>channel/base_channel.py</code> <pre><code>@property\ndef auth_passphrase_pattern(self) -&gt; Pattern[bytes]:\n\"\"\"\n    Getter for `auth_passphrase_pattern` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        Pattern: compiled pattern of the set auth_passphrase_pattern value\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return re.compile(self._auth_passphrase_pattern.encode(), flags=re.I | re.M)\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.auth_password_pattern","title":"<code>auth_password_pattern() -&gt; Pattern[bytes]</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>auth_password_pattern</code> attribute</p> <p>Returns:</p> Name Type Description <code>Pattern</code> <code>Pattern[bytes]</code> <p>compiled pattern of the set auth_password_pattern value</p> Source code in <code>channel/base_channel.py</code> <pre><code>@property\ndef auth_password_pattern(self) -&gt; Pattern[bytes]:\n\"\"\"\n    Getter for `auth_password_pattern` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        Pattern: compiled pattern of the set auth_password_pattern value\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return re.compile(self._auth_password_pattern.encode(), flags=re.I | re.M)\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.auth_telnet_login_pattern","title":"<code>auth_telnet_login_pattern() -&gt; Pattern[bytes]</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>auth_telnet_login_pattern</code> attribute</p> <p>Returns:</p> Name Type Description <code>Pattern</code> <code>Pattern[bytes]</code> <p>compiled pattern of the set auth_telnet_login_pattern value</p> Source code in <code>channel/base_channel.py</code> <pre><code>@property\ndef auth_telnet_login_pattern(self) -&gt; Pattern[bytes]:\n\"\"\"\n    Getter for `auth_telnet_login_pattern` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        Pattern: compiled pattern of the set auth_telnet_login_pattern value\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return re.compile(self._auth_telnet_login_pattern.encode(), flags=re.I | re.M)\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.close","title":"<code>close() -&gt; None</code>","text":"<p>Channel close method</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>channel/base_channel.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Channel close method\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if self.channel_log:\n        self.channel_log.close()\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.open","title":"<code>open() -&gt; None</code>","text":"<p>Channel open method</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>channel/base_channel.py</code> <pre><code>def open(self) -&gt; None:\n\"\"\"\n    Channel open method\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if self._base_channel_args.channel_log:\n        if isinstance(self._base_channel_args.channel_log, BytesIO):\n            self.channel_log = self._base_channel_args.channel_log\n        else:\n            channel_log_destination = \"scrapli_channel.log\"\n            if isinstance(self._base_channel_args.channel_log, str):\n                channel_log_destination = self._base_channel_args.channel_log\n            self.logger.info(\n                f\"channel log enabled, logging channel output to '{channel_log_destination}'\"\n            )\n            # have to ignore type due to mypy not wanting to read the mode from formatted string\n            # if you change the mode --&gt; \"wb\" or \"ab\" it works as you would hope/expect; those\n            # are the only values it can possibly be at this point though so we can safely\n            # ignore here\n            # note that this will *always* be binary mode, so there doesn't need to be any\n            # encoding, hence ignoring that pylint message!\n            self.channel_log = open(  # pylint: disable=W1514,R1732\n                channel_log_destination,\n                mode=f\"{self._base_channel_args.channel_log_mode}b\",  # type: ignore\n            )\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.send_return","title":"<code>send_return() -&gt; None</code>","text":"<p>Convenience method to send return char</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>channel/base_channel.py</code> <pre><code>def send_return(self) -&gt; None:\n\"\"\"\n    Convenience method to send return char\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.write(channel_input=self._base_channel_args.comms_return_char)\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannel.write","title":"<code>write(channel_input: str, redacted: bool = False) -&gt; None</code>","text":"<p>Write input to the underlying Transport session</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>str</code> <p>string of input to send</p> required <code>redacted</code> <code>bool</code> <p>redact channel input from log or not</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>channel/base_channel.py</code> <pre><code>def write(self, channel_input: str, redacted: bool = False) -&gt; None:\n\"\"\"\n    Write input to the underlying Transport session\n\n    Args:\n        channel_input: string of input to send\n        redacted: redact channel input from log or not\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    log_output = \"REDACTED\" if redacted else repr(channel_input)\n    self.logger.debug(f\"write: {log_output}\")\n\n    self.transport.write(channel_input=channel_input.encode())\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannelArgs","title":"<code>BaseChannelArgs</code>  <code>dataclass</code>","text":"<p>Dataclass for all base Channel arguments</p> <p>Parameters:</p> Name Type Description Default <code>comms_prompt_pattern</code> <code>str</code> <p>comms_prompt_pattern to assign to the channel; should generally be created/passed from the driver class</p> <code>'^[a-z0-9.\\\\-@()/:]{1,32}[#&gt;$]$'</code> <code>comms_return_char</code> <code>str</code> <p>comms_return_char to assign to the channel, see above</p> <code>'\\n'</code> <code>comms_prompt_search_depth</code> <code>int</code> <p>depth of the buffer to search in for searching for the prompt in \"read_until_prompt\"; smaller number here will generally be faster, though may be less reliable; default value is 1000</p> <code>1000</code> <code>timeout_ops</code> <code>float</code> <p>timeout_ops to assign to the channel, see above</p> <code>30.0</code> <code>channel_log</code> <code>Union[str, bool, BytesIO]</code> <p>log \"channel\" output -- this would be the output you would normally see on a terminal. If <code>True</code> logs to <code>scrapli_channel.log</code>, if a string is provided, logs to wherever that string points</p> <code>False</code> <code>channel_log_mode</code> <code>str</code> <p>\"write\"|\"append\", all other values will raise ValueError, does what it sounds like it should by setting the channel log to the provided mode</p> <code>'write'</code> <code>channel_lock</code> <code>bool</code> <p>bool indicated if channel lock should be used for all read/write operations</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>channel/base_channel.py</code> <pre><code>@dataclass()\nclass BaseChannelArgs:\n\"\"\"\n    Dataclass for all base Channel arguments\n\n    Args:\n        comms_prompt_pattern: comms_prompt_pattern to assign to the channel; should generally be\n            created/passed from the driver class\n        comms_return_char: comms_return_char to assign to the channel, see above\n        comms_prompt_search_depth: depth of the buffer to search in for searching for the prompt\n            in \"read_until_prompt\"; smaller number here will generally be faster, though may be less\n            reliable; default value is 1000\n        timeout_ops: timeout_ops to assign to the channel, see above\n        channel_log: log \"channel\" output -- this would be the output you would normally see on a\n            terminal. If `True` logs to `scrapli_channel.log`, if a string is provided, logs to\n            wherever that string points\n        channel_log_mode: \"write\"|\"append\", all other values will raise ValueError,\n            does what it sounds like it should by setting the channel log to the provided mode\n        channel_lock: bool indicated if channel lock should be used for all read/write operations\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n\n    comms_prompt_pattern: str = r\"^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$\"\n    comms_return_char: str = \"\\n\"\n    comms_prompt_search_depth: int = 1000\n    timeout_ops: float = 30.0\n    channel_log: Union[str, bool, BytesIO] = False\n    channel_log_mode: str = \"write\"\n    channel_lock: bool = False\n\n    def __post_init__(self) -&gt; None:\n\"\"\"\n        Validate dataclass arguments at end of initialization\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliValueError: if invalid channel_log_mode provided\n\n        \"\"\"\n        if self.channel_log_mode.lower() not in (\n            \"write\",\n            \"append\",\n        ):\n            raise ScrapliValueError(\n                f\"provided channel_log_mode '{self.channel_log_mode}' is not valid, mode must be \"\n                f\"one of: 'write', 'append'\"\n            )\n\n        if self.channel_log_mode.lower() == \"write\":\n            self.channel_log_mode = \"w\"\n        else:\n            self.channel_log_mode = \"a\"\n</code></pre>"},{"location":"reference/channel/base_channel/#channel.base_channel.BaseChannelArgs.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"<p>Validate dataclass arguments at end of initialization</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if invalid channel_log_mode provided</p> Source code in <code>channel/base_channel.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"\n    Validate dataclass arguments at end of initialization\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliValueError: if invalid channel_log_mode provided\n\n    \"\"\"\n    if self.channel_log_mode.lower() not in (\n        \"write\",\n        \"append\",\n    ):\n        raise ScrapliValueError(\n            f\"provided channel_log_mode '{self.channel_log_mode}' is not valid, mode must be \"\n            f\"one of: 'write', 'append'\"\n        )\n\n    if self.channel_log_mode.lower() == \"write\":\n        self.channel_log_mode = \"w\"\n    else:\n        self.channel_log_mode = \"a\"\n</code></pre>"},{"location":"reference/channel/sync_channel/","title":"sync_channel","text":"<p>scrapli.channel.sync_channel</p>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel","title":"<code>Channel</code>","text":"<p>         Bases: <code>BaseChannel</code></p> Source code in <code>channel/sync_channel.py</code> <pre><code>class Channel(BaseChannel):\n    def __init__(\n        self,\n        transport: Transport,\n        base_channel_args: BaseChannelArgs,\n    ) -&gt; None:\n        super().__init__(\n            transport=transport,\n            base_channel_args=base_channel_args,\n        )\n        self.transport: Transport\n\n        self.channel_lock: Optional[Lock] = None\n        if self._base_channel_args.channel_lock:\n            self.channel_lock = Lock()\n\n    @contextmanager\n    def _channel_lock(self) -&gt; Iterator[None]:\n\"\"\"\n        Lock the channel during public channel operations if channel_lock is enabled\n\n        Args:\n            N/A\n\n        Yields:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.channel_lock:\n            with self.channel_lock:\n                yield\n        else:\n            yield\n\n    def read(self) -&gt; bytes:\n\"\"\"\n        Read chunks of output from the channel\n\n        Replaces any r\"\\r\" characters that sometimes get stuffed into the output from the devices\n\n        Args:\n            N/A\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = self.transport.read()\n        buf = buf.replace(b\"\\r\", b\"\")\n\n        self.logger.debug(f\"read: {buf!r}\")\n\n        if self.channel_log:\n            self.channel_log.write(buf)\n\n        if b\"\\x1b\" in buf.lower():\n            buf = self._strip_ansi(buf=buf)\n\n        return buf\n\n    def _read_until_input(self, channel_input: bytes) -&gt; bytes:\n\"\"\"\n        Read until all channel_input has been read on the channel\n\n        Args:\n            channel_input: bytes that should have been written to the channel\n\n        Returns:\n            bytes: output read from channel while checking for the input in the channel stream\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = b\"\"\n\n        if not channel_input:\n            return buf\n\n        # squish all channel input words together and cast to lower to make comparison easier\n        processed_channel_input = b\"\".join(channel_input.lower().split())\n\n        while True:\n            buf += self.read()\n\n            # replace any backspace chars (particular problem w/ junos), and remove any added spaces\n            # this is just for comparison of the inputs to what was read from channel\n            if processed_channel_input in b\"\".join(buf.lower().replace(b\"\\x08\", b\"\").split()):\n                return buf\n\n    def _read_until_prompt(self, buf: bytes = b\"\") -&gt; bytes:\n\"\"\"\n        Read until expected prompt is seen.\n\n        This reads until the \"normal\" `_base_channel_args.comms_prompt_pattern` is seen. The\n        `_read_until_explicit_prompt` method can be used to read until some pattern in an arbitrary\n        list of patterns is seen.\n\n        Args:\n            buf: output from previous reads if needed (used by scrapli netconf)\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        search_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern\n        )\n\n        read_buf = BytesIO(buf)\n\n        while True:\n            read_buf.write(self.read())\n\n            search_buf = self._process_read_buf(read_buf=read_buf)\n\n            channel_match = re.search(\n                pattern=search_pattern,\n                string=search_buf,\n            )\n\n            if channel_match:\n                return read_buf.getvalue()\n\n    def _read_until_explicit_prompt(self, prompts: List[str]) -&gt; bytes:\n\"\"\"\n        Read until expected prompt is seen.\n\n        This method is for *explicit* prompt patterns instead of the \"standard\" prompt patterns\n        contained in the `_base_channel_args.comms_prompt_pattern` attribute. Generally this is\n        only used for `send_interactive` though it could be used elsewhere as well.\n\n        Args:\n            prompts: list of prompt patterns to look for, will return upon seeing any match\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        search_patterns = [\n            self._get_prompt_pattern(\n                class_pattern=self._base_channel_args.comms_prompt_pattern, pattern=prompt\n            )\n            for prompt in prompts\n        ]\n\n        read_buf = BytesIO(b\"\")\n\n        while True:\n            read_buf.write(self.read())\n\n            search_buf = self._process_read_buf(read_buf=read_buf)\n\n            for search_pattern in search_patterns:\n                channel_match = re.search(\n                    pattern=search_pattern,\n                    string=search_buf,\n                )\n\n                if channel_match:\n                    return read_buf.getvalue()\n\n    def _read_until_prompt_or_time(\n        self,\n        buf: bytes = b\"\",\n        channel_outputs: Optional[List[bytes]] = None,\n        read_duration: Optional[float] = None,\n    ) -&gt; bytes:\n\"\"\"\n        Read until expected prompt is seen, outputs are seen, for duration, whichever comes first.\n\n        As transport reading may block, transport timeout is temporarily set to the read_duration\n        and any `ScrapliTimeout` that is raised while reading is ignored.\n\n        Args:\n            buf: bytes from previous reads if needed\n            channel_outputs: List of bytes to search for in channel output, if any are seen, return\n                read output\n            read_duration: duration to read from channel for\n\n        Returns:\n            bytes: output read from channel\n\n        Raises:\n            N/A\n\n        \"\"\"\n        search_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern,\n        )\n\n        if channel_outputs is None:\n            channel_outputs = []\n        if read_duration is None:\n            read_duration = 2.5\n\n        regex_channel_outputs_pattern = self._join_and_compile(channel_outputs=channel_outputs)\n\n        _transport_args = self.transport._base_transport_args  # pylint: disable=W0212\n        previous_timeout_transport = _transport_args.timeout_transport\n        _transport_args.timeout_transport = int(read_duration)\n\n        read_buf = BytesIO(buf)\n\n        start = time.time()\n        while True:\n            with suppress(ScrapliTimeout):\n                read_buf.write(self.read())\n\n            search_buf = self._process_read_buf(read_buf=read_buf)\n\n            if (time.time() - start) &gt; read_duration:\n                break\n            if any((channel_output in search_buf for channel_output in channel_outputs)):\n                break\n            if re.search(pattern=regex_channel_outputs_pattern, string=search_buf):\n                break\n            if re.search(pattern=search_pattern, string=search_buf):\n                break\n\n        _transport_args.timeout_transport = previous_timeout_transport\n\n        return read_buf.getvalue()\n\n    @timeout_wrapper\n    def channel_authenticate_ssh(\n        self, auth_password: str, auth_private_key_passphrase: str\n    ) -&gt; None:\n\"\"\"\n        Handle SSH Authentication for transports that only operate \"in the channel\" (i.e. system)\n\n        Args:\n            auth_password: password to authenticate with\n            auth_private_key_passphrase: passphrase for ssh key if necessary\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliAuthenticationFailed: if password prompt seen more than twice\n            ScrapliAuthenticationFailed: if passphrase prompt seen more than twice\n\n        \"\"\"\n        self.logger.debug(\"attempting in channel ssh authentication\")\n\n        password_count = 0\n        passphrase_count = 0\n        authenticate_buf = b\"\"\n\n        (\n            password_pattern,\n            passphrase_pattern,\n            prompt_pattern,\n        ) = self._pre_channel_authenticate_ssh()\n\n        with self._channel_lock():\n            while True:\n                buf = self.read()\n                authenticate_buf += buf.lower()\n\n                self._ssh_message_handler(output=authenticate_buf)\n\n                if re.search(\n                    pattern=password_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the password prompt\n                    authenticate_buf = b\"\"\n                    password_count += 1\n                    if password_count &gt; 2:\n                        msg = \"password prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_password, redacted=True)\n                    self.send_return()\n\n                if re.search(\n                    pattern=passphrase_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the passphrase prompt\n                    authenticate_buf = b\"\"\n                    passphrase_count += 1\n                    if passphrase_count &gt; 2:\n                        msg = \"passphrase prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_private_key_passphrase, redacted=True)\n                    self.send_return()\n\n                if re.search(\n                    pattern=prompt_pattern,\n                    string=authenticate_buf,\n                ):\n                    return\n\n    @timeout_wrapper\n    def channel_authenticate_telnet(  # noqa: c901\n        self, auth_username: str = \"\", auth_password: str = \"\"\n    ) -&gt; None:\n\"\"\"\n        Handle Telnet Authentication\n\n        Args:\n            auth_username: username to use for telnet authentication\n            auth_password: password to use for telnet authentication\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliAuthenticationFailed: if password prompt seen more than twice\n            ScrapliAuthenticationFailed: if login prompt seen more than twice\n\n        \"\"\"\n        self.logger.debug(\"attempting in channel telnet authentication\")\n\n        username_count = 0\n        password_count = 0\n        authenticate_buf = b\"\"\n\n        (\n            username_pattern,\n            password_pattern,\n            prompt_pattern,\n            auth_start_time,\n            return_interval,\n        ) = self._pre_channel_authenticate_telnet()\n\n        return_attempts = 1\n\n        with self._channel_lock():\n            while True:\n                try:\n                    buf = self.read()\n                except ScrapliConnectionError:\n                    # telnet transport socket can send us an EOF which gets raised as a connection\n                    # error, if we see that we can try to send a return and go back to the top...\n                    # this first cropped up with telnet on asa devices in:\n                    # https://github.com/carlmontanari/scrapli/issues/278\n                    self.send_return()\n                    return_attempts += 1\n                    continue\n\n                if not buf:\n                    current_iteration_time = datetime.now().timestamp()\n                    if (current_iteration_time - auth_start_time) &gt; (\n                        return_interval * return_attempts\n                    ):\n                        self.send_return()\n                        return_attempts += 1\n\n                authenticate_buf += buf.lower()\n\n                if re.search(\n                    pattern=username_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the username prompt\n                    authenticate_buf = b\"\"\n                    username_count += 1\n                    if username_count &gt; 2:\n                        msg = \"username/login prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_username)\n                    self.send_return()\n\n                if re.search(\n                    pattern=password_pattern,\n                    string=authenticate_buf,\n                ):\n                    # clear the authentication buffer so we don't re-read the password prompt\n                    authenticate_buf = b\"\"\n                    password_count += 1\n                    if password_count &gt; 2:\n                        msg = \"password prompt seen more than once, assuming auth failed\"\n                        self.logger.critical(msg)\n                        raise ScrapliAuthenticationFailed(msg)\n                    self.write(channel_input=auth_password, redacted=True)\n                    self.send_return()\n\n                if re.search(\n                    pattern=prompt_pattern,\n                    string=authenticate_buf,\n                ):\n                    return\n\n    @timeout_wrapper\n    def get_prompt(self) -&gt; str:\n\"\"\"\n        Get current channel prompt\n\n        Args:\n            N/A\n\n        Returns:\n            str: string of the current prompt\n\n        Raises:\n            N/A\n\n        \"\"\"\n        buf = b\"\"\n\n        search_pattern = self._get_prompt_pattern(\n            class_pattern=self._base_channel_args.comms_prompt_pattern\n        )\n\n        with self._channel_lock():\n            self.send_return()\n\n            while True:\n                buf += self.read()\n\n                channel_match = re.search(\n                    pattern=search_pattern,\n                    string=buf,\n                )\n\n                if channel_match:\n                    current_prompt = channel_match.group(0)\n                    return current_prompt.decode().strip()\n\n    @timeout_wrapper\n    def send_input(\n        self,\n        channel_input: str,\n        *,\n        strip_prompt: bool = True,\n        eager: bool = False,\n    ) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n        Primary entry point to send data to devices in shell mode; accept input and returns result\n\n        Args:\n            channel_input: string input to send to channel\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            eager: eager mode reads and returns the `_read_until_input` value, but does not attempt\n                to read to the prompt pattern -- this should not be used manually! (only used by\n                `send_configs` with the eager flag set)\n\n        Returns:\n            Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_send_input(channel_input=channel_input)\n\n        buf = b\"\"\n        bytes_channel_input = channel_input.encode()\n\n        self.logger.info(\n            f\"sending channel input: {channel_input}; strip_prompt: {strip_prompt}; eager: {eager}\"\n        )\n\n        with self._channel_lock():\n            self.write(channel_input=channel_input)\n            _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)\n            self.send_return()\n\n            if not eager:\n                buf += self._read_until_prompt()\n\n        processed_buf = self._process_output(\n            buf=buf,\n            strip_prompt=strip_prompt,\n        )\n        return buf, processed_buf\n\n    @timeout_wrapper\n    def send_input_and_read(\n        self,\n        channel_input: str,\n        *,\n        strip_prompt: bool = True,\n        expected_outputs: Optional[List[str]] = None,\n        read_duration: Optional[float] = None,\n    ) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n        Send a command and read until expected prompt is seen, outputs are seen, or for duration\n\n        Args:\n            channel_input: string input to send to channel\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            expected_outputs: list of strings to look for in output; if any of these are seen,\n                return output read up till that read\n            read_duration: float duration to read for\n\n        Returns:\n            Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_send_input(channel_input=channel_input)\n\n        buf = b\"\"\n        bytes_channel_input = channel_input.encode()\n        bytes_channel_outputs = [\n            channel_output.encode() for channel_output in expected_outputs or []\n        ]\n\n        self.logger.info(\n            f\"sending channel input and read: {channel_input}; strip_prompt: {strip_prompt}; \"\n            f\"expected_outputs: {expected_outputs}; read_duration: {read_duration}\"\n        )\n\n        with self._channel_lock():\n            self.write(channel_input=channel_input)\n            _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)\n            self.send_return()\n\n            buf += self._read_until_prompt_or_time(\n                channel_outputs=bytes_channel_outputs, read_duration=read_duration\n            )\n\n        processed_buf = self._process_output(\n            buf=buf,\n            strip_prompt=strip_prompt,\n        )\n\n        return buf, processed_buf\n\n    @timeout_wrapper\n    def send_inputs_interact(\n        self,\n        interact_events: List[Tuple[str, str, Optional[bool]]],\n        *,\n        interaction_complete_patterns: Optional[List[str]] = None,\n    ) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n        Interact with a device with changing prompts per input.\n\n        Used to interact with devices where prompts change per input, and where inputs may be hidden\n        such as in the case of a password input. This can be used to respond to challenges from\n        devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n        example. You may have as many elements in the \"interact_events\" list as needed, and each\n        element of that list should be a tuple of two or three elements. The first element is always\n        the input to send as a string, the second should be the expected response as a string, and\n        the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n        An example where we need this sort of capability:\n\n        '''\n        3560CX#copy flash: scp:\n        Source filename []? test1.txt\n        Address or name of remote host []? 172.31.254.100\n        Destination username [carl]?\n        Writing test1.txt\n        Password:\n\n        Password:\n         Sink: C0644 639 test1.txt\n        !\n        639 bytes copied in 12.066 secs (53 bytes/sec)\n        3560CX#\n        '''\n\n        To accomplish this we can use the following:\n\n        '''\n        interact = conn.channel.send_inputs_interact(\n            [\n                (\"copy flash: scp:\", \"Source filename []?\", False),\n                (\"test1.txt\", \"Address or name of remote host []?\", False),\n                (\"172.31.254.100\", \"Destination username [carl]?\", False),\n                (\"carl\", \"Password:\", False),\n                (\"super_secure_password\", prompt, True),\n            ]\n        )\n        '''\n\n        If we needed to deal with more prompts we could simply continue adding tuples to the list of\n        interact \"events\".\n\n        Args:\n            interact_events: list of tuples containing the \"interactions\" with the device\n                each list element must have an input and an expected response, and may have an\n                optional bool for the third and final element -- the optional bool specifies if the\n                input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n                not provided it is assumed the input is \"normal\" (not hidden)\n            interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n                \"session\" has ended and we should exit the interactive session.\n\n        Returns:\n            Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning,\n                and the output read from the channel that has been \"cleaned up\"\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_send_inputs_interact(interact_events=interact_events)\n\n        buf = b\"\"\n        processed_buf = b\"\"\n\n        with self._channel_lock():\n            for interact_event in interact_events:\n                channel_input = interact_event[0]\n                bytes_channel_input = channel_input.encode()\n                channel_response = interact_event[1]\n                prompts = [channel_response]\n\n                if interaction_complete_patterns is not None:\n                    prompts.extend(interaction_complete_patterns)\n\n                try:\n                    hidden_input = interact_event[2]\n                except IndexError:\n                    hidden_input = False\n\n                _channel_input = channel_input if not hidden_input else \"REDACTED\"\n                self.logger.info(\n                    f\"sending interactive input: {_channel_input}; \"\n                    f\"expecting: {channel_response}; \"\n                    f\"hidden_input: {hidden_input}\"\n                )\n\n                self.write(channel_input=channel_input, redacted=bool(hidden_input))\n                if channel_response and hidden_input is not True:\n                    buf += self._read_until_input(channel_input=bytes_channel_input)\n                self.send_return()\n                buf += self._read_until_explicit_prompt(prompts=prompts)\n\n        processed_buf += self._process_output(\n            buf=buf,\n            strip_prompt=False,\n        )\n\n        return buf, processed_buf\n</code></pre>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel.channel_authenticate_ssh","title":"<code>channel_authenticate_ssh(auth_password: str, auth_private_key_passphrase: str) -&gt; None</code>","text":"<p>Handle SSH Authentication for transports that only operate \"in the channel\" (i.e. system)</p> <p>Parameters:</p> Name Type Description Default <code>auth_password</code> <code>str</code> <p>password to authenticate with</p> required <code>auth_private_key_passphrase</code> <code>str</code> <p>passphrase for ssh key if necessary</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliAuthenticationFailed</code> <p>if password prompt seen more than twice</p> <code>ScrapliAuthenticationFailed</code> <p>if passphrase prompt seen more than twice</p> Source code in <code>channel/sync_channel.py</code> <pre><code>@timeout_wrapper\ndef channel_authenticate_ssh(\n    self, auth_password: str, auth_private_key_passphrase: str\n) -&gt; None:\n\"\"\"\n    Handle SSH Authentication for transports that only operate \"in the channel\" (i.e. system)\n\n    Args:\n        auth_password: password to authenticate with\n        auth_private_key_passphrase: passphrase for ssh key if necessary\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliAuthenticationFailed: if password prompt seen more than twice\n        ScrapliAuthenticationFailed: if passphrase prompt seen more than twice\n\n    \"\"\"\n    self.logger.debug(\"attempting in channel ssh authentication\")\n\n    password_count = 0\n    passphrase_count = 0\n    authenticate_buf = b\"\"\n\n    (\n        password_pattern,\n        passphrase_pattern,\n        prompt_pattern,\n    ) = self._pre_channel_authenticate_ssh()\n\n    with self._channel_lock():\n        while True:\n            buf = self.read()\n            authenticate_buf += buf.lower()\n\n            self._ssh_message_handler(output=authenticate_buf)\n\n            if re.search(\n                pattern=password_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the password prompt\n                authenticate_buf = b\"\"\n                password_count += 1\n                if password_count &gt; 2:\n                    msg = \"password prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_password, redacted=True)\n                self.send_return()\n\n            if re.search(\n                pattern=passphrase_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the passphrase prompt\n                authenticate_buf = b\"\"\n                passphrase_count += 1\n                if passphrase_count &gt; 2:\n                    msg = \"passphrase prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_private_key_passphrase, redacted=True)\n                self.send_return()\n\n            if re.search(\n                pattern=prompt_pattern,\n                string=authenticate_buf,\n            ):\n                return\n</code></pre>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel.channel_authenticate_telnet","title":"<code>channel_authenticate_telnet(auth_username: str = '', auth_password: str = '') -&gt; None</code>","text":"<p>Handle Telnet Authentication</p> <p>Parameters:</p> Name Type Description Default <code>auth_username</code> <code>str</code> <p>username to use for telnet authentication</p> <code>''</code> <code>auth_password</code> <code>str</code> <p>password to use for telnet authentication</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliAuthenticationFailed</code> <p>if password prompt seen more than twice</p> <code>ScrapliAuthenticationFailed</code> <p>if login prompt seen more than twice</p> Source code in <code>channel/sync_channel.py</code> <pre><code>@timeout_wrapper\ndef channel_authenticate_telnet(  # noqa: c901\n    self, auth_username: str = \"\", auth_password: str = \"\"\n) -&gt; None:\n\"\"\"\n    Handle Telnet Authentication\n\n    Args:\n        auth_username: username to use for telnet authentication\n        auth_password: password to use for telnet authentication\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliAuthenticationFailed: if password prompt seen more than twice\n        ScrapliAuthenticationFailed: if login prompt seen more than twice\n\n    \"\"\"\n    self.logger.debug(\"attempting in channel telnet authentication\")\n\n    username_count = 0\n    password_count = 0\n    authenticate_buf = b\"\"\n\n    (\n        username_pattern,\n        password_pattern,\n        prompt_pattern,\n        auth_start_time,\n        return_interval,\n    ) = self._pre_channel_authenticate_telnet()\n\n    return_attempts = 1\n\n    with self._channel_lock():\n        while True:\n            try:\n                buf = self.read()\n            except ScrapliConnectionError:\n                # telnet transport socket can send us an EOF which gets raised as a connection\n                # error, if we see that we can try to send a return and go back to the top...\n                # this first cropped up with telnet on asa devices in:\n                # https://github.com/carlmontanari/scrapli/issues/278\n                self.send_return()\n                return_attempts += 1\n                continue\n\n            if not buf:\n                current_iteration_time = datetime.now().timestamp()\n                if (current_iteration_time - auth_start_time) &gt; (\n                    return_interval * return_attempts\n                ):\n                    self.send_return()\n                    return_attempts += 1\n\n            authenticate_buf += buf.lower()\n\n            if re.search(\n                pattern=username_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the username prompt\n                authenticate_buf = b\"\"\n                username_count += 1\n                if username_count &gt; 2:\n                    msg = \"username/login prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_username)\n                self.send_return()\n\n            if re.search(\n                pattern=password_pattern,\n                string=authenticate_buf,\n            ):\n                # clear the authentication buffer so we don't re-read the password prompt\n                authenticate_buf = b\"\"\n                password_count += 1\n                if password_count &gt; 2:\n                    msg = \"password prompt seen more than once, assuming auth failed\"\n                    self.logger.critical(msg)\n                    raise ScrapliAuthenticationFailed(msg)\n                self.write(channel_input=auth_password, redacted=True)\n                self.send_return()\n\n            if re.search(\n                pattern=prompt_pattern,\n                string=authenticate_buf,\n            ):\n                return\n</code></pre>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel.get_prompt","title":"<code>get_prompt() -&gt; str</code>","text":"<p>Get current channel prompt</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string of the current prompt</p> Source code in <code>channel/sync_channel.py</code> <pre><code>@timeout_wrapper\ndef get_prompt(self) -&gt; str:\n\"\"\"\n    Get current channel prompt\n\n    Args:\n        N/A\n\n    Returns:\n        str: string of the current prompt\n\n    Raises:\n        N/A\n\n    \"\"\"\n    buf = b\"\"\n\n    search_pattern = self._get_prompt_pattern(\n        class_pattern=self._base_channel_args.comms_prompt_pattern\n    )\n\n    with self._channel_lock():\n        self.send_return()\n\n        while True:\n            buf += self.read()\n\n            channel_match = re.search(\n                pattern=search_pattern,\n                string=buf,\n            )\n\n            if channel_match:\n                current_prompt = channel_match.group(0)\n                return current_prompt.decode().strip()\n</code></pre>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel.read","title":"<code>read() -&gt; bytes</code>","text":"<p>Read chunks of output from the channel</p> <p>Replaces any r\" \" characters that sometimes get stuffed into the output from the devices</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output read from channel</p> Source code in <code>channel/sync_channel.py</code> <pre><code>def read(self) -&gt; bytes:\n\"\"\"\n    Read chunks of output from the channel\n\n    Replaces any r\"\\r\" characters that sometimes get stuffed into the output from the devices\n\n    Args:\n        N/A\n\n    Returns:\n        bytes: output read from channel\n\n    Raises:\n        N/A\n\n    \"\"\"\n    buf = self.transport.read()\n    buf = buf.replace(b\"\\r\", b\"\")\n\n    self.logger.debug(f\"read: {buf!r}\")\n\n    if self.channel_log:\n        self.channel_log.write(buf)\n\n    if b\"\\x1b\" in buf.lower():\n        buf = self._strip_ansi(buf=buf)\n\n    return buf\n</code></pre>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel.send_input","title":"<code>send_input(channel_input: str, *, strip_prompt: bool = True, eager: bool = False) -&gt; Tuple[bytes, bytes]</code>","text":"<p>Primary entry point to send data to devices in shell mode; accept input and returns result</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>str</code> <p>string input to send to channel</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>eager</code> <code>bool</code> <p>eager mode reads and returns the <code>_read_until_input</code> value, but does not attempt to read to the prompt pattern -- this should not be used manually! (only used by <code>send_configs</code> with the eager flag set)</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output</p> Source code in <code>channel/sync_channel.py</code> <pre><code>@timeout_wrapper\ndef send_input(\n    self,\n    channel_input: str,\n    *,\n    strip_prompt: bool = True,\n    eager: bool = False,\n) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n    Primary entry point to send data to devices in shell mode; accept input and returns result\n\n    Args:\n        channel_input: string input to send to channel\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        eager: eager mode reads and returns the `_read_until_input` value, but does not attempt\n            to read to the prompt pattern -- this should not be used manually! (only used by\n            `send_configs` with the eager flag set)\n\n    Returns:\n        Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_send_input(channel_input=channel_input)\n\n    buf = b\"\"\n    bytes_channel_input = channel_input.encode()\n\n    self.logger.info(\n        f\"sending channel input: {channel_input}; strip_prompt: {strip_prompt}; eager: {eager}\"\n    )\n\n    with self._channel_lock():\n        self.write(channel_input=channel_input)\n        _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)\n        self.send_return()\n\n        if not eager:\n            buf += self._read_until_prompt()\n\n    processed_buf = self._process_output(\n        buf=buf,\n        strip_prompt=strip_prompt,\n    )\n    return buf, processed_buf\n</code></pre>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel.send_input_and_read","title":"<code>send_input_and_read(channel_input: str, *, strip_prompt: bool = True, expected_outputs: Optional[List[str]] = None, read_duration: Optional[float] = None) -&gt; Tuple[bytes, bytes]</code>","text":"<p>Send a command and read until expected prompt is seen, outputs are seen, or for duration</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>str</code> <p>string input to send to channel</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>expected_outputs</code> <code>Optional[List[str]]</code> <p>list of strings to look for in output; if any of these are seen, return output read up till that read</p> <code>None</code> <code>read_duration</code> <code>Optional[float]</code> <p>float duration to read for</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output</p> Source code in <code>channel/sync_channel.py</code> <pre><code>@timeout_wrapper\ndef send_input_and_read(\n    self,\n    channel_input: str,\n    *,\n    strip_prompt: bool = True,\n    expected_outputs: Optional[List[str]] = None,\n    read_duration: Optional[float] = None,\n) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n    Send a command and read until expected prompt is seen, outputs are seen, or for duration\n\n    Args:\n        channel_input: string input to send to channel\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        expected_outputs: list of strings to look for in output; if any of these are seen,\n            return output read up till that read\n        read_duration: float duration to read for\n\n    Returns:\n        Tuple[bytes, bytes]: tuple of \"raw\" output and \"processed\" (cleaned up/stripped) output\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_send_input(channel_input=channel_input)\n\n    buf = b\"\"\n    bytes_channel_input = channel_input.encode()\n    bytes_channel_outputs = [\n        channel_output.encode() for channel_output in expected_outputs or []\n    ]\n\n    self.logger.info(\n        f\"sending channel input and read: {channel_input}; strip_prompt: {strip_prompt}; \"\n        f\"expected_outputs: {expected_outputs}; read_duration: {read_duration}\"\n    )\n\n    with self._channel_lock():\n        self.write(channel_input=channel_input)\n        _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)\n        self.send_return()\n\n        buf += self._read_until_prompt_or_time(\n            channel_outputs=bytes_channel_outputs, read_duration=read_duration\n        )\n\n    processed_buf = self._process_output(\n        buf=buf,\n        strip_prompt=strip_prompt,\n    )\n\n    return buf, processed_buf\n</code></pre>"},{"location":"reference/channel/sync_channel/#channel.sync_channel.Channel.send_inputs_interact","title":"<code>send_inputs_interact(interact_events: List[Tuple[str, str, Optional[bool]]], *, interaction_complete_patterns: Optional[List[str]] = None) -&gt; Tuple[bytes, bytes]</code>","text":"<p>Interact with a device with changing prompts per input.</p> <p>Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)</p> <p>An example where we need this sort of capability:</p> <p>''' 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password:</p> Password <p>Sink: C0644 639 test1.txt</p> <p>! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# '''</p> <p>To accomplish this we can use the following:</p> <p>''' interact = conn.channel.send_inputs_interact(     [         (\"copy flash: scp:\", \"Source filename []?\", False),         (\"test1.txt\", \"Address or name of remote host []?\", False),         (\"172.31.254.100\", \"Destination username [carl]?\", False),         (\"carl\", \"Password:\", False),         (\"super_secure_password\", prompt, True),     ] ) '''</p> <p>If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\".</p> <p>Parameters:</p> Name Type Description Default <code>interact_events</code> <code>List[Tuple[str, str, Optional[bool]]]</code> <p>list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden)</p> required <code>interaction_complete_patterns</code> <code>Optional[List[str]]</code> <p>list of patterns, that if seen, indicate the interactive \"session\" has ended and we should exit the interactive session.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning, and the output read from the channel that has been \"cleaned up\"</p> Source code in <code>channel/sync_channel.py</code> <pre><code>@timeout_wrapper\ndef send_inputs_interact(\n    self,\n    interact_events: List[Tuple[str, str, Optional[bool]]],\n    *,\n    interaction_complete_patterns: Optional[List[str]] = None,\n) -&gt; Tuple[bytes, bytes]:\n\"\"\"\n    Interact with a device with changing prompts per input.\n\n    Used to interact with devices where prompts change per input, and where inputs may be hidden\n    such as in the case of a password input. This can be used to respond to challenges from\n    devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n    example. You may have as many elements in the \"interact_events\" list as needed, and each\n    element of that list should be a tuple of two or three elements. The first element is always\n    the input to send as a string, the second should be the expected response as a string, and\n    the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n    An example where we need this sort of capability:\n\n    '''\n    3560CX#copy flash: scp:\n    Source filename []? test1.txt\n    Address or name of remote host []? 172.31.254.100\n    Destination username [carl]?\n    Writing test1.txt\n    Password:\n\n    Password:\n     Sink: C0644 639 test1.txt\n    !\n    639 bytes copied in 12.066 secs (53 bytes/sec)\n    3560CX#\n    '''\n\n    To accomplish this we can use the following:\n\n    '''\n    interact = conn.channel.send_inputs_interact(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"test1.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"carl\", \"Password:\", False),\n            (\"super_secure_password\", prompt, True),\n        ]\n    )\n    '''\n\n    If we needed to deal with more prompts we could simply continue adding tuples to the list of\n    interact \"events\".\n\n    Args:\n        interact_events: list of tuples containing the \"interactions\" with the device\n            each list element must have an input and an expected response, and may have an\n            optional bool for the third and final element -- the optional bool specifies if the\n            input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n            not provided it is assumed the input is \"normal\" (not hidden)\n        interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n            \"session\" has ended and we should exit the interactive session.\n\n    Returns:\n        Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning,\n            and the output read from the channel that has been \"cleaned up\"\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_send_inputs_interact(interact_events=interact_events)\n\n    buf = b\"\"\n    processed_buf = b\"\"\n\n    with self._channel_lock():\n        for interact_event in interact_events:\n            channel_input = interact_event[0]\n            bytes_channel_input = channel_input.encode()\n            channel_response = interact_event[1]\n            prompts = [channel_response]\n\n            if interaction_complete_patterns is not None:\n                prompts.extend(interaction_complete_patterns)\n\n            try:\n                hidden_input = interact_event[2]\n            except IndexError:\n                hidden_input = False\n\n            _channel_input = channel_input if not hidden_input else \"REDACTED\"\n            self.logger.info(\n                f\"sending interactive input: {_channel_input}; \"\n                f\"expecting: {channel_response}; \"\n                f\"hidden_input: {hidden_input}\"\n            )\n\n            self.write(channel_input=channel_input, redacted=bool(hidden_input))\n            if channel_response and hidden_input is not True:\n                buf += self._read_until_input(channel_input=bytes_channel_input)\n            self.send_return()\n            buf += self._read_until_explicit_prompt(prompts=prompts)\n\n    processed_buf += self._process_output(\n        buf=buf,\n        strip_prompt=False,\n    )\n\n    return buf, processed_buf\n</code></pre>"},{"location":"reference/driver/","title":"driver","text":"<p>scrapli.driver</p>"},{"location":"reference/driver/base/","title":"base","text":"<p>scrapli.driver.base</p>"},{"location":"reference/driver/base/async_driver/","title":"async_driver","text":"<p>scrapli.driver.base.async_driver</p>"},{"location":"reference/driver/base/async_driver/#driver.base.async_driver.AsyncDriver","title":"<code>AsyncDriver</code>","text":"<p>         Bases: <code>BaseDriver</code></p> Source code in <code>driver/base/async_driver.py</code> <pre><code>class AsyncDriver(BaseDriver):\n    def __init__(self, **kwargs: Any):\n        super().__init__(**kwargs)\n\n        if self.transport_name not in ASYNCIO_TRANSPORTS:\n            raise ScrapliValueError(\n                \"provided transport is *not* an asyncio transport, must use an async transport with\"\n                \" the AsyncDriver(s)\"\n            )\n\n        self.channel = AsyncChannel(\n            transport=self.transport,\n            base_channel_args=self._base_channel_args,\n        )\n\n    async def __aenter__(self: _T) -&gt; _T:\n\"\"\"\n        Enter method for context manager\n\n        Args:\n            N/A\n\n        Returns:\n            _T: a concrete implementation of the opened AsyncDriver object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.open()\n        return self\n\n    async def __aexit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n\"\"\"\n        Exit method to cleanup for context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.close()\n\n    async def open(self) -&gt; None:\n\"\"\"\n        Open the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_open_closing_log(closing=False)\n\n        await self.transport.open()\n        self.channel.open()\n\n        if (\n            self.transport_name\n            in (\n                \"telnet\",\n                \"asynctelnet\",\n            )\n            and not self.auth_bypass\n        ):\n            await self.channel.channel_authenticate_telnet(\n                auth_username=self.auth_username, auth_password=self.auth_password\n            )\n\n        if self.on_open:\n            await self.on_open(self)\n\n        self._post_open_closing_log(closing=False)\n\n    async def close(self) -&gt; None:\n\"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._post_open_closing_log(closing=True)\n\n        if self.on_close:\n            await self.on_close(self)\n\n        self.transport.close()\n        self.channel.close()\n\n        self._post_open_closing_log(closing=True)\n\n    async def commandeer(self, conn: \"AsyncDriver\", execute_on_open: bool = True) -&gt; None:\n\"\"\"\n        Commandeer an existing connection\n\n        See docstring in sync version for more details: `scrapli.driver.base.sync_driver.commandeer`\n\n        Args:\n            conn: connection to commandeer\n            execute_on_open: execute the `on_open` function of the current object once the existing\n                connection has been commandeered\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        original_logger = conn.logger\n        original_transport = conn.transport\n        original_transport_logger = conn.transport.logger\n        original_channel_logger = conn.channel.logger\n        original_channel_channel_log = conn.channel.channel_log\n\n        self.logger = original_logger\n        self.channel.logger = original_channel_logger\n        self.channel.transport = original_transport\n        self.transport = original_transport\n        self.transport.logger = original_transport_logger\n\n        if original_channel_channel_log is not None:\n            # if the original connection had a channel log we also commandeer that; note that when\n            # the new connection is closed this will also close the channel log; see docstring.\n            self.channel.channel_log = original_channel_channel_log\n\n        if execute_on_open and self.on_open is not None:\n            await self.on_open(self)\n\n    @staticmethod\n    def ___getwide___() -&gt; None:  # pragma: no cover\n\"\"\"\n        Dumb inside joke easter egg :)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        wide = r\"\"\"\nKKKXXXXXXXXXXNNNNNNNNNNNNNNNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n000000000000KKKKKKKKKKXXXXXXXXXXXXXXXXXNNXXK0Okxdoolllloodxk0KXNNWWNWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNNN\nkkkkkkkOOOOOOOOOOO00000000000000000000kdl:,...              ..';coxOKKKKKKKKKKKKXKKXXKKKXXXXXKKKK000\nkkkkkkkOOOOOOOOOOOO000000000000000Od:,.                            .,cdOKKKKKKKKKKKK0000OOOOOOOOOOOO\nkkkkkkkkOOOOOOOOOOO0000000000000kc'                                    .:d0KKKKKKKKK0KKOkOOOOOOOOOO0\nkkkkkkkkOOOOOOOOOOOO00000000000o'                                         ,o0KKKKKKKKKKOkOOOOOOOOO00\nkkkkkkkkOOOOOOOOOOOOO000000000o.                                            ;kKKKKKKKKKOkOOOOOOOOO00\nOOOOOOOOOO0000000000000000K0Kk'                                              'xKKKKKKKKOkOOOOOOOOO00\nKKKKKKKKKXXXXXXXXXXXXXXNNNNNNd.                                               cXNNNNNNNK0000O00O0000\nKKKKKKKKKXXXXXXXXXXXXNNNNNNNXl        ...............                         :XWWWWWWWX000000000000\nKKKKKKKKKXXXXXXXXXXXXXXNNNNNXc     ...''',,,,,,;;,,,,,,'''......             .xWWWWWWWWX000000000000\nKKKKKKKKKKKXXXXXXXXXXXXXNNNNK;    ...',,,,;;;;;;;:::::::;;;;;;,,'.          .oNWWWWWWWNK000000OOOO00\nKKKKKKKKKKKKXXXXXXXXXXXXXXXN0,  ...'',,,;;;;;;:::::::::::::::;;;;,'.       .dNWWWWWWWWNK0000OOOOOOOO\n0000KKKKKKKKKKKKKXXXXXXXXXXN0, ..'',,,,;;;;;;:::::::::::::::::;;;;,,..    ;ONNNNNWWWWWNK00OOOOOOOOOO\nkkkkkkOOOOOOOOOOOOOOOOOOO000k; ..,,,,,,'',,;;::::::::::::::::;;;;;;,'.  .lOKKKKXXKXXKK0OOOOOOOOOOOOO\nxxxkkkkkkkkkkkkkkkkkkOOOOkdll;..',,,,,,,''...';::ccccc:::::::::;;;;;,...o0000000000000OkkOOOkkOOOOOO\nxxxxxxkkkkkkkkkkkkkkkkkkOd:;;,..,;;;;;;;;;;,'',,;:ccccccccc:::;;;;;;,..cO0000000000000Oxkkkkkkkkkkkk\nxxxxxxxxkkkkkkkkkkkkkkkkkl:;;,'';;;;;,'''''',,,,,;::ccc::;,,'.'''',;,,lO00000000000000kxkkkkkkkkkkkk\nxxxxxxxxkkkkkkkkkkkkkkkkko::;'';;;;;;,''....,'',,,,;:c:;,,'''',,;;;;,:x00000000000000Okxkkkkkkkkkkkk\nxxxxxxxxxxkkkkkkkkkkkkkkkxl;,,;;;;:::;;;,,,,,,,,,,,,:c:;,'....''',;;,;cxO000000000000Okxkkkkkkkkkkkk\nkkkkOOOOOOOOOOOOOO00000000x:;;;;;:::c::::::;;;;;;;;;:c:;,,,,'',,',;:::lOKKKKKKXXXXXXKKOkkkkkkkkkkkkk\n000000000000000KKKKKKKKKKK0dc;,;;:::ccccccc::::;;;;;:cc:;;;;:::::::::lOXXXXXNNNNNNNNXX0Okkkkkkkkkkkk\nOO00000000000000000KKKKKKKK0d::;;;::ccccccccc:;;;;;;;:c:;::ccccccc::cOXXXXXXXXXNNNNNXX0kkkkkkkkkkkkk\nOOO00000000000000000000KKKKKOxxc;;;::ccccccc:;;;;;;;:ccc:::cccllcc;:kKXXXXXXXXXXXXXXXKOkkkkkkkkkkkkk\nOOOOO00000000000000000000KKK0kdl;;;;;:ccccc::;,,,,;;:clc:::cclllcc:oKXXXXXXXXXXXXXXXXKOkkkkkkkkkkkkk\nOOOOOOO0000000000000000Okxdlc;,,;;::;;::cc::;;,,,,,;:::;;:cccccc::clxkO00KKKKKKKKKXKK0kkkkkkkkkkkxkk\nkkkkkkkkkkkkkkkkkkkxdoc:,''.....,;:::;;;::;;;;;;;;;;;;;;;:ccc:::;,',;;:clodxkOOOOOOOOkxxxxxxxxxxxxxx\nddddddddddddddoolc;,'''..........,;;:;;;::;,,,,,;;;;;::::::c:::;'.',,;;;;;::clodxkkkkxdxxxxxxxxxxxxx\ndddddddoolc::;,'''.......      ..',;;;;;;;;,'........',;::::::;;,,;;;;;;;;:::::ccloddddxxxxxxxxxxxxx\ndollc:;,,''.........         ..'''',,,,;;;;;,'''.....'',::::;,,;;;::::;;,,;;;;;;;;;::cldxxxxxxdxxdxx\nl;'''.''......             ..'',,''',,,,;;;::;;,,,,,,;;::;;'.....',;;,,''',,,,,,'',,,',:odxddddddddd\n.............             .'',,,,,''',,,;;;;::::;::::::;;;........'''''''..'.....,,'...';cdddddddddd\n. .......                .',,,,,;,,'',,,,;;;::::::::::;;cc. .....''...'''.......','......':odxdddddd\n   ...                  .',,;;;;;;,'',;;,,,;;;::::::::;cxo....................''''.......'';lddddddd\n    ..                  .,;,;;;;;;,,,',;;;,,,,;;;;;;;;:dKO:..................''''.. .......',cdddddd\n                         ,:;;;;;,,,,;,,;::;,,,,,;::::::dK0c..................'''..  ........',codddd\n                         .;:;;;;;,,;;;,,;:;;:;,,;:::::clc,...   ...........'''.... ....  .....':oddd\n                          .',;;;;;;;;;,,;:;;;;,;::::::;'......       ......'.........   .....'',cood\n                            ..,;;;;;;;;;;;:;;;;:::::;'.    .         ..............       ...''',:od\n                              ..',;;;;:;;;:::::::,,'.              ...............        ....''.':o\n                                 ...',,;;,,;,,'..                 ...............        ..  .....'c\n               __              _     __....                      ................     ....   ......'\n   ____ ____  / /_   _      __(_)___/ /__                    ..............   ..    ...     .......\n  / __ `/ _ \\/ __/  | | /| / / / __  / _ \\                 ................    .             ......\n / /_/ /  __/ /_    | |/ |/ / / /_/ /  __/                .................                  ......\n \\__, /\\___/\\__/    |__/|__/_/\\__,_/\\___/                  ...............                   ......\n/____/                                                     ...............  ..             ........\n\"\"\"\n        print(wide)\n</code></pre>"},{"location":"reference/driver/base/async_driver/#driver.base.async_driver.AsyncDriver.___getwide___","title":"<code>___getwide___() -&gt; None</code>  <code>staticmethod</code>","text":"<p>Dumb inside joke easter egg :)</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/async_driver.py</code> <pre><code>    @staticmethod\n    def ___getwide___() -&gt; None:  # pragma: no cover\n\"\"\"\n        Dumb inside joke easter egg :)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        wide = r\"\"\"\nKKKXXXXXXXXXXNNNNNNNNNNNNNNNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n000000000000KKKKKKKKKKXXXXXXXXXXXXXXXXXNNXXK0Okxdoolllloodxk0KXNNWWNWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNNN\nkkkkkkkOOOOOOOOOOO00000000000000000000kdl:,...              ..';coxOKKKKKKKKKKKKXKKXXKKKXXXXXKKKK000\nkkkkkkkOOOOOOOOOOOO000000000000000Od:,.                            .,cdOKKKKKKKKKKKK0000OOOOOOOOOOOO\nkkkkkkkkOOOOOOOOOOO0000000000000kc'                                    .:d0KKKKKKKKK0KKOkOOOOOOOOOO0\nkkkkkkkkOOOOOOOOOOOO00000000000o'                                         ,o0KKKKKKKKKKOkOOOOOOOOO00\nkkkkkkkkOOOOOOOOOOOOO000000000o.                                            ;kKKKKKKKKKOkOOOOOOOOO00\nOOOOOOOOOO0000000000000000K0Kk'                                              'xKKKKKKKKOkOOOOOOOOO00\nKKKKKKKKKXXXXXXXXXXXXXXNNNNNNd.                                               cXNNNNNNNK0000O00O0000\nKKKKKKKKKXXXXXXXXXXXXNNNNNNNXl        ...............                         :XWWWWWWWX000000000000\nKKKKKKKKKXXXXXXXXXXXXXXNNNNNXc     ...''',,,,,,;;,,,,,,'''......             .xWWWWWWWWX000000000000\nKKKKKKKKKKKXXXXXXXXXXXXXNNNNK;    ...',,,,;;;;;;;:::::::;;;;;;,,'.          .oNWWWWWWWNK000000OOOO00\nKKKKKKKKKKKKXXXXXXXXXXXXXXXN0,  ...'',,,;;;;;;:::::::::::::::;;;;,'.       .dNWWWWWWWWNK0000OOOOOOOO\n0000KKKKKKKKKKKKKXXXXXXXXXXN0, ..'',,,,;;;;;;:::::::::::::::::;;;;,,..    ;ONNNNNWWWWWNK00OOOOOOOOOO\nkkkkkkOOOOOOOOOOOOOOOOOOO000k; ..,,,,,,'',,;;::::::::::::::::;;;;;;,'.  .lOKKKKXXKXXKK0OOOOOOOOOOOOO\nxxxkkkkkkkkkkkkkkkkkkOOOOkdll;..',,,,,,,''...';::ccccc:::::::::;;;;;,...o0000000000000OkkOOOkkOOOOOO\nxxxxxxkkkkkkkkkkkkkkkkkkOd:;;,..,;;;;;;;;;;,'',,;:ccccccccc:::;;;;;;,..cO0000000000000Oxkkkkkkkkkkkk\nxxxxxxxxkkkkkkkkkkkkkkkkkl:;;,'';;;;;,'''''',,,,,;::ccc::;,,'.'''',;,,lO00000000000000kxkkkkkkkkkkkk\nxxxxxxxxkkkkkkkkkkkkkkkkko::;'';;;;;;,''....,'',,,,;:c:;,,'''',,;;;;,:x00000000000000Okxkkkkkkkkkkkk\nxxxxxxxxxxkkkkkkkkkkkkkkkxl;,,;;;;:::;;;,,,,,,,,,,,,:c:;,'....''',;;,;cxO000000000000Okxkkkkkkkkkkkk\nkkkkOOOOOOOOOOOOOO00000000x:;;;;;:::c::::::;;;;;;;;;:c:;,,,,'',,',;:::lOKKKKKKXXXXXXKKOkkkkkkkkkkkkk\n000000000000000KKKKKKKKKKK0dc;,;;:::ccccccc::::;;;;;:cc:;;;;:::::::::lOXXXXXNNNNNNNNXX0Okkkkkkkkkkkk\nOO00000000000000000KKKKKKKK0d::;;;::ccccccccc:;;;;;;;:c:;::ccccccc::cOXXXXXXXXXNNNNNXX0kkkkkkkkkkkkk\nOOO00000000000000000000KKKKKOxxc;;;::ccccccc:;;;;;;;:ccc:::cccllcc;:kKXXXXXXXXXXXXXXXKOkkkkkkkkkkkkk\nOOOOO00000000000000000000KKK0kdl;;;;;:ccccc::;,,,,;;:clc:::cclllcc:oKXXXXXXXXXXXXXXXXKOkkkkkkkkkkkkk\nOOOOOOO0000000000000000Okxdlc;,,;;::;;::cc::;;,,,,,;:::;;:cccccc::clxkO00KKKKKKKKKXKK0kkkkkkkkkkkxkk\nkkkkkkkkkkkkkkkkkkkxdoc:,''.....,;:::;;;::;;;;;;;;;;;;;;;:ccc:::;,',;;:clodxkOOOOOOOOkxxxxxxxxxxxxxx\nddddddddddddddoolc;,'''..........,;;:;;;::;,,,,,;;;;;::::::c:::;'.',,;;;;;::clodxkkkkxdxxxxxxxxxxxxx\ndddddddoolc::;,'''.......      ..',;;;;;;;;,'........',;::::::;;,,;;;;;;;;:::::ccloddddxxxxxxxxxxxxx\ndollc:;,,''.........         ..'''',,,,;;;;;,'''.....'',::::;,,;;;::::;;,,;;;;;;;;;::cldxxxxxxdxxdxx\nl;'''.''......             ..'',,''',,,,;;;::;;,,,,,,;;::;;'.....',;;,,''',,,,,,'',,,',:odxddddddddd\n.............             .'',,,,,''',,,;;;;::::;::::::;;;........'''''''..'.....,,'...';cdddddddddd\n. .......                .',,,,,;,,'',,,,;;;::::::::::;;cc. .....''...'''.......','......':odxdddddd\n   ...                  .',,;;;;;;,'',;;,,,;;;::::::::;cxo....................''''.......'';lddddddd\n    ..                  .,;,;;;;;;,,,',;;;,,,,;;;;;;;;:dKO:..................''''.. .......',cdddddd\n                         ,:;;;;;,,,,;,,;::;,,,,,;::::::dK0c..................'''..  ........',codddd\n                         .;:;;;;;,,;;;,,;:;;:;,,;:::::clc,...   ...........'''.... ....  .....':oddd\n                          .',;;;;;;;;;,,;:;;;;,;::::::;'......       ......'.........   .....'',cood\n                            ..,;;;;;;;;;;;:;;;;:::::;'.    .         ..............       ...''',:od\n                              ..',;;;;:;;;:::::::,,'.              ...............        ....''.':o\n                                 ...',,;;,,;,,'..                 ...............        ..  .....'c\n               __              _     __....                      ................     ....   ......'\n   ____ ____  / /_   _      __(_)___/ /__                    ..............   ..    ...     .......\n  / __ `/ _ \\/ __/  | | /| / / / __  / _ \\                 ................    .             ......\n / /_/ /  __/ /_    | |/ |/ / / /_/ /  __/                .................                  ......\n \\__, /\\___/\\__/    |__/|__/_/\\__,_/\\___/                  ...............                   ......\n/____/                                                     ...............  ..             ........\n\"\"\"\n        print(wide)\n</code></pre>"},{"location":"reference/driver/base/async_driver/#driver.base.async_driver.AsyncDriver.__aenter__","title":"<code>__aenter__() -&gt; _T</code>  <code>async</code>","text":"<p>Enter method for context manager</p> <p>Returns:</p> Name Type Description <code>_T</code> <code>_T</code> <p>a concrete implementation of the opened AsyncDriver object</p> Source code in <code>driver/base/async_driver.py</code> <pre><code>async def __aenter__(self: _T) -&gt; _T:\n\"\"\"\n    Enter method for context manager\n\n    Args:\n        N/A\n\n    Returns:\n        _T: a concrete implementation of the opened AsyncDriver object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self.open()\n    return self\n</code></pre>"},{"location":"reference/driver/base/async_driver/#driver.base.async_driver.AsyncDriver.__aexit__","title":"<code>__aexit__(exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType]) -&gt; None</code>  <code>async</code>","text":"<p>Exit method to cleanup for context manager</p> <p>Parameters:</p> Name Type Description Default <code>exception_type</code> <code>Optional[Type[BaseException]]</code> <p>exception type being raised</p> required <code>exception_value</code> <code>Optional[BaseException]</code> <p>message from exception being raised</p> required <code>traceback</code> <code>Optional[TracebackType]</code> <p>traceback from exception being raised</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/async_driver.py</code> <pre><code>async def __aexit__(\n    self,\n    exception_type: Optional[Type[BaseException]],\n    exception_value: Optional[BaseException],\n    traceback: Optional[TracebackType],\n) -&gt; None:\n\"\"\"\n    Exit method to cleanup for context manager\n\n    Args:\n        exception_type: exception type being raised\n        exception_value: message from exception being raised\n        traceback: traceback from exception being raised\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self.close()\n</code></pre>"},{"location":"reference/driver/base/async_driver/#driver.base.async_driver.AsyncDriver.close","title":"<code>close() -&gt; None</code>  <code>async</code>","text":"<p>Close the scrapli connection</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/async_driver.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"\n    Close the scrapli connection\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._post_open_closing_log(closing=True)\n\n    if self.on_close:\n        await self.on_close(self)\n\n    self.transport.close()\n    self.channel.close()\n\n    self._post_open_closing_log(closing=True)\n</code></pre>"},{"location":"reference/driver/base/async_driver/#driver.base.async_driver.AsyncDriver.commandeer","title":"<code>commandeer(conn: AsyncDriver, execute_on_open: bool = True) -&gt; None</code>  <code>async</code>","text":"<p>Commandeer an existing connection</p> <p>See docstring in sync version for more details: <code>scrapli.driver.base.sync_driver.commandeer</code></p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncDriver</code> <p>connection to commandeer</p> required <code>execute_on_open</code> <code>bool</code> <p>execute the <code>on_open</code> function of the current object once the existing connection has been commandeered</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/async_driver.py</code> <pre><code>async def commandeer(self, conn: \"AsyncDriver\", execute_on_open: bool = True) -&gt; None:\n\"\"\"\n    Commandeer an existing connection\n\n    See docstring in sync version for more details: `scrapli.driver.base.sync_driver.commandeer`\n\n    Args:\n        conn: connection to commandeer\n        execute_on_open: execute the `on_open` function of the current object once the existing\n            connection has been commandeered\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    original_logger = conn.logger\n    original_transport = conn.transport\n    original_transport_logger = conn.transport.logger\n    original_channel_logger = conn.channel.logger\n    original_channel_channel_log = conn.channel.channel_log\n\n    self.logger = original_logger\n    self.channel.logger = original_channel_logger\n    self.channel.transport = original_transport\n    self.transport = original_transport\n    self.transport.logger = original_transport_logger\n\n    if original_channel_channel_log is not None:\n        # if the original connection had a channel log we also commandeer that; note that when\n        # the new connection is closed this will also close the channel log; see docstring.\n        self.channel.channel_log = original_channel_channel_log\n\n    if execute_on_open and self.on_open is not None:\n        await self.on_open(self)\n</code></pre>"},{"location":"reference/driver/base/async_driver/#driver.base.async_driver.AsyncDriver.open","title":"<code>open() -&gt; None</code>  <code>async</code>","text":"<p>Open the scrapli connection</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/async_driver.py</code> <pre><code>async def open(self) -&gt; None:\n\"\"\"\n    Open the scrapli connection\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_open_closing_log(closing=False)\n\n    await self.transport.open()\n    self.channel.open()\n\n    if (\n        self.transport_name\n        in (\n            \"telnet\",\n            \"asynctelnet\",\n        )\n        and not self.auth_bypass\n    ):\n        await self.channel.channel_authenticate_telnet(\n            auth_username=self.auth_username, auth_password=self.auth_password\n        )\n\n    if self.on_open:\n        await self.on_open(self)\n\n    self._post_open_closing_log(closing=False)\n</code></pre>"},{"location":"reference/driver/base/base_driver/","title":"base_driver","text":"<p>scrapli.driver.base.base_driver</p>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver","title":"<code>BaseDriver</code>","text":"Source code in <code>driver/base/base_driver.py</code> <pre><code>class BaseDriver:\n    def __init__(\n        self,\n        host: str,\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_prompt_pattern: str = r\"^[a-z0-9.\\-@()/:]{1,48}[#&gt;$]\\s*$\",\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n    ) -&gt; None:\nr\"\"\"\n        BaseDriver Object\n\n        BaseDriver is the root for all Scrapli driver classes. The synchronous and asyncio driver\n        base driver classes can be used to provide a semi-pexpect like experience over top of\n        whatever transport a user prefers. Generally, however, the base driver classes should not be\n        used directly. It is best to use the GenericDriver (or AsyncGenericDriver) or NetworkDriver\n        (or AsyncNetworkDriver) sub-classes of the base drivers.\n\n        Args:\n            host: host ip/name to connect to\n            port: port to connect to\n            auth_username: username for authentication\n            auth_private_key: path to private key for authentication\n            auth_private_key_passphrase: passphrase for decrypting ssh key if necessary\n            auth_password: password for authentication\n            auth_strict_key: strict host checking or not\n            auth_bypass: bypass \"in channel\" authentication -- only supported with telnet,\n                asynctelnet, and system transport plugins\n            timeout_socket: timeout for establishing socket/initial connection in seconds\n            timeout_transport: timeout for ssh|telnet transport in seconds\n            timeout_ops: timeout for ssh channel operations\n            comms_prompt_pattern: raw string regex pattern -- preferably use `^` and `$` anchors!\n                this is the single most important attribute here! if this does not match a prompt,\n                scrapli will not work!\n                IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows\n                for highly reliably matching for prompts however we do NOT strip trailing whitespace\n                for each line, so be sure to add '\\\\s?' or similar if your device needs that. This\n                should be mostly sorted for you if using network drivers (i.e. `IOSXEDriver`).\n                Lastly, the case insensitive is just a convenience factor so i can be lazy.\n            comms_return_char: character to use to send returns to host\n            ssh_config_file: string to path for ssh config file, True to use default ssh config file\n                or False to ignore default ssh config file\n            ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known\n                file locations. Only applicable/needed if `auth_strict_key` is set to True\n            on_init: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed as the last step of object instantiation -- its purpose is\n                primarily to provide a mechanism for scrapli community platforms to have an easy way\n                to modify initialization arguments/object attributes without needing to create a\n                class that extends the driver, instead allowing the community platforms to simply\n                build from the GenericDriver or NetworkDriver classes, and pass this callable to do\n                things such as appending to a username (looking at you RouterOS!!). Note that this\n                is *always* a synchronous function (even for asyncio drivers)!\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar\n            transport: name of the transport plugin to use for the actual telnet/ssh/netconf\n                connection. Available \"core\" transports are:\n                    - system\n                    - telnet\n                    - asynctelnet\n                    - ssh2\n                    - paramiko\n                    - asyncssh\n                Please see relevant transport plugin section for details. Additionally third party\n                transport plugins may be available.\n            transport_options: dictionary of options to pass to selected transport class; see\n                docs for given transport class for details of what to pass here\n            channel_lock: True/False to lock the channel (threading.Lock/asyncio.Lock) during\n                any channel operations, defaults to False\n            channel_log: True/False or a string path to a file of where to write out channel logs --\n                these are not \"logs\" in the normal logging module sense, but only the output that is\n                read from the channel. In other words, the output of the channel log should look\n                similar to what you would see as a human connecting to a device\n            channel_log_mode: \"write\"|\"append\", all other values will raise ValueError,\n                does what it sounds like it should by setting the channel log to the provided mode\n            logging_uid: unique identifier (string) to associate to log messages; useful if you have\n                multiple connections to the same device (i.e. one console, one ssh, or one to each\n                supervisor module, etc.)\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if port is None:\n            port = 22\n            if \"telnet\" in transport:\n                port = 23\n\n        self.logger = get_instance_logger(\n            instance_name=\"scrapli.driver\", host=host, port=port, uid=logging_uid\n        )\n\n        self._base_channel_args = BaseChannelArgs(\n            comms_prompt_pattern=comms_prompt_pattern,\n            comms_return_char=comms_return_char,\n            timeout_ops=timeout_ops,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n        )\n\n        # transport options is unused in most transport plugins, but when used will be a dict of\n        # user provided arguments, defaults to None to not be mutable argument, so if its still\n        # None at this point turn it into an empty dict to pass into the transports\n        transport_options = transport_options or {}\n        self._base_transport_args = BaseTransportArgs(\n            transport_options=transport_options,\n            host=host,\n            port=port,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            logging_uid=logging_uid,\n        )\n\n        self.host, self.port = self._setup_host(host=host, port=port)\n\n        self.auth_username = auth_username\n        self.auth_password = auth_password\n        self.auth_private_key_passphrase = auth_private_key_passphrase\n        self.auth_private_key, self.auth_strict_key, self.auth_bypass = self._setup_auth(\n            auth_private_key=auth_private_key,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n        )\n\n        self.ssh_config_file, self.ssh_known_hosts_file = self._setup_ssh_file_args(\n            transport=transport,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n        )\n\n        self._setup_callables(on_init=on_init, on_open=on_open, on_close=on_close)\n\n        self.transport_name = transport\n        if self.transport_name in (\"asyncssh\", \"ssh2\", \"paramiko\"):\n            # for mostly(?) historical reasons these transports use the `ssh_config` module to get\n            # port/username/key file. asyncssh may not need this at all anymore as asyncssh core\n            # has added ssh config file support since scrapli's inception\n            self._update_ssh_args_from_ssh_config()\n\n        transport_class, self._plugin_transport_args = self._transport_factory()\n\n        self.transport = transport_class(\n            base_transport_args=self._base_transport_args,\n            plugin_transport_args=self._plugin_transport_args,\n        )\n\n        if self.on_init:\n            self.on_init(self)\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Magic str method for Scrape\n\n        Args:\n            N/A\n\n        Returns:\n            str: str representation of object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"Scrapli Driver {self.host}:{self.port}\"\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Magic repr method for Scrape\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        password = \"REDACTED\" if self.auth_password else \"\"\n        passphrase = \"REDACTED\" if self.auth_private_key_passphrase else \"\"\n\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"host={self.host!r}, \"\n            f\"port={self.port!r}, \"\n            f\"auth_username={self.auth_username!r}, \"\n            f\"auth_password={password!r}, \"\n            f\"auth_private_key={self.auth_private_key!r}, \"\n            f\"auth_private_key_passphrase={passphrase!r}, \"\n            f\"auth_strict_key={self.auth_strict_key!r}, \"\n            f\"auth_bypass={self.auth_bypass!r}, \"\n            f\"timeout_socket={self._base_transport_args.timeout_socket!r}, \"\n            f\"timeout_transport={self._base_transport_args.timeout_transport!r}, \"\n            f\"timeout_ops={self._base_channel_args.timeout_ops!r}, \"\n            f\"comms_prompt_pattern={self._base_channel_args.comms_prompt_pattern!r}, \"\n            f\"comms_return_char={self._base_channel_args.comms_return_char!r}, \"\n            f\"ssh_config_file={self.ssh_config_file!r}, \"\n            f\"ssh_known_hosts_file={self.ssh_known_hosts_file!r}, \"\n            f\"on_init={self.on_init!r}, \"\n            f\"on_open={self.on_open!r}, \"\n            f\"on_close={self.on_close!r}, \"\n            f\"transport={self.transport_name!r}, \"\n            f\"transport_options={self._base_transport_args.transport_options!r})\"\n            f\"channel_log={self._base_channel_args.channel_log!r}, \"\n            f\"channel_lock={self._base_channel_args.channel_lock!r})\"\n        )\n\n    @staticmethod\n    def _setup_host(host: str, port: int) -&gt; Tuple[str, int]:\n\"\"\"\n        Parse and setup host attributes\n\n        Args:\n            host: host to parse/set\n            port: port to parse/set\n\n        Returns:\n            tuple: host, port -- host is stripped to ensure no weird whitespace floating around\n\n        Raises:\n            ScrapliValueError: if host is not provided\n            ScrapliTypeError: if port is not an integer\n\n        \"\"\"\n        if not host:\n            raise ScrapliValueError(\"`host` should be a hostname/ip address, got nothing!\")\n        if not isinstance(port, int):\n            raise ScrapliTypeError(f\"`port` should be int, got {type(port)}\")\n\n        return host.strip(), port\n\n    @staticmethod\n    def _setup_auth(\n        auth_private_key: str,\n        auth_strict_key: bool,\n        auth_bypass: bool,\n    ) -&gt; Tuple[str, bool, bool]:\n\"\"\"\n        Parse and setup auth attributes\n\n        Args:\n            auth_private_key: ssh key to parse/set\n            auth_strict_key: strict key to parse/set\n            auth_bypass: bypass to parse/set\n\n        Returns:\n            Tuple[str, bool, bool]: string of private key path, bool for auth_strict_key, and bool\n                for auth_bypass values\n\n        Raises:\n            ScrapliTypeError: if auth_strict_key is not a bool\n            ScrapliTypeError: if auth_bypass is not a bool\n\n        \"\"\"\n        if not isinstance(auth_strict_key, bool):\n            raise ScrapliTypeError(f\"`auth_strict_key` should be bool, got {type(auth_strict_key)}\")\n        if not isinstance(auth_bypass, bool):\n            raise ScrapliTypeError(f\"`auth_bypass` should be bool, got {type(auth_bypass)}\")\n\n        if auth_private_key:\n            auth_private_key_path = resolve_file(file=auth_private_key)\n        else:\n            auth_private_key_path = \"\"\n\n        return auth_private_key_path, auth_strict_key, auth_bypass\n\n    def _setup_ssh_file_args(\n        self,\n        transport: str,\n        ssh_config_file: Union[str, bool],\n        ssh_known_hosts_file: Union[str, bool],\n    ) -&gt; Tuple[str, str]:\n\"\"\"\n        Parse and setup ssh related arguments\n\n        Args:\n            transport: string name of selected transport (so we can ignore this if transport\n                contains \"telnet\" in the name)\n            ssh_config_file: string to path for ssh config file, True to use default ssh config file\n                or False to ignore default ssh config file\n            ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known\n                file locations. Only applicable/needed if `auth_strict_key` is set to True\n\n        Returns:\n            Tuple[str, str]: string path to config file, string path to known hosts file\n\n        Raises:\n            ScrapliTypeError: if invalid config file or known hosts file value provided\n\n        \"\"\"\n        if \"telnet\" in transport:\n            self.logger.debug(\"telnet-based transport selected, ignoring ssh file arguments\")\n            # the word \"telnet\" should occur in all telnet drivers, always. so this should be safe!\n            return \"\", \"\"\n\n        if not isinstance(ssh_config_file, (str, bool)):\n            raise ScrapliTypeError(\n                f\"`ssh_config_file` must be str or bool, got {type(ssh_config_file)}\"\n            )\n        if not isinstance(ssh_known_hosts_file, (str, bool)):\n            raise ScrapliTypeError(\n                \"`ssh_known_hosts_file` must be str or bool, got \" f\"{type(ssh_known_hosts_file)}\"\n            )\n\n        if ssh_config_file is not False:\n            if isinstance(ssh_config_file, bool):\n                cfg = \"\"\n            else:\n                cfg = ssh_config_file\n            resolved_ssh_config_file = self._resolve_ssh_config(cfg)\n        else:\n            resolved_ssh_config_file = \"\"\n\n        if ssh_known_hosts_file is not False:\n            if isinstance(ssh_known_hosts_file, bool):\n                known_hosts = \"\"\n            else:\n                known_hosts = ssh_known_hosts_file\n            resolved_ssh_known_hosts_file = self._resolve_ssh_known_hosts(known_hosts)\n        else:\n            resolved_ssh_known_hosts_file = \"\"\n\n        return resolved_ssh_config_file, resolved_ssh_known_hosts_file\n\n    def _update_ssh_args_from_ssh_config(self) -&gt; None:\n\"\"\"\n        Update ssh args based on ssh config file data\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        ssh = ssh_config_factory(ssh_config_file=self.ssh_config_file)\n        host_config = ssh.lookup(host=self.host)\n\n        if host_config.port:\n            self.logger.info(\n                f\"found port for host in ssh configuration file, using this value \"\n                f\"'{host_config.port}' for port!\"\n            )\n            # perhaps this should not override already set port because we dont know if the user\n            # provided the port or we just are accepting the default port value... in any case for\n            # port, if it is in the ssh config file we will override whatever we currently have\n            self.port = host_config.port\n        if host_config.user and not self.auth_username:\n            self.logger.info(\n                f\"found username for host in ssh configuration file, using this value \"\n                f\"'{host_config.user}' for auth_username!\"\n            )\n            # only override auth_username if it is not truthy\n            self.auth_username = host_config.user\n        if host_config.identity_file and not self.auth_private_key:\n            self.logger.info(\n                f\"found identity file for host in ssh configuration file, using this value \"\n                f\"'{host_config.identity_file}' for auth_private_key!\"\n            )\n            # only override auth_private_key if it is not truthy\n            self.auth_private_key = host_config.identity_file\n\n    def _setup_callables(\n        self,\n        on_init: Optional[Callable[..., Any]],\n        on_open: Optional[Callable[..., Any]],\n        on_close: Optional[Callable[..., Any]],\n    ) -&gt; None:\n\"\"\"\n        Parse and setup callables (on_init/on_open/on_close)\n\n        Args:\n            on_init: on_init to parse/set\n            on_open: on_open to parse/set\n            on_close: on_close to parse/set\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if any of the on_* methods are not callables (or None)\n\n        \"\"\"\n        if on_init is not None and not callable(on_init):\n            raise ScrapliTypeError(f\"`on_init` must be a callable, got {type(on_init)}\")\n        if on_open is not None and not callable(on_open):\n            raise ScrapliTypeError(f\"`on_open` must be a callable, got {type(on_open)}\")\n        if on_close is not None and not callable(on_close):\n            raise ScrapliTypeError(f\"`on_close` must be a callable, got {type(on_close)}\")\n\n        self.on_init = on_init\n        self.on_open = on_open\n        self.on_close = on_close\n\n    def _transport_factory(self) -&gt; Tuple[Callable[..., Any], object]:\n\"\"\"\n        Determine proper transport class and necessary arguments to initialize that class\n\n        Args:\n            N/A\n\n        Returns:\n            Tuple[Callable[..., Any], object]: tuple of transport class and dataclass of transport\n                class specific arguments\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.transport_name in CORE_TRANSPORTS:\n            transport_class, _plugin_transport_args_class = self._load_core_transport_plugin()\n        else:\n            transport_class, _plugin_transport_args_class = self._load_non_core_transport_plugin()\n\n        _plugin_transport_args = {\n            field.name: getattr(self, field.name) for field in fields(_plugin_transport_args_class)\n        }\n\n        # ignore type as we are typing it as the base class to make life simple, because of this\n        # mypy thinks we are passing too many args\n        plugin_transport_args = _plugin_transport_args_class(**_plugin_transport_args)\n\n        return transport_class, plugin_transport_args\n\n    def _load_transport_plugin_common(\n        self, transport_plugin_module: ModuleType\n    ) -&gt; Tuple[Any, Type[BasePluginTransportArgs]]:\n\"\"\"\n        Given transport plugin module, load transport class and transport args\n\n        Args:\n            transport_plugin_module: loaded importlib module for the given transport\n\n        Returns:\n            Tuple[Any, Type[BasePluginTransportArgs]]: transport class class and TransportArgs\n                dataclass\n\n        Raises:\n            N/A\n\n        \"\"\"\n        transport_class = getattr(\n            transport_plugin_module, f\"{self.transport_name.capitalize()}Transport\"\n        )\n        plugin_transport_args = getattr(transport_plugin_module, \"PluginTransportArgs\")\n\n        return transport_class, plugin_transport_args\n\n    def _load_core_transport_plugin(\n        self,\n    ) -&gt; Tuple[Any, Type[BasePluginTransportArgs]]:\n\"\"\"\n        Find non-core transport plugins and required plugin arguments\n\n        Args:\n            N/A\n\n        Returns:\n            Tuple[Any, Type[BasePluginTransportArgs]]: transport class class and TransportArgs \\\n                dataclass\n\n        Raises:\n            ScrapliTransportPluginError: if the transport plugin is unable to be loaded\n\n        \"\"\"\n        self.logger.debug(\"load core transport requested\")\n\n        try:\n            transport_plugin_module = importlib.import_module(\n                f\"scrapli.transport.plugins.{self.transport_name}.transport\"\n            )\n        except ModuleNotFoundError as exc:\n            title = \"Transport Plugin Extra Not Installed!\"\n            message = (\n                f\"Optional transport plugin '{self.transport_name}' is not installed!\\n\"\n                f\"To resolve this issue, install the transport plugin. You can do this in one of \"\n                \"the following ways:\\n\"\n                f\"1: 'pip install -r requirements-{self.transport_name}.txt'\\n\"\n                f\"2: 'pip install scrapli[{self.transport_name}]'\"\n            )\n            exception_message = format_user_warning(title=title, message=message)\n            raise ScrapliTransportPluginError(exception_message) from exc\n\n        transport_class, plugin_transport_args = self._load_transport_plugin_common(\n            transport_plugin_module=transport_plugin_module\n        )\n\n        self.logger.debug(f\"core transport '{self.transport_name}' loaded successfully\")\n\n        return transport_class, plugin_transport_args\n\n    def _load_non_core_transport_plugin(self) -&gt; Tuple[Any, Type[BasePluginTransportArgs]]:\n\"\"\"\n        Find non-core transport plugins and required plugin arguments\n\n        Args:\n            N/A\n\n        Returns:\n            Tuple[Any, Type[BasePluginTransportArgs]]: transport class class and TransportArgs\n                dataclass\n\n        Raises:\n            ScrapliTransportPluginError: if non-core transport library is not importable\n\n        \"\"\"\n        try:\n            transport_plugin_module = importlib.import_module(\n                f\"scrapli_{self.transport_name}.transport\"\n            )\n        except ModuleNotFoundError as exc:\n            title = \"Transport Plugin Extra Not Installed!\"\n            message = (\n                f\"Optional third party transport plugin '{self.transport_name}' is not installed!\\n\"\n                f\"To resolve this issue, install the transport plugin. You can do this in one of \"\n                \"the following ways:\\n\"\n                f\"1: 'pip install -r requirements-{self.transport_name}.txt'\\n\"\n                f\"2: 'pip install scrapli[{self.transport_name}]'\"\n            )\n            exception_message = format_user_warning(title=title, message=message)\n            raise ScrapliTransportPluginError(exception_message) from exc\n\n        transport_class, plugin_transport_args = self._load_transport_plugin_common(\n            transport_plugin_module=transport_plugin_module\n        )\n\n        self.logger.debug(f\"non-core transport '{self.transport_name}' loaded successfully\")\n\n        return transport_class, plugin_transport_args\n\n    def _resolve_ssh_config(self, ssh_config_file: str) -&gt; str:\n\"\"\"\n        Resolve ssh configuration file from provided string\n\n        If provided string is empty (`\"\"`) try to resolve system ssh config files located at\n        `~/.ssh/config` or `/etc/ssh/ssh_config`.\n\n        Args:\n            ssh_config_file: string representation of ssh config file to try to use\n\n        Returns:\n            str: string path to ssh config file or an empty string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"attempting to resolve 'ssh_config_file' file\")\n\n        resolved_ssh_config_file = \"\"\n\n        if Path(ssh_config_file).is_file():\n            resolved_ssh_config_file = str(Path(ssh_config_file))\n        elif Path(\"~/.ssh/config\").expanduser().is_file():\n            resolved_ssh_config_file = str(Path(\"~/.ssh/config\").expanduser())\n        elif Path(\"/etc/ssh/ssh_config\").is_file():\n            resolved_ssh_config_file = str(Path(\"/etc/ssh/ssh_config\"))\n\n        if resolved_ssh_config_file:\n            self.logger.debug(\n                f\"using '{resolved_ssh_config_file}' as resolved 'ssh_config_file' file'\"\n            )\n        else:\n            self.logger.debug(\"unable to resolve 'ssh_config_file' file\")\n\n        return resolved_ssh_config_file\n\n    def _resolve_ssh_known_hosts(self, ssh_known_hosts: str) -&gt; str:\n\"\"\"\n        Resolve ssh known hosts file from provided string\n\n        If provided string is empty (`\"\"`) try to resolve system known hosts files located at\n        `~/.ssh/known_hosts` or `/etc/ssh/ssh_known_hosts`.\n\n        Args:\n            ssh_known_hosts: string representation of ssh config file to try to use\n\n        Returns:\n            str: string path to ssh known hosts file or an empty string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"attempting to resolve 'ssh_known_hosts file'\")\n\n        resolved_ssh_known_hosts = \"\"\n\n        if Path(ssh_known_hosts).is_file():\n            resolved_ssh_known_hosts = str(Path(ssh_known_hosts))\n        elif Path(\"~/.ssh/known_hosts\").expanduser().is_file():\n            resolved_ssh_known_hosts = str(Path(\"~/.ssh/known_hosts\").expanduser())\n        elif Path(\"/etc/ssh/ssh_known_hosts\").is_file():\n            resolved_ssh_known_hosts = str(Path(\"/etc/ssh/ssh_known_hosts\"))\n\n        if resolved_ssh_known_hosts:\n            self.logger.debug(\n                f\"using '{resolved_ssh_known_hosts}' as resolved 'ssh_known_hosts' file'\"\n            )\n        else:\n            self.logger.debug(\"unable to resolve 'ssh_known_hosts' file\")\n\n        return resolved_ssh_known_hosts\n\n    @property\n    def comms_prompt_pattern(self) -&gt; str:\n\"\"\"\n        Getter for `comms_prompt_pattern` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            str: comms_prompt_pattern string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self._base_channel_args.comms_prompt_pattern\n\n    @comms_prompt_pattern.setter\n    def comms_prompt_pattern(self, value: str) -&gt; None:\n\"\"\"\n        Setter for `comms_prompt_pattern` attribute\n\n        Args:\n            value: str value for comms_prompt_pattern\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type str\n\n        \"\"\"\n        self.logger.debug(f\"setting 'comms_prompt_pattern' value to '{value}'\")\n\n        if not isinstance(value, str):\n            raise ScrapliTypeError\n\n        self._base_channel_args.comms_prompt_pattern = value\n\n    @property\n    def comms_return_char(self) -&gt; str:\n\"\"\"\n        Getter for `comms_return_char` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            str: comms_return_char string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self._base_channel_args.comms_return_char\n\n    @comms_return_char.setter\n    def comms_return_char(self, value: str) -&gt; None:\n\"\"\"\n        Setter for `comms_return_char` attribute\n\n        Args:\n            value: str value for comms_return_char\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type str\n\n        \"\"\"\n        self.logger.debug(f\"setting 'comms_return_char' value to {value!r}\")\n\n        if not isinstance(value, str):\n            raise ScrapliTypeError\n\n        self._base_channel_args.comms_return_char = value\n\n    @property\n    def timeout_socket(self) -&gt; float:\n\"\"\"\n        Getter for `timeout_socket` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            float: timeout_socket value\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self._base_transport_args.timeout_socket\n\n    @timeout_socket.setter\n    def timeout_socket(self, value: float) -&gt; None:\n\"\"\"\n        Setter for `timeout_socket` attribute\n\n        Args:\n            value: float value for timeout_socket\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type int/float\n\n        \"\"\"\n        self.logger.debug(f\"setting 'timeout_socket' value to '{value}'\")\n\n        if not isinstance(value, (int, float)):\n            raise ScrapliTypeError\n\n        self._base_transport_args.timeout_socket = value\n\n    @property\n    def timeout_transport(self) -&gt; float:\n\"\"\"\n        Getter for `timeout_transport` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            float: timeout_transport value\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self._base_transport_args.timeout_transport\n\n    @timeout_transport.setter\n    def timeout_transport(self, value: float) -&gt; None:\n\"\"\"\n        Setter for `timeout_transport` attribute\n\n        Args:\n            value: float value for timeout_transport\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type int/float\n\n        \"\"\"\n        self.logger.debug(f\"setting 'timeout_transport' value to '{value}'\")\n\n        if not isinstance(value, (int, float)):\n            raise ScrapliTypeError\n\n        if value == 0:\n            self.logger.debug(\"'timeout_transport' value is 0, this will disable timeout decorator\")\n\n        self._base_transport_args.timeout_transport = value\n\n        if hasattr(self.transport, \"_set_timeout\"):\n            # transports such as paramiko/ssh2 we have to set the transport in the session\n            # object, just updating the _base_transport_args value wont update the session!\n            self.transport._set_timeout(value)  # pylint: disable=W0212\n\n    @property\n    def timeout_ops(self) -&gt; float:\n\"\"\"\n        Getter for `timeout_ops` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            float: timeout_ops value\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self._base_channel_args.timeout_ops\n\n    @timeout_ops.setter\n    def timeout_ops(self, value: float) -&gt; None:\n\"\"\"\n        Setter for `timeout_ops` attribute\n\n        Args:\n            value: float value for timeout_ops\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type int/float\n\n        \"\"\"\n        self.logger.debug(f\"setting 'timeout_ops' value to '{value}'\")\n\n        if not isinstance(value, (int, float)):\n            raise ScrapliTypeError\n\n        if value == 0:\n            self.logger.debug(\"'timeout_ops' value is 0, this will disable timeout decorator\")\n\n        self._base_channel_args.timeout_ops = value\n\n    def isalive(self) -&gt; bool:\n\"\"\"\n        Check if underlying transport is \"alive\"\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if transport is alive\n\n        Raises:\n            N/A\n\n        \"\"\"\n        alive: bool = self.transport.isalive()\n        return alive\n\n    def _pre_open_closing_log(self, closing: bool = False) -&gt; None:\n\"\"\"\n        Emit \"pre open\" log message for consistency between sync/async drivers\n\n        Args:\n            closing: bool indicating if message is for closing not opening\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        operation = \"closing\" if closing else \"opening\"\n\n        self.logger.info(f\"{operation} connection to '{self.host}' on port '{self.port}'\")\n\n    def _post_open_closing_log(self, closing: bool = False) -&gt; None:\n\"\"\"\n        Emit \"post open\" log message for consistency between sync/async drivers\n\n        Args:\n            closing: bool indicating if message is for closing not opening\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        operation = \"closed\" if closing else \"opened\"\n\n        self.logger.info(\n            f\"connection to '{self.host}' on port '{self.port}' {operation} successfully\"\n        )\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.__init__","title":"<code>__init__(host: str, port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_prompt_pattern: str = '^[a-z0-9.\\\\-@()/:]{1,48}[#&gt;$]\\\\s*$', comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '') -&gt; None</code>","text":"<p>BaseDriver Object</p> <p>BaseDriver is the root for all Scrapli driver classes. The synchronous and asyncio driver base driver classes can be used to provide a semi-pexpect like experience over top of whatever transport a user prefers. Generally, however, the base driver classes should not be used directly. It is best to use the GenericDriver (or AsyncGenericDriver) or NetworkDriver (or AsyncNetworkDriver) sub-classes of the base drivers.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>host ip/name to connect to</p> required <code>port</code> <code>Optional[int]</code> <p>port to connect to</p> <code>None</code> <code>auth_username</code> <code>str</code> <p>username for authentication</p> <code>''</code> <code>auth_private_key</code> <code>str</code> <p>path to private key for authentication</p> <code>''</code> <code>auth_private_key_passphrase</code> <code>str</code> <p>passphrase for decrypting ssh key if necessary</p> <code>''</code> <code>auth_password</code> <code>str</code> <p>password for authentication</p> <code>''</code> <code>auth_strict_key</code> <code>bool</code> <p>strict host checking or not</p> <code>True</code> <code>auth_bypass</code> <code>bool</code> <p>bypass \"in channel\" authentication -- only supported with telnet, asynctelnet, and system transport plugins</p> <code>False</code> <code>timeout_socket</code> <code>float</code> <p>timeout for establishing socket/initial connection in seconds</p> <code>15.0</code> <code>timeout_transport</code> <code>float</code> <p>timeout for ssh|telnet transport in seconds</p> <code>30.0</code> <code>timeout_ops</code> <code>float</code> <p>timeout for ssh channel operations</p> <code>30.0</code> <code>comms_prompt_pattern</code> <code>str</code> <p>raw string regex pattern -- preferably use <code>^</code> and <code>$</code> anchors! this is the single most important attribute here! if this does not match a prompt, scrapli will not work! IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows for highly reliably matching for prompts however we do NOT strip trailing whitespace for each line, so be sure to add '\\s?' or similar if your device needs that. This should be mostly sorted for you if using network drivers (i.e. <code>IOSXEDriver</code>). Lastly, the case insensitive is just a convenience factor so i can be lazy.</p> <code>'^[a-z0-9.\\\\-@()/:]{1,48}[#&gt;$]\\\\s*$'</code> <code>comms_return_char</code> <code>str</code> <p>character to use to send returns to host</p> <code>'\\n'</code> <code>ssh_config_file</code> <code>Union[str, bool]</code> <p>string to path for ssh config file, True to use default ssh config file or False to ignore default ssh config file</p> <code>False</code> <code>ssh_known_hosts_file</code> <code>Union[str, bool]</code> <p>string to path for ssh known hosts file, True to use default known file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</p> <code>False</code> <code>on_init</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed as the last step of object instantiation -- its purpose is primarily to provide a mechanism for scrapli community platforms to have an easy way to modify initialization arguments/object attributes without needing to create a class that extends the driver, instead allowing the community platforms to simply build from the GenericDriver or NetworkDriver classes, and pass this callable to do things such as appending to a username (looking at you RouterOS!!). Note that this is always a synchronous function (even for asyncio drivers)!</p> <code>None</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar</p> <code>None</code> <code>transport</code> <code>str</code> <p>name of the transport plugin to use for the actual telnet/ssh/netconf connection. Available \"core\" transports are:     - system     - telnet     - asynctelnet     - ssh2     - paramiko     - asyncssh Please see relevant transport plugin section for details. Additionally third party transport plugins may be available.</p> <code>'system'</code> <code>transport_options</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary of options to pass to selected transport class; see docs for given transport class for details of what to pass here</p> <code>None</code> <code>channel_lock</code> <code>bool</code> <p>True/False to lock the channel (threading.Lock/asyncio.Lock) during any channel operations, defaults to False</p> <code>False</code> <code>channel_log</code> <code>Union[str, bool, BytesIO]</code> <p>True/False or a string path to a file of where to write out channel logs -- these are not \"logs\" in the normal logging module sense, but only the output that is read from the channel. In other words, the output of the channel log should look similar to what you would see as a human connecting to a device</p> <code>False</code> <code>channel_log_mode</code> <code>str</code> <p>\"write\"|\"append\", all other values will raise ValueError, does what it sounds like it should by setting the channel log to the provided mode</p> <code>'write'</code> <code>logging_uid</code> <code>str</code> <p>unique identifier (string) to associate to log messages; useful if you have multiple connections to the same device (i.e. one console, one ssh, or one to each supervisor module, etc.)</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_prompt_pattern: str = r\"^[a-z0-9.\\-@()/:]{1,48}[#&gt;$]\\s*$\",\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n) -&gt; None:\nr\"\"\"\n    BaseDriver Object\n\n    BaseDriver is the root for all Scrapli driver classes. The synchronous and asyncio driver\n    base driver classes can be used to provide a semi-pexpect like experience over top of\n    whatever transport a user prefers. Generally, however, the base driver classes should not be\n    used directly. It is best to use the GenericDriver (or AsyncGenericDriver) or NetworkDriver\n    (or AsyncNetworkDriver) sub-classes of the base drivers.\n\n    Args:\n        host: host ip/name to connect to\n        port: port to connect to\n        auth_username: username for authentication\n        auth_private_key: path to private key for authentication\n        auth_private_key_passphrase: passphrase for decrypting ssh key if necessary\n        auth_password: password for authentication\n        auth_strict_key: strict host checking or not\n        auth_bypass: bypass \"in channel\" authentication -- only supported with telnet,\n            asynctelnet, and system transport plugins\n        timeout_socket: timeout for establishing socket/initial connection in seconds\n        timeout_transport: timeout for ssh|telnet transport in seconds\n        timeout_ops: timeout for ssh channel operations\n        comms_prompt_pattern: raw string regex pattern -- preferably use `^` and `$` anchors!\n            this is the single most important attribute here! if this does not match a prompt,\n            scrapli will not work!\n            IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows\n            for highly reliably matching for prompts however we do NOT strip trailing whitespace\n            for each line, so be sure to add '\\\\s?' or similar if your device needs that. This\n            should be mostly sorted for you if using network drivers (i.e. `IOSXEDriver`).\n            Lastly, the case insensitive is just a convenience factor so i can be lazy.\n        comms_return_char: character to use to send returns to host\n        ssh_config_file: string to path for ssh config file, True to use default ssh config file\n            or False to ignore default ssh config file\n        ssh_known_hosts_file: string to path for ssh known hosts file, True to use default known\n            file locations. Only applicable/needed if `auth_strict_key` is set to True\n        on_init: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed as the last step of object instantiation -- its purpose is\n            primarily to provide a mechanism for scrapli community platforms to have an easy way\n            to modify initialization arguments/object attributes without needing to create a\n            class that extends the driver, instead allowing the community platforms to simply\n            build from the GenericDriver or NetworkDriver classes, and pass this callable to do\n            things such as appending to a username (looking at you RouterOS!!). Note that this\n            is *always* a synchronous function (even for asyncio drivers)!\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar\n        transport: name of the transport plugin to use for the actual telnet/ssh/netconf\n            connection. Available \"core\" transports are:\n                - system\n                - telnet\n                - asynctelnet\n                - ssh2\n                - paramiko\n                - asyncssh\n            Please see relevant transport plugin section for details. Additionally third party\n            transport plugins may be available.\n        transport_options: dictionary of options to pass to selected transport class; see\n            docs for given transport class for details of what to pass here\n        channel_lock: True/False to lock the channel (threading.Lock/asyncio.Lock) during\n            any channel operations, defaults to False\n        channel_log: True/False or a string path to a file of where to write out channel logs --\n            these are not \"logs\" in the normal logging module sense, but only the output that is\n            read from the channel. In other words, the output of the channel log should look\n            similar to what you would see as a human connecting to a device\n        channel_log_mode: \"write\"|\"append\", all other values will raise ValueError,\n            does what it sounds like it should by setting the channel log to the provided mode\n        logging_uid: unique identifier (string) to associate to log messages; useful if you have\n            multiple connections to the same device (i.e. one console, one ssh, or one to each\n            supervisor module, etc.)\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if port is None:\n        port = 22\n        if \"telnet\" in transport:\n            port = 23\n\n    self.logger = get_instance_logger(\n        instance_name=\"scrapli.driver\", host=host, port=port, uid=logging_uid\n    )\n\n    self._base_channel_args = BaseChannelArgs(\n        comms_prompt_pattern=comms_prompt_pattern,\n        comms_return_char=comms_return_char,\n        timeout_ops=timeout_ops,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n    )\n\n    # transport options is unused in most transport plugins, but when used will be a dict of\n    # user provided arguments, defaults to None to not be mutable argument, so if its still\n    # None at this point turn it into an empty dict to pass into the transports\n    transport_options = transport_options or {}\n    self._base_transport_args = BaseTransportArgs(\n        transport_options=transport_options,\n        host=host,\n        port=port,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        logging_uid=logging_uid,\n    )\n\n    self.host, self.port = self._setup_host(host=host, port=port)\n\n    self.auth_username = auth_username\n    self.auth_password = auth_password\n    self.auth_private_key_passphrase = auth_private_key_passphrase\n    self.auth_private_key, self.auth_strict_key, self.auth_bypass = self._setup_auth(\n        auth_private_key=auth_private_key,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n    )\n\n    self.ssh_config_file, self.ssh_known_hosts_file = self._setup_ssh_file_args(\n        transport=transport,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n    )\n\n    self._setup_callables(on_init=on_init, on_open=on_open, on_close=on_close)\n\n    self.transport_name = transport\n    if self.transport_name in (\"asyncssh\", \"ssh2\", \"paramiko\"):\n        # for mostly(?) historical reasons these transports use the `ssh_config` module to get\n        # port/username/key file. asyncssh may not need this at all anymore as asyncssh core\n        # has added ssh config file support since scrapli's inception\n        self._update_ssh_args_from_ssh_config()\n\n    transport_class, self._plugin_transport_args = self._transport_factory()\n\n    self.transport = transport_class(\n        base_transport_args=self._base_transport_args,\n        plugin_transport_args=self._plugin_transport_args,\n    )\n\n    if self.on_init:\n        self.on_init(self)\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Magic repr method for Scrape</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>repr for class object</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Magic repr method for Scrape\n\n    Args:\n        N/A\n\n    Returns:\n        str: repr for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    password = \"REDACTED\" if self.auth_password else \"\"\n    passphrase = \"REDACTED\" if self.auth_private_key_passphrase else \"\"\n\n    return (\n        f\"{self.__class__.__name__}(\"\n        f\"host={self.host!r}, \"\n        f\"port={self.port!r}, \"\n        f\"auth_username={self.auth_username!r}, \"\n        f\"auth_password={password!r}, \"\n        f\"auth_private_key={self.auth_private_key!r}, \"\n        f\"auth_private_key_passphrase={passphrase!r}, \"\n        f\"auth_strict_key={self.auth_strict_key!r}, \"\n        f\"auth_bypass={self.auth_bypass!r}, \"\n        f\"timeout_socket={self._base_transport_args.timeout_socket!r}, \"\n        f\"timeout_transport={self._base_transport_args.timeout_transport!r}, \"\n        f\"timeout_ops={self._base_channel_args.timeout_ops!r}, \"\n        f\"comms_prompt_pattern={self._base_channel_args.comms_prompt_pattern!r}, \"\n        f\"comms_return_char={self._base_channel_args.comms_return_char!r}, \"\n        f\"ssh_config_file={self.ssh_config_file!r}, \"\n        f\"ssh_known_hosts_file={self.ssh_known_hosts_file!r}, \"\n        f\"on_init={self.on_init!r}, \"\n        f\"on_open={self.on_open!r}, \"\n        f\"on_close={self.on_close!r}, \"\n        f\"transport={self.transport_name!r}, \"\n        f\"transport_options={self._base_transport_args.transport_options!r})\"\n        f\"channel_log={self._base_channel_args.channel_log!r}, \"\n        f\"channel_lock={self._base_channel_args.channel_lock!r})\"\n    )\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Magic str method for Scrape</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>str representation of object</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Magic str method for Scrape\n\n    Args:\n        N/A\n\n    Returns:\n        str: str representation of object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"Scrapli Driver {self.host}:{self.port}\"\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.comms_prompt_pattern","title":"<code>comms_prompt_pattern() -&gt; str</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>comms_prompt_pattern</code> attribute</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>comms_prompt_pattern string</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>@property\ndef comms_prompt_pattern(self) -&gt; str:\n\"\"\"\n    Getter for `comms_prompt_pattern` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        str: comms_prompt_pattern string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self._base_channel_args.comms_prompt_pattern\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.comms_return_char","title":"<code>comms_return_char() -&gt; str</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>comms_return_char</code> attribute</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>comms_return_char string</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>@property\ndef comms_return_char(self) -&gt; str:\n\"\"\"\n    Getter for `comms_return_char` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        str: comms_return_char string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self._base_channel_args.comms_return_char\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.isalive","title":"<code>isalive() -&gt; bool</code>","text":"<p>Check if underlying transport is \"alive\"</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True/False if transport is alive</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>def isalive(self) -&gt; bool:\n\"\"\"\n    Check if underlying transport is \"alive\"\n\n    Args:\n        N/A\n\n    Returns:\n        bool: True/False if transport is alive\n\n    Raises:\n        N/A\n\n    \"\"\"\n    alive: bool = self.transport.isalive()\n    return alive\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.timeout_ops","title":"<code>timeout_ops() -&gt; float</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>timeout_ops</code> attribute</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>timeout_ops value</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>@property\ndef timeout_ops(self) -&gt; float:\n\"\"\"\n    Getter for `timeout_ops` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        float: timeout_ops value\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self._base_channel_args.timeout_ops\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.timeout_socket","title":"<code>timeout_socket() -&gt; float</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>timeout_socket</code> attribute</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>timeout_socket value</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>@property\ndef timeout_socket(self) -&gt; float:\n\"\"\"\n    Getter for `timeout_socket` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        float: timeout_socket value\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self._base_transport_args.timeout_socket\n</code></pre>"},{"location":"reference/driver/base/base_driver/#driver.base.base_driver.BaseDriver.timeout_transport","title":"<code>timeout_transport() -&gt; float</code>  <code>writable</code> <code>property</code>","text":"<p>Getter for <code>timeout_transport</code> attribute</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>timeout_transport value</p> Source code in <code>driver/base/base_driver.py</code> <pre><code>@property\ndef timeout_transport(self) -&gt; float:\n\"\"\"\n    Getter for `timeout_transport` attribute\n\n    Args:\n        N/A\n\n    Returns:\n        float: timeout_transport value\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self._base_transport_args.timeout_transport\n</code></pre>"},{"location":"reference/driver/base/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.base.sync_driver</p>"},{"location":"reference/driver/base/sync_driver/#driver.base.sync_driver.Driver","title":"<code>Driver</code>","text":"<p>         Bases: <code>BaseDriver</code></p> Source code in <code>driver/base/sync_driver.py</code> <pre><code>class Driver(BaseDriver):\n    def __init__(self, **kwargs: Any):\n        super().__init__(**kwargs)\n\n        if self.transport_name in ASYNCIO_TRANSPORTS:\n            raise ScrapliValueError(\n                \"provided transport is *not* an sync transport, must use an sync transport with\"\n                \" the (sync)Driver(s)\"\n            )\n\n        self.channel = Channel(\n            transport=self.transport,\n            base_channel_args=self._base_channel_args,\n        )\n\n    def __enter__(self: _T) -&gt; _T:\n\"\"\"\n        Enter method for context manager\n\n        Args:\n            N/A\n\n        Returns:\n            _T: a concrete implementation of the opened Driver object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.open()\n        return self\n\n    def __exit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n\"\"\"\n        Exit method to cleanup for context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.close()\n\n    def open(self) -&gt; None:\n\"\"\"\n        Open the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_open_closing_log(closing=False)\n\n        self.transport.open()\n        self.channel.open()\n\n        if self.transport_name in (\"system\",) and not self.auth_bypass:\n            self.channel.channel_authenticate_ssh(\n                auth_password=self.auth_password,\n                auth_private_key_passphrase=self.auth_private_key_passphrase,\n            )\n        if (\n            self.transport_name\n            in (\n                \"telnet\",\n                \"asynctelnet\",\n            )\n            and not self.auth_bypass\n        ):\n            self.channel.channel_authenticate_telnet(\n                auth_username=self.auth_username, auth_password=self.auth_password\n            )\n\n        if self.on_open:\n            self.on_open(self)\n\n        self._post_open_closing_log(closing=False)\n\n    def close(self) -&gt; None:\n\"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._pre_open_closing_log(closing=True)\n\n        if self.on_close:\n            self.on_close(self)\n\n        self.transport.close()\n        self.channel.close()\n\n        self._post_open_closing_log(closing=True)\n\n    def commandeer(self, conn: \"Driver\", execute_on_open: bool = True) -&gt; None:\n\"\"\"\n        Commandeer an existing connection\n\n        Used to \"take over\" or \"commandeer\" a connection. This method accepts a second scrapli conn\n        object and \"steals\" the transport from this connection and uses it for the current instance.\n        The primary reason you would want this is to use a `GenericDriver` to connect to a console\n        server and then to \"commandeer\" that connection and convert it to a \"normal\" network driver\n        connection type (i.e. Junos, EOS, etc.) once connected to the network device (via the\n        console server).\n\n        Right now closing the connection that \"commandeers\" the initial connection will *also close\n        the original connection* -- this is because we are re-using the transport in this new conn.\n        In the future perhaps this will change to *not* close the original connection so users can\n        handle any type of cleanup operations that need to happen on the original connection.\n        Alternatively, you can simply continue using the \"original\" connection to close things for\n        yourself or do any type of clean up work (just dont close the commandeering connection!).\n\n        Args:\n            conn: connection to commandeer\n            execute_on_open: execute the `on_open` function of the current object once the existing\n                connection has been commandeered\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        original_logger = conn.logger\n        original_transport = conn.transport\n        original_transport_logger = conn.transport.logger\n        original_channel_logger = conn.channel.logger\n        original_channel_channel_log = conn.channel.channel_log\n\n        self.logger = original_logger\n        self.channel.logger = original_channel_logger\n        self.channel.transport = original_transport\n        self.transport = original_transport\n        self.transport.logger = original_transport_logger\n\n        if original_channel_channel_log is not None:\n            # if the original connection had a channel log we also commandeer that; note that when\n            # the new connection is closed this will also close the channel log; see docstring.\n            self.channel.channel_log = original_channel_channel_log\n\n        if execute_on_open and self.on_open is not None:\n            self.on_open(self)\n</code></pre>"},{"location":"reference/driver/base/sync_driver/#driver.base.sync_driver.Driver.__enter__","title":"<code>__enter__() -&gt; _T</code>","text":"<p>Enter method for context manager</p> <p>Returns:</p> Name Type Description <code>_T</code> <code>_T</code> <p>a concrete implementation of the opened Driver object</p> Source code in <code>driver/base/sync_driver.py</code> <pre><code>def __enter__(self: _T) -&gt; _T:\n\"\"\"\n    Enter method for context manager\n\n    Args:\n        N/A\n\n    Returns:\n        _T: a concrete implementation of the opened Driver object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.open()\n    return self\n</code></pre>"},{"location":"reference/driver/base/sync_driver/#driver.base.sync_driver.Driver.__exit__","title":"<code>__exit__(exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType]) -&gt; None</code>","text":"<p>Exit method to cleanup for context manager</p> <p>Parameters:</p> Name Type Description Default <code>exception_type</code> <code>Optional[Type[BaseException]]</code> <p>exception type being raised</p> required <code>exception_value</code> <code>Optional[BaseException]</code> <p>message from exception being raised</p> required <code>traceback</code> <code>Optional[TracebackType]</code> <p>traceback from exception being raised</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/sync_driver.py</code> <pre><code>def __exit__(\n    self,\n    exception_type: Optional[Type[BaseException]],\n    exception_value: Optional[BaseException],\n    traceback: Optional[TracebackType],\n) -&gt; None:\n\"\"\"\n    Exit method to cleanup for context manager\n\n    Args:\n        exception_type: exception type being raised\n        exception_value: message from exception being raised\n        traceback: traceback from exception being raised\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/driver/base/sync_driver/#driver.base.sync_driver.Driver.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the scrapli connection</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/sync_driver.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Close the scrapli connection\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_open_closing_log(closing=True)\n\n    if self.on_close:\n        self.on_close(self)\n\n    self.transport.close()\n    self.channel.close()\n\n    self._post_open_closing_log(closing=True)\n</code></pre>"},{"location":"reference/driver/base/sync_driver/#driver.base.sync_driver.Driver.commandeer","title":"<code>commandeer(conn: Driver, execute_on_open: bool = True) -&gt; None</code>","text":"<p>Commandeer an existing connection</p> <p>Used to \"take over\" or \"commandeer\" a connection. This method accepts a second scrapli conn object and \"steals\" the transport from this connection and uses it for the current instance. The primary reason you would want this is to use a <code>GenericDriver</code> to connect to a console server and then to \"commandeer\" that connection and convert it to a \"normal\" network driver connection type (i.e. Junos, EOS, etc.) once connected to the network device (via the console server).</p> <p>Right now closing the connection that \"commandeers\" the initial connection will also close the original connection -- this is because we are re-using the transport in this new conn. In the future perhaps this will change to not close the original connection so users can handle any type of cleanup operations that need to happen on the original connection. Alternatively, you can simply continue using the \"original\" connection to close things for yourself or do any type of clean up work (just dont close the commandeering connection!).</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>Driver</code> <p>connection to commandeer</p> required <code>execute_on_open</code> <code>bool</code> <p>execute the <code>on_open</code> function of the current object once the existing connection has been commandeered</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/sync_driver.py</code> <pre><code>def commandeer(self, conn: \"Driver\", execute_on_open: bool = True) -&gt; None:\n\"\"\"\n    Commandeer an existing connection\n\n    Used to \"take over\" or \"commandeer\" a connection. This method accepts a second scrapli conn\n    object and \"steals\" the transport from this connection and uses it for the current instance.\n    The primary reason you would want this is to use a `GenericDriver` to connect to a console\n    server and then to \"commandeer\" that connection and convert it to a \"normal\" network driver\n    connection type (i.e. Junos, EOS, etc.) once connected to the network device (via the\n    console server).\n\n    Right now closing the connection that \"commandeers\" the initial connection will *also close\n    the original connection* -- this is because we are re-using the transport in this new conn.\n    In the future perhaps this will change to *not* close the original connection so users can\n    handle any type of cleanup operations that need to happen on the original connection.\n    Alternatively, you can simply continue using the \"original\" connection to close things for\n    yourself or do any type of clean up work (just dont close the commandeering connection!).\n\n    Args:\n        conn: connection to commandeer\n        execute_on_open: execute the `on_open` function of the current object once the existing\n            connection has been commandeered\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    original_logger = conn.logger\n    original_transport = conn.transport\n    original_transport_logger = conn.transport.logger\n    original_channel_logger = conn.channel.logger\n    original_channel_channel_log = conn.channel.channel_log\n\n    self.logger = original_logger\n    self.channel.logger = original_channel_logger\n    self.channel.transport = original_transport\n    self.transport = original_transport\n    self.transport.logger = original_transport_logger\n\n    if original_channel_channel_log is not None:\n        # if the original connection had a channel log we also commandeer that; note that when\n        # the new connection is closed this will also close the channel log; see docstring.\n        self.channel.channel_log = original_channel_channel_log\n\n    if execute_on_open and self.on_open is not None:\n        self.on_open(self)\n</code></pre>"},{"location":"reference/driver/base/sync_driver/#driver.base.sync_driver.Driver.open","title":"<code>open() -&gt; None</code>","text":"<p>Open the scrapli connection</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/base/sync_driver.py</code> <pre><code>def open(self) -&gt; None:\n\"\"\"\n    Open the scrapli connection\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._pre_open_closing_log(closing=False)\n\n    self.transport.open()\n    self.channel.open()\n\n    if self.transport_name in (\"system\",) and not self.auth_bypass:\n        self.channel.channel_authenticate_ssh(\n            auth_password=self.auth_password,\n            auth_private_key_passphrase=self.auth_private_key_passphrase,\n        )\n    if (\n        self.transport_name\n        in (\n            \"telnet\",\n            \"asynctelnet\",\n        )\n        and not self.auth_bypass\n    ):\n        self.channel.channel_authenticate_telnet(\n            auth_username=self.auth_username, auth_password=self.auth_password\n        )\n\n    if self.on_open:\n        self.on_open(self)\n\n    self._post_open_closing_log(closing=False)\n</code></pre>"},{"location":"reference/driver/core/","title":"core","text":"<p>scrapli.driver.core</p>"},{"location":"reference/driver/core/arista_eos/","title":"arista_eos","text":"<p>scrapli.driver.core.arista_eos</p>"},{"location":"reference/driver/core/arista_eos/async_driver/","title":"async_driver","text":"<p>scrapli.driver.core.arista_eos.async_driver</p>"},{"location":"reference/driver/core/arista_eos/async_driver/#driver.core.arista_eos.async_driver.AsyncEOSDriver","title":"<code>AsyncEOSDriver</code>","text":"<p>         Bases: <code>AsyncNetworkDriver</code>, <code>EOSDriverBase</code></p> Source code in <code>driver/core/arista_eos/async_driver.py</code> <pre><code>class AsyncEOSDriver(AsyncNetworkDriver, EOSDriverBase):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"arista_eos\",\n        genie_platform: str = \"\",\n    ):\n\"\"\"\n        AsyncEOSDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n        self.comms_prompt_pattern: str\n\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = eos_on_open\n        if on_close is None:\n            on_close = eos_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    async def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort EOS configuration session (if using a config session!)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # eos pattern for config sessions should *always* have `config-s`\n        if \"config\\\\-s\" in self._current_priv_level.pattern:\n            await self.channel.send_input(channel_input=\"abort\")\n            self._current_priv_level = self.privilege_levels[\"privilege_exec\"]\n\n    def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n        Register EOS configuration session\n\n        Args:\n            session_name: name of config session to register\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._create_configuration_session(session_name=session_name)\n        self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/arista_eos/async_driver/#driver.core.arista_eos.async_driver.AsyncEOSDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'arista_eos', genie_platform: str = '')</code>","text":"<p>AsyncEOSDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/arista_eos/async_driver/#driver.core.arista_eos.async_driver.AsyncEOSDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>str</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>'privilege_exec'</code> <code>auth_secondary</code> <code>str</code> <p>password to use for secondary authentication (enable)</p> <code>''</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar.</p> <code>None</code> <code>textfsm_platform</code> <code>str</code> <p>string name of textfsm parser platform</p> <code>'arista_eos'</code> <code>genie_platform</code> <code>str</code> <p>string name of cisco genie parser platform</p> <code>''</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/arista_eos/async_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"arista_eos\",\n    genie_platform: str = \"\",\n):\n\"\"\"\n    AsyncEOSDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n    self.comms_prompt_pattern: str\n\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = eos_on_open\n    if on_close is None:\n        on_close = eos_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/arista_eos/async_driver/#driver.core.arista_eos.async_driver.AsyncEOSDriver.register_configuration_session","title":"<code>register_configuration_session(session_name: str) -&gt; None</code>","text":"<p>Register EOS configuration session</p> <p>Parameters:</p> Name Type Description Default <code>session_name</code> <code>str</code> <p>name of config session to register</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/arista_eos/async_driver.py</code> <pre><code>def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n    Register EOS configuration session\n\n    Args:\n        session_name: name of config session to register\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._create_configuration_session(session_name=session_name)\n    self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/arista_eos/async_driver/#driver.core.arista_eos.async_driver.eos_on_close","title":"<code>eos_on_close(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>AsyncEOSDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/arista_eos/async_driver.py</code> <pre><code>async def eos_on_close(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    AsyncEOSDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/arista_eos/async_driver/#driver.core.arista_eos.async_driver.eos_on_open","title":"<code>eos_on_open(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>AsyncEOSDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/arista_eos/async_driver.py</code> <pre><code>async def eos_on_open(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    AsyncEOSDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    await conn.send_command(command=\"terminal length 0\")\n    await conn.send_command(command=\"terminal width 32767\")\n</code></pre>"},{"location":"reference/driver/core/arista_eos/base_driver/","title":"base_driver","text":"<p>scrapli.driver.core.arista_eos.base_driver</p>"},{"location":"reference/driver/core/arista_eos/base_driver/#driver.core.arista_eos.base_driver.EOSDriverBase","title":"<code>EOSDriverBase</code>","text":"Source code in <code>driver/core/arista_eos/base_driver.py</code> <pre><code>class EOSDriverBase:\n    # EOSDriverBase Mixin values set in init of sync/async NetworkDriver classes\n    privilege_levels: Dict[str, PrivilegeLevel]\n\n    def _create_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n        Handle configuration session creation tasks for consistency between sync/async versions\n\n        Args:\n            session_name: name of session to register\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliValueError: if a session of given name already exists\n\n        \"\"\"\n        if session_name in self.privilege_levels.keys():\n            msg = (\n                f\"session name `{session_name}` already registered as a privilege level, chose a \"\n                \"unique session name\"\n            )\n            raise ScrapliValueError(msg)\n        sess_prompt = re.escape(session_name[:6])\n        pattern = (\n            rf\"^[a-z0-9.\\-@()/: ]{{1,63}}\\(config\\-s\\-{sess_prompt}[a-z0-9_.\\-@/:]{{0,32}}\\)#\\s?$\"\n        )\n        name = session_name\n        config_session = PrivilegeLevel(\n            pattern=pattern,\n            name=name,\n            previous_priv=\"privilege_exec\",\n            deescalate=\"end\",\n            escalate=f\"configure session {session_name}\",\n            escalate_auth=False,\n            escalate_prompt=\"\",\n        )\n        self.privilege_levels[name] = config_session\n</code></pre>"},{"location":"reference/driver/core/arista_eos/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.core.arista_eos.sync_driver</p>"},{"location":"reference/driver/core/arista_eos/sync_driver/#driver.core.arista_eos.sync_driver.EOSDriver","title":"<code>EOSDriver</code>","text":"<p>         Bases: <code>NetworkDriver</code>, <code>EOSDriverBase</code></p> Source code in <code>driver/core/arista_eos/sync_driver.py</code> <pre><code>class EOSDriver(NetworkDriver, EOSDriverBase):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"arista_eos\",\n        genie_platform: str = \"\",\n    ):\n\"\"\"\n        EOSDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n        self.comms_prompt_pattern: str\n\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = eos_on_open\n        if on_close is None:\n            on_close = eos_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort EOS configuration session (if using a config session!)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # eos pattern for config sessions should *always* have `config-s`\n        if \"config\\\\-s\" in self._current_priv_level.pattern:\n            self.channel.send_input(channel_input=\"abort\")\n            self._current_priv_level = self.privilege_levels[\"privilege_exec\"]\n\n    def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n        EOS specific implementation of register_configuration_session\n\n        Args:\n            session_name: name of session to register\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._create_configuration_session(session_name=session_name)\n        self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/arista_eos/sync_driver/#driver.core.arista_eos.sync_driver.EOSDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'arista_eos', genie_platform: str = '')</code>","text":"<p>EOSDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/arista_eos/sync_driver/#driver.core.arista_eos.sync_driver.EOSDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>str</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>'privilege_exec'</code> <code>auth_secondary</code> <code>str</code> <p>password to use for secondary authentication (enable)</p> <code>''</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar.</p> <code>None</code> <code>textfsm_platform</code> <code>str</code> <p>string name of textfsm parser platform</p> <code>'arista_eos'</code> <code>genie_platform</code> <code>str</code> <p>string name of cisco genie parser platform</p> <code>''</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/arista_eos/sync_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"arista_eos\",\n    genie_platform: str = \"\",\n):\n\"\"\"\n    EOSDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n    self.comms_prompt_pattern: str\n\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = eos_on_open\n    if on_close is None:\n        on_close = eos_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/arista_eos/sync_driver/#driver.core.arista_eos.sync_driver.EOSDriver.register_configuration_session","title":"<code>register_configuration_session(session_name: str) -&gt; None</code>","text":"<p>EOS specific implementation of register_configuration_session</p> <p>Parameters:</p> Name Type Description Default <code>session_name</code> <code>str</code> <p>name of session to register</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/arista_eos/sync_driver.py</code> <pre><code>def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n    EOS specific implementation of register_configuration_session\n\n    Args:\n        session_name: name of session to register\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._create_configuration_session(session_name=session_name)\n    self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/arista_eos/sync_driver/#driver.core.arista_eos.sync_driver.eos_on_close","title":"<code>eos_on_close(conn: NetworkDriver) -&gt; None</code>","text":"<p>EOSDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/arista_eos/sync_driver.py</code> <pre><code>def eos_on_close(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    EOSDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/arista_eos/sync_driver/#driver.core.arista_eos.sync_driver.eos_on_open","title":"<code>eos_on_open(conn: NetworkDriver) -&gt; None</code>","text":"<p>EOSDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/arista_eos/sync_driver.py</code> <pre><code>def eos_on_open(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    EOSDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.send_input(channel_input=\"terminal length 0\")\n    conn.channel.send_input(channel_input=\"terminal width 32767\")\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/","title":"cisco_iosxe","text":"<p>scrapli.driver.core.cisco_iosxe</p>"},{"location":"reference/driver/core/cisco_iosxe/async_driver/","title":"async_driver","text":"<p>scrapli.driver.core.cisco_iosxe.async_driver</p>"},{"location":"reference/driver/core/cisco_iosxe/async_driver/#driver.core.cisco_iosxe.async_driver.AsyncIOSXEDriver","title":"<code>AsyncIOSXEDriver</code>","text":"<p>         Bases: <code>AsyncNetworkDriver</code></p> Source code in <code>driver/core/cisco_iosxe/async_driver.py</code> <pre><code>class AsyncIOSXEDriver(AsyncNetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"cisco_iosxe\",\n        genie_platform: str = \"iosxe\",\n    ):\n\"\"\"\n        AsyncIOSXEDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = iosxe_on_open\n        if on_close is None:\n            on_close = iosxe_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/async_driver/#driver.core.cisco_iosxe.async_driver.AsyncIOSXEDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'cisco_iosxe', genie_platform: str = 'iosxe')</code>","text":"<p>AsyncIOSXEDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/cisco_iosxe/async_driver/#driver.core.cisco_iosxe.async_driver.AsyncIOSXEDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>str</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>'privilege_exec'</code> <code>auth_secondary</code> <code>str</code> <p>password to use for secondary authentication (enable)</p> <code>''</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar.</p> <code>None</code> <code>textfsm_platform</code> <code>str</code> <p>string name of textfsm parser platform</p> <code>'cisco_iosxe'</code> <code>genie_platform</code> <code>str</code> <p>string name of cisco genie parser platform</p> <code>'iosxe'</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/cisco_iosxe/async_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"cisco_iosxe\",\n    genie_platform: str = \"iosxe\",\n):\n\"\"\"\n    AsyncIOSXEDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = iosxe_on_open\n    if on_close is None:\n        on_close = iosxe_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/async_driver/#driver.core.cisco_iosxe.async_driver.iosxe_on_close","title":"<code>iosxe_on_close(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>AsyncIOSXEDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxe/async_driver.py</code> <pre><code>async def iosxe_on_close(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    AsyncIOSXEDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/async_driver/#driver.core.cisco_iosxe.async_driver.iosxe_on_open","title":"<code>iosxe_on_open(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>AsyncIOSXEDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxe/async_driver.py</code> <pre><code>async def iosxe_on_open(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    AsyncIOSXEDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    await conn.send_command(command=\"terminal length 0\")\n    await conn.send_command(command=\"terminal width 512\")\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/base_driver/","title":"base_driver","text":"<p>scrapli.driver.core.cisco_iosxe.base_driver</p>"},{"location":"reference/driver/core/cisco_iosxe/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.core.cisco_iosxe.sync_driver</p>"},{"location":"reference/driver/core/cisco_iosxe/sync_driver/#driver.core.cisco_iosxe.sync_driver.IOSXEDriver","title":"<code>IOSXEDriver</code>","text":"<p>         Bases: <code>NetworkDriver</code></p> Source code in <code>driver/core/cisco_iosxe/sync_driver.py</code> <pre><code>class IOSXEDriver(NetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"cisco_iosxe\",\n        genie_platform: str = \"iosxe\",\n    ):\n\"\"\"\n        IOSXEDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = iosxe_on_open\n        if on_close is None:\n            on_close = iosxe_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/sync_driver/#driver.core.cisco_iosxe.sync_driver.IOSXEDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'cisco_iosxe', genie_platform: str = 'iosxe')</code>","text":"<p>IOSXEDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/cisco_iosxe/sync_driver/#driver.core.cisco_iosxe.sync_driver.IOSXEDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>str</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>'privilege_exec'</code> <code>auth_secondary</code> <code>str</code> <p>password to use for secondary authentication (enable)</p> <code>''</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar.</p> <code>None</code> <code>textfsm_platform</code> <code>str</code> <p>string name of textfsm parser platform</p> <code>'cisco_iosxe'</code> <code>genie_platform</code> <code>str</code> <p>string name of cisco genie parser platform</p> <code>'iosxe'</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/cisco_iosxe/sync_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"cisco_iosxe\",\n    genie_platform: str = \"iosxe\",\n):\n\"\"\"\n    IOSXEDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = iosxe_on_open\n    if on_close is None:\n        on_close = iosxe_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/sync_driver/#driver.core.cisco_iosxe.sync_driver.iosxe_on_close","title":"<code>iosxe_on_close(conn: NetworkDriver) -&gt; None</code>","text":"<p>IOSXEDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxe/sync_driver.py</code> <pre><code>def iosxe_on_close(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    IOSXEDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxe/sync_driver/#driver.core.cisco_iosxe.sync_driver.iosxe_on_open","title":"<code>iosxe_on_open(conn: NetworkDriver) -&gt; None</code>","text":"<p>IOSXEDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxe/sync_driver.py</code> <pre><code>def iosxe_on_open(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    IOSXEDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.send_command(command=\"terminal length 0\")\n    conn.send_command(command=\"terminal width 512\")\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/","title":"cisco_iosxr","text":"<p>scrapli.driver.core.cisco_iosxr</p>"},{"location":"reference/driver/core/cisco_iosxr/async_driver/","title":"async_driver","text":"<p>scrapli.driver.core.cisco_iosxr.async_driver</p>"},{"location":"reference/driver/core/cisco_iosxr/async_driver/#driver.core.cisco_iosxr.async_driver.AsyncIOSXRDriver","title":"<code>AsyncIOSXRDriver</code>","text":"<p>         Bases: <code>AsyncNetworkDriver</code></p> Source code in <code>driver/core/cisco_iosxr/async_driver.py</code> <pre><code>class AsyncIOSXRDriver(AsyncNetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"cisco_xr\",\n        genie_platform: str = \"iosxr\",\n    ):\n\"\"\"\n        IOSXRDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            N/A  # noqa: DAR202\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = iosxr_on_open\n        if on_close is None:\n            on_close = iosxr_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    async def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort IOSXR configuration session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.channel.send_input(channel_input=\"abort\")\n        self._current_priv_level = self.privilege_levels[\"privilege_exec\"]\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/async_driver/#driver.core.cisco_iosxr.async_driver.AsyncIOSXRDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'cisco_xr', genie_platform: str = 'iosxr')</code>","text":"<p>IOSXRDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/cisco_iosxr/async_driver/#driver.core.cisco_iosxr.async_driver.AsyncIOSXRDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>str</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>'privilege_exec'</code> <code>auth_secondary</code> <code>str</code> <p>password to use for secondary authentication (enable)</p> <code>''</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar.</p> <code>None</code> <code>textfsm_platform</code> <code>str</code> <p>string name of textfsm parser platform</p> <code>'cisco_xr'</code> <code>genie_platform</code> <code>str</code> <p>string name of cisco genie parser platform</p> <code>'iosxr'</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <p>Returns:</p> Type Description <p>N/A  # noqa: DAR202</p> Source code in <code>driver/core/cisco_iosxr/async_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"cisco_xr\",\n    genie_platform: str = \"iosxr\",\n):\n\"\"\"\n    IOSXRDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        N/A  # noqa: DAR202\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = iosxr_on_open\n    if on_close is None:\n        on_close = iosxr_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/async_driver/#driver.core.cisco_iosxr.async_driver.iosxr_on_close","title":"<code>iosxr_on_close(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>IOSXRDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxr/async_driver.py</code> <pre><code>async def iosxr_on_close(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    IOSXRDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/async_driver/#driver.core.cisco_iosxr.async_driver.iosxr_on_open","title":"<code>iosxr_on_open(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>IOSXRDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxr/async_driver.py</code> <pre><code>async def iosxr_on_open(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    IOSXRDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    await conn.send_command(command=\"terminal length 0\")\n    await conn.send_command(command=\"terminal width 512\")\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/base_driver/","title":"base_driver","text":"<p>scrapli.driver.core.cisco_iosxr.base_driver</p>"},{"location":"reference/driver/core/cisco_iosxr/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.core.cisco_iosxr.sync_driver</p>"},{"location":"reference/driver/core/cisco_iosxr/sync_driver/#driver.core.cisco_iosxr.sync_driver.IOSXRDriver","title":"<code>IOSXRDriver</code>","text":"<p>         Bases: <code>NetworkDriver</code></p> Source code in <code>driver/core/cisco_iosxr/sync_driver.py</code> <pre><code>class IOSXRDriver(NetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"cisco_xr\",\n        genie_platform: str = \"iosxr\",\n    ):\n\"\"\"\n        IOSXRDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n            privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = iosxr_on_open\n        if on_close is None:\n            on_close = iosxr_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort IOSXR configuration session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.channel.send_input(channel_input=\"abort\")\n        self._current_priv_level = self.privilege_levels[\"privilege_exec\"]\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/sync_driver/#driver.core.cisco_iosxr.sync_driver.IOSXRDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'cisco_xr', genie_platform: str = 'iosxr')</code>","text":"<p>IOSXRDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/cisco_iosxr/sync_driver/#driver.core.cisco_iosxr.sync_driver.IOSXRDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <code>default_desired_privilege_level</code> <code>str</code> <p>string of name of default desired priv, this is the priv level that is generally used to disable paging/set terminal width and things like that upon first login, and is also the priv level scrapli will try to acquire for normal \"command\" operations (<code>send_command</code>, <code>send_commands</code>)</p> <code>'privilege_exec'</code> <code>auth_secondary</code> <code>str</code> <p>password to use for secondary authentication (enable)</p> <code>''</code> <code>on_open</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately after authentication is completed. Common use cases for this callable would be to disable paging or accept any kind of banner message that prompts a user upon connection</p> <code>None</code> <code>on_close</code> <code>Optional[Callable[..., Any]]</code> <p>callable that accepts the class instance as its only argument. this callable, if provided, is executed immediately prior to closing the underlying transport. Common use cases for this callable would be to save configurations prior to exiting, or to logout properly to free up vtys or similar.</p> <code>None</code> <code>textfsm_platform</code> <code>str</code> <p>string name of textfsm parser platform</p> <code>'cisco_xr'</code> <code>genie_platform</code> <code>str</code> <p>string name of cisco genie parser platform</p> <code>'iosxr'</code> <code>failed_when_contains</code> <code>Optional[List[str]]</code> <p>List of strings that indicate a command/config has failed</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/cisco_iosxr/sync_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"cisco_xr\",\n    genie_platform: str = \"iosxr\",\n):\n\"\"\"\n    IOSXRDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n        privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = iosxr_on_open\n    if on_close is None:\n        on_close = iosxr_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/sync_driver/#driver.core.cisco_iosxr.sync_driver.iosxr_on_close","title":"<code>iosxr_on_close(conn: NetworkDriver) -&gt; None</code>","text":"<p>IOSXRDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxr/sync_driver.py</code> <pre><code>def iosxr_on_close(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    IOSXRDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # write exit directly to the transport as channel would fail to find the prompt after sending\n    # the exit command!\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/cisco_iosxr/sync_driver/#driver.core.cisco_iosxr.sync_driver.iosxr_on_open","title":"<code>iosxr_on_open(conn: NetworkDriver) -&gt; None</code>","text":"<p>IOSXRDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_iosxr/sync_driver.py</code> <pre><code>def iosxr_on_open(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    IOSXRDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.send_command(command=\"terminal length 0\")\n    conn.send_command(command=\"terminal width 512\")\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/","title":"cisco_nxos","text":"<p>scrapli.driver.core.cisco_nxos</p>"},{"location":"reference/driver/core/cisco_nxos/async_driver/","title":"async_driver","text":"<p>scrapli.driver.core.cisco_nxos.async_driver</p>"},{"location":"reference/driver/core/cisco_nxos/async_driver/#driver.core.cisco_nxos.async_driver.AsyncNXOSDriver","title":"<code>AsyncNXOSDriver</code>","text":"<p>         Bases: <code>AsyncNetworkDriver</code>, <code>NXOSDriverBase</code></p> Source code in <code>driver/core/cisco_nxos/async_driver.py</code> <pre><code>class AsyncNXOSDriver(AsyncNetworkDriver, NXOSDriverBase):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"cisco_nxos\",\n        genie_platform: str = \"nxos\",\n    ):\n\"\"\"\n        NXOSDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n             privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n        self.comms_prompt_pattern: str\n\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = nxos_on_open\n        if on_close is None:\n            on_close = nxos_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    async def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort NXOS configuration session (if using a config session!)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # nxos pattern for config sessions should *always* have `config-s`\n        if \"config\\\\-s\" in self._current_priv_level.pattern:\n            await self.channel.send_input(channel_input=\"abort\")\n            self._current_priv_level = self.privilege_levels[\"privilege_exec\"]\n\n    def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n        NXOS specific implementation of register_configuration_session\n\n        Args:\n            session_name: name of session to register\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._create_configuration_session(session_name=session_name)\n        self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/async_driver/#driver.core.cisco_nxos.async_driver.AsyncNXOSDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'cisco_nxos', genie_platform: str = 'nxos')</code>","text":"<p>NXOSDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/cisco_nxos/async_driver/#driver.core.cisco_nxos.async_driver.AsyncNXOSDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <pre><code>default_desired_privilege_level: string of name of default desired priv, this is the\npriv level that is generally used to disable paging/set terminal width and things\nlike that upon first login, and is also the priv level scrapli will try to acquire\nfor normal \"command\" operations (`send_command`, `send_commands`)\nauth_secondary: password to use for secondary authentication (enable)\non_open: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately after authentication is completed. Common use\ncases for this callable would be to disable paging or accept any kind of banner\nmessage that prompts a user upon connection\non_close: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately prior to closing the underlying transport.\nCommon use cases for this callable would be to save configurations prior to exiting,\nor to logout properly to free up vtys or similar.\ntextfsm_platform: string name of textfsm parser platform\ngenie_platform: string name of cisco genie parser platform\nfailed_when_contains: List of strings that indicate a command/config has failed\n</code></pre> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/cisco_nxos/async_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"cisco_nxos\",\n    genie_platform: str = \"nxos\",\n):\n\"\"\"\n    NXOSDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n         privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n    self.comms_prompt_pattern: str\n\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = nxos_on_open\n    if on_close is None:\n        on_close = nxos_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/async_driver/#driver.core.cisco_nxos.async_driver.AsyncNXOSDriver.register_configuration_session","title":"<code>register_configuration_session(session_name: str) -&gt; None</code>","text":"<p>NXOS specific implementation of register_configuration_session</p> <p>Parameters:</p> Name Type Description Default <code>session_name</code> <code>str</code> <p>name of session to register</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_nxos/async_driver.py</code> <pre><code>def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n    NXOS specific implementation of register_configuration_session\n\n    Args:\n        session_name: name of session to register\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._create_configuration_session(session_name=session_name)\n    self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/async_driver/#driver.core.cisco_nxos.async_driver.nxos_on_close","title":"<code>nxos_on_close(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>AsyncNXOSDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_nxos/async_driver.py</code> <pre><code>async def nxos_on_close(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    AsyncNXOSDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/async_driver/#driver.core.cisco_nxos.async_driver.nxos_on_open","title":"<code>nxos_on_open(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>AsyncNXOSDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_nxos/async_driver.py</code> <pre><code>async def nxos_on_open(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    AsyncNXOSDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    await conn.send_command(command=\"terminal length 0\")\n    await conn.send_command(command=\"terminal width 511\")\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/base_driver/","title":"base_driver","text":"<p>scrapli.driver.core.cisco_nxos.base_driver</p>"},{"location":"reference/driver/core/cisco_nxos/base_driver/#driver.core.cisco_nxos.base_driver.NXOSDriverBase","title":"<code>NXOSDriverBase</code>","text":"Source code in <code>driver/core/cisco_nxos/base_driver.py</code> <pre><code>class NXOSDriverBase:\n    # NXOSDriverBase Mixin values set in init of sync/async NetworkDriver classes\n    privilege_levels: Dict[str, PrivilegeLevel]\n\n    def _create_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n        Handle configuration session creation tasks for consistency between sync/async versions\n\n        Args:\n            session_name: name of session to register\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliValueError: if a session of given name already exists\n\n        \"\"\"\n        if session_name in self.privilege_levels.keys():\n            msg = (\n                f\"session name `{session_name}` already registered as a privilege level, chose a \"\n                \"unique session name\"\n            )\n            raise ScrapliValueError(msg)\n        pattern = r\"^[a-z0-9.\\-_@/:]{1,32}\\(config\\-s[a-z0-9.\\-@/:]{0,32}\\)#\\s?$\"\n        name = session_name\n        config_session = PrivilegeLevel(\n            pattern=pattern,\n            name=name,\n            previous_priv=\"privilege_exec\",\n            deescalate=\"end\",\n            escalate=f\"configure session {session_name}\",\n            escalate_auth=False,\n            escalate_prompt=\"\",\n        )\n        self.privilege_levels[name] = config_session\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.core.cisco_nxos.sync_driver</p>"},{"location":"reference/driver/core/cisco_nxos/sync_driver/#driver.core.cisco_nxos.sync_driver.NXOSDriver","title":"<code>NXOSDriver</code>","text":"<p>         Bases: <code>NetworkDriver</code>, <code>NXOSDriverBase</code></p> Source code in <code>driver/core/cisco_nxos/sync_driver.py</code> <pre><code>class NXOSDriver(NetworkDriver, NXOSDriverBase):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"privilege_exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"cisco_nxos\",\n        genie_platform: str = \"nxos\",\n    ):\n\"\"\"\n        NXOSDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n             privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n        self.comms_prompt_pattern: str\n\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = nxos_on_open\n        if on_close is None:\n            on_close = nxos_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort NXOS configuration session (if using a config session!)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # nxos pattern for config sessions should *always* have `config-s`\n        if \"config\\\\-s\" in self._current_priv_level.pattern:\n            self.channel.send_input(channel_input=\"abort\")\n            self._current_priv_level = self.privilege_levels[\"privilege_exec\"]\n\n    def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n        NXOS specific implementation of register_configuration_session\n\n        Args:\n            session_name: name of session to register\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._create_configuration_session(session_name=session_name)\n        self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/sync_driver/#driver.core.cisco_nxos.sync_driver.NXOSDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'privilege_exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'cisco_nxos', genie_platform: str = 'nxos')</code>","text":"<p>NXOSDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/cisco_nxos/sync_driver/#driver.core.cisco_nxos.sync_driver.NXOSDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <pre><code>default_desired_privilege_level: string of name of default desired priv, this is the\npriv level that is generally used to disable paging/set terminal width and things\nlike that upon first login, and is also the priv level scrapli will try to acquire\nfor normal \"command\" operations (`send_command`, `send_commands`)\nauth_secondary: password to use for secondary authentication (enable)\non_open: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately after authentication is completed. Common use\ncases for this callable would be to disable paging or accept any kind of banner\nmessage that prompts a user upon connection\non_close: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately prior to closing the underlying transport.\nCommon use cases for this callable would be to save configurations prior to exiting,\nor to logout properly to free up vtys or similar.\ntextfsm_platform: string name of textfsm parser platform\ngenie_platform: string name of cisco genie parser platform\nfailed_when_contains: List of strings that indicate a command/config has failed\n</code></pre> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/cisco_nxos/sync_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"privilege_exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"cisco_nxos\",\n    genie_platform: str = \"nxos\",\n):\n\"\"\"\n    NXOSDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n         privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # somewhere/somehow the mixin is causing mypy to be upset about comms_prompt_pattern...\n    self.comms_prompt_pattern: str\n\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = nxos_on_open\n    if on_close is None:\n        on_close = nxos_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/sync_driver/#driver.core.cisco_nxos.sync_driver.NXOSDriver.register_configuration_session","title":"<code>register_configuration_session(session_name: str) -&gt; None</code>","text":"<p>NXOS specific implementation of register_configuration_session</p> <p>Parameters:</p> Name Type Description Default <code>session_name</code> <code>str</code> <p>name of session to register</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_nxos/sync_driver.py</code> <pre><code>def register_configuration_session(self, session_name: str) -&gt; None:\n\"\"\"\n    NXOS specific implementation of register_configuration_session\n\n    Args:\n        session_name: name of session to register\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._create_configuration_session(session_name=session_name)\n    self.update_privilege_levels()\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/sync_driver/#driver.core.cisco_nxos.sync_driver.nxos_on_close","title":"<code>nxos_on_close(conn: NetworkDriver) -&gt; None</code>","text":"<p>NXOSDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_nxos/sync_driver.py</code> <pre><code>def nxos_on_close(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    NXOSDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/cisco_nxos/sync_driver/#driver.core.cisco_nxos.sync_driver.nxos_on_open","title":"<code>nxos_on_open(conn: NetworkDriver) -&gt; None</code>","text":"<p>NXOSDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/cisco_nxos/sync_driver.py</code> <pre><code>def nxos_on_open(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    NXOSDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.send_command(command=\"terminal length 0\")\n    conn.send_command(command=\"terminal width 511\")\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/","title":"juniper_junos","text":"<p>scrapli.driver.core.juniper_junos</p>"},{"location":"reference/driver/core/juniper_junos/async_driver/","title":"async_driver","text":"<p>scrapli.driver.core.juniper_junos.async_driver</p>"},{"location":"reference/driver/core/juniper_junos/async_driver/#driver.core.juniper_junos.async_driver.AsyncJunosDriver","title":"<code>AsyncJunosDriver</code>","text":"<p>         Bases: <code>AsyncNetworkDriver</code></p> Source code in <code>driver/core/juniper_junos/async_driver.py</code> <pre><code>class AsyncJunosDriver(AsyncNetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"juniper_junos\",\n        genie_platform: str = \"\",\n    ):\n\"\"\"\n        JunosDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n             privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = junos_on_open\n        if on_close is None:\n            on_close = junos_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    async def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort Junos configuration session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.send_configs([\"rollback 0\", \"exit\"])\n        self._current_priv_level = self.privilege_levels[\"exec\"]\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/async_driver/#driver.core.juniper_junos.async_driver.AsyncJunosDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'juniper_junos', genie_platform: str = '')</code>","text":"<p>JunosDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/juniper_junos/async_driver/#driver.core.juniper_junos.async_driver.AsyncJunosDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <pre><code>default_desired_privilege_level: string of name of default desired priv, this is the\npriv level that is generally used to disable paging/set terminal width and things\nlike that upon first login, and is also the priv level scrapli will try to acquire\nfor normal \"command\" operations (`send_command`, `send_commands`)\nauth_secondary: password to use for secondary authentication (enable)\non_open: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately after authentication is completed. Common use\ncases for this callable would be to disable paging or accept any kind of banner\nmessage that prompts a user upon connection\non_close: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately prior to closing the underlying transport.\nCommon use cases for this callable would be to save configurations prior to exiting,\nor to logout properly to free up vtys or similar.\ntextfsm_platform: string name of textfsm parser platform\ngenie_platform: string name of cisco genie parser platform\nfailed_when_contains: List of strings that indicate a command/config has failed\n</code></pre> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/juniper_junos/async_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"juniper_junos\",\n    genie_platform: str = \"\",\n):\n\"\"\"\n    JunosDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n         privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = junos_on_open\n    if on_close is None:\n        on_close = junos_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/async_driver/#driver.core.juniper_junos.async_driver.junos_on_close","title":"<code>junos_on_close(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>JunosDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/juniper_junos/async_driver.py</code> <pre><code>async def junos_on_close(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    JunosDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/async_driver/#driver.core.juniper_junos.async_driver.junos_on_open","title":"<code>junos_on_open(conn: AsyncNetworkDriver) -&gt; None</code>  <code>async</code>","text":"<p>JunosDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/juniper_junos/async_driver.py</code> <pre><code>async def junos_on_open(conn: AsyncNetworkDriver) -&gt; None:\n\"\"\"\n    JunosDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    await conn.send_command(command=\"set cli screen-length 0\")\n    await conn.send_command(command=\"set cli screen-width 511\")\n    await conn.send_command(command=\"set cli complete-on-space off\")\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/base_driver/","title":"base_driver","text":"<p>scrapli.driver.core.juniper_junos.base_driver</p>"},{"location":"reference/driver/core/juniper_junos/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.core.juniper_junos.driver</p>"},{"location":"reference/driver/core/juniper_junos/sync_driver/#driver.core.juniper_junos.sync_driver.JunosDriver","title":"<code>JunosDriver</code>","text":"<p>         Bases: <code>NetworkDriver</code></p> Source code in <code>driver/core/juniper_junos/sync_driver.py</code> <pre><code>class JunosDriver(NetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n        default_desired_privilege_level: str = \"exec\",\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"juniper_junos\",\n        genie_platform: str = \"junos\",\n    ):\n\"\"\"\n        JunosDriver Object\n\n        Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n        # noqa: DAR101\n\n        Args:\n             privilege_levels: optional user provided privilege levels, if left None will default to\n                scrapli standard privilege levels\n            default_desired_privilege_level: string of name of default desired priv, this is the\n                priv level that is generally used to disable paging/set terminal width and things\n                like that upon first login, and is also the priv level scrapli will try to acquire\n                for normal \"command\" operations (`send_command`, `send_commands`)\n            auth_secondary: password to use for secondary authentication (enable)\n            on_open: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately after authentication is completed. Common use\n                cases for this callable would be to disable paging or accept any kind of banner\n                message that prompts a user upon connection\n            on_close: callable that accepts the class instance as its only argument. this callable,\n                if provided, is executed immediately prior to closing the underlying transport.\n                Common use cases for this callable would be to save configurations prior to exiting,\n                or to logout properly to free up vtys or similar.\n            textfsm_platform: string name of textfsm parser platform\n            genie_platform: string name of cisco genie parser platform.  Default: junos\n            failed_when_contains: List of strings that indicate a command/config has failed\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if privilege_levels is None:\n            privilege_levels = deepcopy(PRIVS)\n\n        if on_open is None:\n            on_open = junos_on_open\n        if on_close is None:\n            on_close = junos_on_close\n\n        if failed_when_contains is None:\n            failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n            privilege_levels=privilege_levels,\n            default_desired_privilege_level=default_desired_privilege_level,\n            auth_secondary=auth_secondary,\n            failed_when_contains=failed_when_contains,\n            textfsm_platform=textfsm_platform,\n            genie_platform=genie_platform,\n        )\n\n    def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort Junos configuration session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.send_configs([\"rollback 0\", \"exit\"])\n        self._current_priv_level = self.privilege_levels[\"exec\"]\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/sync_driver/#driver.core.juniper_junos.sync_driver.JunosDriver.__init__","title":"<code>__init__(host: str, privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None, default_desired_privilege_level: str = 'exec', port: Optional[int] = None, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_return_char: str = '\\n', ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Optional[Callable[..., Any]] = None, on_open: Optional[Callable[..., Any]] = None, on_close: Optional[Callable[..., Any]] = None, transport: str = 'system', transport_options: Optional[Dict[str, Any]] = None, channel_log: Union[str, bool, BytesIO] = False, channel_log_mode: str = 'write', channel_lock: bool = False, logging_uid: str = '', auth_secondary: str = '', failed_when_contains: Optional[List[str]] = None, textfsm_platform: str = 'juniper_junos', genie_platform: str = 'junos')</code>","text":"<p>JunosDriver Object</p> <p>Please see <code>scrapli.driver.base.base_driver.Driver</code> for all \"base driver\" arguments!</p>"},{"location":"reference/driver/core/juniper_junos/sync_driver/#driver.core.juniper_junos.sync_driver.JunosDriver.__init__--noqa-dar101","title":"noqa: DAR101","text":"<p>Parameters:</p> Name Type Description Default <code>privilege_levels</code> <code>Optional[Dict[str, PrivilegeLevel]]</code> <p>optional user provided privilege levels, if left None will default to scrapli standard privilege levels</p> <code>None</code> <pre><code>default_desired_privilege_level: string of name of default desired priv, this is the\npriv level that is generally used to disable paging/set terminal width and things\nlike that upon first login, and is also the priv level scrapli will try to acquire\nfor normal \"command\" operations (`send_command`, `send_commands`)\nauth_secondary: password to use for secondary authentication (enable)\non_open: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately after authentication is completed. Common use\ncases for this callable would be to disable paging or accept any kind of banner\nmessage that prompts a user upon connection\non_close: callable that accepts the class instance as its only argument. this callable,\nif provided, is executed immediately prior to closing the underlying transport.\nCommon use cases for this callable would be to save configurations prior to exiting,\nor to logout properly to free up vtys or similar.\ntextfsm_platform: string name of textfsm parser platform\ngenie_platform: string name of cisco genie parser platform.  Default: junos\nfailed_when_contains: List of strings that indicate a command/config has failed\n</code></pre> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/core/juniper_junos/sync_driver.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    privilege_levels: Optional[Dict[str, PrivilegeLevel]] = None,\n    default_desired_privilege_level: str = \"exec\",\n    port: Optional[int] = None,\n    auth_username: str = \"\",\n    auth_password: str = \"\",\n    auth_private_key: str = \"\",\n    auth_private_key_passphrase: str = \"\",\n    auth_strict_key: bool = True,\n    auth_bypass: bool = False,\n    timeout_socket: float = 15.0,\n    timeout_transport: float = 30.0,\n    timeout_ops: float = 30.0,\n    comms_return_char: str = \"\\n\",\n    ssh_config_file: Union[str, bool] = False,\n    ssh_known_hosts_file: Union[str, bool] = False,\n    on_init: Optional[Callable[..., Any]] = None,\n    on_open: Optional[Callable[..., Any]] = None,\n    on_close: Optional[Callable[..., Any]] = None,\n    transport: str = \"system\",\n    transport_options: Optional[Dict[str, Any]] = None,\n    channel_log: Union[str, bool, BytesIO] = False,\n    channel_log_mode: str = \"write\",\n    channel_lock: bool = False,\n    logging_uid: str = \"\",\n    auth_secondary: str = \"\",\n    failed_when_contains: Optional[List[str]] = None,\n    textfsm_platform: str = \"juniper_junos\",\n    genie_platform: str = \"junos\",\n):\n\"\"\"\n    JunosDriver Object\n\n    Please see `scrapli.driver.base.base_driver.Driver` for all \"base driver\" arguments!\n\n    # noqa: DAR101\n\n    Args:\n         privilege_levels: optional user provided privilege levels, if left None will default to\n            scrapli standard privilege levels\n        default_desired_privilege_level: string of name of default desired priv, this is the\n            priv level that is generally used to disable paging/set terminal width and things\n            like that upon first login, and is also the priv level scrapli will try to acquire\n            for normal \"command\" operations (`send_command`, `send_commands`)\n        auth_secondary: password to use for secondary authentication (enable)\n        on_open: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately after authentication is completed. Common use\n            cases for this callable would be to disable paging or accept any kind of banner\n            message that prompts a user upon connection\n        on_close: callable that accepts the class instance as its only argument. this callable,\n            if provided, is executed immediately prior to closing the underlying transport.\n            Common use cases for this callable would be to save configurations prior to exiting,\n            or to logout properly to free up vtys or similar.\n        textfsm_platform: string name of textfsm parser platform\n        genie_platform: string name of cisco genie parser platform.  Default: junos\n        failed_when_contains: List of strings that indicate a command/config has failed\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if privilege_levels is None:\n        privilege_levels = deepcopy(PRIVS)\n\n    if on_open is None:\n        on_open = junos_on_open\n    if on_close is None:\n        on_close = junos_on_close\n\n    if failed_when_contains is None:\n        failed_when_contains = FAILED_WHEN_CONTAINS.copy()\n\n    super().__init__(\n        host=host,\n        port=port,\n        auth_username=auth_username,\n        auth_password=auth_password,\n        auth_private_key=auth_private_key,\n        auth_private_key_passphrase=auth_private_key_passphrase,\n        auth_strict_key=auth_strict_key,\n        auth_bypass=auth_bypass,\n        timeout_socket=timeout_socket,\n        timeout_transport=timeout_transport,\n        timeout_ops=timeout_ops,\n        comms_return_char=comms_return_char,\n        ssh_config_file=ssh_config_file,\n        ssh_known_hosts_file=ssh_known_hosts_file,\n        on_init=on_init,\n        on_open=on_open,\n        on_close=on_close,\n        transport=transport,\n        transport_options=transport_options,\n        channel_log=channel_log,\n        channel_log_mode=channel_log_mode,\n        channel_lock=channel_lock,\n        logging_uid=logging_uid,\n        privilege_levels=privilege_levels,\n        default_desired_privilege_level=default_desired_privilege_level,\n        auth_secondary=auth_secondary,\n        failed_when_contains=failed_when_contains,\n        textfsm_platform=textfsm_platform,\n        genie_platform=genie_platform,\n    )\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/sync_driver/#driver.core.juniper_junos.sync_driver.junos_on_close","title":"<code>junos_on_close(conn: NetworkDriver) -&gt; None</code>","text":"<p>JunosDriver default on_close callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/juniper_junos/sync_driver.py</code> <pre><code>def junos_on_close(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    JunosDriver default on_close callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.channel.write(channel_input=\"exit\")\n    conn.channel.send_return()\n</code></pre>"},{"location":"reference/driver/core/juniper_junos/sync_driver/#driver.core.juniper_junos.sync_driver.junos_on_open","title":"<code>junos_on_open(conn: NetworkDriver) -&gt; None</code>","text":"<p>JunosDriver default on_open callable</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>NetworkDriver object</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/core/juniper_junos/sync_driver.py</code> <pre><code>def junos_on_open(conn: NetworkDriver) -&gt; None:\n\"\"\"\n    JunosDriver default on_open callable\n\n    Args:\n        conn: NetworkDriver object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    conn.acquire_priv(desired_priv=conn.default_desired_privilege_level)\n    conn.send_command(command=\"set cli screen-length 0\")\n    conn.send_command(command=\"set cli screen-width 511\")\n    conn.send_command(command=\"set cli complete-on-space off\")\n</code></pre>"},{"location":"reference/driver/generic/","title":"generic","text":"<p>scrapli.driver.generic</p>"},{"location":"reference/driver/generic/async_driver/","title":"async_driver","text":"<p>scrapli.driver.generic.async_driver</p>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver","title":"<code>AsyncGenericDriver</code>","text":"<p>         Bases: <code>AsyncDriver</code>, <code>BaseGenericDriver</code></p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>class AsyncGenericDriver(AsyncDriver, BaseGenericDriver):\n    def __init__(\n        self,\n        host: str,\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_prompt_pattern: str = r\"^\\S{0,48}[#&gt;$~@:\\]]\\s*$\",\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n    ) -&gt; None:\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_prompt_pattern=comms_prompt_pattern,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n        )\n\n    async def get_prompt(self) -&gt; str:\n\"\"\"\n        Convenience method to fetch prompt from the underlying Channel object\n\n        Args:\n            N/A\n\n        Returns:\n            str: string of the current prompt\n\n        Raises:\n            N/A\n\n        \"\"\"\n        prompt: str = await self.channel.get_prompt()\n        return prompt\n\n    @timeout_modifier\n    async def _send_command(\n        self,\n        command: str,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send a command\n\n        Private method so that we can handle `eager` w/out having to have that argument showing up\n        in all the methods that super to the \"normal\" send_command method as we only ever want eager\n        to be used for the plural options -- i.e. send_commands not send_command!\n\n        Args:\n            command: string to send to device in privilege exec mode\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            failed_when_contains: string or list of strings indicating failure if found in response\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            ScrapliValueError: if _base_transport_args is None for some reason\n\n        \"\"\"\n        # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n        _ = timeout_ops\n\n        if not self._base_transport_args:\n            # should not happen! :)\n            raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n        response = self._pre_send_command(\n            host=self._base_transport_args.host,\n            command=command,\n            failed_when_contains=failed_when_contains,\n        )\n        raw_response, processed_response = await self.channel.send_input(\n            channel_input=command, strip_prompt=strip_prompt, eager=eager\n        )\n        return self._post_send_command(\n            raw_response=raw_response, processed_response=processed_response, response=response\n        )\n\n    async def send_command(\n        self,\n        command: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send a command\n\n        Args:\n            command: string to send to device in privilege exec mode\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            failed_when_contains: string or list of strings indicating failure if found in response\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response: Response = await self._send_command(\n            command=command,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n        )\n        return response\n\n    async def send_commands(\n        self,\n        commands: List[str],\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send multiple commands\n\n        Args:\n            commands: list of strings to send to device in privilege exec mode\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        responses = self._pre_send_commands(commands=commands)\n        for command in commands[:-1]:\n            response = await self._send_command(\n                command=command,\n                strip_prompt=strip_prompt,\n                failed_when_contains=failed_when_contains,\n                timeout_ops=timeout_ops,\n                eager=eager,\n            )\n            responses.append(response)\n            if stop_on_failed and response.failed is True:\n                # should we find the prompt here w/ get_prompt?? or just let subsequent operations\n                # deal w/ finding that? future us problem? :)\n                break\n        else:\n            # if we did *not* break (i.e. no failure and/or no stop_on_failed) send the last command\n            # with eager = False -- this way we *always* find the prompt at the end of the commands\n            response = await self._send_command(\n                command=commands[-1],\n                strip_prompt=strip_prompt,\n                failed_when_contains=failed_when_contains,\n                timeout_ops=timeout_ops,\n                eager=False,\n            )\n            responses.append(response)\n\n        return responses\n\n    async def send_commands_from_file(\n        self,\n        file: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send command(s) from file\n\n        Args:\n            file: string path to file\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        commands = self._pre_send_from_file(file=file, caller=\"send_commands_from_file\")\n\n        return await self.send_commands(\n            commands=commands,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n    @timeout_modifier\n    async def send_and_read(\n        self,\n        channel_input: str,\n        *,\n        expected_outputs: Optional[List[str]] = None,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        timeout_ops: Optional[float] = None,\n        read_duration: float = 2.5,\n    ) -&gt; Response:\n\"\"\"\n        Send an input and read outputs.\n\n        Unlike \"normal\" scrapli behavior this method reads until the prompt(normal) OR until any of\n        a list of expected outputs is seen, OR until the read duration is exceeded. This method does\n        not care about/understand privilege levels. This *can* cause you some potential issues if\n        not used carefully!\n\n        Args:\n            channel_input: input to send to the channel; intentionally named \"channel_input\" instead\n                of \"command\" or \"config\" due to this method not caring about privilege levels\n            expected_outputs: List of outputs to look for in device response; returns as soon as any\n                of the outputs are seen\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n            read_duration:  float duration to read for\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            ScrapliValueError: if _base_transport_args is None for some reason\n\n        \"\"\"\n        # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n        _ = timeout_ops\n\n        if not self._base_transport_args:\n            # should not happen! :)\n            raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n        response = self._pre_send_command(\n            host=self._base_transport_args.host,\n            command=channel_input,\n            failed_when_contains=failed_when_contains,\n        )\n        raw_response, processed_response = await self.channel.send_input_and_read(\n            channel_input=channel_input,\n            strip_prompt=strip_prompt,\n            expected_outputs=expected_outputs,\n            read_duration=read_duration,\n        )\n        return self._post_send_command(\n            raw_response=raw_response, processed_response=processed_response, response=response\n        )\n\n    @timeout_modifier\n    async def send_interactive(\n        self,\n        interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n        *,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        privilege_level: str = \"\",\n        timeout_ops: Optional[float] = None,\n        interaction_complete_patterns: Optional[List[str]] = None,\n    ) -&gt; Response:\n\"\"\"\n        Interact with a device with changing prompts per input.\n\n        Used to interact with devices where prompts change per input, and where inputs may be hidden\n        such as in the case of a password input. This can be used to respond to challenges from\n        devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n        example. You may have as many elements in the \"interact_events\" list as needed, and each\n        element of that list should be a tuple of two or three elements. The first element is always\n        the input to send as a string, the second should be the expected response as a string, and\n        the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n        An example where we need this sort of capability:\n\n        ```\n        3560CX#copy flash: scp:\n        Source filename []? test1.txt\n        Address or name of remote host []? 172.31.254.100\n        Destination username [carl]?\n        Writing test1.txt\n        Password:\n\n        Password:\n         Sink: C0644 639 test1.txt\n        !\n        639 bytes copied in 12.066 secs (53 bytes/sec)\n        3560CX#\n        ```\n\n        To accomplish this we can use the following:\n\n        ```\n        interact = conn.channel.send_inputs_interact(\n            [\n                (\"copy flash: scp:\", \"Source filename []?\", False),\n                (\"test1.txt\", \"Address or name of remote host []?\", False),\n                (\"172.31.254.100\", \"Destination username [carl]?\", False),\n                (\"carl\", \"Password:\", False),\n                (\"super_secure_password\", prompt, True),\n            ]\n        )\n        ```\n\n        If we needed to deal with more prompts we could simply continue adding tuples to the list of\n        interact \"events\".\n\n        Args:\n            interact_events: list of tuples containing the \"interactions\" with the device\n                each list element must have an input and an expected response, and may have an\n                optional bool for the third and final element -- the optional bool specifies if the\n                input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n                not provided it is assumed the input is \"normal\" (not hidden)\n            failed_when_contains: list of strings that, if present in final output, represent a\n                failed command/interaction\n            privilege_level: ignored in this base class; for LSP reasons for subclasses\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n            interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n                \"session\" has ended and we should exit the interactive session.\n\n        Returns:\n            Response: scrapli Response object\n\n        Raises:\n            ScrapliValueError: if _base_transport_args is None for some reason\n\n        \"\"\"\n        # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n        _ = timeout_ops\n        # privilege level only matters \"up\" in the network driver layer\n        _ = privilege_level\n\n        if not self._base_transport_args:\n            # should not happen! :)\n            raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n        response = self._pre_send_interactive(\n            host=self._base_transport_args.host,\n            interact_events=interact_events,\n            failed_when_contains=failed_when_contains,\n        )\n        raw_response, processed_response = await self.channel.send_inputs_interact(\n            interact_events=interact_events,\n            interaction_complete_patterns=interaction_complete_patterns,\n        )\n        return self._post_send_command(\n            raw_response=raw_response, processed_response=processed_response, response=response\n        )\n\n    async def read_callback(  # noqa: C901\n        self,\n        callbacks: List[\"ReadCallback\"],\n        initial_input: Optional[str] = None,\n        read_output: bytes = b\"\",\n        read_delay: float = 0.1,\n        read_timeout: float = -1.0,\n    ) -&gt; \"ReadCallbackReturnable\":\nr\"\"\"\n        Read from a channel and react to the output with some callback.\n\n        This method is kind of like an \"advanced\" send_interactive -- the idea is simple: send some\n        \"stuff\" to the channel (optionally), and then read from the channel. Based on the output\n        do something. The callbacks is a list of `ReadCallback` which is an object containing the\n        actual callback to execute, some info about when to trigger that callback (also when *not*\n        to trigger that callback), as well as some attributes to control the next (if desired)\n        iteration of read_callback. You could in theory do basically everything with this method by\n        chaining callbacks forever, but you probably don't want to do that for real!\n\n        Example usage:\n\n        ```\n        from scrapli.driver.core import IOSXEDriver\n        from scrapli.driver.generic.base_driver import ReadCallback\n        from scrapli.driver.generic.sync_driver import GenericDriver\n\n        device = {\n            \"host\": \"rtr1\",\n            \"auth_strict_key\": False,\n            \"ssh_config_file\": True,\n        }\n\n        def callback_one(cls: GenericDriver, read_output: str):\n            cls.acquire_priv(\"configuration\")\n            cls.channel.send_return()\n\n\n        def callback_two(cls: GenericDriver, read_output: str):\n            print(f\"previous read output : {read_output}\")\n\n            r = cls.send_command(\"show run | i hostname\")\n            print(f\"result: {r.result}\")\n\n\n        with IOSXEDriver(**device) as conn:\n            callbacks = [\n                ReadCallback(\n                    contains=\"rtr1#\",\n                    callback=callback_one,\n                    name=\"call1\",\n                    case_insensitive=False\n                ),\n                ReadCallback(\n                    contains_re=r\"^rtr1\\(config\\)#\",\n                    callback=callback_two,\n                    complete=True,\n                )\n            ]\n            conn.read_callback(callbacks=callbacks, initial_input=\"show run | i hostname\")\n        ```\n\n        Args:\n            callbacks: a list of ReadCallback objects\n            initial_input: optional string to send to \"kick off\" the read_callback method\n            read_output: optional bytes to append any new reads to\n            read_delay: sleep interval between reads\n            read_timeout: value to set the `transport_timeout` to for the duration of the reading\n                portion of this method. If left default (-1.0) or set to anything below 0, the\n                transport timeout value will be left alone (whatever the timeout_transport value is)\n                otherwise, the provided value will be temporarily set as the timeout_transport for\n                duration of the reading.\n\n        Returns:\n            ReadCallbackReturnable: either None or call to read_callback again\n\n        Raises:\n            ScrapliTimeout: if the read operation times out (base don the read_timeout value) during\n                the read callback check.\n\n        \"\"\"\n        if initial_input is not None:\n            self.channel.write(channel_input=f\"{initial_input}{self.comms_return_char}\")\n            return await self.read_callback(callbacks=callbacks, initial_input=None)\n\n        original_transport_timeout = self.timeout_transport\n\n        # if the read_timeout value is -1.0 or just less than 0, that indicates we should use\n        # the \"normal\" transport timeout and not modify anything\n        self.timeout_transport = read_timeout if read_timeout &gt;= 0 else self.timeout_transport\n\n        _read_delay = 0.1 if read_delay &lt;= 0 else read_delay\n\n        while True:\n            try:\n                read_output += await self.channel.read()\n            except ScrapliTimeout as exc:\n                self.timeout_transport = original_transport_timeout\n\n                raise ScrapliTimeout(\"timeout during read in read_callback operation\") from exc\n\n            for callback in callbacks:\n                _run_callback = callback.check(read_output=read_output)\n\n                if (\n                    callback.only_once is True\n                    and callback._triggered is True  # pylint: disable=W0212\n                ):\n                    self.logger.warning(\n                        f\"callback {callback.name} matches but is set to 'only_once', \"\n                        \"skipping this callback\"\n                    )\n\n                    continue\n\n                if _run_callback is True:\n                    self.logger.info(f\"callback {callback.name} matched, executing\")\n\n                    self.timeout_transport = original_transport_timeout\n\n                    coro = callback.run(driver=self)\n                    if coro is not None:\n                        # should always be a coroutine in this case, this appeases mypy\n                        await coro\n\n                    if callback.complete:\n                        self.logger.debug(\"callback complete is true, done with read_callback\")\n                        return None\n\n                    if callback.reset_output:\n                        read_output = b\"\"\n\n                    return await self.read_callback(\n                        callbacks=callbacks,\n                        initial_input=None,\n                        read_output=read_output,\n                        read_delay=callback.next_delay,\n                        read_timeout=callback.next_timeout,\n                    )\n\n            await asyncio.sleep(_read_delay)\n</code></pre>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver.get_prompt","title":"<code>get_prompt() -&gt; str</code>  <code>async</code>","text":"<p>Convenience method to fetch prompt from the underlying Channel object</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string of the current prompt</p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>async def get_prompt(self) -&gt; str:\n\"\"\"\n    Convenience method to fetch prompt from the underlying Channel object\n\n    Args:\n        N/A\n\n    Returns:\n        str: string of the current prompt\n\n    Raises:\n        N/A\n\n    \"\"\"\n    prompt: str = await self.channel.get_prompt()\n    return prompt\n</code></pre>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver.read_callback","title":"<code>read_callback(callbacks: List[ReadCallback], initial_input: Optional[str] = None, read_output: bytes = b'', read_delay: float = 0.1, read_timeout: float = -1.0) -&gt; ReadCallbackReturnable</code>  <code>async</code>","text":"<p>Read from a channel and react to the output with some callback.</p> <p>This method is kind of like an \"advanced\" send_interactive -- the idea is simple: send some \"stuff\" to the channel (optionally), and then read from the channel. Based on the output do something. The callbacks is a list of <code>ReadCallback</code> which is an object containing the actual callback to execute, some info about when to trigger that callback (also when not to trigger that callback), as well as some attributes to control the next (if desired) iteration of read_callback. You could in theory do basically everything with this method by chaining callbacks forever, but you probably don't want to do that for real!</p> <p>Example usage:</p> <pre><code>from scrapli.driver.core import IOSXEDriver\nfrom scrapli.driver.generic.base_driver import ReadCallback\nfrom scrapli.driver.generic.sync_driver import GenericDriver\n\ndevice = {\n    \"host\": \"rtr1\",\n    \"auth_strict_key\": False,\n    \"ssh_config_file\": True,\n}\n\ndef callback_one(cls: GenericDriver, read_output: str):\n    cls.acquire_priv(\"configuration\")\n    cls.channel.send_return()\n\n\ndef callback_two(cls: GenericDriver, read_output: str):\n    print(f\"previous read output : {read_output}\")\n\n    r = cls.send_command(\"show run | i hostname\")\n    print(f\"result: {r.result}\")\n\n\nwith IOSXEDriver(**device) as conn:\n    callbacks = [\n        ReadCallback(\n            contains=\"rtr1#\",\n            callback=callback_one,\n            name=\"call1\",\n            case_insensitive=False\n        ),\n        ReadCallback(\n            contains_re=r\"^rtr1\\(config\\)#\",\n            callback=callback_two,\n            complete=True,\n        )\n    ]\n    conn.read_callback(callbacks=callbacks, initial_input=\"show run | i hostname\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callbacks</code> <code>List[ReadCallback]</code> <p>a list of ReadCallback objects</p> required <code>initial_input</code> <code>Optional[str]</code> <p>optional string to send to \"kick off\" the read_callback method</p> <code>None</code> <code>read_output</code> <code>bytes</code> <p>optional bytes to append any new reads to</p> <code>b''</code> <code>read_delay</code> <code>float</code> <p>sleep interval between reads</p> <code>0.1</code> <code>read_timeout</code> <code>float</code> <p>value to set the <code>transport_timeout</code> to for the duration of the reading portion of this method. If left default (-1.0) or set to anything below 0, the transport timeout value will be left alone (whatever the timeout_transport value is) otherwise, the provided value will be temporarily set as the timeout_transport for duration of the reading.</p> <code>-1.0</code> <p>Returns:</p> Name Type Description <code>ReadCallbackReturnable</code> <code>ReadCallbackReturnable</code> <p>either None or call to read_callback again</p> <p>Raises:</p> Type Description <code>ScrapliTimeout</code> <p>if the read operation times out (base don the read_timeout value) during the read callback check.</p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>async def read_callback(  # noqa: C901\n    self,\n    callbacks: List[\"ReadCallback\"],\n    initial_input: Optional[str] = None,\n    read_output: bytes = b\"\",\n    read_delay: float = 0.1,\n    read_timeout: float = -1.0,\n) -&gt; \"ReadCallbackReturnable\":\nr\"\"\"\n    Read from a channel and react to the output with some callback.\n\n    This method is kind of like an \"advanced\" send_interactive -- the idea is simple: send some\n    \"stuff\" to the channel (optionally), and then read from the channel. Based on the output\n    do something. The callbacks is a list of `ReadCallback` which is an object containing the\n    actual callback to execute, some info about when to trigger that callback (also when *not*\n    to trigger that callback), as well as some attributes to control the next (if desired)\n    iteration of read_callback. You could in theory do basically everything with this method by\n    chaining callbacks forever, but you probably don't want to do that for real!\n\n    Example usage:\n\n    ```\n    from scrapli.driver.core import IOSXEDriver\n    from scrapli.driver.generic.base_driver import ReadCallback\n    from scrapli.driver.generic.sync_driver import GenericDriver\n\n    device = {\n        \"host\": \"rtr1\",\n        \"auth_strict_key\": False,\n        \"ssh_config_file\": True,\n    }\n\n    def callback_one(cls: GenericDriver, read_output: str):\n        cls.acquire_priv(\"configuration\")\n        cls.channel.send_return()\n\n\n    def callback_two(cls: GenericDriver, read_output: str):\n        print(f\"previous read output : {read_output}\")\n\n        r = cls.send_command(\"show run | i hostname\")\n        print(f\"result: {r.result}\")\n\n\n    with IOSXEDriver(**device) as conn:\n        callbacks = [\n            ReadCallback(\n                contains=\"rtr1#\",\n                callback=callback_one,\n                name=\"call1\",\n                case_insensitive=False\n            ),\n            ReadCallback(\n                contains_re=r\"^rtr1\\(config\\)#\",\n                callback=callback_two,\n                complete=True,\n            )\n        ]\n        conn.read_callback(callbacks=callbacks, initial_input=\"show run | i hostname\")\n    ```\n\n    Args:\n        callbacks: a list of ReadCallback objects\n        initial_input: optional string to send to \"kick off\" the read_callback method\n        read_output: optional bytes to append any new reads to\n        read_delay: sleep interval between reads\n        read_timeout: value to set the `transport_timeout` to for the duration of the reading\n            portion of this method. If left default (-1.0) or set to anything below 0, the\n            transport timeout value will be left alone (whatever the timeout_transport value is)\n            otherwise, the provided value will be temporarily set as the timeout_transport for\n            duration of the reading.\n\n    Returns:\n        ReadCallbackReturnable: either None or call to read_callback again\n\n    Raises:\n        ScrapliTimeout: if the read operation times out (base don the read_timeout value) during\n            the read callback check.\n\n    \"\"\"\n    if initial_input is not None:\n        self.channel.write(channel_input=f\"{initial_input}{self.comms_return_char}\")\n        return await self.read_callback(callbacks=callbacks, initial_input=None)\n\n    original_transport_timeout = self.timeout_transport\n\n    # if the read_timeout value is -1.0 or just less than 0, that indicates we should use\n    # the \"normal\" transport timeout and not modify anything\n    self.timeout_transport = read_timeout if read_timeout &gt;= 0 else self.timeout_transport\n\n    _read_delay = 0.1 if read_delay &lt;= 0 else read_delay\n\n    while True:\n        try:\n            read_output += await self.channel.read()\n        except ScrapliTimeout as exc:\n            self.timeout_transport = original_transport_timeout\n\n            raise ScrapliTimeout(\"timeout during read in read_callback operation\") from exc\n\n        for callback in callbacks:\n            _run_callback = callback.check(read_output=read_output)\n\n            if (\n                callback.only_once is True\n                and callback._triggered is True  # pylint: disable=W0212\n            ):\n                self.logger.warning(\n                    f\"callback {callback.name} matches but is set to 'only_once', \"\n                    \"skipping this callback\"\n                )\n\n                continue\n\n            if _run_callback is True:\n                self.logger.info(f\"callback {callback.name} matched, executing\")\n\n                self.timeout_transport = original_transport_timeout\n\n                coro = callback.run(driver=self)\n                if coro is not None:\n                    # should always be a coroutine in this case, this appeases mypy\n                    await coro\n\n                if callback.complete:\n                    self.logger.debug(\"callback complete is true, done with read_callback\")\n                    return None\n\n                if callback.reset_output:\n                    read_output = b\"\"\n\n                return await self.read_callback(\n                    callbacks=callbacks,\n                    initial_input=None,\n                    read_output=read_output,\n                    read_delay=callback.next_delay,\n                    read_timeout=callback.next_timeout,\n                )\n\n        await asyncio.sleep(_read_delay)\n</code></pre>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver.send_and_read","title":"<code>send_and_read(channel_input: str, *, expected_outputs: Optional[List[str]] = None, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, timeout_ops: Optional[float] = None, read_duration: float = 2.5) -&gt; Response</code>  <code>async</code>","text":"<p>Send an input and read outputs.</p> <p>Unlike \"normal\" scrapli behavior this method reads until the prompt(normal) OR until any of a list of expected outputs is seen, OR until the read duration is exceeded. This method does not care about/understand privilege levels. This can cause you some potential issues if not used carefully!</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>str</code> <p>input to send to the channel; intentionally named \"channel_input\" instead of \"command\" or \"config\" due to this method not caring about privilege levels</p> required <code>expected_outputs</code> <code>Optional[List[str]]</code> <p>List of outputs to look for in device response; returns as soon as any of the outputs are seen</p> <code>None</code> <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <code>read_duration</code> <code>float</code> <p>float duration to read for</p> <code>2.5</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if _base_transport_args is None for some reason</p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>@timeout_modifier\nasync def send_and_read(\n    self,\n    channel_input: str,\n    *,\n    expected_outputs: Optional[List[str]] = None,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    timeout_ops: Optional[float] = None,\n    read_duration: float = 2.5,\n) -&gt; Response:\n\"\"\"\n    Send an input and read outputs.\n\n    Unlike \"normal\" scrapli behavior this method reads until the prompt(normal) OR until any of\n    a list of expected outputs is seen, OR until the read duration is exceeded. This method does\n    not care about/understand privilege levels. This *can* cause you some potential issues if\n    not used carefully!\n\n    Args:\n        channel_input: input to send to the channel; intentionally named \"channel_input\" instead\n            of \"command\" or \"config\" due to this method not caring about privilege levels\n        expected_outputs: List of outputs to look for in device response; returns as soon as any\n            of the outputs are seen\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n        read_duration:  float duration to read for\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        ScrapliValueError: if _base_transport_args is None for some reason\n\n    \"\"\"\n    # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n    _ = timeout_ops\n\n    if not self._base_transport_args:\n        # should not happen! :)\n        raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n    response = self._pre_send_command(\n        host=self._base_transport_args.host,\n        command=channel_input,\n        failed_when_contains=failed_when_contains,\n    )\n    raw_response, processed_response = await self.channel.send_input_and_read(\n        channel_input=channel_input,\n        strip_prompt=strip_prompt,\n        expected_outputs=expected_outputs,\n        read_duration=read_duration,\n    )\n    return self._post_send_command(\n        raw_response=raw_response, processed_response=processed_response, response=response\n    )\n</code></pre>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver.send_command","title":"<code>send_command(command: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, timeout_ops: Optional[float] = None) -&gt; Response</code>  <code>async</code>","text":"<p>Send a command</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>string to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>async def send_command(\n    self,\n    command: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    timeout_ops: Optional[float] = None,\n) -&gt; Response:\n\"\"\"\n    Send a command\n\n    Args:\n        command: string to send to device in privilege exec mode\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        failed_when_contains: string or list of strings indicating failure if found in response\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    response: Response = await self._send_command(\n        command=command,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        timeout_ops=timeout_ops,\n    )\n    return response\n</code></pre>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver.send_commands","title":"<code>send_commands(commands: List[str], *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>  <code>async</code>","text":"<p>Send multiple commands</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[str]</code> <p>list of strings to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>async def send_commands(\n    self,\n    commands: List[str],\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send multiple commands\n\n    Args:\n        commands: list of strings to send to device in privilege exec mode\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    responses = self._pre_send_commands(commands=commands)\n    for command in commands[:-1]:\n        response = await self._send_command(\n            command=command,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n            eager=eager,\n        )\n        responses.append(response)\n        if stop_on_failed and response.failed is True:\n            # should we find the prompt here w/ get_prompt?? or just let subsequent operations\n            # deal w/ finding that? future us problem? :)\n            break\n    else:\n        # if we did *not* break (i.e. no failure and/or no stop_on_failed) send the last command\n        # with eager = False -- this way we *always* find the prompt at the end of the commands\n        response = await self._send_command(\n            command=commands[-1],\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n            eager=False,\n        )\n        responses.append(response)\n\n    return responses\n</code></pre>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver.send_commands_from_file","title":"<code>send_commands_from_file(file: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>  <code>async</code>","text":"<p>Send command(s) from file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>string path to file</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>async def send_commands_from_file(\n    self,\n    file: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send command(s) from file\n\n    Args:\n        file: string path to file\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    commands = self._pre_send_from_file(file=file, caller=\"send_commands_from_file\")\n\n    return await self.send_commands(\n        commands=commands,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n</code></pre>"},{"location":"reference/driver/generic/async_driver/#driver.generic.async_driver.AsyncGenericDriver.send_interactive","title":"<code>send_interactive(interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]], *, failed_when_contains: Optional[Union[str, List[str]]] = None, privilege_level: str = '', timeout_ops: Optional[float] = None, interaction_complete_patterns: Optional[List[str]] = None) -&gt; Response</code>  <code>async</code>","text":"<p>Interact with a device with changing prompts per input.</p> <p>Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)</p> <p>An example where we need this sort of capability:</p> <pre><code>3560CX#copy flash: scp:\nSource filename []? test1.txt\nAddress or name of remote host []? 172.31.254.100\nDestination username [carl]?\nWriting test1.txt\nPassword:\n\nPassword:\n Sink: C0644 639 test1.txt\n!\n639 bytes copied in 12.066 secs (53 bytes/sec)\n3560CX#\n</code></pre> <p>To accomplish this we can use the following:</p> <pre><code>interact = conn.channel.send_inputs_interact(\n    [\n        (\"copy flash: scp:\", \"Source filename []?\", False),\n        (\"test1.txt\", \"Address or name of remote host []?\", False),\n        (\"172.31.254.100\", \"Destination username [carl]?\", False),\n        (\"carl\", \"Password:\", False),\n        (\"super_secure_password\", prompt, True),\n    ]\n)\n</code></pre> <p>If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\".</p> <p>Parameters:</p> Name Type Description Default <code>interact_events</code> <code>Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]]</code> <p>list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden)</p> required <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>list of strings that, if present in final output, represent a failed command/interaction</p> <code>None</code> <code>privilege_level</code> <code>str</code> <p>ignored in this base class; for LSP reasons for subclasses</p> <code>''</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <code>interaction_complete_patterns</code> <code>Optional[List[str]]</code> <p>list of patterns, that if seen, indicate the interactive \"session\" has ended and we should exit the interactive session.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>scrapli Response object</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if _base_transport_args is None for some reason</p> Source code in <code>driver/generic/async_driver.py</code> <pre><code>@timeout_modifier\nasync def send_interactive(\n    self,\n    interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n    *,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    privilege_level: str = \"\",\n    timeout_ops: Optional[float] = None,\n    interaction_complete_patterns: Optional[List[str]] = None,\n) -&gt; Response:\n\"\"\"\n    Interact with a device with changing prompts per input.\n\n    Used to interact with devices where prompts change per input, and where inputs may be hidden\n    such as in the case of a password input. This can be used to respond to challenges from\n    devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n    example. You may have as many elements in the \"interact_events\" list as needed, and each\n    element of that list should be a tuple of two or three elements. The first element is always\n    the input to send as a string, the second should be the expected response as a string, and\n    the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n    An example where we need this sort of capability:\n\n    ```\n    3560CX#copy flash: scp:\n    Source filename []? test1.txt\n    Address or name of remote host []? 172.31.254.100\n    Destination username [carl]?\n    Writing test1.txt\n    Password:\n\n    Password:\n     Sink: C0644 639 test1.txt\n    !\n    639 bytes copied in 12.066 secs (53 bytes/sec)\n    3560CX#\n    ```\n\n    To accomplish this we can use the following:\n\n    ```\n    interact = conn.channel.send_inputs_interact(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"test1.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"carl\", \"Password:\", False),\n            (\"super_secure_password\", prompt, True),\n        ]\n    )\n    ```\n\n    If we needed to deal with more prompts we could simply continue adding tuples to the list of\n    interact \"events\".\n\n    Args:\n        interact_events: list of tuples containing the \"interactions\" with the device\n            each list element must have an input and an expected response, and may have an\n            optional bool for the third and final element -- the optional bool specifies if the\n            input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n            not provided it is assumed the input is \"normal\" (not hidden)\n        failed_when_contains: list of strings that, if present in final output, represent a\n            failed command/interaction\n        privilege_level: ignored in this base class; for LSP reasons for subclasses\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n        interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n            \"session\" has ended and we should exit the interactive session.\n\n    Returns:\n        Response: scrapli Response object\n\n    Raises:\n        ScrapliValueError: if _base_transport_args is None for some reason\n\n    \"\"\"\n    # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n    _ = timeout_ops\n    # privilege level only matters \"up\" in the network driver layer\n    _ = privilege_level\n\n    if not self._base_transport_args:\n        # should not happen! :)\n        raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n    response = self._pre_send_interactive(\n        host=self._base_transport_args.host,\n        interact_events=interact_events,\n        failed_when_contains=failed_when_contains,\n    )\n    raw_response, processed_response = await self.channel.send_inputs_interact(\n        interact_events=interact_events,\n        interaction_complete_patterns=interaction_complete_patterns,\n    )\n    return self._post_send_command(\n        raw_response=raw_response, processed_response=processed_response, response=response\n    )\n</code></pre>"},{"location":"reference/driver/generic/base_driver/","title":"base_driver","text":"<p>scrapli.driver.generic.base_driver</p>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.BaseGenericDriver","title":"<code>BaseGenericDriver</code>","text":"Source code in <code>driver/generic/base_driver.py</code> <pre><code>class BaseGenericDriver:\n    @staticmethod\n    def _pre_send_command(\n        host: str, command: str, failed_when_contains: Optional[Union[str, List[str]]] = None\n    ) -&gt; Response:\n\"\"\"\n        Handle pre \"send_command\" tasks for consistency between sync/async versions\n\n        Args:\n            host: string name of the host\n            command: string to send to device in privilege exec mode\n            failed_when_contains: string or list of strings indicating failure if found in response\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            ScrapliTypeError: if command is anything but a string\n\n        \"\"\"\n        if not isinstance(command, str):\n            raise ScrapliTypeError(\n                f\"`send_command` expects a single string, got {type(command)}, \"\n                \"to send a list of commands use the `send_commands` method instead.\"\n            )\n\n        return Response(\n            host=host,\n            channel_input=command,\n            failed_when_contains=failed_when_contains,\n        )\n\n    @staticmethod\n    def _post_send_command(\n        raw_response: bytes, processed_response: bytes, response: Response\n    ) -&gt; Response:\n\"\"\"\n        Handle post \"send_command\" tasks for consistency between sync/async versions\n\n        Args:\n            raw_response: raw response returned from the channel\n            processed_response: processed response returned from the channel\n            response: response object to update with channel results\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(result=processed_response)\n        response.raw_result = raw_response\n        return response\n\n    @staticmethod\n    def _pre_send_commands(commands: List[str]) -&gt; MultiResponse:\n\"\"\"\n        Handle pre \"send_command\" tasks for consistency between sync/async versions\n\n        Args:\n            commands: list of strings to send to device in privilege exec mode\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            ScrapliTypeError: if command is anything but a string\n\n        \"\"\"\n        if not isinstance(commands, list):\n            raise ScrapliTypeError(\n                f\"`send_commands` expects a list of strings, got {type(commands)}, \"\n                \"to send a single command use the `send_command` method instead.\"\n            )\n\n        return MultiResponse()\n\n    @staticmethod\n    def _pre_send_from_file(file: str, caller: str) -&gt; List[str]:\n\"\"\"\n        Handle pre \"send_*_from_file\" tasks for consistency between sync/async versions\n\n        Args:\n            file: string path to file\n            caller: name of the calling method for more helpful error message\n\n        Returns:\n            list: list of commands/configs read from file\n\n        Raises:\n            ScrapliTypeError: if anything but a string is provided for `file`\n\n        \"\"\"\n        if not isinstance(file, str):\n            raise ScrapliTypeError(f\"`{caller}` expects a string path to a file, got {type(file)}\")\n        resolved_file = resolve_file(file)\n\n        with open(resolved_file, \"r\", encoding=\"utf-8\") as f:\n            commands = f.read().splitlines()\n\n        return commands\n\n    @classmethod\n    def _pre_send_interactive(\n        cls,\n        host: str,\n        interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n    ) -&gt; Response:\n\"\"\"\n        Handle pre \"send_interactive\" tasks for consistency between sync/async versions\n\n        Args:\n            host: string name of the host\n            interact_events: list of tuples containing the \"interactions\" with the device\n                each list element must have an input and an expected response, and may have an\n                optional bool for the third and final element -- the optional bool specifies if the\n                input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n                not provided it is assumed the input is \"normal\" (not hidden)\n            failed_when_contains: string or list of strings indicating failure if found in response\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        joined_input = \", \".join(event[0] for event in interact_events)\n        return cls._pre_send_command(\n            host=host, command=joined_input, failed_when_contains=failed_when_contains\n        )\n</code></pre>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.ReadCallback","title":"<code>ReadCallback</code>","text":"Source code in <code>driver/generic/base_driver.py</code> <pre><code>class ReadCallback:\n    def __init__(\n        self,\n        callback: Callable[\n            [Union[\"GenericDriver\", \"AsyncGenericDriver\"], str],\n            Union[None, Coroutine[Any, Any, None]],\n        ],\n        contains: str = \"\",\n        not_contains: str = \"\",\n        contains_re: str = \"\",\n        case_insensitive: bool = True,\n        multiline: bool = True,\n        reset_output: bool = True,\n        only_once: bool = False,\n        next_delay: float = -1.0,\n        next_timeout: float = -1.0,\n        complete: bool = False,\n        name: str = \"\",\n    ):\n\"\"\"\n        Object representing a single callback to be used with `GenericDriver` `read_callback` method\n\n        Though the callable is typed with GenericDriver and AsyncGenericDriver, the callable can of\n        course accept a NetworkDriver or AsyncNetworkDriver or any class extending those, you just\n        may get some IDE/mypy complaints!\n\n        Args:\n            callback: callback function to execute, callback function must accept instance of the\n                class as first argument, and the  \"read_output\" as second\n            contains: string of text that, if in the read output, indicates to execute this callback\n            not_contains: string of text that should *not* be contained in the output\n            contains_re: string of a regex pattern that will be compiled and used to match the\n                callback\n            case_insensitive: ignored unless contains_re provided, sets re.I on compiled regex\n            multiline: ignored unless contains_re provided, sets re.M on compiled regex\n            reset_output: bool indicating to reset (clear) the output or to pass the output along\n                to the next iteration. Sometimes you may want to clear the output to not\n                accidentally continue matching on one callback over and over again. You could also\n                use `only_once` to help with that\n            only_once: bool indicating if this callback should only ever be executed one time\n            next_delay: optional sleep between reads for next callback check\n            next_timeout: optionally set the transport timeout (to timeout the read operation) for\n                the subsequent callback checks -- the default value of -1.0 will tell scrapli to use\n                the \"normal\" transport timeout for the operation\n            complete: bool indicating if this is the \"last\" callback to execute\n            name: friendly name to give the callback, will be function name if not provided\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.name = name\n        if self.name == \"\":\n            self.name = callback.__name__\n\n        self.callback = callback\n\n        self.contains = contains\n        self._contains_bytes = b\"\"\n\n        self.not_contains = not_contains\n        self._not_contains_bytes = b\"\"\n\n        self.contains_re = contains_re\n        self._contains_re_bytes: Optional[Pattern[bytes]] = None\n\n        self.case_insensitive = case_insensitive\n        self.multiline = multiline\n        self.reset_output = reset_output\n\n        self.only_once = only_once\n        self._triggered = False\n\n        self.next_delay = next_delay\n        self.next_timeout = next_timeout\n\n        self.complete = complete\n\n        self._read_output = b\"\"\n\n    @property\n    def contains_bytes(self) -&gt; bytes:\n\"\"\"\n        Property to encode provided not contains if requested\n\n        Args:\n            N/A\n\n        Returns:\n            bytes: encoded not contains string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.contains and not self._contains_bytes:\n            self._contains_bytes = self.contains.encode()\n\n        return self._contains_bytes\n\n    @property\n    def not_contains_bytes(self) -&gt; bytes:\n\"\"\"\n        Property to encode provided contains if requested\n\n        Args:\n            N/A\n\n        Returns:\n            bytes: encoded contains string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.not_contains and not self._not_contains_bytes:\n            self._not_contains_bytes = self.not_contains.encode()\n\n        return self._not_contains_bytes\n\n    @property\n    def contains_re_bytes(self) -&gt; Pattern[bytes]:\n\"\"\"\n        Property to encode provided regex contains if requested\n\n        Args:\n            N/A\n\n        Returns:\n            re.Pattern: compiled bytes pattern\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not self._contains_re_bytes:\n            flags = 0\n\n            if self.case_insensitive and self.multiline:\n                flags = re.I | re.M\n            elif self.case_insensitive:\n                flags = re.I\n            elif self.multiline:\n                flags = re.M\n\n            self._contains_re_bytes = re.compile(pattern=self.contains_re.encode(), flags=flags)\n\n        return self._contains_re_bytes\n\n    def check(self, read_output: bytes) -&gt; bool:\n\"\"\"\n        Determine if a callback has matched based on device output\n\n        Args:\n            read_output: bytes read from the device\n\n        Returns:\n            bool: True/False indicating if the callback \"matches\" the output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._read_output = read_output\n\n        if self.case_insensitive:\n            _read_output = read_output.lower()\n        else:\n            _read_output = read_output\n\n        if (\n            self.contains_bytes\n            and self.contains_bytes in _read_output\n            and not (self.not_contains and self.not_contains_bytes in _read_output)\n        ):\n            return True\n\n        if (\n            self.contains_re\n            and re.search(self.contains_re_bytes, _read_output)\n            and not (self.not_contains and self.not_contains_bytes in _read_output)\n        ):\n            return True\n\n        return False\n\n    def run(\n        self, driver: Union[\"GenericDriver\", \"AsyncGenericDriver\"]\n    ) -&gt; Union[None, Awaitable[Any]]:\n\"\"\"\n        Run the callback\n\n        Args:\n            driver: driver object to pass to the callback function\n\n        Returns:\n            Union[None, Awaitable[Any]]: return the result of the callable if sync or the future\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.only_once is True:\n            self._triggered = True\n\n        return self.callback(driver, self._read_output.decode())\n</code></pre>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.ReadCallback.__init__","title":"<code>__init__(callback: Callable[[Union[GenericDriver, AsyncGenericDriver], str], Union[None, Coroutine[Any, Any, None]]], contains: str = '', not_contains: str = '', contains_re: str = '', case_insensitive: bool = True, multiline: bool = True, reset_output: bool = True, only_once: bool = False, next_delay: float = -1.0, next_timeout: float = -1.0, complete: bool = False, name: str = '')</code>","text":"<p>Object representing a single callback to be used with <code>GenericDriver</code> <code>read_callback</code> method</p> <p>Though the callable is typed with GenericDriver and AsyncGenericDriver, the callable can of course accept a NetworkDriver or AsyncNetworkDriver or any class extending those, you just may get some IDE/mypy complaints!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Union[GenericDriver, AsyncGenericDriver], str], Union[None, Coroutine[Any, Any, None]]]</code> <p>callback function to execute, callback function must accept instance of the class as first argument, and the  \"read_output\" as second</p> required <code>contains</code> <code>str</code> <p>string of text that, if in the read output, indicates to execute this callback</p> <code>''</code> <code>not_contains</code> <code>str</code> <p>string of text that should not be contained in the output</p> <code>''</code> <code>contains_re</code> <code>str</code> <p>string of a regex pattern that will be compiled and used to match the callback</p> <code>''</code> <code>case_insensitive</code> <code>bool</code> <p>ignored unless contains_re provided, sets re.I on compiled regex</p> <code>True</code> <code>multiline</code> <code>bool</code> <p>ignored unless contains_re provided, sets re.M on compiled regex</p> <code>True</code> <code>reset_output</code> <code>bool</code> <p>bool indicating to reset (clear) the output or to pass the output along to the next iteration. Sometimes you may want to clear the output to not accidentally continue matching on one callback over and over again. You could also use <code>only_once</code> to help with that</p> <code>True</code> <code>only_once</code> <code>bool</code> <p>bool indicating if this callback should only ever be executed one time</p> <code>False</code> <code>next_delay</code> <code>float</code> <p>optional sleep between reads for next callback check</p> <code>-1.0</code> <code>next_timeout</code> <code>float</code> <p>optionally set the transport timeout (to timeout the read operation) for the subsequent callback checks -- the default value of -1.0 will tell scrapli to use the \"normal\" transport timeout for the operation</p> <code>-1.0</code> <code>complete</code> <code>bool</code> <p>bool indicating if this is the \"last\" callback to execute</p> <code>False</code> <code>name</code> <code>str</code> <p>friendly name to give the callback, will be function name if not provided</p> <code>''</code> <p>Returns:</p> Type Description <p>N/A</p> Source code in <code>driver/generic/base_driver.py</code> <pre><code>def __init__(\n    self,\n    callback: Callable[\n        [Union[\"GenericDriver\", \"AsyncGenericDriver\"], str],\n        Union[None, Coroutine[Any, Any, None]],\n    ],\n    contains: str = \"\",\n    not_contains: str = \"\",\n    contains_re: str = \"\",\n    case_insensitive: bool = True,\n    multiline: bool = True,\n    reset_output: bool = True,\n    only_once: bool = False,\n    next_delay: float = -1.0,\n    next_timeout: float = -1.0,\n    complete: bool = False,\n    name: str = \"\",\n):\n\"\"\"\n    Object representing a single callback to be used with `GenericDriver` `read_callback` method\n\n    Though the callable is typed with GenericDriver and AsyncGenericDriver, the callable can of\n    course accept a NetworkDriver or AsyncNetworkDriver or any class extending those, you just\n    may get some IDE/mypy complaints!\n\n    Args:\n        callback: callback function to execute, callback function must accept instance of the\n            class as first argument, and the  \"read_output\" as second\n        contains: string of text that, if in the read output, indicates to execute this callback\n        not_contains: string of text that should *not* be contained in the output\n        contains_re: string of a regex pattern that will be compiled and used to match the\n            callback\n        case_insensitive: ignored unless contains_re provided, sets re.I on compiled regex\n        multiline: ignored unless contains_re provided, sets re.M on compiled regex\n        reset_output: bool indicating to reset (clear) the output or to pass the output along\n            to the next iteration. Sometimes you may want to clear the output to not\n            accidentally continue matching on one callback over and over again. You could also\n            use `only_once` to help with that\n        only_once: bool indicating if this callback should only ever be executed one time\n        next_delay: optional sleep between reads for next callback check\n        next_timeout: optionally set the transport timeout (to timeout the read operation) for\n            the subsequent callback checks -- the default value of -1.0 will tell scrapli to use\n            the \"normal\" transport timeout for the operation\n        complete: bool indicating if this is the \"last\" callback to execute\n        name: friendly name to give the callback, will be function name if not provided\n\n    Returns:\n        N/A\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.name = name\n    if self.name == \"\":\n        self.name = callback.__name__\n\n    self.callback = callback\n\n    self.contains = contains\n    self._contains_bytes = b\"\"\n\n    self.not_contains = not_contains\n    self._not_contains_bytes = b\"\"\n\n    self.contains_re = contains_re\n    self._contains_re_bytes: Optional[Pattern[bytes]] = None\n\n    self.case_insensitive = case_insensitive\n    self.multiline = multiline\n    self.reset_output = reset_output\n\n    self.only_once = only_once\n    self._triggered = False\n\n    self.next_delay = next_delay\n    self.next_timeout = next_timeout\n\n    self.complete = complete\n\n    self._read_output = b\"\"\n</code></pre>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.ReadCallback.check","title":"<code>check(read_output: bytes) -&gt; bool</code>","text":"<p>Determine if a callback has matched based on device output</p> <p>Parameters:</p> Name Type Description Default <code>read_output</code> <code>bytes</code> <p>bytes read from the device</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True/False indicating if the callback \"matches\" the output</p> Source code in <code>driver/generic/base_driver.py</code> <pre><code>def check(self, read_output: bytes) -&gt; bool:\n\"\"\"\n    Determine if a callback has matched based on device output\n\n    Args:\n        read_output: bytes read from the device\n\n    Returns:\n        bool: True/False indicating if the callback \"matches\" the output\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._read_output = read_output\n\n    if self.case_insensitive:\n        _read_output = read_output.lower()\n    else:\n        _read_output = read_output\n\n    if (\n        self.contains_bytes\n        and self.contains_bytes in _read_output\n        and not (self.not_contains and self.not_contains_bytes in _read_output)\n    ):\n        return True\n\n    if (\n        self.contains_re\n        and re.search(self.contains_re_bytes, _read_output)\n        and not (self.not_contains and self.not_contains_bytes in _read_output)\n    ):\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.ReadCallback.contains_bytes","title":"<code>contains_bytes() -&gt; bytes</code>  <code>property</code>","text":"<p>Property to encode provided not contains if requested</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>encoded not contains string</p> Source code in <code>driver/generic/base_driver.py</code> <pre><code>@property\ndef contains_bytes(self) -&gt; bytes:\n\"\"\"\n    Property to encode provided not contains if requested\n\n    Args:\n        N/A\n\n    Returns:\n        bytes: encoded not contains string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if self.contains and not self._contains_bytes:\n        self._contains_bytes = self.contains.encode()\n\n    return self._contains_bytes\n</code></pre>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.ReadCallback.contains_re_bytes","title":"<code>contains_re_bytes() -&gt; Pattern[bytes]</code>  <code>property</code>","text":"<p>Property to encode provided regex contains if requested</p> <p>Returns:</p> Type Description <code>Pattern[bytes]</code> <p>re.Pattern: compiled bytes pattern</p> Source code in <code>driver/generic/base_driver.py</code> <pre><code>@property\ndef contains_re_bytes(self) -&gt; Pattern[bytes]:\n\"\"\"\n    Property to encode provided regex contains if requested\n\n    Args:\n        N/A\n\n    Returns:\n        re.Pattern: compiled bytes pattern\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if not self._contains_re_bytes:\n        flags = 0\n\n        if self.case_insensitive and self.multiline:\n            flags = re.I | re.M\n        elif self.case_insensitive:\n            flags = re.I\n        elif self.multiline:\n            flags = re.M\n\n        self._contains_re_bytes = re.compile(pattern=self.contains_re.encode(), flags=flags)\n\n    return self._contains_re_bytes\n</code></pre>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.ReadCallback.not_contains_bytes","title":"<code>not_contains_bytes() -&gt; bytes</code>  <code>property</code>","text":"<p>Property to encode provided contains if requested</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>encoded contains string</p> Source code in <code>driver/generic/base_driver.py</code> <pre><code>@property\ndef not_contains_bytes(self) -&gt; bytes:\n\"\"\"\n    Property to encode provided contains if requested\n\n    Args:\n        N/A\n\n    Returns:\n        bytes: encoded contains string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if self.not_contains and not self._not_contains_bytes:\n        self._not_contains_bytes = self.not_contains.encode()\n\n    return self._not_contains_bytes\n</code></pre>"},{"location":"reference/driver/generic/base_driver/#driver.generic.base_driver.ReadCallback.run","title":"<code>run(driver: Union[GenericDriver, AsyncGenericDriver]) -&gt; Union[None, Awaitable[Any]]</code>","text":"<p>Run the callback</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>Union[GenericDriver, AsyncGenericDriver]</code> <p>driver object to pass to the callback function</p> required <p>Returns:</p> Type Description <code>Union[None, Awaitable[Any]]</code> <p>Union[None, Awaitable[Any]]: return the result of the callable if sync or the future</p> Source code in <code>driver/generic/base_driver.py</code> <pre><code>def run(\n    self, driver: Union[\"GenericDriver\", \"AsyncGenericDriver\"]\n) -&gt; Union[None, Awaitable[Any]]:\n\"\"\"\n    Run the callback\n\n    Args:\n        driver: driver object to pass to the callback function\n\n    Returns:\n        Union[None, Awaitable[Any]]: return the result of the callable if sync or the future\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if self.only_once is True:\n        self._triggered = True\n\n    return self.callback(driver, self._read_output.decode())\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.generic.sync_driver</p>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver","title":"<code>GenericDriver</code>","text":"<p>         Bases: <code>Driver</code>, <code>BaseGenericDriver</code></p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>class GenericDriver(Driver, BaseGenericDriver):\n    def __init__(\n        self,\n        host: str,\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_prompt_pattern: str = r\"^\\S{0,48}[#&gt;$~@:\\]]\\s*$\",\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n    ) -&gt; None:\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_prompt_pattern=comms_prompt_pattern,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n        )\n\n    def get_prompt(self) -&gt; str:\n\"\"\"\n        Convenience method to fetch prompt from the underlying Channel object\n\n        Args:\n            N/A\n\n        Returns:\n            str: string of the current prompt\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # assigned/typed here as decorator indicates return of Any\n        prompt: str = self.channel.get_prompt()\n        return prompt\n\n    @timeout_modifier\n    def _send_command(\n        self,\n        command: str,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send a command\n\n        Private method so that we can handle `eager` w/out having to have that argument showing up\n        in all the methods that super to the \"normal\" send_command method as we only ever want eager\n        to be used for the plural options -- i.e. send_commands not send_command!\n\n        Args:\n            command: string to send to device in privilege exec mode\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            failed_when_contains: string or list of strings indicating failure if found in response\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            ScrapliValueError: if _base_transport_args is None for some reason\n\n        \"\"\"\n        # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n        _ = timeout_ops\n\n        if not self._base_transport_args:\n            # should not happen! :)\n            raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n        response = self._pre_send_command(\n            host=self._base_transport_args.host,\n            command=command,\n            failed_when_contains=failed_when_contains,\n        )\n        raw_response, processed_response = self.channel.send_input(\n            channel_input=command, strip_prompt=strip_prompt, eager=eager\n        )\n        return self._post_send_command(\n            raw_response=raw_response, processed_response=processed_response, response=response\n        )\n\n    def send_command(\n        self,\n        command: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send a command\n\n        Args:\n            command: string to send to device in privilege exec mode\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            failed_when_contains: string or list of strings indicating failure if found in response\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response: Response = self._send_command(\n            command=command,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n        )\n        return response\n\n    def send_commands(\n        self,\n        commands: List[str],\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send multiple commands\n\n        Args:\n            commands: list of strings to send to device in privilege exec mode\n            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        responses = self._pre_send_commands(commands=commands)\n        for command in commands[:-1]:\n            response = self._send_command(\n                command=command,\n                strip_prompt=strip_prompt,\n                failed_when_contains=failed_when_contains,\n                timeout_ops=timeout_ops,\n                eager=eager,\n            )\n            responses.append(response)\n            if stop_on_failed and response.failed is True:\n                # should we find the prompt here w/ get_prompt?? or just let subsequent operations\n                # deal w/ finding that? future us problem? :)\n                break\n        else:\n            # if we did *not* break (i.e. no failure and/or no stop_on_failed) send the last command\n            # with eager = False -- this way we *always* find the prompt at the end of the commands\n            response = self._send_command(\n                command=commands[-1],\n                strip_prompt=strip_prompt,\n                failed_when_contains=failed_when_contains,\n                timeout_ops=timeout_ops,\n                eager=False,\n            )\n            responses.append(response)\n\n        return responses\n\n    def send_commands_from_file(\n        self,\n        file: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send command(s) from file\n\n        Args:\n            file: string path to file\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        commands = self._pre_send_from_file(file=file, caller=\"send_commands_from_file\")\n\n        return self.send_commands(\n            commands=commands,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n    @timeout_modifier\n    def send_and_read(\n        self,\n        channel_input: str,\n        *,\n        expected_outputs: Optional[List[str]] = None,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        timeout_ops: Optional[float] = None,\n        read_duration: float = 2.5,\n    ) -&gt; Response:\n\"\"\"\n        Send an input and read outputs.\n\n        Unlike \"normal\" scrapli behavior this method reads until the prompt(normal) OR until any of\n        a list of expected outputs is seen, OR until the read duration is exceeded. This method does\n        not care about/understand privilege levels. This *can* cause you some potential issues if\n        not used carefully!\n\n        Args:\n            channel_input: input to send to the channel; intentionally named \"channel_input\" instead\n                of \"command\" or \"config\" due to this method not caring about privilege levels\n            expected_outputs: List of outputs to look for in device response; returns as soon as any\n                of the outputs are seen\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n            read_duration:  float duration to read for\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            ScrapliValueError: if _base_transport_args is None for some reason\n\n        \"\"\"\n        # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n        _ = timeout_ops\n\n        if not self._base_transport_args:\n            # should not happen! :)\n            raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n        response = self._pre_send_command(\n            host=self._base_transport_args.host,\n            command=channel_input,\n            failed_when_contains=failed_when_contains,\n        )\n        raw_response, processed_response = self.channel.send_input_and_read(\n            channel_input=channel_input,\n            strip_prompt=strip_prompt,\n            expected_outputs=expected_outputs,\n            read_duration=read_duration,\n        )\n        return self._post_send_command(\n            raw_response=raw_response, processed_response=processed_response, response=response\n        )\n\n    @timeout_modifier\n    def send_interactive(\n        self,\n        interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n        *,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        privilege_level: str = \"\",\n        timeout_ops: Optional[float] = None,\n        interaction_complete_patterns: Optional[List[str]] = None,\n    ) -&gt; Response:\n\"\"\"\n        Interact with a device with changing prompts per input.\n\n        Used to interact with devices where prompts change per input, and where inputs may be hidden\n        such as in the case of a password input. This can be used to respond to challenges from\n        devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n        example. You may have as many elements in the \"interact_events\" list as needed, and each\n        element of that list should be a tuple of two or three elements. The first element is always\n        the input to send as a string, the second should be the expected response as a string, and\n        the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n        An example where we need this sort of capability:\n\n        ```\n        3560CX#copy flash: scp:\n        Source filename []? test1.txt\n        Address or name of remote host []? 172.31.254.100\n        Destination username [carl]?\n        Writing test1.txt\n        Password:\n\n        Password:\n         Sink: C0644 639 test1.txt\n        !\n        639 bytes copied in 12.066 secs (53 bytes/sec)\n        3560CX#\n        ```\n\n        To accomplish this we can use the following:\n\n        ```\n        interact = conn.channel.send_inputs_interact(\n            [\n                (\"copy flash: scp:\", \"Source filename []?\", False),\n                (\"test1.txt\", \"Address or name of remote host []?\", False),\n                (\"172.31.254.100\", \"Destination username [carl]?\", False),\n                (\"carl\", \"Password:\", False),\n                (\"super_secure_password\", prompt, True),\n            ]\n        )\n        ```\n\n        If we needed to deal with more prompts we could simply continue adding tuples to the list of\n        interact \"events\".\n\n        Args:\n            interact_events: list of tuples containing the \"interactions\" with the device\n                each list element must have an input and an expected response, and may have an\n                optional bool for the third and final element -- the optional bool specifies if the\n                input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n                not provided it is assumed the input is \"normal\" (not hidden)\n            failed_when_contains: list of strings that, if present in final output, represent a\n                failed command/interaction\n            privilege_level: ignored in this base class; for LSP reasons for subclasses\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n            interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n                \"session\" has ended and we should exit the interactive session.\n\n        Returns:\n            Response: scrapli Response object\n\n        Raises:\n            ScrapliValueError: if _base_transport_args is None for some reason\n\n        \"\"\"\n        # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n        _ = timeout_ops\n        # privilege level only matters \"up\" in the network driver layer\n        _ = privilege_level\n\n        if not self._base_transport_args:\n            # should not happen! :)\n            raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n        response = self._pre_send_interactive(\n            host=self._base_transport_args.host,\n            interact_events=interact_events,\n            failed_when_contains=failed_when_contains,\n        )\n        raw_response, processed_response = self.channel.send_inputs_interact(\n            interact_events=interact_events,\n            interaction_complete_patterns=interaction_complete_patterns,\n        )\n        return self._post_send_command(\n            raw_response=raw_response, processed_response=processed_response, response=response\n        )\n\n    def read_callback(\n        self,\n        callbacks: List[\"ReadCallback\"],\n        initial_input: Optional[str] = None,\n        read_output: bytes = b\"\",\n        read_delay: float = 0.1,\n        read_timeout: float = -1.0,\n    ) -&gt; \"ReadCallbackReturnable\":\nr\"\"\"\n        Read from a channel and react to the output with some callback.\n\n        This method is kind of like an \"advanced\" send_interactive -- the idea is simple: send some\n        \"stuff\" to the channel (optionally), and then read from the channel. Based on the output\n        do something. The callbacks is a list of `ReadCallback` which is an object containing the\n        actual callback to execute, some info about when to trigger that callback (also when *not*\n        to trigger that callback), as well as some attributes to control the next (if desired)\n        iteration of read_callback. You could in theory do basically everything with this method by\n        chaining callbacks forever, but you probably don't want to do that for real!\n\n        Example usage:\n\n        ```\n        from scrapli.driver.core import IOSXEDriver\n        from scrapli.driver.generic.base_driver import ReadCallback\n        from scrapli.driver.generic.sync_driver import GenericDriver\n\n        device = {\n            \"host\": \"rtr1\",\n            \"auth_strict_key\": False,\n            \"ssh_config_file\": True,\n        }\n\n        def callback_one(cls: GenericDriver, read_output: str):\n            cls.acquire_priv(\"configuration\")\n            cls.channel.send_return()\n\n\n        def callback_two(cls: GenericDriver, read_output: str):\n            print(f\"previous read output : {read_output}\")\n\n            r = cls.send_command(\"show run | i hostname\")\n            print(f\"result: {r.result}\")\n\n\n        with IOSXEDriver(**device) as conn:\n            callbacks = [\n                ReadCallback(\n                    contains=\"rtr1#\",\n                    callback=callback_one,\n                    name=\"call1\",\n                    case_insensitive=False\n                ),\n                ReadCallback(\n                    contains_re=r\"^rtr1\\(config\\)#\",\n                    callback=callback_two,\n                    complete=True,\n                )\n            ]\n            conn.read_callback(callbacks=callbacks, initial_input=\"show run | i hostname\")\n        ```\n\n        Args:\n            callbacks: a list of ReadCallback objects\n            initial_input: optional string to send to \"kick off\" the read_callback method\n            read_output: optional bytes to append any new reads to\n            read_delay: sleep interval between reads\n            read_timeout: value to set the `transport_timeout` to for the duration of the reading\n                portion of this method. If left default (-1.0) or set to anything below 0, the\n                transport timeout value will be left alone (whatever the timeout_transport value is)\n                otherwise, the provided value will be temporarily set as the timeout_transport for\n                duration of the reading.\n\n        Returns:\n            ReadCallbackReturnable: either None or call to read_callback again\n\n        Raises:\n            ScrapliTimeout: if the read operation times out (base don the read_timeout value) during\n                the read callback check.\n\n        \"\"\"\n        if initial_input is not None:\n            self.channel.write(channel_input=f\"{initial_input}{self.comms_return_char}\")\n            return self.read_callback(callbacks=callbacks, initial_input=None)\n\n        original_transport_timeout = self.timeout_transport\n\n        # if the read_timeout value is -1.0 or just less than 0, that indicates we should use\n        # the \"normal\" transport timeout and not modify anything\n        self.timeout_transport = read_timeout if read_timeout &gt;= 0 else self.timeout_transport\n\n        _read_delay = 0.1 if read_delay &lt;= 0 else read_delay\n\n        while True:\n            try:\n                read_output += self.channel.read()\n            except ScrapliTimeout as exc:\n                self.timeout_transport = original_transport_timeout\n\n                raise ScrapliTimeout(\"timeout during read in read_callback operation\") from exc\n\n            for callback in callbacks:\n                _run_callback = callback.check(read_output=read_output)\n\n                if (\n                    callback.only_once is True\n                    and callback._triggered is True  # pylint: disable=W0212\n                ):\n                    self.logger.warning(\n                        f\"callback {callback.name} matches but is set to 'only_once', \"\n                        \"skipping this callback\"\n                    )\n\n                    continue\n\n                if _run_callback is True:\n                    self.logger.info(f\"callback {callback.name} matched, executing\")\n\n                    self.timeout_transport = original_transport_timeout\n\n                    callback.run(driver=self)\n\n                    if callback.complete:\n                        self.logger.debug(\"callback complete is true, done with read_callback\")\n                        return None\n\n                    if callback.reset_output:\n                        read_output = b\"\"\n\n                    return self.read_callback(\n                        callbacks=callbacks,\n                        initial_input=None,\n                        read_output=read_output,\n                        read_delay=callback.next_delay,\n                        read_timeout=callback.next_timeout,\n                    )\n\n            time.sleep(_read_delay)\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver.get_prompt","title":"<code>get_prompt() -&gt; str</code>","text":"<p>Convenience method to fetch prompt from the underlying Channel object</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>string of the current prompt</p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>def get_prompt(self) -&gt; str:\n\"\"\"\n    Convenience method to fetch prompt from the underlying Channel object\n\n    Args:\n        N/A\n\n    Returns:\n        str: string of the current prompt\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # assigned/typed here as decorator indicates return of Any\n    prompt: str = self.channel.get_prompt()\n    return prompt\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver.read_callback","title":"<code>read_callback(callbacks: List[ReadCallback], initial_input: Optional[str] = None, read_output: bytes = b'', read_delay: float = 0.1, read_timeout: float = -1.0) -&gt; ReadCallbackReturnable</code>","text":"<p>Read from a channel and react to the output with some callback.</p> <p>This method is kind of like an \"advanced\" send_interactive -- the idea is simple: send some \"stuff\" to the channel (optionally), and then read from the channel. Based on the output do something. The callbacks is a list of <code>ReadCallback</code> which is an object containing the actual callback to execute, some info about when to trigger that callback (also when not to trigger that callback), as well as some attributes to control the next (if desired) iteration of read_callback. You could in theory do basically everything with this method by chaining callbacks forever, but you probably don't want to do that for real!</p> <p>Example usage:</p> <pre><code>from scrapli.driver.core import IOSXEDriver\nfrom scrapli.driver.generic.base_driver import ReadCallback\nfrom scrapli.driver.generic.sync_driver import GenericDriver\n\ndevice = {\n    \"host\": \"rtr1\",\n    \"auth_strict_key\": False,\n    \"ssh_config_file\": True,\n}\n\ndef callback_one(cls: GenericDriver, read_output: str):\n    cls.acquire_priv(\"configuration\")\n    cls.channel.send_return()\n\n\ndef callback_two(cls: GenericDriver, read_output: str):\n    print(f\"previous read output : {read_output}\")\n\n    r = cls.send_command(\"show run | i hostname\")\n    print(f\"result: {r.result}\")\n\n\nwith IOSXEDriver(**device) as conn:\n    callbacks = [\n        ReadCallback(\n            contains=\"rtr1#\",\n            callback=callback_one,\n            name=\"call1\",\n            case_insensitive=False\n        ),\n        ReadCallback(\n            contains_re=r\"^rtr1\\(config\\)#\",\n            callback=callback_two,\n            complete=True,\n        )\n    ]\n    conn.read_callback(callbacks=callbacks, initial_input=\"show run | i hostname\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callbacks</code> <code>List[ReadCallback]</code> <p>a list of ReadCallback objects</p> required <code>initial_input</code> <code>Optional[str]</code> <p>optional string to send to \"kick off\" the read_callback method</p> <code>None</code> <code>read_output</code> <code>bytes</code> <p>optional bytes to append any new reads to</p> <code>b''</code> <code>read_delay</code> <code>float</code> <p>sleep interval between reads</p> <code>0.1</code> <code>read_timeout</code> <code>float</code> <p>value to set the <code>transport_timeout</code> to for the duration of the reading portion of this method. If left default (-1.0) or set to anything below 0, the transport timeout value will be left alone (whatever the timeout_transport value is) otherwise, the provided value will be temporarily set as the timeout_transport for duration of the reading.</p> <code>-1.0</code> <p>Returns:</p> Name Type Description <code>ReadCallbackReturnable</code> <code>ReadCallbackReturnable</code> <p>either None or call to read_callback again</p> <p>Raises:</p> Type Description <code>ScrapliTimeout</code> <p>if the read operation times out (base don the read_timeout value) during the read callback check.</p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>def read_callback(\n    self,\n    callbacks: List[\"ReadCallback\"],\n    initial_input: Optional[str] = None,\n    read_output: bytes = b\"\",\n    read_delay: float = 0.1,\n    read_timeout: float = -1.0,\n) -&gt; \"ReadCallbackReturnable\":\nr\"\"\"\n    Read from a channel and react to the output with some callback.\n\n    This method is kind of like an \"advanced\" send_interactive -- the idea is simple: send some\n    \"stuff\" to the channel (optionally), and then read from the channel. Based on the output\n    do something. The callbacks is a list of `ReadCallback` which is an object containing the\n    actual callback to execute, some info about when to trigger that callback (also when *not*\n    to trigger that callback), as well as some attributes to control the next (if desired)\n    iteration of read_callback. You could in theory do basically everything with this method by\n    chaining callbacks forever, but you probably don't want to do that for real!\n\n    Example usage:\n\n    ```\n    from scrapli.driver.core import IOSXEDriver\n    from scrapli.driver.generic.base_driver import ReadCallback\n    from scrapli.driver.generic.sync_driver import GenericDriver\n\n    device = {\n        \"host\": \"rtr1\",\n        \"auth_strict_key\": False,\n        \"ssh_config_file\": True,\n    }\n\n    def callback_one(cls: GenericDriver, read_output: str):\n        cls.acquire_priv(\"configuration\")\n        cls.channel.send_return()\n\n\n    def callback_two(cls: GenericDriver, read_output: str):\n        print(f\"previous read output : {read_output}\")\n\n        r = cls.send_command(\"show run | i hostname\")\n        print(f\"result: {r.result}\")\n\n\n    with IOSXEDriver(**device) as conn:\n        callbacks = [\n            ReadCallback(\n                contains=\"rtr1#\",\n                callback=callback_one,\n                name=\"call1\",\n                case_insensitive=False\n            ),\n            ReadCallback(\n                contains_re=r\"^rtr1\\(config\\)#\",\n                callback=callback_two,\n                complete=True,\n            )\n        ]\n        conn.read_callback(callbacks=callbacks, initial_input=\"show run | i hostname\")\n    ```\n\n    Args:\n        callbacks: a list of ReadCallback objects\n        initial_input: optional string to send to \"kick off\" the read_callback method\n        read_output: optional bytes to append any new reads to\n        read_delay: sleep interval between reads\n        read_timeout: value to set the `transport_timeout` to for the duration of the reading\n            portion of this method. If left default (-1.0) or set to anything below 0, the\n            transport timeout value will be left alone (whatever the timeout_transport value is)\n            otherwise, the provided value will be temporarily set as the timeout_transport for\n            duration of the reading.\n\n    Returns:\n        ReadCallbackReturnable: either None or call to read_callback again\n\n    Raises:\n        ScrapliTimeout: if the read operation times out (base don the read_timeout value) during\n            the read callback check.\n\n    \"\"\"\n    if initial_input is not None:\n        self.channel.write(channel_input=f\"{initial_input}{self.comms_return_char}\")\n        return self.read_callback(callbacks=callbacks, initial_input=None)\n\n    original_transport_timeout = self.timeout_transport\n\n    # if the read_timeout value is -1.0 or just less than 0, that indicates we should use\n    # the \"normal\" transport timeout and not modify anything\n    self.timeout_transport = read_timeout if read_timeout &gt;= 0 else self.timeout_transport\n\n    _read_delay = 0.1 if read_delay &lt;= 0 else read_delay\n\n    while True:\n        try:\n            read_output += self.channel.read()\n        except ScrapliTimeout as exc:\n            self.timeout_transport = original_transport_timeout\n\n            raise ScrapliTimeout(\"timeout during read in read_callback operation\") from exc\n\n        for callback in callbacks:\n            _run_callback = callback.check(read_output=read_output)\n\n            if (\n                callback.only_once is True\n                and callback._triggered is True  # pylint: disable=W0212\n            ):\n                self.logger.warning(\n                    f\"callback {callback.name} matches but is set to 'only_once', \"\n                    \"skipping this callback\"\n                )\n\n                continue\n\n            if _run_callback is True:\n                self.logger.info(f\"callback {callback.name} matched, executing\")\n\n                self.timeout_transport = original_transport_timeout\n\n                callback.run(driver=self)\n\n                if callback.complete:\n                    self.logger.debug(\"callback complete is true, done with read_callback\")\n                    return None\n\n                if callback.reset_output:\n                    read_output = b\"\"\n\n                return self.read_callback(\n                    callbacks=callbacks,\n                    initial_input=None,\n                    read_output=read_output,\n                    read_delay=callback.next_delay,\n                    read_timeout=callback.next_timeout,\n                )\n\n        time.sleep(_read_delay)\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver.send_and_read","title":"<code>send_and_read(channel_input: str, *, expected_outputs: Optional[List[str]] = None, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, timeout_ops: Optional[float] = None, read_duration: float = 2.5) -&gt; Response</code>","text":"<p>Send an input and read outputs.</p> <p>Unlike \"normal\" scrapli behavior this method reads until the prompt(normal) OR until any of a list of expected outputs is seen, OR until the read duration is exceeded. This method does not care about/understand privilege levels. This can cause you some potential issues if not used carefully!</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>str</code> <p>input to send to the channel; intentionally named \"channel_input\" instead of \"command\" or \"config\" due to this method not caring about privilege levels</p> required <code>expected_outputs</code> <code>Optional[List[str]]</code> <p>List of outputs to look for in device response; returns as soon as any of the outputs are seen</p> <code>None</code> <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <code>read_duration</code> <code>float</code> <p>float duration to read for</p> <code>2.5</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if _base_transport_args is None for some reason</p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>@timeout_modifier\ndef send_and_read(\n    self,\n    channel_input: str,\n    *,\n    expected_outputs: Optional[List[str]] = None,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    timeout_ops: Optional[float] = None,\n    read_duration: float = 2.5,\n) -&gt; Response:\n\"\"\"\n    Send an input and read outputs.\n\n    Unlike \"normal\" scrapli behavior this method reads until the prompt(normal) OR until any of\n    a list of expected outputs is seen, OR until the read duration is exceeded. This method does\n    not care about/understand privilege levels. This *can* cause you some potential issues if\n    not used carefully!\n\n    Args:\n        channel_input: input to send to the channel; intentionally named \"channel_input\" instead\n            of \"command\" or \"config\" due to this method not caring about privilege levels\n        expected_outputs: List of outputs to look for in device response; returns as soon as any\n            of the outputs are seen\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n        read_duration:  float duration to read for\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        ScrapliValueError: if _base_transport_args is None for some reason\n\n    \"\"\"\n    # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n    _ = timeout_ops\n\n    if not self._base_transport_args:\n        # should not happen! :)\n        raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n    response = self._pre_send_command(\n        host=self._base_transport_args.host,\n        command=channel_input,\n        failed_when_contains=failed_when_contains,\n    )\n    raw_response, processed_response = self.channel.send_input_and_read(\n        channel_input=channel_input,\n        strip_prompt=strip_prompt,\n        expected_outputs=expected_outputs,\n        read_duration=read_duration,\n    )\n    return self._post_send_command(\n        raw_response=raw_response, processed_response=processed_response, response=response\n    )\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver.send_command","title":"<code>send_command(command: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, timeout_ops: Optional[float] = None) -&gt; Response</code>","text":"<p>Send a command</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>string to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>def send_command(\n    self,\n    command: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    timeout_ops: Optional[float] = None,\n) -&gt; Response:\n\"\"\"\n    Send a command\n\n    Args:\n        command: string to send to device in privilege exec mode\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        failed_when_contains: string or list of strings indicating failure if found in response\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    response: Response = self._send_command(\n        command=command,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        timeout_ops=timeout_ops,\n    )\n    return response\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver.send_commands","title":"<code>send_commands(commands: List[str], *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>","text":"<p>Send multiple commands</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[str]</code> <p>list of strings to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>strip prompt or not, defaults to True (yes, strip the prompt)</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>def send_commands(\n    self,\n    commands: List[str],\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send multiple commands\n\n    Args:\n        commands: list of strings to send to device in privilege exec mode\n        strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    responses = self._pre_send_commands(commands=commands)\n    for command in commands[:-1]:\n        response = self._send_command(\n            command=command,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n            eager=eager,\n        )\n        responses.append(response)\n        if stop_on_failed and response.failed is True:\n            # should we find the prompt here w/ get_prompt?? or just let subsequent operations\n            # deal w/ finding that? future us problem? :)\n            break\n    else:\n        # if we did *not* break (i.e. no failure and/or no stop_on_failed) send the last command\n        # with eager = False -- this way we *always* find the prompt at the end of the commands\n        response = self._send_command(\n            command=commands[-1],\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n            eager=False,\n        )\n        responses.append(response)\n\n    return responses\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver.send_commands_from_file","title":"<code>send_commands_from_file(file: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>","text":"<p>Send command(s) from file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>string path to file</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>def send_commands_from_file(\n    self,\n    file: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send command(s) from file\n\n    Args:\n        file: string path to file\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    commands = self._pre_send_from_file(file=file, caller=\"send_commands_from_file\")\n\n    return self.send_commands(\n        commands=commands,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n</code></pre>"},{"location":"reference/driver/generic/sync_driver/#driver.generic.sync_driver.GenericDriver.send_interactive","title":"<code>send_interactive(interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]], *, failed_when_contains: Optional[Union[str, List[str]]] = None, privilege_level: str = '', timeout_ops: Optional[float] = None, interaction_complete_patterns: Optional[List[str]] = None) -&gt; Response</code>","text":"<p>Interact with a device with changing prompts per input.</p> <p>Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)</p> <p>An example where we need this sort of capability:</p> <pre><code>3560CX#copy flash: scp:\nSource filename []? test1.txt\nAddress or name of remote host []? 172.31.254.100\nDestination username [carl]?\nWriting test1.txt\nPassword:\n\nPassword:\n Sink: C0644 639 test1.txt\n!\n639 bytes copied in 12.066 secs (53 bytes/sec)\n3560CX#\n</code></pre> <p>To accomplish this we can use the following:</p> <pre><code>interact = conn.channel.send_inputs_interact(\n    [\n        (\"copy flash: scp:\", \"Source filename []?\", False),\n        (\"test1.txt\", \"Address or name of remote host []?\", False),\n        (\"172.31.254.100\", \"Destination username [carl]?\", False),\n        (\"carl\", \"Password:\", False),\n        (\"super_secure_password\", prompt, True),\n    ]\n)\n</code></pre> <p>If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\".</p> <p>Parameters:</p> Name Type Description Default <code>interact_events</code> <code>Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]]</code> <p>list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden)</p> required <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>list of strings that, if present in final output, represent a failed command/interaction</p> <code>None</code> <code>privilege_level</code> <code>str</code> <p>ignored in this base class; for LSP reasons for subclasses</p> <code>''</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <code>interaction_complete_patterns</code> <code>Optional[List[str]]</code> <p>list of patterns, that if seen, indicate the interactive \"session\" has ended and we should exit the interactive session.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>scrapli Response object</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if _base_transport_args is None for some reason</p> Source code in <code>driver/generic/sync_driver.py</code> <pre><code>@timeout_modifier\ndef send_interactive(\n    self,\n    interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n    *,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    privilege_level: str = \"\",\n    timeout_ops: Optional[float] = None,\n    interaction_complete_patterns: Optional[List[str]] = None,\n) -&gt; Response:\n\"\"\"\n    Interact with a device with changing prompts per input.\n\n    Used to interact with devices where prompts change per input, and where inputs may be hidden\n    such as in the case of a password input. This can be used to respond to challenges from\n    devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n    example. You may have as many elements in the \"interact_events\" list as needed, and each\n    element of that list should be a tuple of two or three elements. The first element is always\n    the input to send as a string, the second should be the expected response as a string, and\n    the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n    An example where we need this sort of capability:\n\n    ```\n    3560CX#copy flash: scp:\n    Source filename []? test1.txt\n    Address or name of remote host []? 172.31.254.100\n    Destination username [carl]?\n    Writing test1.txt\n    Password:\n\n    Password:\n     Sink: C0644 639 test1.txt\n    !\n    639 bytes copied in 12.066 secs (53 bytes/sec)\n    3560CX#\n    ```\n\n    To accomplish this we can use the following:\n\n    ```\n    interact = conn.channel.send_inputs_interact(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"test1.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"carl\", \"Password:\", False),\n            (\"super_secure_password\", prompt, True),\n        ]\n    )\n    ```\n\n    If we needed to deal with more prompts we could simply continue adding tuples to the list of\n    interact \"events\".\n\n    Args:\n        interact_events: list of tuples containing the \"interactions\" with the device\n            each list element must have an input and an expected response, and may have an\n            optional bool for the third and final element -- the optional bool specifies if the\n            input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n            not provided it is assumed the input is \"normal\" (not hidden)\n        failed_when_contains: list of strings that, if present in final output, represent a\n            failed command/interaction\n        privilege_level: ignored in this base class; for LSP reasons for subclasses\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n        interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n            \"session\" has ended and we should exit the interactive session.\n\n    Returns:\n        Response: scrapli Response object\n\n    Raises:\n        ScrapliValueError: if _base_transport_args is None for some reason\n\n    \"\"\"\n    # decorator cares about timeout_ops, but nothing else does, assign to _ to appease linters\n    _ = timeout_ops\n    # privilege level only matters \"up\" in the network driver layer\n    _ = privilege_level\n\n    if not self._base_transport_args:\n        # should not happen! :)\n        raise ScrapliValueError(\"driver _base_transport_args not set for some reason\")\n\n    response = self._pre_send_interactive(\n        host=self._base_transport_args.host,\n        interact_events=interact_events,\n        failed_when_contains=failed_when_contains,\n    )\n    raw_response, processed_response = self.channel.send_inputs_interact(\n        interact_events=interact_events,\n        interaction_complete_patterns=interaction_complete_patterns,\n    )\n    return self._post_send_command(\n        raw_response=raw_response, processed_response=processed_response, response=response\n    )\n</code></pre>"},{"location":"reference/driver/network/","title":"network","text":"<p>scrapli.driver.network</p>"},{"location":"reference/driver/network/async_driver/","title":"async_driver","text":"<p>scrapli.driver.network.async_driver</p>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver","title":"<code>AsyncNetworkDriver</code>","text":"<p>         Bases: <code>AsyncGenericDriver</code>, <code>BaseNetworkDriver</code></p> Source code in <code>driver/network/async_driver.py</code> <pre><code>class AsyncNetworkDriver(AsyncGenericDriver, BaseNetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Dict[str, PrivilegeLevel],\n        default_desired_privilege_level: str,\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"\",\n        genie_platform: str = \"\",\n    ):\n        # ensure type for comms_prompt_pattern exists before setting it in the mixin\n        self.comms_prompt_pattern: str\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n        )\n\n        self.auth_secondary = auth_secondary\n        self.failed_when_contains = failed_when_contains or []\n        self.textfsm_platform = textfsm_platform\n        self.genie_platform = genie_platform\n\n        self.privilege_levels = privilege_levels\n        self.default_desired_privilege_level = default_desired_privilege_level\n        self._priv_graph = defaultdict(set)\n        self.update_privilege_levels()\n\n    async def _escalate(self, escalate_priv: PrivilegeLevel) -&gt; None:\n\"\"\"\n        Escalate to the next privilege level up\n\n        Args:\n            escalate_priv: privilege level to escalate to\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliAuthenticationFailed: if auth escalation timeout\n\n        \"\"\"\n        self._pre_escalate(escalate_priv=escalate_priv)\n\n        if escalate_priv.escalate_auth is False:\n            await self.channel.send_input(channel_input=escalate_priv.escalate)\n        else:\n            try:\n                await super().send_interactive(\n                    interact_events=[\n                        (escalate_priv.escalate, escalate_priv.escalate_prompt, False),\n                        (self.auth_secondary, escalate_priv.pattern, True),\n                    ],\n                    interaction_complete_patterns=[\n                        self.privilege_levels[escalate_priv.previous_priv].pattern,\n                        escalate_priv.pattern,\n                    ],\n                )\n            except ScrapliTimeout as exc:\n                raise ScrapliAuthenticationFailed(\n                    f\"failed escalating privilege from '{escalate_priv.previous_priv}' to \"\n                    f\"'{escalate_priv.name}'. do you need to set an 'auth_secondary' password?\"\n                ) from exc\n\n    async def _deescalate(self, current_priv: PrivilegeLevel) -&gt; None:\n\"\"\"\n        Deescalate to the next privilege level down\n\n        Args:\n            current_priv: current privilege level\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.channel.send_input(channel_input=current_priv.deescalate)\n\n    async def acquire_priv(self, desired_priv: str) -&gt; None:\n\"\"\"\n        Acquire desired priv level\n\n        Args:\n            desired_priv: string name of desired privilege level see\n                `scrapli.driver.&lt;driver_category.device_type&gt;.driver` for levels\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliPrivilegeError: if desired_priv cannot be attained\n\n        \"\"\"\n        self._validate_privilege_level_name(privilege_level_name=desired_priv)\n\n        privilege_change_count = 0\n\n        while True:\n            current_prompt = await self.channel.get_prompt()\n            privilege_action, target_priv = self._process_acquire_priv(\n                destination_priv=desired_priv,\n                current_prompt=current_prompt,\n            )\n\n            if privilege_action == PrivilegeAction.NO_ACTION:\n                self._current_priv_level = target_priv\n                return\n            if privilege_action == PrivilegeAction.DEESCALATE:\n                await self._deescalate(current_priv=target_priv)\n            if privilege_action == PrivilegeAction.ESCALATE:\n                await self._escalate(escalate_priv=target_priv)\n\n            privilege_change_count += 1\n            if privilege_change_count &gt; len(self.privilege_levels) * 2:\n                msg = f\"Failed to acquire requested privilege level {desired_priv}\"\n                raise ScrapliPrivilegeError(msg)\n\n    async def _acquire_appropriate_privilege_level(self, privilege_level: str = \"\") -&gt; None:\n\"\"\"\n        Acquire the appropriate priv level\n\n        Acquires the \"right\" priv level based on generic_driver_mode, provided privilege level,\n        and default desired privilege level. If in \"generic_driver_mode\" and no priv level is\n        provided, we simply return as we are already at the \"right\" priv level (since we don't care\n        about priv levels in this mode). If we are in \"generic_driver_mode\" and we are provided a\n        priv level (this is only applicable in `send_interactive`) we will try to acquire that\n        provided priv level. If a priv name is passed we try to resolve it and use that as the\n        privilege level to acquire, otherwise if no priv leve is provided we will acquire the\n        default_desired_privilege_level.\n\n        Args:\n            privilege_level: optional name of privilege level to acquire\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not privilege_level and self._generic_driver_mode is True:\n            return\n\n        if privilege_level:\n            self._validate_privilege_level_name(privilege_level_name=privilege_level)\n            resolved_privilege_level = privilege_level\n        else:\n            resolved_privilege_level = self.default_desired_privilege_level\n\n        if self._current_priv_level.name != resolved_privilege_level:\n            await self.acquire_priv(desired_priv=resolved_privilege_level)\n\n    async def send_command(\n        self,\n        command: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send a command\n\n        Super method will raise TypeError if anything but a string is passed here!\n\n        Args:\n            command: string to send to device in privilege exec mode\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self._acquire_appropriate_privilege_level()\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        response = await super().send_command(\n            command=command,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n        )\n        self._update_response(response)\n\n        return response\n\n    async def send_commands(\n        self,\n        commands: List[str],\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send multiple commands\n\n        Super method will raise TypeError if anything but a list of strings is passed here!\n\n        Args:\n            commands: list of strings to send to device in privilege exec mode\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self._acquire_appropriate_privilege_level()\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        responses = await super().send_commands(\n            commands=commands,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n        for response in responses:\n            self._update_response(response=response)\n\n        return responses\n\n    async def send_commands_from_file(\n        self,\n        file: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send command(s) from file\n\n        Args:\n            file: string path to file\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self._acquire_appropriate_privilege_level()\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        return await super().send_commands_from_file(\n            file=file,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n    async def send_interactive(\n        self,\n        interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n        *,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        privilege_level: str = \"\",\n        timeout_ops: Optional[float] = None,\n        interaction_complete_patterns: Optional[List[str]] = None,\n    ) -&gt; Response:\n\"\"\"\n        Interact with a device with changing prompts per input.\n\n        Used to interact with devices where prompts change per input, and where inputs may be hidden\n        such as in the case of a password input. This can be used to respond to challenges from\n        devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n        example. You may have as many elements in the \"interact_events\" list as needed, and each\n        element of that list should be a tuple of two or three elements. The first element is always\n        the input to send as a string, the second should be the expected response as a string, and\n        the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n        An example where we need this sort of capability:\n\n        '''\n        3560CX#copy flash: scp:\n        Source filename []? test1.txt\n        Address or name of remote host []? 172.31.254.100\n        Destination username [carl]?\n        Writing test1.txt\n        Password:\n\n        Password:\n         Sink: C0644 639 test1.txt\n        !\n        639 bytes copied in 12.066 secs (53 bytes/sec)\n        3560CX#\n        '''\n\n        To accomplish this we can use the following:\n\n        '''\n        interact = conn.channel.send_inputs_interact(\n            [\n                (\"copy flash: scp:\", \"Source filename []?\", False),\n                (\"test1.txt\", \"Address or name of remote host []?\", False),\n                (\"172.31.254.100\", \"Destination username [carl]?\", False),\n                (\"carl\", \"Password:\", False),\n                (\"super_secure_password\", prompt, True),\n            ]\n        )\n        '''\n\n        If we needed to deal with more prompts we could simply continue adding tuples to the list of\n        interact \"events\".\n\n        Args:\n            interact_events: list of tuples containing the \"interactions\" with the device\n                each list element must have an input and an expected response, and may have an\n                optional bool for the third and final element -- the optional bool specifies if the\n                input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n                not provided it is assumed the input is \"normal\" (not hidden)\n            failed_when_contains: list of strings that, if present in final output, represent a\n                failed command/interaction\n            privilege_level: name of the privilege level to operate in\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n            interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n                \"session\" has ended and we should exit the interactive session.\n\n        Returns:\n            Response: scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self._acquire_appropriate_privilege_level(privilege_level=privilege_level)\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        # type hint is due to the timeout_modifier wrapper returning `Any` so that we dont anger the\n        # asyncio parts (which will get an awaitable not a Response returned)\n        response: Response = await super().send_interactive(\n            interact_events=interact_events,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n            interaction_complete_patterns=interaction_complete_patterns,\n        )\n        self._update_response(response=response)\n\n        return response\n\n    async def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort a configuration operation/session if applicable (for config sessions like junos/iosxr)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    async def send_configs(\n        self,\n        configs: List[str],\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        privilege_level: str = \"\",\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send configuration(s)\n\n        Args:\n            configs: list of strings to send to device in config mode\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution; aborts configuration session if applicable (iosxr/junos or\n                eos/nxos if using a configuration session)\n            privilege_level: name of configuration privilege level/type to acquire; this is platform\n                dependent, so check the device driver for specifics. Examples of privilege_name\n                would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n                JunosDriver. You can also pass in a name of a configuration session such as\n                \"my-config-session\" if you have registered a session using the\n                \"register_config_session\" method of the EOSDriver or NXOSDriver.\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER CONFIG sent, not for the total\n                of the configs being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        resolved_privilege_level, failed_when_contains = self._pre_send_configs(\n            configs=configs,\n            failed_when_contains=failed_when_contains,\n            privilege_level=privilege_level,\n        )\n\n        if self._current_priv_level.name != resolved_privilege_level:\n            await self.acquire_priv(desired_priv=resolved_privilege_level)\n\n        responses = await super().send_commands(\n            commands=configs,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n        if stop_on_failed and responses.failed:\n            await self._abort_config()\n\n        return self._post_send_configs(responses=responses)\n\n    async def send_config(\n        self,\n        config: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        privilege_level: str = \"\",\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send configuration string\n\n        Args:\n            config: string configuration to send to the device, supports sending multi-line strings\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution; aborts configuration session if applicable (iosxr/junos or\n                eos/nxos if using a configuration session)\n            privilege_level: name of configuration privilege level/type to acquire; this is platform\n                dependent, so check the device driver for specifics. Examples of privilege_name\n                would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n                JunosDriver. You can also pass in a name of a configuration session such as\n                \"my-config-session\" if you have registered a session using the\n                \"register_config_session\" method of the EOSDriver or NXOSDriver.\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER CONFIG sent, not for the total\n                of the configs being sent!\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        split_config = self._pre_send_config(config=config)\n\n        # now that we have a list of configs, just use send_configs to actually execute them\n        multi_response = await self.send_configs(\n            configs=split_config,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            privilege_level=privilege_level,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n        return self._post_send_config(config=config, multi_response=multi_response)\n\n    async def send_configs_from_file(\n        self,\n        file: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        privilege_level: str = \"\",\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send configuration(s) from a file\n\n        Args:\n            file: string path to file\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution; aborts configuration session if applicable (iosxr/junos or\n                eos/nxos if using a configuration session)\n            privilege_level: name of configuration privilege level/type to acquire; this is platform\n                dependent, so check the device driver for specifics. Examples of privilege_name\n                would be \"exclusive\" for IOSXRDriver, \"private\" for JunosDriver. You can also pass\n                in a name of a configuration session such as \"session_mysession\" if you have\n                registered a session using the \"register_config_session\" method of the EOSDriver or\n                NXOSDriver.\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER CONFIG sent, not for the total\n                of the configs being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        configs = self._pre_send_from_file(file=file, caller=\"send_configs_from_file\")\n\n        return await self.send_configs(\n            configs=configs,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            privilege_level=privilege_level,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.acquire_priv","title":"<code>acquire_priv(desired_priv: str) -&gt; None</code>  <code>async</code>","text":"<p>Acquire desired priv level</p> <p>Parameters:</p> Name Type Description Default <code>desired_priv</code> <code>str</code> <p>string name of desired privilege level see <code>scrapli.driver.&lt;driver_category.device_type&gt;.driver</code> for levels</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliPrivilegeError</code> <p>if desired_priv cannot be attained</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def acquire_priv(self, desired_priv: str) -&gt; None:\n\"\"\"\n    Acquire desired priv level\n\n    Args:\n        desired_priv: string name of desired privilege level see\n            `scrapli.driver.&lt;driver_category.device_type&gt;.driver` for levels\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliPrivilegeError: if desired_priv cannot be attained\n\n    \"\"\"\n    self._validate_privilege_level_name(privilege_level_name=desired_priv)\n\n    privilege_change_count = 0\n\n    while True:\n        current_prompt = await self.channel.get_prompt()\n        privilege_action, target_priv = self._process_acquire_priv(\n            destination_priv=desired_priv,\n            current_prompt=current_prompt,\n        )\n\n        if privilege_action == PrivilegeAction.NO_ACTION:\n            self._current_priv_level = target_priv\n            return\n        if privilege_action == PrivilegeAction.DEESCALATE:\n            await self._deescalate(current_priv=target_priv)\n        if privilege_action == PrivilegeAction.ESCALATE:\n            await self._escalate(escalate_priv=target_priv)\n\n        privilege_change_count += 1\n        if privilege_change_count &gt; len(self.privilege_levels) * 2:\n            msg = f\"Failed to acquire requested privilege level {desired_priv}\"\n            raise ScrapliPrivilegeError(msg)\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.send_command","title":"<code>send_command(command: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, timeout_ops: Optional[float] = None) -&gt; Response</code>  <code>async</code>","text":"<p>Send a command</p> <p>Super method will raise TypeError if anything but a string is passed here!</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>string to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def send_command(\n    self,\n    command: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    timeout_ops: Optional[float] = None,\n) -&gt; Response:\n\"\"\"\n    Send a command\n\n    Super method will raise TypeError if anything but a string is passed here!\n\n    Args:\n        command: string to send to device in privilege exec mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self._acquire_appropriate_privilege_level()\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    response = await super().send_command(\n        command=command,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        timeout_ops=timeout_ops,\n    )\n    self._update_response(response)\n\n    return response\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.send_commands","title":"<code>send_commands(commands: List[str], *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>  <code>async</code>","text":"<p>Send multiple commands</p> <p>Super method will raise TypeError if anything but a list of strings is passed here!</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[str]</code> <p>list of strings to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def send_commands(\n    self,\n    commands: List[str],\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send multiple commands\n\n    Super method will raise TypeError if anything but a list of strings is passed here!\n\n    Args:\n        commands: list of strings to send to device in privilege exec mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self._acquire_appropriate_privilege_level()\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    responses = await super().send_commands(\n        commands=commands,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    for response in responses:\n        self._update_response(response=response)\n\n    return responses\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.send_commands_from_file","title":"<code>send_commands_from_file(file: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>  <code>async</code>","text":"<p>Send command(s) from file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>string path to file</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def send_commands_from_file(\n    self,\n    file: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send command(s) from file\n\n    Args:\n        file: string path to file\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self._acquire_appropriate_privilege_level()\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    return await super().send_commands_from_file(\n        file=file,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.send_config","title":"<code>send_config(config: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; Response</code>  <code>async</code>","text":"<p>Send configuration string</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string configuration to send to the device, supports sending multi-line strings</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution; aborts configuration session if applicable (iosxr/junos or eos/nxos if using a configuration session)</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def send_config(\n    self,\n    config: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; Response:\n\"\"\"\n    Send configuration string\n\n    Args:\n        config: string configuration to send to the device, supports sending multi-line strings\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution; aborts configuration session if applicable (iosxr/junos or\n            eos/nxos if using a configuration session)\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n            JunosDriver. You can also pass in a name of a configuration session such as\n            \"my-config-session\" if you have registered a session using the\n            \"register_config_session\" method of the EOSDriver or NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    split_config = self._pre_send_config(config=config)\n\n    # now that we have a list of configs, just use send_configs to actually execute them\n    multi_response = await self.send_configs(\n        configs=split_config,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        privilege_level=privilege_level,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n    return self._post_send_config(config=config, multi_response=multi_response)\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.send_configs","title":"<code>send_configs(configs: List[str], *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>  <code>async</code>","text":"<p>Send configuration(s)</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>List[str]</code> <p>list of strings to send to device in config mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution; aborts configuration session if applicable (iosxr/junos or eos/nxos if using a configuration session)</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def send_configs(\n    self,\n    configs: List[str],\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send configuration(s)\n\n    Args:\n        configs: list of strings to send to device in config mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution; aborts configuration session if applicable (iosxr/junos or\n            eos/nxos if using a configuration session)\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n            JunosDriver. You can also pass in a name of a configuration session such as\n            \"my-config-session\" if you have registered a session using the\n            \"register_config_session\" method of the EOSDriver or NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    resolved_privilege_level, failed_when_contains = self._pre_send_configs(\n        configs=configs,\n        failed_when_contains=failed_when_contains,\n        privilege_level=privilege_level,\n    )\n\n    if self._current_priv_level.name != resolved_privilege_level:\n        await self.acquire_priv(desired_priv=resolved_privilege_level)\n\n    responses = await super().send_commands(\n        commands=configs,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    if stop_on_failed and responses.failed:\n        await self._abort_config()\n\n    return self._post_send_configs(responses=responses)\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.send_configs_from_file","title":"<code>send_configs_from_file(file: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>  <code>async</code>","text":"<p>Send configuration(s) from a file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>string path to file</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution; aborts configuration session if applicable (iosxr/junos or eos/nxos if using a configuration session)</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"exclusive\" for IOSXRDriver, \"private\" for JunosDriver. You can also pass in a name of a configuration session such as \"session_mysession\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def send_configs_from_file(\n    self,\n    file: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send configuration(s) from a file\n\n    Args:\n        file: string path to file\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution; aborts configuration session if applicable (iosxr/junos or\n            eos/nxos if using a configuration session)\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"exclusive\" for IOSXRDriver, \"private\" for JunosDriver. You can also pass\n            in a name of a configuration session such as \"session_mysession\" if you have\n            registered a session using the \"register_config_session\" method of the EOSDriver or\n            NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    configs = self._pre_send_from_file(file=file, caller=\"send_configs_from_file\")\n\n    return await self.send_configs(\n        configs=configs,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        privilege_level=privilege_level,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n</code></pre>"},{"location":"reference/driver/network/async_driver/#driver.network.async_driver.AsyncNetworkDriver.send_interactive","title":"<code>send_interactive(interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]], *, failed_when_contains: Optional[Union[str, List[str]]] = None, privilege_level: str = '', timeout_ops: Optional[float] = None, interaction_complete_patterns: Optional[List[str]] = None) -&gt; Response</code>  <code>async</code>","text":"<p>Interact with a device with changing prompts per input.</p> <p>Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)</p> <p>An example where we need this sort of capability:</p> <p>''' 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password:</p> Password <p>Sink: C0644 639 test1.txt</p> <p>! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# '''</p> <p>To accomplish this we can use the following:</p> <p>''' interact = conn.channel.send_inputs_interact(     [         (\"copy flash: scp:\", \"Source filename []?\", False),         (\"test1.txt\", \"Address or name of remote host []?\", False),         (\"172.31.254.100\", \"Destination username [carl]?\", False),         (\"carl\", \"Password:\", False),         (\"super_secure_password\", prompt, True),     ] ) '''</p> <p>If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\".</p> <p>Parameters:</p> Name Type Description Default <code>interact_events</code> <code>Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]]</code> <p>list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden)</p> required <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>list of strings that, if present in final output, represent a failed command/interaction</p> <code>None</code> <code>privilege_level</code> <code>str</code> <p>name of the privilege level to operate in</p> <code>''</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <code>interaction_complete_patterns</code> <code>Optional[List[str]]</code> <p>list of patterns, that if seen, indicate the interactive \"session\" has ended and we should exit the interactive session.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>scrapli Response object</p> Source code in <code>driver/network/async_driver.py</code> <pre><code>async def send_interactive(\n    self,\n    interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n    *,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    privilege_level: str = \"\",\n    timeout_ops: Optional[float] = None,\n    interaction_complete_patterns: Optional[List[str]] = None,\n) -&gt; Response:\n\"\"\"\n    Interact with a device with changing prompts per input.\n\n    Used to interact with devices where prompts change per input, and where inputs may be hidden\n    such as in the case of a password input. This can be used to respond to challenges from\n    devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n    example. You may have as many elements in the \"interact_events\" list as needed, and each\n    element of that list should be a tuple of two or three elements. The first element is always\n    the input to send as a string, the second should be the expected response as a string, and\n    the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n    An example where we need this sort of capability:\n\n    '''\n    3560CX#copy flash: scp:\n    Source filename []? test1.txt\n    Address or name of remote host []? 172.31.254.100\n    Destination username [carl]?\n    Writing test1.txt\n    Password:\n\n    Password:\n     Sink: C0644 639 test1.txt\n    !\n    639 bytes copied in 12.066 secs (53 bytes/sec)\n    3560CX#\n    '''\n\n    To accomplish this we can use the following:\n\n    '''\n    interact = conn.channel.send_inputs_interact(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"test1.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"carl\", \"Password:\", False),\n            (\"super_secure_password\", prompt, True),\n        ]\n    )\n    '''\n\n    If we needed to deal with more prompts we could simply continue adding tuples to the list of\n    interact \"events\".\n\n    Args:\n        interact_events: list of tuples containing the \"interactions\" with the device\n            each list element must have an input and an expected response, and may have an\n            optional bool for the third and final element -- the optional bool specifies if the\n            input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n            not provided it is assumed the input is \"normal\" (not hidden)\n        failed_when_contains: list of strings that, if present in final output, represent a\n            failed command/interaction\n        privilege_level: name of the privilege level to operate in\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n        interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n            \"session\" has ended and we should exit the interactive session.\n\n    Returns:\n        Response: scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self._acquire_appropriate_privilege_level(privilege_level=privilege_level)\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    # type hint is due to the timeout_modifier wrapper returning `Any` so that we dont anger the\n    # asyncio parts (which will get an awaitable not a Response returned)\n    response: Response = await super().send_interactive(\n        interact_events=interact_events,\n        failed_when_contains=failed_when_contains,\n        timeout_ops=timeout_ops,\n        interaction_complete_patterns=interaction_complete_patterns,\n    )\n    self._update_response(response=response)\n\n    return response\n</code></pre>"},{"location":"reference/driver/network/base_driver/","title":"base_driver","text":"<p>scrapli.driver.network.base_driver</p>"},{"location":"reference/driver/network/base_driver/#driver.network.base_driver.BaseNetworkDriver","title":"<code>BaseNetworkDriver</code>","text":"Source code in <code>driver/network/base_driver.py</code> <pre><code>class BaseNetworkDriver:\n    # BaseNetworkDriver Mixin vars for typing/linting purposes\n    logger: LoggerAdapterT\n    auth_secondary: str\n    failed_when_contains: List[str]\n    textfsm_platform: str\n    genie_platform: str\n    privilege_levels: Dict[str, PrivilegeLevel]\n    comms_prompt_pattern: str\n    _current_priv_level = DUMMY_PRIV_LEVEL\n    _priv_graph: DefaultDict[str, Set[str]]\n\n    def _generate_comms_prompt_pattern(self) -&gt; None:\n\"\"\"\n        Generate the `comms_prompt_pattern` from the currently assigned privilege levels\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"generating combined network comms prompt pattern\")\n        self.comms_prompt_pattern = r\"|\".join(\n            rf\"({priv_level_data.pattern})\" for priv_level_data in self.privilege_levels.values()\n        )\n\n    @lru_cache(maxsize=64)\n    def _determine_current_priv(self, current_prompt: str) -&gt; List[str]:\n\"\"\"\n        Determine current privilege level from prompt string\n\n        Args:\n            current_prompt: string of current prompt\n\n        Returns:\n            list: list of string names of matching privilege levels\n\n        Raises:\n            ScrapliPrivilegeError: if privilege level cannot be determined\n\n        \"\"\"\n        matching_priv_levels = []\n        for priv_level in self.privilege_levels.values():\n            if priv_level.not_contains:\n                # starting at 2021.07.30 the `not_contains` field was added to privilege levels\n                # (defaulting to an empty tuple) -- this helps us to simplify the priv patterns\n                # greatly, as well as have no reliance on look arounds which makes the \"normal\"\n                # scrapli privilege levels more go friendly -- useful for scrapligo!\n                if any(not_contains in current_prompt for not_contains in priv_level.not_contains):\n                    continue\n\n            search_result = re.search(\n                pattern=priv_level.pattern, string=current_prompt, flags=re.M | re.I\n            )\n            if not search_result:\n                continue\n\n            matching_priv_levels.append(priv_level.name)\n        if not matching_priv_levels:\n            msg = f\"could not determine privilege level from provided prompt: '{current_prompt}'\"\n            self.logger.critical(msg)\n            raise ScrapliPrivilegeError(msg)\n\n        self.logger.debug(f\"determined current privilege level is one of '{matching_priv_levels}'\")\n\n        return matching_priv_levels\n\n    def _build_priv_graph(self) -&gt; None:\n\"\"\"\n        Build a graph of privilege levels\n\n        `_priv_graph` is a \"graph\" of all privilege levels and how to acquire them from any given\n        priv level. This is probably not very efficient but we should never have more than a\n        handful of priv levels so this should never be a big issue.\n\n        While at the moment priv levels are always... \"linear\" in that there is only ever one \"up\"\n        and one \"down\" privilege from any given priv, we still have \"forks\" in the road -- for\n        example, in IOSXR we can go from privilege exec to configuration or configuration exclusive.\n        This method builds a graph that allows us to make intelligent decisions about how to get\n        from where we are to where we want to be!\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._priv_graph = defaultdict(set)\n\n        privilege_levels = self.privilege_levels.values()\n        for privilege_level in privilege_levels:\n            if privilege_level.previous_priv:\n                self._priv_graph[privilege_level.name].add(privilege_level.previous_priv)\n            else:\n                self._priv_graph[privilege_level.name] = set()\n\n        for higher_privilege_level, privilege_level_list in self._priv_graph.items():\n            for privilege_level_name in privilege_level_list:\n                self._priv_graph[privilege_level_name].add(higher_privilege_level)\n\n    def _build_priv_change_map(\n        self,\n        starting_priv_name: str,\n        destination_priv_name: str,\n        priv_change_map: Optional[List[str]] = None,\n    ) -&gt; List[str]:\n\"\"\"\n        Generate a list of priv levels from starting priv to destination priv\n\n        Args:\n            starting_priv_name: name of starting priv\n            destination_priv_name: name of destination priv\n            priv_change_map: current priv_change_map; should only be passed when this function\n                calls itself\n\n        Returns:\n            list: list of strings of priv names to get from starting to destination priv level\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if priv_change_map is None:\n            priv_change_map = []\n\n        priv_change_map = priv_change_map + [starting_priv_name]\n\n        if starting_priv_name == destination_priv_name:\n            return priv_change_map\n\n        for privilege_name in self._priv_graph[starting_priv_name]:\n            if privilege_name not in priv_change_map:\n                updated_priv_change_map = self._build_priv_change_map(\n                    starting_priv_name=privilege_name,\n                    destination_priv_name=destination_priv_name,\n                    priv_change_map=priv_change_map,\n                )\n                if updated_priv_change_map:\n                    return updated_priv_change_map\n\n        # shouldnt ever get to this i dont think... putting here to appease pylint and ignoring cov\n        return []  # pragma: nocover\n\n    def update_privilege_levels(self) -&gt; None:\n\"\"\"\n        Re-generate the privilege graph, and update the comms prompt pattern\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # build/update the priv graph\n        self._build_priv_graph()\n\n        # build/update the joined comms prompt pattern\n        self._generate_comms_prompt_pattern()\n\n        # ensure the channel has the updated prompt pattern so it knows how to match any newly\n        # updated priv levels (such as registered configuration sessions)\n        self.channel.comms_prompt_pattern = (  # type: ignore  # pylint: disable=E1101\n            self.comms_prompt_pattern\n        )\n\n        # finally, clear the lru caches as patterns may have been updated\n        self._determine_current_priv.cache_clear()\n\n    def _validate_privilege_level_name(self, privilege_level_name: str) -&gt; None:\n\"\"\"\n        Get privilege level name if provided privilege is valid\n\n        Args:\n            privilege_level_name: string name of desired privilege level\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliPrivilegeError: if attempting to acquire an unknown priv\n\n        \"\"\"\n        desired_privilege_level = self.privilege_levels.get(privilege_level_name)\n        if desired_privilege_level is None:\n            msg = (\n                f\"requested privilege level '{privilege_level_name}' not a valid privilege level of\"\n                f\" '{self.__class__.__name__}'\"\n            )\n            self.logger.critical(msg)\n            raise ScrapliPrivilegeError(msg)\n\n    def _pre_escalate(self, escalate_priv: PrivilegeLevel) -&gt; None:\n\"\"\"\n        Handle pre \"_escalate\" tasks for consistency between sync/async versions\n\n        Args:\n            escalate_priv: privilege level to escalate to\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if escalate_priv.escalate_auth is True and not self.auth_secondary:\n            title = \"Authentication Warning!\"\n            message = (\n                \"scrapli will try to escalate privilege without entering a password but may \"\n                \"fail.\\nSet an 'auth_secondary' password if your device requires a password to \"\n                \"increase privilege, otherwise ignore this message.\"\n            )\n            user_warning(title=title, message=message)\n\n    def _process_acquire_priv(\n        self,\n        destination_priv: str,\n        current_prompt: str,\n    ) -&gt; Tuple[PrivilegeAction, PrivilegeLevel]:\n\"\"\"\n        Handle non channel \"acquire_priv\" tasks for consistency between sync/async versions\n\n        Args:\n            destination_priv: string name of desired privilege level\n            current_prompt: string of the current prompt\n\n        Returns:\n            Tuple[PrivilegeAction, PrivilegeLevel]: enum set to appropriate value for no action,\n                escalate or deescalate and privilege level object to pass to either escalate or\n                deescalate method\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(f\"attempting to acquire '{destination_priv}' privilege level\")\n\n        # decide if we are already at the desired priv, then we don't need to do any thing!\n        current_priv_patterns = self._determine_current_priv(current_prompt=current_prompt)\n\n        if self._current_priv_level.name in current_priv_patterns:\n            current_priv = self.privilege_levels[self._current_priv_level.name]\n        elif destination_priv in current_priv_patterns:\n            current_priv = self.privilege_levels[destination_priv]\n        else:\n            # if multiple patterns match pick the zeroith... hopefully this never happens though...\n            # and it *shouldn't* because right now the only way to have the same priv patterns is\n            # to be *basically* the same privilege level -- i.e. configuration and configuration\n            # exclusive for iosxr\n            current_priv = self.privilege_levels[current_priv_patterns[0]]\n\n        if current_priv.name == destination_priv:\n            self.logger.debug(\n                \"determined current privilege level is target privilege level, no action needed\"\n            )\n            self._current_priv_level = self.privilege_levels[destination_priv]\n            return PrivilegeAction.NO_ACTION, self.privilege_levels[destination_priv]\n\n        map_to_destination_priv = self._build_priv_change_map(\n            starting_priv_name=current_priv.name, destination_priv_name=destination_priv\n        )\n\n        # at this point we basically dont *know* the privilege leve we are at (or we wont/cant after\n        # we do an escalation or deescalation, so we reset to the dummy priv level\n        self._current_priv_level = DUMMY_PRIV_LEVEL\n\n        if self.privilege_levels[map_to_destination_priv[1]].previous_priv != current_priv.name:\n            self.logger.debug(\"determined privilege deescalation necessary\")\n            return PrivilegeAction.DEESCALATE, current_priv\n\n        self.logger.debug(\"determined privilege escalation necessary\")\n        return PrivilegeAction.ESCALATE, self.privilege_levels[map_to_destination_priv[1]]\n\n    @property\n    def _generic_driver_mode(self) -&gt; bool:\n\"\"\"\n        Getter for `_generic_driver_mode` attribute\n\n        Args:\n            N/A\n\n        Returns:\n            bool: _generic_driver_mode value\n\n        Raises:\n            N/A\n\n        \"\"\"\n        try:\n            return self.__generic_driver_mode\n        except AttributeError:\n            return False\n\n    @_generic_driver_mode.setter\n    def _generic_driver_mode(self, value: bool) -&gt; None:\n\"\"\"\n        Setter for `_generic_driver_mode` attribute\n\n        Args:\n            value: bool value for _generic_driver_mode\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliTypeError: if value is not of type bool\n\n        \"\"\"\n        self.logger.debug(f\"setting '_generic_driver_mode' value to '{value}'\")\n\n        if not isinstance(value, bool):\n            raise ScrapliTypeError\n\n        if value is True:\n            # if we are setting ingore priv level we reset current priv to the dummy priv so that\n            # once (if) a user turns ignore priv back off we know we need to reset/reacquire priv\n            # as the user coulda done pretty much anything and we could end up at who knows what\n            # priv level\n            self._current_priv_level = DUMMY_PRIV_LEVEL\n\n        self.__generic_driver_mode = value\n\n    def _update_response(self, response: Response) -&gt; None:\n\"\"\"\n        Update response with network driver specific data\n\n        This happens here as the underlying channel provides a response object but is unaware of any\n        of the network/platform specific attributes that may need to get updated\n\n        Args:\n            response: response to update\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.textfsm_platform = self.textfsm_platform\n        response.genie_platform = self.genie_platform\n\n    @staticmethod\n    def _pre_send_config(config: str) -&gt; List[str]:\n\"\"\"\n        Handle pre \"send_config\" tasks for consistency between sync/async versions\n\n        Args:\n            config: string configuration to send to the device, supports sending multi-line strings\n\n        Returns:\n            list: list of config lines from provided \"config\" input\n\n        Raises:\n            ScrapliTypeError: if anything but a string is provided for `file`\n\n        \"\"\"\n        if not isinstance(config, str):\n            raise ScrapliTypeError(\n                f\"'send_config' expects a single string, got {type(config)}, \"\n                \"to send a list of configs use the 'send_configs' method instead.\"\n            )\n\n        # in order to handle multi-line strings, we split lines\n        split_config = config.splitlines()\n\n        return split_config\n\n    def _post_send_config(\n        self,\n        config: str,\n        multi_response: MultiResponse,\n    ) -&gt; Response:\n\"\"\"\n        Handle post \"send_config\" tasks for consistency between sync/async versions\n\n        Args:\n            config: string configuration to send to the device, supports sending multi-line strings\n            multi_response: multi_response object send_config got from calling self.send_configs;\n                we need this to parse out the multi_response back into a single Response object\n\n        Returns:\n            Response: Unified response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # capture failed_when_contains and host from zeroith multi_response element (there should\n        #  always be at least a zeroith element here!); getting host just lets us keep the mixin\n        #  class a little cleaner without having to deal with sync vs async transport classes from\n        #  a typing perspective\n        failed_when_contains = multi_response[0].failed_when_contains\n        host = multi_response[0].host\n\n        # create a new unified response object\n        response = Response(\n            host=host,\n            channel_input=config,\n            failed_when_contains=failed_when_contains,\n        )\n        response.start_time = multi_response[0].start_time\n        response.finish_time = datetime.now()\n        response.elapsed_time = (response.finish_time - response.start_time).total_seconds()\n\n        # join all the results together into a single final result\n        response.result = \"\\n\".join(response.result for response in multi_response)\n        response.failed = False\n\n        if any(r.failed for r in multi_response):\n            response.failed = True\n        self._update_response(response=response)\n\n        return response\n\n    def _pre_send_configs(\n        self,\n        configs: List[str],\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        privilege_level: str = \"\",\n    ) -&gt; Tuple[str, Union[str, List[str]]]:\n\"\"\"\n        Handle pre \"send_configs\" tasks for consistency between sync/async versions\n\n        Args:\n            configs: list of strings to send to device in config mode\n            failed_when_contains: string or list of strings indicating failure if found in response\n            privilege_level: name of configuration privilege level/type to acquire; this is platform\n                dependent, so check the device driver for specifics. Examples of privilege_name\n                would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n                JunosDriver. You can also pass in a name of a configuration session such as\n                \"my-config-session\" if you have registered a session using the\n                \"register_config_session\" method of the EOSDriver or NXOSDriver.\n\n        Returns:\n            Tuple[str, Union[str, List[str]]]: string of resolved privilege level name, and failed\n                when contains which may be a string or list of strings\n\n        Raises:\n            ScrapliTypeError: if configs is anything but a list\n            ScrapliPrivilegeError: if connection is in 'generic_driver_mode' -- this should be a\n                non-standard use case so there is no reason to complicate the config(s) methods\n                with supporting generic driver mode (plus if there was config modes in generic\n                driver mode that wouldn't be very generic driver like, would it!)\n\n        \"\"\"\n        if not isinstance(configs, list):\n            raise ScrapliTypeError(\n                f\"'send_configs' expects a list of strings, got {type(configs)}, \"\n                \"to send a single configuration line/string use the 'send_config' method instead.\"\n            )\n\n        if self._generic_driver_mode is True:\n            raise ScrapliPrivilegeError(\n                \"connection is in 'generic_driver_mode', send config(s|s_from_file) is disabled\"\n            )\n\n        if failed_when_contains is None:\n            final_failed_when_contains = self.failed_when_contains\n        elif isinstance(failed_when_contains, str):\n            final_failed_when_contains = [failed_when_contains]\n        else:\n            final_failed_when_contains = failed_when_contains\n\n        if privilege_level:\n            self._validate_privilege_level_name(privilege_level_name=privilege_level)\n            resolved_privilege_level = privilege_level\n        else:\n            resolved_privilege_level = \"configuration\"\n\n        return resolved_privilege_level, final_failed_when_contains\n\n    def _post_send_configs(self, responses: MultiResponse) -&gt; MultiResponse:\n\"\"\"\n        Handle post \"send_configs\" tasks for consistency between sync/async versions\n\n        Args:\n            responses: multi_response object to update\n\n        Returns:\n            MultiResponse: Unified response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        for response in responses:\n            self._update_response(response=response)\n\n        return responses\n</code></pre>"},{"location":"reference/driver/network/base_driver/#driver.network.base_driver.BaseNetworkDriver.update_privilege_levels","title":"<code>update_privilege_levels() -&gt; None</code>","text":"<p>Re-generate the privilege graph, and update the comms prompt pattern</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>driver/network/base_driver.py</code> <pre><code>def update_privilege_levels(self) -&gt; None:\n\"\"\"\n    Re-generate the privilege graph, and update the comms prompt pattern\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # build/update the priv graph\n    self._build_priv_graph()\n\n    # build/update the joined comms prompt pattern\n    self._generate_comms_prompt_pattern()\n\n    # ensure the channel has the updated prompt pattern so it knows how to match any newly\n    # updated priv levels (such as registered configuration sessions)\n    self.channel.comms_prompt_pattern = (  # type: ignore  # pylint: disable=E1101\n        self.comms_prompt_pattern\n    )\n\n    # finally, clear the lru caches as patterns may have been updated\n    self._determine_current_priv.cache_clear()\n</code></pre>"},{"location":"reference/driver/network/base_driver/#driver.network.base_driver.PrivilegeLevel","title":"<code>PrivilegeLevel</code>","text":"Source code in <code>driver/network/base_driver.py</code> <pre><code>class PrivilegeLevel:\n    __slots__ = (\n        \"pattern\",\n        \"name\",\n        \"previous_priv\",\n        \"deescalate\",\n        \"escalate\",\n        \"escalate_auth\",\n        \"escalate_prompt\",\n        \"not_contains\",\n    )\n\n    def __init__(\n        self,\n        pattern: str,\n        name: str,\n        previous_priv: str,\n        deescalate: str,\n        escalate: str,\n        escalate_auth: bool,\n        escalate_prompt: str,\n        not_contains: Optional[List[str]] = None,\n    ):\n\"\"\"\n        PrivilegeLevel Object\n\n        Args:\n            pattern: regex pattern to use to identify this privilege level by the prompt\n            name: friendly name of this privilege level\n            previous_priv: name of the lower/previous privilege level\n            deescalate: how to deescalate *from* this privilege level (to the lower/previous priv)\n            escalate: how to escalate *to* this privilege level (from the lower/previous priv)\n            escalate_auth: True/False escalation requires authentication\n            escalate_prompt: prompt pattern to search for during escalation if escalate auth is True\n            not_contains: list of substrings that should *not* be seen in a prompt for this\n                privilege level\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.pattern = pattern\n        self.name = name\n        self.previous_priv = previous_priv\n        self.deescalate = deescalate\n        self.escalate = escalate\n        self.escalate_auth = escalate_auth\n        self.escalate_prompt = escalate_prompt\n        self.not_contains: List[str] = not_contains or []\n</code></pre>"},{"location":"reference/driver/network/base_driver/#driver.network.base_driver.PrivilegeLevel.__init__","title":"<code>__init__(pattern: str, name: str, previous_priv: str, deescalate: str, escalate: str, escalate_auth: bool, escalate_prompt: str, not_contains: Optional[List[str]] = None)</code>","text":"<p>PrivilegeLevel Object</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>regex pattern to use to identify this privilege level by the prompt</p> required <code>name</code> <code>str</code> <p>friendly name of this privilege level</p> required <code>previous_priv</code> <code>str</code> <p>name of the lower/previous privilege level</p> required <code>deescalate</code> <code>str</code> <p>how to deescalate from this privilege level (to the lower/previous priv)</p> required <code>escalate</code> <code>str</code> <p>how to escalate to this privilege level (from the lower/previous priv)</p> required <code>escalate_auth</code> <code>bool</code> <p>True/False escalation requires authentication</p> required <code>escalate_prompt</code> <code>str</code> <p>prompt pattern to search for during escalation if escalate auth is True</p> required <code>not_contains</code> <code>Optional[List[str]]</code> <p>list of substrings that should not be seen in a prompt for this privilege level</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>driver/network/base_driver.py</code> <pre><code>def __init__(\n    self,\n    pattern: str,\n    name: str,\n    previous_priv: str,\n    deescalate: str,\n    escalate: str,\n    escalate_auth: bool,\n    escalate_prompt: str,\n    not_contains: Optional[List[str]] = None,\n):\n\"\"\"\n    PrivilegeLevel Object\n\n    Args:\n        pattern: regex pattern to use to identify this privilege level by the prompt\n        name: friendly name of this privilege level\n        previous_priv: name of the lower/previous privilege level\n        deescalate: how to deescalate *from* this privilege level (to the lower/previous priv)\n        escalate: how to escalate *to* this privilege level (from the lower/previous priv)\n        escalate_auth: True/False escalation requires authentication\n        escalate_prompt: prompt pattern to search for during escalation if escalate auth is True\n        not_contains: list of substrings that should *not* be seen in a prompt for this\n            privilege level\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.pattern = pattern\n    self.name = name\n    self.previous_priv = previous_priv\n    self.deescalate = deescalate\n    self.escalate = escalate\n    self.escalate_auth = escalate_auth\n    self.escalate_prompt = escalate_prompt\n    self.not_contains: List[str] = not_contains or []\n</code></pre>"},{"location":"reference/driver/network/sync_driver/","title":"sync_driver","text":"<p>scrapli.driver.network.sync_driver</p>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver","title":"<code>NetworkDriver</code>","text":"<p>         Bases: <code>GenericDriver</code>, <code>BaseNetworkDriver</code></p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>class NetworkDriver(GenericDriver, BaseNetworkDriver):\n    def __init__(\n        self,\n        host: str,\n        privilege_levels: Dict[str, PrivilegeLevel],\n        default_desired_privilege_level: str,\n        port: Optional[int] = None,\n        auth_username: str = \"\",\n        auth_password: str = \"\",\n        auth_private_key: str = \"\",\n        auth_private_key_passphrase: str = \"\",\n        auth_strict_key: bool = True,\n        auth_bypass: bool = False,\n        timeout_socket: float = 15.0,\n        timeout_transport: float = 30.0,\n        timeout_ops: float = 30.0,\n        comms_return_char: str = \"\\n\",\n        ssh_config_file: Union[str, bool] = False,\n        ssh_known_hosts_file: Union[str, bool] = False,\n        on_init: Optional[Callable[..., Any]] = None,\n        on_open: Optional[Callable[..., Any]] = None,\n        on_close: Optional[Callable[..., Any]] = None,\n        transport: str = \"system\",\n        transport_options: Optional[Dict[str, Any]] = None,\n        channel_log: Union[str, bool, BytesIO] = False,\n        channel_log_mode: str = \"write\",\n        channel_lock: bool = False,\n        logging_uid: str = \"\",\n        auth_secondary: str = \"\",\n        failed_when_contains: Optional[List[str]] = None,\n        textfsm_platform: str = \"\",\n        genie_platform: str = \"\",\n    ):\n        # ensure type for comms_prompt_pattern exists before setting it in the mixin\n        self.comms_prompt_pattern: str\n\n        super().__init__(\n            host=host,\n            port=port,\n            auth_username=auth_username,\n            auth_password=auth_password,\n            auth_private_key=auth_private_key,\n            auth_private_key_passphrase=auth_private_key_passphrase,\n            auth_strict_key=auth_strict_key,\n            auth_bypass=auth_bypass,\n            timeout_socket=timeout_socket,\n            timeout_transport=timeout_transport,\n            timeout_ops=timeout_ops,\n            comms_return_char=comms_return_char,\n            ssh_config_file=ssh_config_file,\n            ssh_known_hosts_file=ssh_known_hosts_file,\n            on_init=on_init,\n            on_open=on_open,\n            on_close=on_close,\n            transport=transport,\n            transport_options=transport_options,\n            channel_log=channel_log,\n            channel_log_mode=channel_log_mode,\n            channel_lock=channel_lock,\n            logging_uid=logging_uid,\n        )\n\n        self.auth_secondary = auth_secondary\n        self.failed_when_contains = failed_when_contains or []\n        self.textfsm_platform = textfsm_platform\n        self.genie_platform = genie_platform\n\n        self.privilege_levels = privilege_levels\n        self.default_desired_privilege_level = default_desired_privilege_level\n        self._priv_graph = defaultdict(set)\n        self.update_privilege_levels()\n\n    def _escalate(self, escalate_priv: PrivilegeLevel) -&gt; None:\n\"\"\"\n        Escalate to the next privilege level up\n\n        Args:\n            escalate_priv: privilege level to escalate to\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliAuthenticationFailed: if auth escalation timeout\n\n        \"\"\"\n        self._pre_escalate(escalate_priv=escalate_priv)\n\n        if escalate_priv.escalate_auth is False:\n            self.channel.send_input(channel_input=escalate_priv.escalate)\n        else:\n            try:\n                super().send_interactive(\n                    interact_events=[\n                        (escalate_priv.escalate, escalate_priv.escalate_prompt, False),\n                        (self.auth_secondary, escalate_priv.pattern, True),\n                    ],\n                    interaction_complete_patterns=[\n                        self.privilege_levels[escalate_priv.previous_priv].pattern,\n                        escalate_priv.pattern,\n                    ],\n                )\n            except ScrapliTimeout as exc:\n                raise ScrapliAuthenticationFailed(\n                    f\"failed escalating privilege from '{escalate_priv.previous_priv}' to \"\n                    f\"'{escalate_priv.name}'. do you need to set an 'auth_secondary' password?\"\n                ) from exc\n\n    def _deescalate(self, current_priv: PrivilegeLevel) -&gt; None:\n\"\"\"\n        Deescalate to the next privilege level down\n\n        Args:\n            current_priv: current privilege level\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.channel.send_input(channel_input=current_priv.deescalate)\n\n    def acquire_priv(self, desired_priv: str) -&gt; None:\n\"\"\"\n        Acquire desired priv level\n\n        Args:\n            desired_priv: string name of desired privilege level see\n                `scrapli.driver.&lt;driver_category.device_type&gt;.driver` for levels\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliPrivilegeError: if desired_priv cannot be attained\n\n        \"\"\"\n        self._validate_privilege_level_name(privilege_level_name=desired_priv)\n\n        privilege_change_count = 0\n\n        while True:\n            current_prompt = self.channel.get_prompt()\n            privilege_action, target_priv = self._process_acquire_priv(\n                destination_priv=desired_priv,\n                current_prompt=current_prompt,\n            )\n\n            if privilege_action == PrivilegeAction.NO_ACTION:\n                self._current_priv_level = target_priv\n                return\n            if privilege_action == PrivilegeAction.DEESCALATE:\n                self._deescalate(current_priv=target_priv)\n            if privilege_action == PrivilegeAction.ESCALATE:\n                self._escalate(escalate_priv=target_priv)\n\n            privilege_change_count += 1\n            if privilege_change_count &gt; len(self.privilege_levels) * 2:\n                msg = f\"Failed to acquire requested privilege level {desired_priv}\"\n                raise ScrapliPrivilegeError(msg)\n\n    def _acquire_appropriate_privilege_level(self, privilege_level: str = \"\") -&gt; None:\n\"\"\"\n        Acquire the appropriate priv level\n\n        Acquires the \"right\" priv level based on generic_driver_mode, provided privilege level,\n        and default desired privilege level. If in \"generic_driver_mode\" and no priv level is\n        provided, we simply return as we are already at the \"right\" priv level (since we don't care\n        about priv levels in this mode). If we are in \"generic_driver_mode\" and we are provided a\n        priv level (this is only applicable in `send_interactive`) we will try to acquire that\n        provided priv level. If a priv name is passed we try to resolve it and use that as the\n        privilege level to acquire, otherwise if no priv leve is provided we will acquire the\n        default_desired_privilege_level.\n\n        Args:\n            privilege_level: optional name of privilege level to acquire\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not privilege_level and self._generic_driver_mode is True:\n            return\n\n        if privilege_level:\n            self._validate_privilege_level_name(privilege_level_name=privilege_level)\n            resolved_privilege_level = privilege_level\n        else:\n            resolved_privilege_level = self.default_desired_privilege_level\n\n        if self._current_priv_level.name != resolved_privilege_level:\n            self.acquire_priv(desired_priv=resolved_privilege_level)\n\n    def send_command(\n        self,\n        command: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send a command\n\n        Super method will raise TypeError if anything but a string is passed here!\n\n        Args:\n            command: string to send to device in privilege exec mode\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._acquire_appropriate_privilege_level()\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        response: Response = super().send_command(\n            command=command,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n        )\n        self._update_response(response)\n\n        return response\n\n    def send_commands(\n        self,\n        commands: List[str],\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send multiple commands\n\n        Super method will raise TypeError if anything but a list of strings is passed here!\n\n        Args:\n            commands: list of strings to send to device in privilege exec mode\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._acquire_appropriate_privilege_level()\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        responses = super().send_commands(\n            commands=commands,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n        for response in responses:\n            self._update_response(response=response)\n\n        return responses\n\n    def send_commands_from_file(\n        self,\n        file: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send command(s) from file\n\n        Args:\n            file: string path to file\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._acquire_appropriate_privilege_level()\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        return super().send_commands_from_file(\n            file=file,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n    def send_interactive(\n        self,\n        interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n        *,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        privilege_level: str = \"\",\n        timeout_ops: Optional[float] = None,\n        interaction_complete_patterns: Optional[List[str]] = None,\n    ) -&gt; Response:\n\"\"\"\n        Interact with a device with changing prompts per input.\n\n        Used to interact with devices where prompts change per input, and where inputs may be hidden\n        such as in the case of a password input. This can be used to respond to challenges from\n        devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n        example. You may have as many elements in the \"interact_events\" list as needed, and each\n        element of that list should be a tuple of two or three elements. The first element is always\n        the input to send as a string, the second should be the expected response as a string, and\n        the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n        An example where we need this sort of capability:\n\n        '''\n        3560CX#copy flash: scp:\n        Source filename []? test1.txt\n        Address or name of remote host []? 172.31.254.100\n        Destination username [carl]?\n        Writing test1.txt\n        Password:\n\n        Password:\n         Sink: C0644 639 test1.txt\n        !\n        639 bytes copied in 12.066 secs (53 bytes/sec)\n        3560CX#\n        '''\n\n        To accomplish this we can use the following:\n\n        '''\n        interact = conn.channel.send_inputs_interact(\n            [\n                (\"copy flash: scp:\", \"Source filename []?\", False),\n                (\"test1.txt\", \"Address or name of remote host []?\", False),\n                (\"172.31.254.100\", \"Destination username [carl]?\", False),\n                (\"carl\", \"Password:\", False),\n                (\"super_secure_password\", prompt, True),\n            ]\n        )\n        '''\n\n        If we needed to deal with more prompts we could simply continue adding tuples to the list of\n        interact \"events\".\n\n        Args:\n            interact_events: list of tuples containing the \"interactions\" with the device\n                each list element must have an input and an expected response, and may have an\n                optional bool for the third and final element -- the optional bool specifies if the\n                input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n                not provided it is assumed the input is \"normal\" (not hidden)\n            failed_when_contains: list of strings that, if present in final output, represent a\n                failed command/interaction\n            privilege_level: name of the privilege level to operate in\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER COMMAND sent, not for the total\n                of the commands being sent!\n            interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n                \"session\" has ended and we should exit the interactive session.\n\n        Returns:\n            Response: scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._acquire_appropriate_privilege_level(privilege_level=privilege_level)\n\n        if failed_when_contains is None:\n            failed_when_contains = self.failed_when_contains\n\n        # type hint is due to the timeout_modifier wrapper returning `Any` so that we dont anger the\n        # asyncio parts (which will get an awaitable not a Response returned)\n        response: Response = super().send_interactive(\n            interact_events=interact_events,\n            failed_when_contains=failed_when_contains,\n            timeout_ops=timeout_ops,\n            interaction_complete_patterns=interaction_complete_patterns,\n        )\n        self._update_response(response=response)\n\n        return response\n\n    def _abort_config(self) -&gt; None:\n\"\"\"\n        Abort a configuration operation/session if applicable (for config sessions like junos/iosxr)\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    def send_configs(\n        self,\n        configs: List[str],\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        privilege_level: str = \"\",\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send configuration(s)\n\n        Args:\n            configs: list of strings to send to device in config mode\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution; aborts configuration session if applicable (iosxr/junos or\n                eos/nxos if using a configuration session)\n            privilege_level: name of configuration privilege level/type to acquire; this is platform\n                dependent, so check the device driver for specifics. Examples of privilege_name\n                would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n                JunosDriver. You can also pass in a name of a configuration session such as\n                \"my-config-session\" if you have registered a session using the\n                \"register_config_session\" method of the EOSDriver or NXOSDriver.\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER CONFIG sent, not for the total\n                of the configs being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        resolved_privilege_level, failed_when_contains = self._pre_send_configs(\n            configs=configs,\n            failed_when_contains=failed_when_contains,\n            privilege_level=privilege_level,\n        )\n\n        if self._current_priv_level.name != resolved_privilege_level:\n            self.acquire_priv(desired_priv=resolved_privilege_level)\n\n        responses = super().send_commands(\n            commands=configs,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n\n        if stop_on_failed and responses.failed:\n            self._abort_config()\n\n        return self._post_send_configs(responses=responses)\n\n    def send_config(\n        self,\n        config: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        privilege_level: str = \"\",\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; Response:\n\"\"\"\n        Send configuration string\n\n        Args:\n            config: string configuration to send to the device, supports sending multi-line strings\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution; aborts configuration session if applicable (iosxr/junos or\n                eos/nxos if using a configuration session)\n            privilege_level: name of configuration privilege level/type to acquire; this is platform\n                dependent, so check the device driver for specifics. Examples of privilege_name\n                would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n                JunosDriver. You can also pass in a name of a configuration session such as\n                \"my-config-session\" if you have registered a session using the\n                \"register_config_session\" method of the EOSDriver or NXOSDriver.\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER CONFIG sent, not for the total\n                of the configs being sent!\n\n        Returns:\n            Response: Scrapli Response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        split_config = self._pre_send_config(config=config)\n\n        # now that we have a list of configs, just use send_configs to actually execute them\n        multi_response = self.send_configs(\n            configs=split_config,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            privilege_level=privilege_level,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n        return self._post_send_config(config=config, multi_response=multi_response)\n\n    def send_configs_from_file(\n        self,\n        file: str,\n        *,\n        strip_prompt: bool = True,\n        failed_when_contains: Optional[Union[str, List[str]]] = None,\n        stop_on_failed: bool = False,\n        privilege_level: str = \"\",\n        eager: bool = False,\n        timeout_ops: Optional[float] = None,\n    ) -&gt; MultiResponse:\n\"\"\"\n        Send configuration(s) from a file\n\n        Args:\n            file: string path to file\n            strip_prompt: True/False strip prompt from returned output\n            failed_when_contains: string or list of strings indicating failure if found in response\n            stop_on_failed: True/False stop executing commands if a command fails, returns results\n                as of current execution; aborts configuration session if applicable (iosxr/junos or\n                eos/nxos if using a configuration session)\n            privilege_level: name of configuration privilege level/type to acquire; this is platform\n                dependent, so check the device driver for specifics. Examples of privilege_name\n                would be \"exclusive\" for IOSXRDriver, \"private\" for JunosDriver. You can also pass\n                in a name of a configuration session such as \"session_mysession\" if you have\n                registered a session using the \"register_config_session\" method of the EOSDriver or\n                NXOSDriver.\n            eager: if eager is True we do not read until prompt is seen at each command sent to the\n                channel. Do *not* use this unless you know what you are doing as it is possible that\n                it can make scrapli less reliable!\n            timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n                the duration of the operation, value is reset to initial value after operation is\n                completed. Note that this is the timeout value PER CONFIG sent, not for the total\n                of the configs being sent!\n\n        Returns:\n            MultiResponse: Scrapli MultiResponse object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        configs = self._pre_send_from_file(file=file, caller=\"send_configs_from_file\")\n\n        return self.send_configs(\n            configs=configs,\n            strip_prompt=strip_prompt,\n            failed_when_contains=failed_when_contains,\n            stop_on_failed=stop_on_failed,\n            privilege_level=privilege_level,\n            eager=eager,\n            timeout_ops=timeout_ops,\n        )\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.acquire_priv","title":"<code>acquire_priv(desired_priv: str) -&gt; None</code>","text":"<p>Acquire desired priv level</p> <p>Parameters:</p> Name Type Description Default <code>desired_priv</code> <code>str</code> <p>string name of desired privilege level see <code>scrapli.driver.&lt;driver_category.device_type&gt;.driver</code> for levels</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliPrivilegeError</code> <p>if desired_priv cannot be attained</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def acquire_priv(self, desired_priv: str) -&gt; None:\n\"\"\"\n    Acquire desired priv level\n\n    Args:\n        desired_priv: string name of desired privilege level see\n            `scrapli.driver.&lt;driver_category.device_type&gt;.driver` for levels\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliPrivilegeError: if desired_priv cannot be attained\n\n    \"\"\"\n    self._validate_privilege_level_name(privilege_level_name=desired_priv)\n\n    privilege_change_count = 0\n\n    while True:\n        current_prompt = self.channel.get_prompt()\n        privilege_action, target_priv = self._process_acquire_priv(\n            destination_priv=desired_priv,\n            current_prompt=current_prompt,\n        )\n\n        if privilege_action == PrivilegeAction.NO_ACTION:\n            self._current_priv_level = target_priv\n            return\n        if privilege_action == PrivilegeAction.DEESCALATE:\n            self._deescalate(current_priv=target_priv)\n        if privilege_action == PrivilegeAction.ESCALATE:\n            self._escalate(escalate_priv=target_priv)\n\n        privilege_change_count += 1\n        if privilege_change_count &gt; len(self.privilege_levels) * 2:\n            msg = f\"Failed to acquire requested privilege level {desired_priv}\"\n            raise ScrapliPrivilegeError(msg)\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.send_command","title":"<code>send_command(command: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, timeout_ops: Optional[float] = None) -&gt; Response</code>","text":"<p>Send a command</p> <p>Super method will raise TypeError if anything but a string is passed here!</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>string to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def send_command(\n    self,\n    command: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    timeout_ops: Optional[float] = None,\n) -&gt; Response:\n\"\"\"\n    Send a command\n\n    Super method will raise TypeError if anything but a string is passed here!\n\n    Args:\n        command: string to send to device in privilege exec mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._acquire_appropriate_privilege_level()\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    response: Response = super().send_command(\n        command=command,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        timeout_ops=timeout_ops,\n    )\n    self._update_response(response)\n\n    return response\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.send_commands","title":"<code>send_commands(commands: List[str], *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>","text":"<p>Send multiple commands</p> <p>Super method will raise TypeError if anything but a list of strings is passed here!</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[str]</code> <p>list of strings to send to device in privilege exec mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def send_commands(\n    self,\n    commands: List[str],\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send multiple commands\n\n    Super method will raise TypeError if anything but a list of strings is passed here!\n\n    Args:\n        commands: list of strings to send to device in privilege exec mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._acquire_appropriate_privilege_level()\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    responses = super().send_commands(\n        commands=commands,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    for response in responses:\n        self._update_response(response=response)\n\n    return responses\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.send_commands_from_file","title":"<code>send_commands_from_file(file: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>","text":"<p>Send command(s) from file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>string path to file</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution</p> <code>False</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def send_commands_from_file(\n    self,\n    file: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send command(s) from file\n\n    Args:\n        file: string path to file\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._acquire_appropriate_privilege_level()\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    return super().send_commands_from_file(\n        file=file,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.send_config","title":"<code>send_config(config: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; Response</code>","text":"<p>Send configuration string</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string configuration to send to the device, supports sending multi-line strings</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution; aborts configuration session if applicable (iosxr/junos or eos/nxos if using a configuration session)</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Scrapli Response object</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def send_config(\n    self,\n    config: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; Response:\n\"\"\"\n    Send configuration string\n\n    Args:\n        config: string configuration to send to the device, supports sending multi-line strings\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution; aborts configuration session if applicable (iosxr/junos or\n            eos/nxos if using a configuration session)\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n            JunosDriver. You can also pass in a name of a configuration session such as\n            \"my-config-session\" if you have registered a session using the\n            \"register_config_session\" method of the EOSDriver or NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        Response: Scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    split_config = self._pre_send_config(config=config)\n\n    # now that we have a list of configs, just use send_configs to actually execute them\n    multi_response = self.send_configs(\n        configs=split_config,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        privilege_level=privilege_level,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n    return self._post_send_config(config=config, multi_response=multi_response)\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.send_configs","title":"<code>send_configs(configs: List[str], *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>","text":"<p>Send configuration(s)</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>List[str]</code> <p>list of strings to send to device in config mode</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution; aborts configuration session if applicable (iosxr/junos or eos/nxos if using a configuration session)</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for JunosDriver. You can also pass in a name of a configuration session such as \"my-config-session\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def send_configs(\n    self,\n    configs: List[str],\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send configuration(s)\n\n    Args:\n        configs: list of strings to send to device in config mode\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution; aborts configuration session if applicable (iosxr/junos or\n            eos/nxos if using a configuration session)\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"configuration_exclusive\" for IOSXRDriver, or \"configuration_private\" for\n            JunosDriver. You can also pass in a name of a configuration session such as\n            \"my-config-session\" if you have registered a session using the\n            \"register_config_session\" method of the EOSDriver or NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    resolved_privilege_level, failed_when_contains = self._pre_send_configs(\n        configs=configs,\n        failed_when_contains=failed_when_contains,\n        privilege_level=privilege_level,\n    )\n\n    if self._current_priv_level.name != resolved_privilege_level:\n        self.acquire_priv(desired_priv=resolved_privilege_level)\n\n    responses = super().send_commands(\n        commands=configs,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n\n    if stop_on_failed and responses.failed:\n        self._abort_config()\n\n    return self._post_send_configs(responses=responses)\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.send_configs_from_file","title":"<code>send_configs_from_file(file: str, *, strip_prompt: bool = True, failed_when_contains: Optional[Union[str, List[str]]] = None, stop_on_failed: bool = False, privilege_level: str = '', eager: bool = False, timeout_ops: Optional[float] = None) -&gt; MultiResponse</code>","text":"<p>Send configuration(s) from a file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>string path to file</p> required <code>strip_prompt</code> <code>bool</code> <p>True/False strip prompt from returned output</p> <code>True</code> <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>string or list of strings indicating failure if found in response</p> <code>None</code> <code>stop_on_failed</code> <code>bool</code> <p>True/False stop executing commands if a command fails, returns results as of current execution; aborts configuration session if applicable (iosxr/junos or eos/nxos if using a configuration session)</p> <code>False</code> <code>privilege_level</code> <code>str</code> <p>name of configuration privilege level/type to acquire; this is platform dependent, so check the device driver for specifics. Examples of privilege_name would be \"exclusive\" for IOSXRDriver, \"private\" for JunosDriver. You can also pass in a name of a configuration session such as \"session_mysession\" if you have registered a session using the \"register_config_session\" method of the EOSDriver or NXOSDriver.</p> <code>''</code> <code>eager</code> <code>bool</code> <p>if eager is True we do not read until prompt is seen at each command sent to the channel. Do not use this unless you know what you are doing as it is possible that it can make scrapli less reliable!</p> <code>False</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER CONFIG sent, not for the total of the configs being sent!</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MultiResponse</code> <code>MultiResponse</code> <p>Scrapli MultiResponse object</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def send_configs_from_file(\n    self,\n    file: str,\n    *,\n    strip_prompt: bool = True,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    stop_on_failed: bool = False,\n    privilege_level: str = \"\",\n    eager: bool = False,\n    timeout_ops: Optional[float] = None,\n) -&gt; MultiResponse:\n\"\"\"\n    Send configuration(s) from a file\n\n    Args:\n        file: string path to file\n        strip_prompt: True/False strip prompt from returned output\n        failed_when_contains: string or list of strings indicating failure if found in response\n        stop_on_failed: True/False stop executing commands if a command fails, returns results\n            as of current execution; aborts configuration session if applicable (iosxr/junos or\n            eos/nxos if using a configuration session)\n        privilege_level: name of configuration privilege level/type to acquire; this is platform\n            dependent, so check the device driver for specifics. Examples of privilege_name\n            would be \"exclusive\" for IOSXRDriver, \"private\" for JunosDriver. You can also pass\n            in a name of a configuration session such as \"session_mysession\" if you have\n            registered a session using the \"register_config_session\" method of the EOSDriver or\n            NXOSDriver.\n        eager: if eager is True we do not read until prompt is seen at each command sent to the\n            channel. Do *not* use this unless you know what you are doing as it is possible that\n            it can make scrapli less reliable!\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER CONFIG sent, not for the total\n            of the configs being sent!\n\n    Returns:\n        MultiResponse: Scrapli MultiResponse object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    configs = self._pre_send_from_file(file=file, caller=\"send_configs_from_file\")\n\n    return self.send_configs(\n        configs=configs,\n        strip_prompt=strip_prompt,\n        failed_when_contains=failed_when_contains,\n        stop_on_failed=stop_on_failed,\n        privilege_level=privilege_level,\n        eager=eager,\n        timeout_ops=timeout_ops,\n    )\n</code></pre>"},{"location":"reference/driver/network/sync_driver/#driver.network.sync_driver.NetworkDriver.send_interactive","title":"<code>send_interactive(interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]], *, failed_when_contains: Optional[Union[str, List[str]]] = None, privilege_level: str = '', timeout_ops: Optional[float] = None, interaction_complete_patterns: Optional[List[str]] = None) -&gt; Response</code>","text":"<p>Interact with a device with changing prompts per input.</p> <p>Used to interact with devices where prompts change per input, and where inputs may be hidden such as in the case of a password input. This can be used to respond to challenges from devices such as the confirmation for the command \"clear logging\" on IOSXE devices for example. You may have as many elements in the \"interact_events\" list as needed, and each element of that list should be a tuple of two or three elements. The first element is always the input to send as a string, the second should be the expected response as a string, and the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)</p> <p>An example where we need this sort of capability:</p> <p>''' 3560CX#copy flash: scp: Source filename []? test1.txt Address or name of remote host []? 172.31.254.100 Destination username [carl]? Writing test1.txt Password:</p> Password <p>Sink: C0644 639 test1.txt</p> <p>! 639 bytes copied in 12.066 secs (53 bytes/sec) 3560CX# '''</p> <p>To accomplish this we can use the following:</p> <p>''' interact = conn.channel.send_inputs_interact(     [         (\"copy flash: scp:\", \"Source filename []?\", False),         (\"test1.txt\", \"Address or name of remote host []?\", False),         (\"172.31.254.100\", \"Destination username [carl]?\", False),         (\"carl\", \"Password:\", False),         (\"super_secure_password\", prompt, True),     ] ) '''</p> <p>If we needed to deal with more prompts we could simply continue adding tuples to the list of interact \"events\".</p> <p>Parameters:</p> Name Type Description Default <code>interact_events</code> <code>Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]]</code> <p>list of tuples containing the \"interactions\" with the device each list element must have an input and an expected response, and may have an optional bool for the third and final element -- the optional bool specifies if the input that is sent to the device is \"hidden\" (ex: password), if the hidden param is not provided it is assumed the input is \"normal\" (not hidden)</p> required <code>failed_when_contains</code> <code>Optional[Union[str, List[str]]]</code> <p>list of strings that, if present in final output, represent a failed command/interaction</p> <code>None</code> <code>privilege_level</code> <code>str</code> <p>name of the privilege level to operate in</p> <code>''</code> <code>timeout_ops</code> <code>Optional[float]</code> <p>timeout ops value for this operation; only sets the timeout_ops value for the duration of the operation, value is reset to initial value after operation is completed. Note that this is the timeout value PER COMMAND sent, not for the total of the commands being sent!</p> <code>None</code> <code>interaction_complete_patterns</code> <code>Optional[List[str]]</code> <p>list of patterns, that if seen, indicate the interactive \"session\" has ended and we should exit the interactive session.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>scrapli Response object</p> Source code in <code>driver/network/sync_driver.py</code> <pre><code>def send_interactive(\n    self,\n    interact_events: Union[List[Tuple[str, str]], List[Tuple[str, str, bool]]],\n    *,\n    failed_when_contains: Optional[Union[str, List[str]]] = None,\n    privilege_level: str = \"\",\n    timeout_ops: Optional[float] = None,\n    interaction_complete_patterns: Optional[List[str]] = None,\n) -&gt; Response:\n\"\"\"\n    Interact with a device with changing prompts per input.\n\n    Used to interact with devices where prompts change per input, and where inputs may be hidden\n    such as in the case of a password input. This can be used to respond to challenges from\n    devices such as the confirmation for the command \"clear logging\" on IOSXE devices for\n    example. You may have as many elements in the \"interact_events\" list as needed, and each\n    element of that list should be a tuple of two or three elements. The first element is always\n    the input to send as a string, the second should be the expected response as a string, and\n    the optional third a bool for whether or not the input is \"hidden\" (i.e. password input)\n\n    An example where we need this sort of capability:\n\n    '''\n    3560CX#copy flash: scp:\n    Source filename []? test1.txt\n    Address or name of remote host []? 172.31.254.100\n    Destination username [carl]?\n    Writing test1.txt\n    Password:\n\n    Password:\n     Sink: C0644 639 test1.txt\n    !\n    639 bytes copied in 12.066 secs (53 bytes/sec)\n    3560CX#\n    '''\n\n    To accomplish this we can use the following:\n\n    '''\n    interact = conn.channel.send_inputs_interact(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"test1.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"carl\", \"Password:\", False),\n            (\"super_secure_password\", prompt, True),\n        ]\n    )\n    '''\n\n    If we needed to deal with more prompts we could simply continue adding tuples to the list of\n    interact \"events\".\n\n    Args:\n        interact_events: list of tuples containing the \"interactions\" with the device\n            each list element must have an input and an expected response, and may have an\n            optional bool for the third and final element -- the optional bool specifies if the\n            input that is sent to the device is \"hidden\" (ex: password), if the hidden param is\n            not provided it is assumed the input is \"normal\" (not hidden)\n        failed_when_contains: list of strings that, if present in final output, represent a\n            failed command/interaction\n        privilege_level: name of the privilege level to operate in\n        timeout_ops: timeout ops value for this operation; only sets the timeout_ops value for\n            the duration of the operation, value is reset to initial value after operation is\n            completed. Note that this is the timeout value PER COMMAND sent, not for the total\n            of the commands being sent!\n        interaction_complete_patterns: list of patterns, that if seen, indicate the interactive\n            \"session\" has ended and we should exit the interactive session.\n\n    Returns:\n        Response: scrapli Response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._acquire_appropriate_privilege_level(privilege_level=privilege_level)\n\n    if failed_when_contains is None:\n        failed_when_contains = self.failed_when_contains\n\n    # type hint is due to the timeout_modifier wrapper returning `Any` so that we dont anger the\n    # asyncio parts (which will get an awaitable not a Response returned)\n    response: Response = super().send_interactive(\n        interact_events=interact_events,\n        failed_when_contains=failed_when_contains,\n        timeout_ops=timeout_ops,\n        interaction_complete_patterns=interaction_complete_patterns,\n    )\n    self._update_response(response=response)\n\n    return response\n</code></pre>"},{"location":"reference/transport/","title":"transport","text":"<p>scrapli.transport</p>"},{"location":"reference/transport/base/","title":"base","text":"<p>scrapli.transport.base</p>"},{"location":"reference/transport/base/async_transport/","title":"async_transport","text":"<p>scrapli.transport.async_transport</p>"},{"location":"reference/transport/base/async_transport/#transport.base.async_transport.AsyncTransport","title":"<code>AsyncTransport</code>","text":"<p>         Bases: <code>BaseTransport</code>, <code>ABC</code></p> Source code in <code>transport/base/async_transport.py</code> <pre><code>class AsyncTransport(BaseTransport, ABC):\n    @abstractmethod\n    async def open(self) -&gt; None:\n\"\"\"\n        Open the transport session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def read(self) -&gt; bytes:\n\"\"\"\n        Read data from the transport session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n</code></pre>"},{"location":"reference/transport/base/async_transport/#transport.base.async_transport.AsyncTransport.open","title":"<code>open() -&gt; None</code>  <code>async</code> <code>abstractmethod</code>","text":"<p>Open the transport session</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/base/async_transport.py</code> <pre><code>@abstractmethod\nasync def open(self) -&gt; None:\n\"\"\"\n    Open the transport session\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/base/async_transport/#transport.base.async_transport.AsyncTransport.read","title":"<code>read() -&gt; bytes</code>  <code>async</code> <code>abstractmethod</code>","text":"<p>Read data from the transport session</p> <p>Returns:</p> Type Description <code>bytes</code> <p>None</p> Source code in <code>transport/base/async_transport.py</code> <pre><code>@abstractmethod\nasync def read(self) -&gt; bytes:\n\"\"\"\n    Read data from the transport session\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/base/base_socket/","title":"base_socket","text":"<p>scrapli.transport.base.base_socket</p>"},{"location":"reference/transport/base/base_socket/#transport.base.base_socket.Socket","title":"<code>Socket</code>","text":"Source code in <code>transport/base/base_socket.py</code> <pre><code>class Socket:\n    def __init__(self, host: str, port: int, timeout: float):\n\"\"\"\n        Socket object\n\n        Args:\n            host: host to connect to\n            port: port to connect to\n            timeout: timeout in seconds\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger = get_instance_logger(instance_name=\"scrapli.socket\", host=host, port=port)\n\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n\n        self.sock: Optional[socket.socket] = None\n\n    def __bool__(self) -&gt; bool:\n\"\"\"\n        Magic bool method for Socket\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if socket is alive or not\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self.isalive()\n\n    def _connect(self, socket_address_families: Set[\"socket.AddressFamily\"]) -&gt; None:\n\"\"\"\n        Try to open socket to host using all possible address families\n\n        It seems that very occasionally when resolving a hostname (i.e. localhost during functional\n        tests against vrouter devices), a v6 address family will be the first af the socket\n        getaddrinfo returns, in this case, because the qemu hostfwd is not listening on ::1, instead\n        only listening on 127.0.0.1 the connection will fail. Presumably this is something that can\n        happen in real life too... something gets resolved with a v6 address but is denying\n        connections or just not listening on that ipv6 address. This little connect wrapper is\n        intended to deal with these weird scenarios.\n\n        Args:\n            socket_address_families: set of address families available for the provided host\n                really only should ever be v4 AND v6 if providing a hostname that resolves with\n                both addresses, otherwise if you just provide a v4/v6 address it will just be a\n                single address family for that type of address\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if socket refuses connection on all address families\n            ScrapliConnectionNotOpened: if socket connection times out on all address families\n\n        \"\"\"\n        for address_family_index, address_family in enumerate(socket_address_families, start=1):\n            self.sock = socket.socket(address_family, socket.SOCK_STREAM)\n            self.sock.settimeout(self.timeout)\n\n            try:\n                self.sock.connect((self.host, self.port))\n            except ConnectionRefusedError as exc:\n                msg = (\n                    f\"connection refused trying to open socket to {self.host} on port {self.port} \"\n                    f\"for address family {address_family.name}\"\n                )\n                self.logger.warning(msg)\n                if address_family_index == len(socket_address_families):\n                    raise ScrapliConnectionNotOpened(msg) from exc\n            except socket.timeout as exc:\n                msg = (\n                    f\"timed out trying to open socket to {self.host} on port {self.port} for \"\n                    f\"address family {address_family.name}\"\n                )\n                self.logger.warning(msg)\n                if address_family_index == len(socket_address_families):\n                    raise ScrapliConnectionNotOpened(msg) from exc\n            else:\n                return\n\n    def open(self) -&gt; None:\n\"\"\"\n        Open underlying socket\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if cant fetch socket addr info\n\n        \"\"\"\n        self.logger.debug(f\"opening socket connection to '{self.host}' on port '{self.port}'\")\n\n        socket_address_families = None\n        with suppress(socket.gaierror):\n            sock_info = socket.getaddrinfo(self.host, self.port)\n            if sock_info:\n                # get all possible address families for the provided host/port\n                # should only ever be two... one for v4 and one for v6... i think/hope?! :)?\n                socket_address_families = {sock[0] for sock in sock_info}\n\n        if not socket_address_families:\n            # this will likely need to be clearer just dont know what failure scenarios exist for\n            # this yet...\n            raise ScrapliConnectionNotOpened(\"failed to determine socket address family for host\")\n\n        if not self.isalive():\n            self._connect(socket_address_families=socket_address_families)\n\n        self.logger.debug(\n            f\"opened socket connection to '{self.host}' on port '{self.port}' successfully\"\n        )\n\n    def close(self) -&gt; None:\n\"\"\"\n        Close socket\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(f\"closing socket connection to '{self.host}' on port '{self.port}'\")\n\n        if self.isalive() and isinstance(self.sock, socket.socket):\n            self.sock.close()\n\n        self.logger.debug(\n            f\"closed socket connection to '{self.host}' on port '{self.port}' successfully\"\n        )\n\n    def isalive(self) -&gt; bool:\n\"\"\"\n        Check if socket is alive\n\n        Args:\n            N/A\n\n        Returns:\n            bool True/False if socket is alive\n\n        Raises:\n            N/A\n\n        \"\"\"\n        try:\n            if isinstance(self.sock, socket.socket):\n                self.sock.send(b\"\")\n                return True\n        except OSError:\n            self.logger.debug(f\"Socket to host {self.host} is not alive\")\n            return False\n        return False\n</code></pre>"},{"location":"reference/transport/base/base_socket/#transport.base.base_socket.Socket.__bool__","title":"<code>__bool__() -&gt; bool</code>","text":"<p>Magic bool method for Socket</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True/False if socket is alive or not</p> Source code in <code>transport/base/base_socket.py</code> <pre><code>def __bool__(self) -&gt; bool:\n\"\"\"\n    Magic bool method for Socket\n\n    Args:\n        N/A\n\n    Returns:\n        bool: True/False if socket is alive or not\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self.isalive()\n</code></pre>"},{"location":"reference/transport/base/base_socket/#transport.base.base_socket.Socket.__init__","title":"<code>__init__(host: str, port: int, timeout: float)</code>","text":"<p>Socket object</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>host to connect to</p> required <code>port</code> <code>int</code> <p>port to connect to</p> required <code>timeout</code> <code>float</code> <p>timeout in seconds</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>transport/base/base_socket.py</code> <pre><code>def __init__(self, host: str, port: int, timeout: float):\n\"\"\"\n    Socket object\n\n    Args:\n        host: host to connect to\n        port: port to connect to\n        timeout: timeout in seconds\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger = get_instance_logger(instance_name=\"scrapli.socket\", host=host, port=port)\n\n    self.host = host\n    self.port = port\n    self.timeout = timeout\n\n    self.sock: Optional[socket.socket] = None\n</code></pre>"},{"location":"reference/transport/base/base_socket/#transport.base.base_socket.Socket.close","title":"<code>close() -&gt; None</code>","text":"<p>Close socket</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/base/base_socket.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Close socket\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.debug(f\"closing socket connection to '{self.host}' on port '{self.port}'\")\n\n    if self.isalive() and isinstance(self.sock, socket.socket):\n        self.sock.close()\n\n    self.logger.debug(\n        f\"closed socket connection to '{self.host}' on port '{self.port}' successfully\"\n    )\n</code></pre>"},{"location":"reference/transport/base/base_socket/#transport.base.base_socket.Socket.isalive","title":"<code>isalive() -&gt; bool</code>","text":"<p>Check if socket is alive</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool True/False if socket is alive</p> Source code in <code>transport/base/base_socket.py</code> <pre><code>def isalive(self) -&gt; bool:\n\"\"\"\n    Check if socket is alive\n\n    Args:\n        N/A\n\n    Returns:\n        bool True/False if socket is alive\n\n    Raises:\n        N/A\n\n    \"\"\"\n    try:\n        if isinstance(self.sock, socket.socket):\n            self.sock.send(b\"\")\n            return True\n    except OSError:\n        self.logger.debug(f\"Socket to host {self.host} is not alive\")\n        return False\n    return False\n</code></pre>"},{"location":"reference/transport/base/base_socket/#transport.base.base_socket.Socket.open","title":"<code>open() -&gt; None</code>","text":"<p>Open underlying socket</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ScrapliConnectionNotOpened</code> <p>if cant fetch socket addr info</p> Source code in <code>transport/base/base_socket.py</code> <pre><code>def open(self) -&gt; None:\n\"\"\"\n    Open underlying socket\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        ScrapliConnectionNotOpened: if cant fetch socket addr info\n\n    \"\"\"\n    self.logger.debug(f\"opening socket connection to '{self.host}' on port '{self.port}'\")\n\n    socket_address_families = None\n    with suppress(socket.gaierror):\n        sock_info = socket.getaddrinfo(self.host, self.port)\n        if sock_info:\n            # get all possible address families for the provided host/port\n            # should only ever be two... one for v4 and one for v6... i think/hope?! :)?\n            socket_address_families = {sock[0] for sock in sock_info}\n\n    if not socket_address_families:\n        # this will likely need to be clearer just dont know what failure scenarios exist for\n        # this yet...\n        raise ScrapliConnectionNotOpened(\"failed to determine socket address family for host\")\n\n    if not self.isalive():\n        self._connect(socket_address_families=socket_address_families)\n\n    self.logger.debug(\n        f\"opened socket connection to '{self.host}' on port '{self.port}' successfully\"\n    )\n</code></pre>"},{"location":"reference/transport/base/base_transport/","title":"base_transport","text":"<p>scrapli.transport.base_transport</p>"},{"location":"reference/transport/base/base_transport/#transport.base.base_transport.BaseTransport","title":"<code>BaseTransport</code>","text":"<p>         Bases: <code>ABC</code></p> Source code in <code>transport/base/base_transport.py</code> <pre><code>class BaseTransport(ABC):\n    def __init__(self, base_transport_args: BaseTransportArgs) -&gt; None:\n\"\"\"\n        Scrapli's transport base class\n\n        Args:\n            base_transport_args: base transport args dataclass\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._base_transport_args = base_transport_args\n\n        self.logger = get_instance_logger(\n            instance_name=\"scrapli.transport\",\n            host=self._base_transport_args.host,\n            port=self._base_transport_args.port,\n            uid=self._base_transport_args.logging_uid,\n        )\n\n    @abstractmethod\n    def close(self) -&gt; None:\n\"\"\"\n        Close the transport session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def write(self, channel_input: bytes) -&gt; None:\n\"\"\"\n        Write bytes into the transport session\n\n        Args:\n            channel_input: bytes to write to transport session\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def isalive(self) -&gt; bool:\n\"\"\"\n        Check if transport is alive\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if transport is alive\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    def _pre_open_closing_log(self, closing: bool = False) -&gt; None:\n\"\"\"\n        Emit \"pre open\" log message for consistency between transports\n\n        Args:\n            closing: bool indicating if message is for closing not opening\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        operation = \"closing\" if closing else \"opening\"\n\n        self.logger.debug(\n            f\"{operation} transport connection to '{self._base_transport_args.host}' on port \"\n            f\"'{self._base_transport_args.port}'\"\n        )\n\n    def _post_open_closing_log(self, closing: bool = False) -&gt; None:\n\"\"\"\n        Emit \"post open\" log message for consistency between transports\n\n        Args:\n            closing: bool indicating if message is for closing not opening\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        operation = \"closed\" if closing else \"opened\"\n\n        self.logger.debug(\n            f\"transport connection to '{self._base_transport_args.host}' on port \"\n            f\"'{self._base_transport_args.port}' {operation} successfully\"\n        )\n</code></pre>"},{"location":"reference/transport/base/base_transport/#transport.base.base_transport.BaseTransport.__init__","title":"<code>__init__(base_transport_args: BaseTransportArgs) -&gt; None</code>","text":"<p>Scrapli's transport base class</p> <p>Parameters:</p> Name Type Description Default <code>base_transport_args</code> <code>BaseTransportArgs</code> <p>base transport args dataclass</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/base/base_transport.py</code> <pre><code>def __init__(self, base_transport_args: BaseTransportArgs) -&gt; None:\n\"\"\"\n    Scrapli's transport base class\n\n    Args:\n        base_transport_args: base transport args dataclass\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._base_transport_args = base_transport_args\n\n    self.logger = get_instance_logger(\n        instance_name=\"scrapli.transport\",\n        host=self._base_transport_args.host,\n        port=self._base_transport_args.port,\n        uid=self._base_transport_args.logging_uid,\n    )\n</code></pre>"},{"location":"reference/transport/base/base_transport/#transport.base.base_transport.BaseTransport.close","title":"<code>close() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Close the transport session</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/base/base_transport.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n\"\"\"\n    Close the transport session\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/base/base_transport/#transport.base.base_transport.BaseTransport.isalive","title":"<code>isalive() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if transport is alive</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True/False if transport is alive</p> Source code in <code>transport/base/base_transport.py</code> <pre><code>@abstractmethod\ndef isalive(self) -&gt; bool:\n\"\"\"\n    Check if transport is alive\n\n    Args:\n        N/A\n\n    Returns:\n        bool: True/False if transport is alive\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/base/base_transport/#transport.base.base_transport.BaseTransport.write","title":"<code>write(channel_input: bytes) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Write bytes into the transport session</p> <p>Parameters:</p> Name Type Description Default <code>channel_input</code> <code>bytes</code> <p>bytes to write to transport session</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/base/base_transport.py</code> <pre><code>@abstractmethod\ndef write(self, channel_input: bytes) -&gt; None:\n\"\"\"\n    Write bytes into the transport session\n\n    Args:\n        channel_input: bytes to write to transport session\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/base/sync_transport/","title":"sync_transport","text":"<p>scrapli.transport.base_transport</p>"},{"location":"reference/transport/base/sync_transport/#transport.base.sync_transport.Transport","title":"<code>Transport</code>","text":"<p>         Bases: <code>BaseTransport</code>, <code>ABC</code></p> Source code in <code>transport/base/sync_transport.py</code> <pre><code>class Transport(BaseTransport, ABC):\n    @abstractmethod\n    def open(self) -&gt; None:\n\"\"\"\n        Open the transport session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def read(self) -&gt; bytes:\n\"\"\"\n        Read data from the transport session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n</code></pre>"},{"location":"reference/transport/base/sync_transport/#transport.base.sync_transport.Transport.open","title":"<code>open() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Open the transport session</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/base/sync_transport.py</code> <pre><code>@abstractmethod\ndef open(self) -&gt; None:\n\"\"\"\n    Open the transport session\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/base/sync_transport/#transport.base.sync_transport.Transport.read","title":"<code>read() -&gt; bytes</code>  <code>abstractmethod</code>","text":"<p>Read data from the transport session</p> <p>Returns:</p> Type Description <code>bytes</code> <p>None</p> Source code in <code>transport/base/sync_transport.py</code> <pre><code>@abstractmethod\ndef read(self) -&gt; bytes:\n\"\"\"\n    Read data from the transport session\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/base/telnet_common/","title":"telnet_common","text":"<p>scrapli.transport.base.telnet_common</p>"},{"location":"reference/transport/plugins/","title":"plugins","text":"<p>scrapli.transport.plugins</p>"},{"location":"reference/transport/plugins/asyncssh/","title":"asyncssh","text":"<p>scrapli.transport.plugins.asyncssh</p>"},{"location":"reference/transport/plugins/asyncssh/transport/","title":"transport","text":"<p>scrapli.transport.plugins.asyncssh.transport</p>"},{"location":"reference/transport/plugins/asyncssh/transport/#transport.plugins.asyncssh.transport.AsyncsshTransport","title":"<code>AsyncsshTransport</code>","text":"<p>         Bases: <code>AsyncTransport</code></p> Source code in <code>transport/plugins/asyncssh/transport.py</code> <pre><code>class AsyncsshTransport(AsyncTransport):\n    def __init__(\n        self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n    ) -&gt; None:\n\"\"\"\n        Asyncssh transport plugin.\n\n        Important note: some ssh servers may refuse connections if too many ssh host key algorithms\n        are passed to it during the connection opening -- Asyncssh sends a bunch by default! If you\n        encounter this issue, you can simply update your SSH config file to set a smaller (or one)\n        number of ssh host key algorithms to work around this like so:\n\n        ```\n        Host *\n            HostKeyAlgorithms ssh-rsa\n        ```\n\n        Thank you to @davaeron [https://github.com/davaeron] for reporting this in #173, see also\n        asyncssh #323 here: https://github.com/ronf/asyncssh/issues/323.\n\n        This transport supports some additional `transport_options` to control behavior --\n        `asyncssh` is a dictionary that contains options that are passed directly to asyncssh during\n        connection creation, you can find the SSH Client options of asyncssh here:\n        https://asyncssh.readthedocs.io/en/latest/api.html#sshclientconnectionoptions.\n\n        Below is an example of passing in options to modify kex and encryption algorithms\n\n        ```\n        device = {\n            \"host\": \"localhost\",\n            \"transport_options\": {\n                \"asyncssh\": {\n                    \"kex_algs\": [\"diffie-hellman-group14-sha1\", \"diffie-hellman-group1-sha1\"],\n                    \"encryption_algs\": [\"aes256-cbc\", \"aes192-cbc\", \"aes256-ctr\", \"aes192-ctr\"],\n                }\n            },\n            \"platform\": \"cisco_iosxe\"\n        }\n\n        conn = Scrapli(**device)\n        ```\n\n        Args:\n            base_transport_args: scrapli base transport plugin arguments\n            plugin_transport_args: asyncssh ssh specific transport plugin arguments\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        super().__init__(base_transport_args=base_transport_args)\n        self.plugin_transport_args = plugin_transport_args\n\n        self.session: Optional[SSHClientConnection] = None\n        self.stdout: Optional[SSHReader[Any]] = None\n        self.stdin: Optional[SSHWriter[Any]] = None\n\n    def _verify_key(self) -&gt; None:\n\"\"\"\n        Verify target host public key, raise exception if invalid/unknown\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliAuthenticationFailed: if host is not in known hosts\n\n        \"\"\"\n        known_hosts = SSHKnownHosts(self.plugin_transport_args.ssh_known_hosts_file)\n        known_host_public_key = known_hosts.lookup(self._base_transport_args.host)\n\n        if not known_host_public_key:\n            raise ScrapliAuthenticationFailed(\n                f\"{self._base_transport_args.host} not in known_hosts!\"\n            )\n\n    def _verify_key_value(self) -&gt; None:\n\"\"\"\n        Verify target host public key, raise exception if invalid/unknown\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n            ScrapliAuthenticationFailed: if host is in known hosts but public key does not match or\n                cannot glean remote server key from session.\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        known_hosts = SSHKnownHosts(self.plugin_transport_args.ssh_known_hosts_file)\n        known_host_public_key = known_hosts.lookup(self._base_transport_args.host)\n\n        remote_server_key = self.session.get_server_host_key()\n        if remote_server_key is None:\n            raise ScrapliAuthenticationFailed(\n                f\"failed gleaning remote server ssh key for host {self._base_transport_args.host}\"\n            )\n\n        remote_public_key = remote_server_key.export_public_key().split()[1].decode()\n\n        if known_host_public_key[\"public_key\"] != remote_public_key:\n            raise ScrapliAuthenticationFailed(\n                f\"{self._base_transport_args.host} in known_hosts but public key does not match!\"\n            )\n\n    async def open(self) -&gt; None:\n        self._pre_open_closing_log(closing=False)\n\n        if self.plugin_transport_args.auth_strict_key:\n            self.logger.debug(\n                f\"Attempting to validate {self._base_transport_args.host} public key is in known \"\n                f\"hosts\"\n            )\n            self._verify_key()\n\n        # we already fetched host/port/user from the user input and/or the ssh config file, so we\n        # want to use those explicitly. likewise we pass config file we already found. set known\n        # hosts and agent to None so we can not have an agent and deal w/ known hosts ourselves.\n        # to use ssh-agent either pass an empty tuple (to pick up ssh-agent socket from\n        # SSH_AUTH_SOCK), or pass an explicit path to ssh-agent socket should be provided as part\n        # of transport_options -- in either case these get merged into the dict *after* we set the\n        # default value of `None`, so users options override our defaults.\n\n        common_args: Dict[str, Any] = {\n            \"host\": self._base_transport_args.host,\n            \"port\": self._base_transport_args.port,\n            \"username\": self.plugin_transport_args.auth_username,\n            \"known_hosts\": None,\n            \"agent_path\": None,\n            \"config\": self.plugin_transport_args.ssh_config_file,\n        }\n\n        # Allow passing `transport_options` to asyncssh\n        common_args.update(self._base_transport_args.transport_options.get(\"asyncssh\", {}))\n\n        # Common authentication args\n        auth_args: Dict[str, Any] = {\n            \"client_keys\": self.plugin_transport_args.auth_private_key,\n            \"password\": self.plugin_transport_args.auth_password,\n            \"preferred_auth\": (\n                \"publickey\",\n                \"keyboard-interactive\",\n                \"password\",\n            ),\n        }\n\n        # The session args to use in connect() - to merge the dicts in\n        # the order to have transport options preference over predefined auth args\n        conn_args = {**auth_args, **common_args}\n\n        try:\n            self.session = await asyncio.wait_for(\n                connect(**conn_args),\n                timeout=self._base_transport_args.timeout_socket,\n            )\n        except PermissionDenied as exc:\n            msg = \"all authentication methods failed\"\n            self.logger.critical(msg)\n            raise ScrapliAuthenticationFailed(msg) from exc\n        except asyncio.TimeoutError as exc:\n            msg = \"timed out opening connection to device\"\n            self.logger.critical(msg)\n            raise ScrapliAuthenticationFailed(msg) from exc\n\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        if self.plugin_transport_args.auth_strict_key:\n            self.logger.debug(\n                f\"Attempting to validate {self._base_transport_args.host} public key is in known \"\n                f\"hosts and is valid\"\n            )\n            self._verify_key_value()\n\n        self.stdin, self.stdout, _ = await self.session.open_session(\n            term_type=\"xterm\", encoding=None\n        )\n\n        self._post_open_closing_log(closing=False)\n\n    def close(self) -&gt; None:\n        self._pre_open_closing_log(closing=True)\n\n        if self.session:\n            with suppress(BrokenPipeError):\n                # this may raise a BrokenPipeError because seems it is possible for the connection\n                # transport is_closing() to be true already in some cases... since we are closing\n                # the connection anyway we will just ignore this note that this seemed to only\n                # happen in github actions on ubuntu-latest w/ py3.8... hence the suppress!\n                self.session.close()\n\n        # always reset session/stdin/stdout back to None if we are closing!\n        self.session = None\n        self.stdin = None\n        self.stdout = None\n\n        self._post_open_closing_log(closing=True)\n\n    def isalive(self) -&gt; bool:\n        if not self.session:\n            return False\n\n        # this may need to be revisited in the future, but this seems to be a good check for\n        # aliveness\n        with suppress(AttributeError):\n            if (\n                self.session._auth_complete  # pylint:  disable=W0212\n                and self.session._transport is not None  # pylint:  disable=W0212\n                and self.session._transport.is_closing() is False  # pylint:  disable=W0212\n            ):\n                return True\n\n        return False\n\n    @timeout_wrapper\n    async def read(self) -&gt; bytes:\n        if not self.stdout:\n            raise ScrapliConnectionNotOpened\n\n        try:\n            buf: bytes = await self.stdout.read(65535)\n        except ConnectionLost as exc:\n            msg = (\n                \"encountered EOF reading from transport; typically means the device closed the \"\n                \"connection\"\n            )\n            self.logger.critical(msg)\n            raise ScrapliConnectionError(msg) from exc\n\n        return buf\n\n    def write(self, channel_input: bytes) -&gt; None:\n        if not self.stdin:\n            raise ScrapliConnectionNotOpened\n        self.stdin.write(channel_input)\n</code></pre>"},{"location":"reference/transport/plugins/asyncssh/transport/#transport.plugins.asyncssh.transport.AsyncsshTransport.__init__","title":"<code>__init__(base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs) -&gt; None</code>","text":"<p>Asyncssh transport plugin.</p> <p>Important note: some ssh servers may refuse connections if too many ssh host key algorithms are passed to it during the connection opening -- Asyncssh sends a bunch by default! If you encounter this issue, you can simply update your SSH config file to set a smaller (or one) number of ssh host key algorithms to work around this like so:</p> <pre><code>Host *\n    HostKeyAlgorithms ssh-rsa\n</code></pre> <p>Thank you to @davaeron [https://github.com/davaeron] for reporting this in #173, see also asyncssh #323 here: https://github.com/ronf/asyncssh/issues/323.</p> <p>This transport supports some additional <code>transport_options</code> to control behavior -- <code>asyncssh</code> is a dictionary that contains options that are passed directly to asyncssh during connection creation, you can find the SSH Client options of asyncssh here: https://asyncssh.readthedocs.io/en/latest/api.html#sshclientconnectionoptions.</p> <p>Below is an example of passing in options to modify kex and encryption algorithms</p> <pre><code>device = {\n    \"host\": \"localhost\",\n    \"transport_options\": {\n        \"asyncssh\": {\n            \"kex_algs\": [\"diffie-hellman-group14-sha1\", \"diffie-hellman-group1-sha1\"],\n            \"encryption_algs\": [\"aes256-cbc\", \"aes192-cbc\", \"aes256-ctr\", \"aes192-ctr\"],\n        }\n    },\n    \"platform\": \"cisco_iosxe\"\n}\n\nconn = Scrapli(**device)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>base_transport_args</code> <code>BaseTransportArgs</code> <p>scrapli base transport plugin arguments</p> required <code>plugin_transport_args</code> <code>PluginTransportArgs</code> <p>asyncssh ssh specific transport plugin arguments</p> required <p>Returns:</p> Type Description <code>None</code> <p>N/A</p> Source code in <code>transport/plugins/asyncssh/transport.py</code> <pre><code>def __init__(\n    self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n) -&gt; None:\n\"\"\"\n    Asyncssh transport plugin.\n\n    Important note: some ssh servers may refuse connections if too many ssh host key algorithms\n    are passed to it during the connection opening -- Asyncssh sends a bunch by default! If you\n    encounter this issue, you can simply update your SSH config file to set a smaller (or one)\n    number of ssh host key algorithms to work around this like so:\n\n    ```\n    Host *\n        HostKeyAlgorithms ssh-rsa\n    ```\n\n    Thank you to @davaeron [https://github.com/davaeron] for reporting this in #173, see also\n    asyncssh #323 here: https://github.com/ronf/asyncssh/issues/323.\n\n    This transport supports some additional `transport_options` to control behavior --\n    `asyncssh` is a dictionary that contains options that are passed directly to asyncssh during\n    connection creation, you can find the SSH Client options of asyncssh here:\n    https://asyncssh.readthedocs.io/en/latest/api.html#sshclientconnectionoptions.\n\n    Below is an example of passing in options to modify kex and encryption algorithms\n\n    ```\n    device = {\n        \"host\": \"localhost\",\n        \"transport_options\": {\n            \"asyncssh\": {\n                \"kex_algs\": [\"diffie-hellman-group14-sha1\", \"diffie-hellman-group1-sha1\"],\n                \"encryption_algs\": [\"aes256-cbc\", \"aes192-cbc\", \"aes256-ctr\", \"aes192-ctr\"],\n            }\n        },\n        \"platform\": \"cisco_iosxe\"\n    }\n\n    conn = Scrapli(**device)\n    ```\n\n    Args:\n        base_transport_args: scrapli base transport plugin arguments\n        plugin_transport_args: asyncssh ssh specific transport plugin arguments\n\n    Returns:\n        N/A\n\n    Raises:\n        N/A\n\n    \"\"\"\n    super().__init__(base_transport_args=base_transport_args)\n    self.plugin_transport_args = plugin_transport_args\n\n    self.session: Optional[SSHClientConnection] = None\n    self.stdout: Optional[SSHReader[Any]] = None\n    self.stdin: Optional[SSHWriter[Any]] = None\n</code></pre>"},{"location":"reference/transport/plugins/asynctelnet/","title":"asynctelnet","text":"<p>scrapli.transport.plugins.asynctelnet</p>"},{"location":"reference/transport/plugins/asynctelnet/transport/","title":"transport","text":"<p>scrapli.transport.plugins.asynctelnet.transport</p>"},{"location":"reference/transport/plugins/asynctelnet/transport/#transport.plugins.asynctelnet.transport.AsynctelnetTransport","title":"<code>AsynctelnetTransport</code>","text":"<p>         Bases: <code>AsyncTransport</code></p> Source code in <code>transport/plugins/asynctelnet/transport.py</code> <pre><code>class AsynctelnetTransport(AsyncTransport):\n    def __init__(\n        self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n    ) -&gt; None:\n        super().__init__(base_transport_args=base_transport_args)\n        self.plugin_transport_args = plugin_transport_args\n\n        self.stdout: Optional[asyncio.StreamReader] = None\n        self.stdin: Optional[asyncio.StreamWriter] = None\n\n        self._eof = False\n        self._raw_buf = b\"\"\n        self._cooked_buf = b\"\"\n\n        self._control_char_sent_counter = 0\n        self._control_char_sent_limit = 10\n\n    def _handle_control_chars_response(self, control_buf: bytes, c: bytes) -&gt; bytes:\n\"\"\"\n        Handle the actual response to control characters\n\n        Broken up to be easier to test as well as to appease mr. mccabe\n\n        Args:\n            control_buf: current control_buf to work with\n            c: currently read control char to process\n\n        Returns:\n            bytes: updated control_buf\n\n        Raises:\n            ScrapliConnectionNotOpened: if connection is not opened for some reason\n\n        \"\"\"\n        if not self.stdin:\n            raise ScrapliConnectionNotOpened\n\n        # control_buf is empty, lets see if we got a control character\n        if not control_buf:\n            if c != IAC:\n                # add whatever character we read to the \"normal\" output buf so it gets sent off\n                # to the auth method later (username/show prompts may show up here)\n                self._cooked_buf += c\n            else:\n                # we got a control character, put it into the control_buf\n                control_buf += c\n\n        elif len(control_buf) == 1 and c in (DO, DONT, WILL, WONT):\n            # control buf already has the IAC byte loaded, if the next char is DO/DONT/WILL/WONT\n            # add that into the control buffer and move on\n            control_buf += c\n\n        elif len(control_buf) == 2:\n            # control buffer is already loaded with IAC and directive, we now have an option to\n            # deal with, create teh base command out of the existing buffer then reset the buf\n            # for the next go around\n            cmd = control_buf[1:2]\n            control_buf = b\"\"\n\n            if (cmd == DO) and (c == SUPPRESS_GO_AHEAD):\n                # if server says do suppress go ahead we say will for that option\n                self.stdin.write(IAC + WILL + c)\n            elif cmd in (DO, DONT):\n                # if server says do/dont we always say wont for that option\n                self.stdin.write(IAC + WONT + c)\n            elif cmd == WILL:\n                # if server says will we always say do for that option\n                self.stdin.write(IAC + DO + c)\n            elif cmd == WONT:\n                # if server says wont we always say dont for that option\n                self.stdin.write(IAC + DONT + c)\n\n        return control_buf\n\n    def _handle_control_chars(self) -&gt; None:\n\"\"\"\n        Handle control characters -- nearly identical to CPython telnetlib\n\n        Basically we want to read and \"decline\" any and all control options that the server proposes\n        to us -- so if they say \"DO\" XYZ directive, we say \"DONT\", if they say \"WILL\" we say \"WONT\".\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if connection is not opened for some reason\n            ScrapliConnectionNotOpened: if we read an empty byte string from the reader -- this\n                indicates the server sent an EOF -- see #142\n\n        \"\"\"\n        if not self.stdout:\n            raise ScrapliConnectionNotOpened\n\n        # control_buf is the buffer for control characters, we reset this after being \"done\" with\n        # responding to a control sequence, so it always represents the \"current\" control sequence\n        # we are working on responding to\n        control_buf = b\"\"\n\n        while self._raw_buf:\n            c, self._raw_buf = self._raw_buf[:1], self._raw_buf[1:]\n            if not c:\n                raise ScrapliConnectionNotOpened(\"server returned EOF, connection not opened\")\n\n            control_buf = self._handle_control_chars_response(control_buf=control_buf, c=c)\n\n    async def open(self) -&gt; None:\n        self._pre_open_closing_log(closing=False)\n\n        try:\n            fut = asyncio.open_connection(\n                host=self._base_transport_args.host, port=self._base_transport_args.port\n            )\n            self.stdout, self.stdin = await asyncio.wait_for(\n                fut, timeout=self._base_transport_args.timeout_socket\n            )\n        except ConnectionError as exc:\n            msg = f\"Failed to open telnet session to host {self._base_transport_args.host}\"\n            if \"connection refused\" in str(exc).lower():\n                msg = (\n                    f\"Failed to open telnet session to host {self._base_transport_args.host}, \"\n                    \"connection refused\"\n                )\n            raise ScrapliConnectionError(msg) from exc\n        except asyncio.TimeoutError as exc:\n            msg = \"timed out opening connection to device\"\n            self.logger.critical(msg)\n            raise ScrapliAuthenticationFailed(msg) from exc\n        except (OSError, socket.gaierror) as exc:\n            msg = (\n                f\"Failed to open telnet session to host {self._base_transport_args.host} -- \"\n                \"do you have a bad host/port?\"\n            )\n            raise ScrapliConnectionError(msg) from exc\n\n        self._post_open_closing_log(closing=False)\n\n    def close(self) -&gt; None:\n        self._pre_open_closing_log(closing=True)\n\n        if self.stdin:\n            self.stdin.close()\n\n            with suppress(AttributeError):\n                # wait closed only in 3.7+... unclear if we should be doing something else for 3.6?\n                # it doesnt seem to hurt anything... note 9/2022 probably can remove this but...\n                # it still doesnt seem to hurt anything :)\n                self.stdin.close()\n\n        self.stdin = None\n        self.stdout = None\n\n        self._post_open_closing_log(closing=True)\n\n    def isalive(self) -&gt; bool:\n        if not self.stdin or not self.stdout:\n            return False\n        return not self.stdout.at_eof()\n\n    async def _read(self, n: int = 65535) -&gt; None:\n        if not self.stdout:\n            raise ScrapliConnectionNotOpened\n\n        if not self._raw_buf:\n            try:\n                buf = await self.stdout.read(n)\n                self._eof = not buf\n                if self._control_char_sent_counter &lt; self._control_char_sent_limit:\n                    self._raw_buf += buf\n                else:\n                    self._cooked_buf += buf\n            except EOFError as exc:\n                raise ScrapliConnectionError(\n                    \"encountered EOF reading from transport; typically means the device closed the \"\n                    \"connection\"\n                ) from exc\n\n    @timeout_wrapper\n    async def read(self) -&gt; bytes:\n        if not self.stdout:\n            raise ScrapliConnectionNotOpened\n\n        if self._control_char_sent_counter &lt; self._control_char_sent_limit:\n            self._handle_control_chars()\n\n        while not self._cooked_buf and not self._eof:\n            await self._read()\n            if self._control_char_sent_counter &lt; self._control_char_sent_limit:\n                self._handle_control_chars()\n\n        buf = self._cooked_buf\n        self._cooked_buf = b\"\"\n\n        # possible to still have null bytes in the buf, replace them with nothing\n        return buf.replace(NULL, b\"\")\n\n    def write(self, channel_input: bytes) -&gt; None:\n        if not self.stdin:\n            raise ScrapliConnectionNotOpened\n        self.stdin.write(channel_input)\n</code></pre>"},{"location":"reference/transport/plugins/paramiko/","title":"paramiko","text":"<p>scrapli.transport.plugins.paramiko</p>"},{"location":"reference/transport/plugins/paramiko/transport/","title":"transport","text":"<p>scrapli.transport.plugins.paramiko.transport</p>"},{"location":"reference/transport/plugins/paramiko/transport/#transport.plugins.paramiko.transport.ParamikoTransport","title":"<code>ParamikoTransport</code>","text":"<p>         Bases: <code>Transport</code></p> Source code in <code>transport/plugins/paramiko/transport.py</code> <pre><code>class ParamikoTransport(Transport):\n    def __init__(\n        self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n    ) -&gt; None:\n\"\"\"\n        Paramiko transport plugin.\n\n        This transport supports some additional `transport_options` to control behavior --\n\n        `enable_rsa2` is bool defaulting to `False`. Please see the paramiko changelog entry for\n            version 2.9.0 here: https://www.paramiko.org/changelog.html. Basically, even though\n            scrapli *tries* to default to safe/sane/secure things where possible, it is also focused\n            on *network* devices which maybe sometimes are less up-to-date/safe/secure than we'd\n            all hope. In this case paramiko 2.9.0 defaults to supporting only RSA2based servers,\n            which, causes issues for the devices in the test suite, and likely for many other\n            network devices out there. So, by default, we'll *disable* this. If you wish to enable\n            this you can simply pass `True` to this transport option!\n\n        Args:\n            base_transport_args: scrapli base transport plugin arguments\n            plugin_transport_args: paramiko ssh specific transport plugin arguments\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        super().__init__(base_transport_args=base_transport_args)\n        self.plugin_transport_args = plugin_transport_args\n\n        self.socket: Optional[Socket] = None\n        self.session: Optional[_ParamikoTransport] = None\n        self.session_channel: Optional[Channel] = None\n\n    def open(self) -&gt; None:\n        self._pre_open_closing_log(closing=False)\n\n        if not self.socket:\n            self.socket = Socket(\n                host=self._base_transport_args.host,\n                port=self._base_transport_args.port,\n                timeout=self._base_transport_args.timeout_socket,\n            )\n\n        if not self.socket.isalive():\n            self.socket.open()\n\n        try:\n            self.session = _ParamikoTransport(self.socket.sock)  # type: ignore\n            self.session.start_client()\n        except Exception as exc:\n            self.logger.critical(\"failed to complete handshake with host\")\n            raise ScrapliConnectionNotOpened from exc\n\n        if self.plugin_transport_args.auth_strict_key:\n            self.logger.debug(f\"attempting to validate {self._base_transport_args.host} public key\")\n            self._verify_key()\n\n        self._authenticate()\n\n        if not self.session.is_authenticated():\n            msg = \"all authentication methods failed\"\n            self.logger.critical(msg)\n            raise ScrapliAuthenticationFailed(msg)\n\n        self._open_channel()\n\n        self._post_open_closing_log(closing=False)\n\n    def _verify_key(self) -&gt; None:\n\"\"\"\n        Verify target host public key, raise exception if invalid/unknown\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n            ScrapliAuthenticationFailed: if host is not in known hosts\n            ScrapliAuthenticationFailed: if host is in known hosts but public key does not match\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        known_hosts = SSHKnownHosts(self.plugin_transport_args.ssh_known_hosts_file)\n        known_host_public_key = known_hosts.lookup(self._base_transport_args.host)\n\n        if not known_host_public_key:\n            raise ScrapliAuthenticationFailed(\n                f\"{self._base_transport_args.host} not in known_hosts!\"\n            )\n\n        remote_server_key = self.session.get_remote_server_key()\n        remote_public_key = remote_server_key.get_base64()\n\n        if known_host_public_key[\"public_key\"] != remote_public_key:\n            raise ScrapliAuthenticationFailed(\n                f\"{self._base_transport_args.host} in known_hosts but public key does not match!\"\n            )\n\n    def _authenticate(self) -&gt; None:\n\"\"\"\n        Parent method to try all means of authentication\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n            ScrapliAuthenticationFailed: if auth fails\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        if self.plugin_transport_args.auth_private_key:\n            self._authenticate_public_key()\n            if self.session.is_authenticated():\n                return\n            if (\n                not self.plugin_transport_args.auth_password\n                or not self.plugin_transport_args.auth_username\n            ):\n                msg = (\n                    f\"Failed to authenticate to host {self._base_transport_args.host} with private \"\n                    f\"key `{self.plugin_transport_args.auth_private_key}`. Unable to continue \"\n                    \"authentication, missing username, password, or both.\"\n                )\n                raise ScrapliAuthenticationFailed(msg)\n\n        self._authenticate_password()\n\n    def _authenticate_public_key(self) -&gt; None:\n\"\"\"\n        Attempt to authenticate with public key authentication\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        if self._base_transport_args.transport_options.get(\"enable_rsa2\", False) is False:\n            # do this for \"keys\" and \"pubkeys\": https://github.com/paramiko/paramiko/issues/1984\n            self.session.disabled_algorithms = {\n                \"keys\": [\"rsa-sha2-256\", \"rsa-sha2-512\"],\n                \"pubkeys\": [\"rsa-sha2-256\", \"rsa-sha2-512\"],\n            }\n\n        try:\n            paramiko_key = RSAKey(filename=self.plugin_transport_args.auth_private_key)\n            self.session.auth_publickey(\n                username=self.plugin_transport_args.auth_username, key=paramiko_key\n            )\n        except AuthenticationException:\n            pass\n        except Exception:  # pylint: disable=W0703\n            pass\n\n    def _authenticate_password(self) -&gt; None:\n\"\"\"\n        Attempt to authenticate with password authentication\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        with suppress(AuthenticationException):\n            self.session.auth_password(\n                username=self.plugin_transport_args.auth_username,\n                password=self.plugin_transport_args.auth_password,\n            )\n\n    def _open_channel(self) -&gt; None:\n\"\"\"\n        Open channel, acquire pty, request interactive shell\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        self.session_channel = self.session.open_session()\n        self._set_timeout(self._base_transport_args.timeout_transport)\n        self.session_channel.get_pty()\n        self.session_channel.invoke_shell()\n\n    def close(self) -&gt; None:\n        self._pre_open_closing_log(closing=True)\n\n        if self.session_channel:\n            self.session_channel.close()\n\n            if self.socket:\n                self.socket.close()\n\n        self.session = None\n        self.session_channel = None\n\n        self._post_open_closing_log(closing=True)\n\n    def isalive(self) -&gt; bool:\n        if not self.session:\n            return False\n        _isalive: bool = self.session.is_alive()\n        return _isalive\n\n    def read(self) -&gt; bytes:\n        if not self.session_channel:\n            raise ScrapliConnectionNotOpened\n        try:\n            buf: bytes = self.session_channel.recv(65535)\n        except Exception as exc:\n            msg = (\n                \"encountered EOF reading from transport; typically means the device closed the \"\n                \"connection\"\n            )\n            self.logger.critical(msg)\n            raise ScrapliConnectionError(msg) from exc\n        return buf\n\n    def write(self, channel_input: bytes) -&gt; None:\n        if not self.session_channel:\n            raise ScrapliConnectionNotOpened\n        self.session_channel.send(channel_input)\n\n    def _set_timeout(self, value: float) -&gt; None:\n\"\"\"\n        Set session object timeout value\n\n        Args:\n            value: timeout in seconds\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session_channel:\n            raise ScrapliConnectionNotOpened\n        self.session_channel.settimeout(value)\n</code></pre>"},{"location":"reference/transport/plugins/paramiko/transport/#transport.plugins.paramiko.transport.ParamikoTransport.__init__","title":"<code>__init__(base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs) -&gt; None</code>","text":"<p>Paramiko transport plugin.</p> <p>This transport supports some additional <code>transport_options</code> to control behavior --</p> <p><code>enable_rsa2</code> is bool defaulting to <code>False</code>. Please see the paramiko changelog entry for     version 2.9.0 here: https://www.paramiko.org/changelog.html. Basically, even though     scrapli tries to default to safe/sane/secure things where possible, it is also focused     on network devices which maybe sometimes are less up-to-date/safe/secure than we'd     all hope. In this case paramiko 2.9.0 defaults to supporting only RSA2based servers,     which, causes issues for the devices in the test suite, and likely for many other     network devices out there. So, by default, we'll disable this. If you wish to enable     this you can simply pass <code>True</code> to this transport option!</p> <p>Parameters:</p> Name Type Description Default <code>base_transport_args</code> <code>BaseTransportArgs</code> <p>scrapli base transport plugin arguments</p> required <code>plugin_transport_args</code> <code>PluginTransportArgs</code> <p>paramiko ssh specific transport plugin arguments</p> required <p>Returns:</p> Type Description <code>None</code> <p>N/A</p> Source code in <code>transport/plugins/paramiko/transport.py</code> <pre><code>def __init__(\n    self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n) -&gt; None:\n\"\"\"\n    Paramiko transport plugin.\n\n    This transport supports some additional `transport_options` to control behavior --\n\n    `enable_rsa2` is bool defaulting to `False`. Please see the paramiko changelog entry for\n        version 2.9.0 here: https://www.paramiko.org/changelog.html. Basically, even though\n        scrapli *tries* to default to safe/sane/secure things where possible, it is also focused\n        on *network* devices which maybe sometimes are less up-to-date/safe/secure than we'd\n        all hope. In this case paramiko 2.9.0 defaults to supporting only RSA2based servers,\n        which, causes issues for the devices in the test suite, and likely for many other\n        network devices out there. So, by default, we'll *disable* this. If you wish to enable\n        this you can simply pass `True` to this transport option!\n\n    Args:\n        base_transport_args: scrapli base transport plugin arguments\n        plugin_transport_args: paramiko ssh specific transport plugin arguments\n\n    Returns:\n        N/A\n\n    Raises:\n        N/A\n\n    \"\"\"\n    super().__init__(base_transport_args=base_transport_args)\n    self.plugin_transport_args = plugin_transport_args\n\n    self.socket: Optional[Socket] = None\n    self.session: Optional[_ParamikoTransport] = None\n    self.session_channel: Optional[Channel] = None\n</code></pre>"},{"location":"reference/transport/plugins/ssh2/","title":"ssh2","text":"<p>scrapli.transport.plugins.ssh2</p>"},{"location":"reference/transport/plugins/ssh2/transport/","title":"transport","text":"<p>scrapli.transport.plugins.ssh2.transport</p>"},{"location":"reference/transport/plugins/ssh2/transport/#transport.plugins.ssh2.transport.Ssh2Transport","title":"<code>Ssh2Transport</code>","text":"<p>         Bases: <code>Transport</code></p> Source code in <code>transport/plugins/ssh2/transport.py</code> <pre><code>class Ssh2Transport(Transport):\n    def __init__(\n        self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n    ) -&gt; None:\n        super().__init__(base_transport_args=base_transport_args)\n        self.plugin_transport_args = plugin_transport_args\n\n        self.socket: Optional[Socket] = None\n        self.session: Optional[Session] = None\n        self.session_channel: Optional[Channel] = None\n\n    def open(self) -&gt; None:\n        self._pre_open_closing_log(closing=False)\n\n        if not self.socket:\n            self.socket = Socket(\n                host=self._base_transport_args.host,\n                port=self._base_transport_args.port,\n                timeout=self._base_transport_args.timeout_socket,\n            )\n\n        if not self.socket.isalive():\n            self.socket.open()\n\n        self.session = Session()\n        self._set_timeout(value=self._base_transport_args.timeout_transport)\n\n        try:\n            self.session.handshake(self.socket.sock)\n        except Exception as exc:\n            self.logger.critical(\"failed to complete handshake with host\")\n            raise ScrapliConnectionNotOpened from exc\n\n        if self.plugin_transport_args.auth_strict_key:\n            self.logger.debug(f\"attempting to validate {self._base_transport_args.host} public key\")\n            self._verify_key()\n\n        self._authenticate()\n\n        if not self.session.userauth_authenticated():\n            msg = \"all authentication methods failed\"\n            self.logger.critical(msg)\n            raise ScrapliAuthenticationFailed(msg)\n\n        self._open_channel()\n\n        self._post_open_closing_log(closing=False)\n\n    def _verify_key(self) -&gt; None:\n\"\"\"\n        Verify target host public key, raise exception if invalid/unknown\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n            ScrapliAuthenticationFailed: if public key verification fails\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        known_hosts = SSHKnownHosts(self.plugin_transport_args.ssh_known_hosts_file)\n        known_host_public_key = known_hosts.lookup(self._base_transport_args.host)\n\n        if not known_host_public_key:\n            raise ScrapliAuthenticationFailed(\n                f\"{self._base_transport_args.host} not in known_hosts!\"\n            )\n\n        remote_server_key_info = self.session.hostkey()\n        encoded_remote_server_key = remote_server_key_info[0]\n        raw_remote_public_key = base64.encodebytes(encoded_remote_server_key)\n        remote_public_key = raw_remote_public_key.replace(b\"\\n\", b\"\").decode()\n\n        if known_host_public_key[\"public_key\"] != remote_public_key:\n            raise ScrapliAuthenticationFailed(\n                f\"{self._base_transport_args.host} in known_hosts but public key does not match!\"\n            )\n\n    def _authenticate(self) -&gt; None:\n\"\"\"\n        Parent method to try all means of authentication\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n            ScrapliAuthenticationFailed: if auth fails\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        if self.plugin_transport_args.auth_private_key:\n            self._authenticate_public_key()\n            if self.session.userauth_authenticated():\n                return\n            if (\n                not self.plugin_transport_args.auth_password\n                or not self.plugin_transport_args.auth_username\n            ):\n                msg = (\n                    f\"Failed to authenticate to host {self._base_transport_args.host} with private \"\n                    f\"key `{self.plugin_transport_args.auth_private_key}`. Unable to continue \"\n                    \"authentication, missing username, password, or both.\"\n                )\n                raise ScrapliAuthenticationFailed(msg)\n\n        self._authenticate_password()\n\n    def _authenticate_public_key(self) -&gt; None:\n\"\"\"\n        Attempt to authenticate with public key authentication\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        with suppress(AuthenticationError, SSH2Error):\n            self.session.userauth_publickey_fromfile(\n                self.plugin_transport_args.auth_username,\n                self.plugin_transport_args.auth_private_key.encode(),\n                self.plugin_transport_args.auth_private_key_passphrase,\n            )\n\n    def _authenticate_password(self) -&gt; None:\n\"\"\"\n        Attempt to authenticate with password authentication\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        with suppress(AuthenticationError):\n            self.session.userauth_password(\n                username=self.plugin_transport_args.auth_username,\n                password=self.plugin_transport_args.auth_password,\n            )\n            return\n\n        try:\n            self.session.userauth_keyboardinteractive(\n                self.plugin_transport_args.auth_username, self.plugin_transport_args.auth_password\n            )\n        except AttributeError:\n            msg = (\n                \"Keyboard interactive authentication may not be supported in your \"\n                \"ssh2-python version.\"\n            )\n            self.logger.warning(msg)\n        except AuthenticationError:\n            pass\n\n    def _open_channel(self) -&gt; None:\n\"\"\"\n        Open channel, acquire pty, request interactive shell\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        self.session_channel = self.session.open_session()\n        self.session_channel.pty()\n        self.session_channel.shell()\n\n    def close(self) -&gt; None:\n        self._pre_open_closing_log(closing=True)\n\n        if self.session_channel:\n            self.session_channel.close()\n\n            if self.socket:\n                self.socket.close()\n\n        self.session = None\n        self.session_channel = None\n\n        self._post_open_closing_log(closing=True)\n\n    def isalive(self) -&gt; bool:\n        if not self.session_channel:\n            return False\n        return not self.session_channel.eof()\n\n    def read(self) -&gt; bytes:\n        if not self.session_channel:\n            raise ScrapliConnectionNotOpened\n        try:\n            buf: bytes\n            _, buf = self.session_channel.read(65535)\n        except Exception as exc:\n            msg = (\n                \"encountered EOF reading from transport; typically means the device closed the \"\n                \"connection\"\n            )\n            self.logger.critical(msg)\n            raise ScrapliConnectionError(msg) from exc\n        return buf\n\n    def write(self, channel_input: bytes) -&gt; None:\n        if not self.session_channel:\n            raise ScrapliConnectionNotOpened\n        self.session_channel.write(channel_input)\n\n    def _set_timeout(self, value: float) -&gt; None:\n\"\"\"\n        Set session object timeout value\n\n        Args:\n            value: timeout in seconds\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if session is unopened/None\n\n        \"\"\"\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n\n        # ssh2-python expects timeout in milliseconds\n        self.session.set_timeout(value * 1000)\n</code></pre>"},{"location":"reference/transport/plugins/system/","title":"system","text":"<p>scrapli.transport.plugins.system</p>"},{"location":"reference/transport/plugins/system/ptyprocess/","title":"ptyprocess","text":"<p>scrapli.transport.plugins.system.ptyprocess</p>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess","title":"<code>PtyProcess</code>","text":"Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>class PtyProcess:\n    def __init__(self, pid: int, fd: int) -&gt; None:\n\"\"\"\n        This class represents a process running in a pseudoterminal.\n\n        The main constructor is the `spawn` method.\n\n        Args:\n            pid: integer value of pid\n            fd: integer value of fd\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        _make_eof_intr()  # Ensure _EOF and _INTR are calculated\n        self.pid = pid\n        self.fd = fd\n        readf = io.open(fd, \"rb\", buffering=0)\n        writef = io.open(fd, \"wb\", buffering=0, closefd=False)\n        self.fileobj = io.BufferedRWPair(readf, writef)  # type: ignore\n\n        self.terminated = False\n        self.closed = False\n        self.exitstatus: Optional[int] = None\n        self.signalstatus: Optional[int] = None\n        # status returned by os.waitpid\n        self.status: Optional[int] = None\n        self.flag_eof = False\n        # Used by close() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterclose = 0.1\n        # Used by terminate() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterterminate = 0.1\n\n    @classmethod\n    def spawn(\n        cls: Type[PtyProcessType],\n        spawn_command: List[str],\n        echo: bool = True,\n        rows: int = 80,\n        cols: int = 256,\n    ) -&gt; PtyProcessType:\n\"\"\"\n        Start the given command in a child process in a pseudo terminal.\n\n        This does all the fork/exec type of stuff for a pty, and returns an instance of PtyProcess.\n        For some devices setting terminal width strictly in the operating system (the actual network\n        operating system) does not seem to be sufficient by itself for setting terminal length or\n        width -- so we have optional values for rows/cols that can be passed here as well.\n\n        Args:\n            spawn_command: command to execute with arguments (if applicable), as a list\n            echo: enable/disable echo -- defaults to True, should be left as True for \"normal\"\n                scrapli operations, optionally disable for scrapli_netconf operations.\n            rows: integer number of rows for ptyprocess \"window\"\n            cols: integer number of cols for ptyprocess \"window\"\n\n        Returns:\n            PtyProcessType: instantiated PtyProcess object\n\n        Raises:\n            ScrapliValueError: if no ssh binary found on PATH\n            Exception: IOError - if unable to set window size of child process\n            Exception: OSError - if unable to spawn command in child process\n            IOError: failing to reset window size\n            exception: if we get an exception decoding output\n\n        \"\"\"\n        # Note that it is difficult for this method to fail.\n        # You cannot detect if the child process cannot start.\n        # So the only way you can tell if the child process started\n        # or not is to try to read from the file descriptor. If you get\n        # EOF immediately then it means that the child is already dead.\n        # That may not necessarily be bad because you may have spawned a child\n        # that performs some task; creates no stdout output; and then dies.\n\n        import fcntl\n        import pty\n        import resource\n        import termios\n        from pty import CHILD, STDIN_FILENO\n\n        spawn_executable = which(spawn_command[0])\n        if spawn_executable is None:\n            raise ScrapliValueError(\"ssh executable not found!\")\n        spawn_command[0] = spawn_executable\n\n        # [issue #119] To prevent the case where exec fails and the user is\n        # stuck interacting with a python child process instead of whatever\n        # was expected, we implement the solution from\n        # http://stackoverflow.com/a/3703179 to pass the exception to the\n        # parent process\n        # [issue #119] 1. Before forking, open a pipe in the parent process.\n        exec_err_pipe_read, exec_err_pipe_write = os.pipe()\n\n        pid, fd = pty.fork()\n\n        # Some platforms must call setwinsize() and setecho() from the\n        # child process, and others from the master process. We do both,\n        # allowing IOError for either.\n        if pid == CHILD:\n            try:\n                _setwinsize(fd=STDIN_FILENO, rows=rows, cols=cols)\n            except IOError as err:\n                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                    raise\n\n            # disable echo if requested\n            if echo is False:\n                try:\n                    _setecho(STDIN_FILENO, False)\n                except (IOError, termios.error) as err:\n                    if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                        raise\n\n            # [issue #119] 3. The child closes the reading end and sets the\n            # close-on-exec flag for the writing end.\n            os.close(exec_err_pipe_read)\n            fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)\n\n            # Do not allow child to inherit open file descriptors from parent,\n            # with the exception of the exec_err_pipe_write of the pipe.\n            # Impose ceiling on max_fd: AIX bugfix for users with unlimited\n            # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()\n            # occasionally raises out of range error\n            max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])\n            pass_fds = sorted({exec_err_pipe_write})\n            for pair in zip([2] + pass_fds, pass_fds + [max_fd]):\n                os.closerange(pair[0] + 1, pair[1])\n\n            try:\n                os.execv(spawn_executable, spawn_command)\n            except OSError as err:\n                # [issue #119] 5. If exec fails, the child writes the error\n                # code back to the parent using the pipe, then exits.\n                tosend = f\"OSError:{err.errno}:{err}\".encode()\n                os.write(exec_err_pipe_write, tosend)\n                os.close(exec_err_pipe_write)\n                os._exit(os.EX_OSERR)\n\n        # Parent\n        inst = cls(pid, fd)\n\n        # [issue #119] 2. After forking, the parent closes the writing end\n        # of the pipe and reads from the reading end.\n        os.close(exec_err_pipe_write)\n        exec_err_data = os.read(exec_err_pipe_read, 4096)\n        os.close(exec_err_pipe_read)\n\n        # [issue #119] 6. The parent reads eof (a zero-length read) if the\n        # child successfully performed exec, since close-on-exec made\n        # successful exec close the writing end of the pipe. Or, if exec\n        # failed, the parent reads the error code and can proceed\n        # accordingly. Either way, the parent blocks until the child calls\n        # exec.\n        if len(exec_err_data) != 0:\n            try:\n                errclass, errno_s, errmsg = exec_err_data.split(b\":\", 2)\n                exctype = getattr(builtins, errclass.decode(\"ascii\"), Exception)\n\n                exception = exctype(errmsg.decode(\"utf-8\", \"replace\"))\n                if exctype is OSError:\n                    exception.errno = int(errno_s)\n            except Exception:\n                raise Exception(\"Subprocess failed, got bad error data: %r\" % exec_err_data)\n            else:\n                raise exception\n\n        try:\n            inst.setwinsize(rows=rows, cols=cols)\n        except IOError as err:\n            if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):\n                raise\n\n        return inst\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Magic repr method for PtyProcess\n\n        Args:\n            N/A\n\n        Returns:\n            str: str repr of object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"{type(self).__name__}(pid={self.pid}, fd={self.fd})\"\n\n    def __del__(self) -&gt; None:\n\"\"\"\n        Magic delete method for PtyProcess\n\n        This makes sure that no system resources are left open. Python only\n        garbage collects Python objects. OS file descriptors are not Python\n        objects, so they must be handled explicitly. If the child file\n        descriptor was opened outside of this class (passed to the constructor)\n        then this does not close it.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not self.closed:\n            # It is possible for __del__ methods to execute during the\n            # teardown of the Python VM itself. Thus self.close() may\n            # trigger an exception because os.close may be None.\n            with suppress(Exception):\n                self.close()\n\n    def close(self) -&gt; None:\n\"\"\"\n        Close the instance\n\n        This closes the connection with the child application. Note that\n        calling close() more than once is valid. This emulates standard Python\n        behavior with files. Set force to True if you want to make sure that\n        the child is terminated (SIGKILL is sent if the child ignores SIGHUP\n        and SIGINT).\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            PtyProcessError: if child cannot be terminated\n\n        \"\"\"\n        if not self.closed:\n            # in the original ptyprocess vendor'd code the file object is \"gracefully\" closed,\n            # however in some situations it seemed to hang forever on the close call... given that\n            # as soon as this connection is closed it will need to be re-opened, and that will of\n            # course re-create the fileobject this seems like an ok workaround because for reasons\n            # unknown to me... this does not hang (even though in theory delete method just closes\n            # things...?)\n            with suppress(AttributeError):\n                del self.fileobj\n\n            # Give kernel time to update process status.\n            time.sleep(self.delayafterclose)\n            if self.isalive():\n                if not self.terminate(force=True):\n                    raise PtyProcessError(\"Could not terminate the child.\")\n            self.fd = -1\n            self.closed = True\n            self.pid = None\n\n    def flush(self) -&gt; None:\n\"\"\"\n        This does nothing.\n\n        It is here to support the interface for a File-like object.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    def read(self, size: int = 1024) -&gt; bytes:\n\"\"\"\n        Read and return at most ``size`` bytes from the pty.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n\n        Unlike Pexpect's ``read_nonblocking`` method, this doesn't try to deal\n        with the vagaries of EOF on platforms that do strange things, like IRIX\n        or older Solaris systems. It handles the errno=EIO pattern used on\n        Linux, and the empty-string return used on BSD platforms and (seemingly)\n        on recent Solaris.\n\n        Args:\n            size: bytes to read\n\n        Returns:\n            bytes: bytes read\n\n        Raises:\n            EOFError: eof encountered\n            EOFError: eof encountered\n\n        \"\"\"\n        try:\n            s = self.fileobj.read1(size)\n        except (OSError, IOError) as err:\n            if err.args[0] == errno.EIO:\n                # Linux-style EOF\n                self.flag_eof = True\n                raise EOFError(\"End Of File (EOF). Exception style platform.\")\n            raise\n        if s == b\"\":\n            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))\n            self.flag_eof = True\n            raise EOFError(\"End Of File (EOF). Empty string style platform.\")\n\n        return s\n\n    def write(self, bytes_to_write: bytes, flush: bool = True) -&gt; int:\n\"\"\"\n        Write bytes to the pseudoterminal.\n\n        Returns the number of bytes written.\n\n        Args:\n            bytes_to_write: bytes to write to the terminal\n            flush: flush the terminal or not\n\n        Returns:\n            int: number of bytes written\n\n        Raises:\n            N/A\n\n        \"\"\"\n        n = self.fileobj.write(bytes_to_write)\n        if flush:\n            self.fileobj.flush()\n        return n\n\n    def eof(self) -&gt; bool:\n\"\"\"\n        This returns True if the EOF exception was ever raised.\n\n        Args:\n            N/A\n\n        Returns:\n            bool: if eof\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self.flag_eof\n\n    def terminate(self, force: bool = False) -&gt; bool:\n\"\"\"\n        This forces a child process to terminate.\n\n        It starts nicely with SIGHUP and SIGINT. If \"force\" is True then moves onto SIGKILL. This\n        returns True if the child was terminated. This returns False if the child could not be\n        terminated.\n\n        Args:\n            force: bool; force termination\n\n        Returns:\n            bool: terminate succeeded or failed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if not self.isalive():\n            return True\n        try:\n            self.kill(signal.SIGHUP)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGCONT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGINT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            if force:\n                self.kill(signal.SIGKILL)\n                time.sleep(self.delayafterterminate)\n                if not self.isalive():\n                    return True\n        except OSError:\n            # I think there are kernel timing issues that sometimes cause\n            # this to happen. I think isalive() reports True, but the\n            # process is dead to the kernel.\n            # Make one last attempt to see if the kernel is up to date.\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n        return False\n\n    def isalive(self) -&gt; bool:\n\"\"\"\n        This tests if the child process is running or not. This is\n        non-blocking. If the child was terminated then this will read the\n        exitstatus or signalstatus of the child. This returns True if the child\n        process appears to be running or False if not. It can take literally\n        SECONDS for Solaris to return the right status.\n\n        Args:\n            N/A\n\n        Returns:\n            bool: if alive\n\n        Raises:\n            PtyProcessError: an error occurred with the process\n            PtyProcessError: an error occurred with the process\n            PtyProcessError: an error occurred with the process\n\n        \"\"\"\n\n        if self.terminated:\n            return False\n\n        if self.flag_eof:\n            # This is for Linux, which requires the blocking form\n            # of waitpid to get the status of a defunct process.\n            # This is super-lame. The flag_eof would have been set\n            # in read_nonblocking(), so this should be safe.\n            waitpid_options = 0\n        else:\n            waitpid_options = os.WNOHANG\n\n        try:\n            pid, status = os.waitpid(self.pid, waitpid_options)\n        except OSError as e:\n            # No child processes\n            if e.errno == errno.ECHILD:\n                raise PtyProcessError(\n                    \"isalive() encountered condition \"\n                    + 'where \"terminated\" is 0, but there was no child '\n                    + \"process. Did someone else call waitpid() \"\n                    + \"on our process?\"\n                )\n            raise\n\n        # I have to do this twice for Solaris.\n        # I can't even believe that I figured this out...\n        # If waitpid() returns 0 it means that no child process\n        # wishes to report, and the value of status is undefined.\n        if pid == 0:\n            try:\n                ### os.WNOHANG) # Solaris!\n                pid, status = os.waitpid(self.pid, waitpid_options)\n            except OSError as e:  # pragma: no cover\n                # This should never happen...\n                if e.errno == errno.ECHILD:\n                    raise PtyProcessError(\n                        \"isalive() encountered condition \"\n                        + \"that should never happen. There was no child \"\n                        + \"process. Did someone else call waitpid() \"\n                        + \"on our process?\"\n                    )\n                raise\n\n            # If pid is still 0 after two calls to waitpid() then the process\n            # really is alive. This seems to work on all platforms, except for\n            # Irix which seems to require a blocking call on waitpid or select,\n            # so I let read_nonblocking take care of this situation\n            # (unfortunately, this requires waiting through the timeout).\n            if pid == 0:\n                return True\n\n        if pid == 0:\n            return True\n\n        if os.WIFEXITED(status):\n            self.status = status\n            self.exitstatus = os.WEXITSTATUS(status)\n            self.signalstatus = None\n            self.terminated = True\n        elif os.WIFSIGNALED(status):\n            self.status = status\n            self.exitstatus = None\n            self.signalstatus = os.WTERMSIG(status)\n            self.terminated = True\n        elif os.WIFSTOPPED(status):\n            raise PtyProcessError(\n                \"isalive() encountered condition \"\n                + \"where child process is stopped. This is not \"\n                + \"supported. Is some other process attempting \"\n                + \"job control with our child pid?\"\n            )\n        return False\n\n    def kill(self, sig: int) -&gt; None:\n\"\"\"\n        Send the given signal to the child application.\n\n        In keeping with UNIX tradition it has a misleading name. It does not\n        necessarily kill the child unless you send the right signal. See the\n        :mod:`signal` module for constants representing signal numbers.\n\n        Args:\n            sig: signal to send to kill\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n        # Same as os.kill, but the pid is given for you.\n        if self.isalive():\n            os.kill(self.pid, sig)\n\n    def setwinsize(self, rows: int = 24, cols: int = 80) -&gt; None:\n\"\"\"\n        Set window size.\n\n        This will cause a SIGWINCH signal to be sent to the child. This does not change the physical\n        window size. It changes the size reported to TTY-aware applications like vi or curses --\n        applications that respond to the SIGWINCH signal.\n\n        Args:\n            rows: int number of rows for terminal\n            cols: int number of cols for terminal\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return _setwinsize(self.fd, rows, cols)\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.__del__","title":"<code>__del__() -&gt; None</code>","text":"<p>Magic delete method for PtyProcess</p> <p>This makes sure that no system resources are left open. Python only garbage collects Python objects. OS file descriptors are not Python objects, so they must be handled explicitly. If the child file descriptor was opened outside of this class (passed to the constructor) then this does not close it.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"\n    Magic delete method for PtyProcess\n\n    This makes sure that no system resources are left open. Python only\n    garbage collects Python objects. OS file descriptors are not Python\n    objects, so they must be handled explicitly. If the child file\n    descriptor was opened outside of this class (passed to the constructor)\n    then this does not close it.\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if not self.closed:\n        # It is possible for __del__ methods to execute during the\n        # teardown of the Python VM itself. Thus self.close() may\n        # trigger an exception because os.close may be None.\n        with suppress(Exception):\n            self.close()\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.__init__","title":"<code>__init__(pid: int, fd: int) -&gt; None</code>","text":"<p>This class represents a process running in a pseudoterminal.</p> <p>The main constructor is the <code>spawn</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>integer value of pid</p> required <code>fd</code> <code>int</code> <p>integer value of fd</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def __init__(self, pid: int, fd: int) -&gt; None:\n\"\"\"\n    This class represents a process running in a pseudoterminal.\n\n    The main constructor is the `spawn` method.\n\n    Args:\n        pid: integer value of pid\n        fd: integer value of fd\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    _make_eof_intr()  # Ensure _EOF and _INTR are calculated\n    self.pid = pid\n    self.fd = fd\n    readf = io.open(fd, \"rb\", buffering=0)\n    writef = io.open(fd, \"wb\", buffering=0, closefd=False)\n    self.fileobj = io.BufferedRWPair(readf, writef)  # type: ignore\n\n    self.terminated = False\n    self.closed = False\n    self.exitstatus: Optional[int] = None\n    self.signalstatus: Optional[int] = None\n    # status returned by os.waitpid\n    self.status: Optional[int] = None\n    self.flag_eof = False\n    # Used by close() to give kernel time to update process status.\n    # Time in seconds.\n    self.delayafterclose = 0.1\n    # Used by terminate() to give kernel time to update process status.\n    # Time in seconds.\n    self.delayafterterminate = 0.1\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Magic repr method for PtyProcess</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>str repr of object</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Magic repr method for PtyProcess\n\n    Args:\n        N/A\n\n    Returns:\n        str: str repr of object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"{type(self).__name__}(pid={self.pid}, fd={self.fd})\"\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the instance</p> <p>This closes the connection with the child application. Note that calling close() more than once is valid. This emulates standard Python behavior with files. Set force to True if you want to make sure that the child is terminated (SIGKILL is sent if the child ignores SIGHUP and SIGINT).</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>PtyProcessError</code> <p>if child cannot be terminated</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def close(self) -&gt; None:\n\"\"\"\n    Close the instance\n\n    This closes the connection with the child application. Note that\n    calling close() more than once is valid. This emulates standard Python\n    behavior with files. Set force to True if you want to make sure that\n    the child is terminated (SIGKILL is sent if the child ignores SIGHUP\n    and SIGINT).\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        PtyProcessError: if child cannot be terminated\n\n    \"\"\"\n    if not self.closed:\n        # in the original ptyprocess vendor'd code the file object is \"gracefully\" closed,\n        # however in some situations it seemed to hang forever on the close call... given that\n        # as soon as this connection is closed it will need to be re-opened, and that will of\n        # course re-create the fileobject this seems like an ok workaround because for reasons\n        # unknown to me... this does not hang (even though in theory delete method just closes\n        # things...?)\n        with suppress(AttributeError):\n            del self.fileobj\n\n        # Give kernel time to update process status.\n        time.sleep(self.delayafterclose)\n        if self.isalive():\n            if not self.terminate(force=True):\n                raise PtyProcessError(\"Could not terminate the child.\")\n        self.fd = -1\n        self.closed = True\n        self.pid = None\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.eof","title":"<code>eof() -&gt; bool</code>","text":"<p>This returns True if the EOF exception was ever raised.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if eof</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def eof(self) -&gt; bool:\n\"\"\"\n    This returns True if the EOF exception was ever raised.\n\n    Args:\n        N/A\n\n    Returns:\n        bool: if eof\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self.flag_eof\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.flush","title":"<code>flush() -&gt; None</code>","text":"<p>This does nothing.</p> <p>It is here to support the interface for a File-like object.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def flush(self) -&gt; None:\n\"\"\"\n    This does nothing.\n\n    It is here to support the interface for a File-like object.\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.isalive","title":"<code>isalive() -&gt; bool</code>","text":"<p>This tests if the child process is running or not. This is non-blocking. If the child was terminated then this will read the exitstatus or signalstatus of the child. This returns True if the child process appears to be running or False if not. It can take literally SECONDS for Solaris to return the right status.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if alive</p> <p>Raises:</p> Type Description <code>PtyProcessError</code> <p>an error occurred with the process</p> <code>PtyProcessError</code> <p>an error occurred with the process</p> <code>PtyProcessError</code> <p>an error occurred with the process</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def isalive(self) -&gt; bool:\n\"\"\"\n    This tests if the child process is running or not. This is\n    non-blocking. If the child was terminated then this will read the\n    exitstatus or signalstatus of the child. This returns True if the child\n    process appears to be running or False if not. It can take literally\n    SECONDS for Solaris to return the right status.\n\n    Args:\n        N/A\n\n    Returns:\n        bool: if alive\n\n    Raises:\n        PtyProcessError: an error occurred with the process\n        PtyProcessError: an error occurred with the process\n        PtyProcessError: an error occurred with the process\n\n    \"\"\"\n\n    if self.terminated:\n        return False\n\n    if self.flag_eof:\n        # This is for Linux, which requires the blocking form\n        # of waitpid to get the status of a defunct process.\n        # This is super-lame. The flag_eof would have been set\n        # in read_nonblocking(), so this should be safe.\n        waitpid_options = 0\n    else:\n        waitpid_options = os.WNOHANG\n\n    try:\n        pid, status = os.waitpid(self.pid, waitpid_options)\n    except OSError as e:\n        # No child processes\n        if e.errno == errno.ECHILD:\n            raise PtyProcessError(\n                \"isalive() encountered condition \"\n                + 'where \"terminated\" is 0, but there was no child '\n                + \"process. Did someone else call waitpid() \"\n                + \"on our process?\"\n            )\n        raise\n\n    # I have to do this twice for Solaris.\n    # I can't even believe that I figured this out...\n    # If waitpid() returns 0 it means that no child process\n    # wishes to report, and the value of status is undefined.\n    if pid == 0:\n        try:\n            ### os.WNOHANG) # Solaris!\n            pid, status = os.waitpid(self.pid, waitpid_options)\n        except OSError as e:  # pragma: no cover\n            # This should never happen...\n            if e.errno == errno.ECHILD:\n                raise PtyProcessError(\n                    \"isalive() encountered condition \"\n                    + \"that should never happen. There was no child \"\n                    + \"process. Did someone else call waitpid() \"\n                    + \"on our process?\"\n                )\n            raise\n\n        # If pid is still 0 after two calls to waitpid() then the process\n        # really is alive. This seems to work on all platforms, except for\n        # Irix which seems to require a blocking call on waitpid or select,\n        # so I let read_nonblocking take care of this situation\n        # (unfortunately, this requires waiting through the timeout).\n        if pid == 0:\n            return True\n\n    if pid == 0:\n        return True\n\n    if os.WIFEXITED(status):\n        self.status = status\n        self.exitstatus = os.WEXITSTATUS(status)\n        self.signalstatus = None\n        self.terminated = True\n    elif os.WIFSIGNALED(status):\n        self.status = status\n        self.exitstatus = None\n        self.signalstatus = os.WTERMSIG(status)\n        self.terminated = True\n    elif os.WIFSTOPPED(status):\n        raise PtyProcessError(\n            \"isalive() encountered condition \"\n            + \"where child process is stopped. This is not \"\n            + \"supported. Is some other process attempting \"\n            + \"job control with our child pid?\"\n        )\n    return False\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.kill","title":"<code>kill(sig: int) -&gt; None</code>","text":"<p>Send the given signal to the child application.</p> <p>In keeping with UNIX tradition it has a misleading name. It does not necessarily kill the child unless you send the right signal. See the :mod:<code>signal</code> module for constants representing signal numbers.</p> <p>Parameters:</p> Name Type Description Default <code>sig</code> <code>int</code> <p>signal to send to kill</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def kill(self, sig: int) -&gt; None:\n\"\"\"\n    Send the given signal to the child application.\n\n    In keeping with UNIX tradition it has a misleading name. It does not\n    necessarily kill the child unless you send the right signal. See the\n    :mod:`signal` module for constants representing signal numbers.\n\n    Args:\n        sig: signal to send to kill\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n\n    # Same as os.kill, but the pid is given for you.\n    if self.isalive():\n        os.kill(self.pid, sig)\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.read","title":"<code>read(size: int = 1024) -&gt; bytes</code>","text":"<p>Read and return at most <code>size</code> bytes from the pty.</p> <p>Can block if there is nothing to read. Raises :exc:<code>EOFError</code> if the terminal was closed.</p> <p>Unlike Pexpect's <code>read_nonblocking</code> method, this doesn't try to deal with the vagaries of EOF on platforms that do strange things, like IRIX or older Solaris systems. It handles the errno=EIO pattern used on Linux, and the empty-string return used on BSD platforms and (seemingly) on recent Solaris.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>bytes to read</p> <code>1024</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>bytes read</p> <p>Raises:</p> Type Description <code>EOFError</code> <p>eof encountered</p> <code>EOFError</code> <p>eof encountered</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def read(self, size: int = 1024) -&gt; bytes:\n\"\"\"\n    Read and return at most ``size`` bytes from the pty.\n\n    Can block if there is nothing to read. Raises :exc:`EOFError` if the\n    terminal was closed.\n\n    Unlike Pexpect's ``read_nonblocking`` method, this doesn't try to deal\n    with the vagaries of EOF on platforms that do strange things, like IRIX\n    or older Solaris systems. It handles the errno=EIO pattern used on\n    Linux, and the empty-string return used on BSD platforms and (seemingly)\n    on recent Solaris.\n\n    Args:\n        size: bytes to read\n\n    Returns:\n        bytes: bytes read\n\n    Raises:\n        EOFError: eof encountered\n        EOFError: eof encountered\n\n    \"\"\"\n    try:\n        s = self.fileobj.read1(size)\n    except (OSError, IOError) as err:\n        if err.args[0] == errno.EIO:\n            # Linux-style EOF\n            self.flag_eof = True\n            raise EOFError(\"End Of File (EOF). Exception style platform.\")\n        raise\n    if s == b\"\":\n        # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))\n        self.flag_eof = True\n        raise EOFError(\"End Of File (EOF). Empty string style platform.\")\n\n    return s\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.setwinsize","title":"<code>setwinsize(rows: int = 24, cols: int = 80) -&gt; None</code>","text":"<p>Set window size.</p> <p>This will cause a SIGWINCH signal to be sent to the child. This does not change the physical window size. It changes the size reported to TTY-aware applications like vi or curses -- applications that respond to the SIGWINCH signal.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>int number of rows for terminal</p> <code>24</code> <code>cols</code> <code>int</code> <p>int number of cols for terminal</p> <code>80</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def setwinsize(self, rows: int = 24, cols: int = 80) -&gt; None:\n\"\"\"\n    Set window size.\n\n    This will cause a SIGWINCH signal to be sent to the child. This does not change the physical\n    window size. It changes the size reported to TTY-aware applications like vi or curses --\n    applications that respond to the SIGWINCH signal.\n\n    Args:\n        rows: int number of rows for terminal\n        cols: int number of cols for terminal\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return _setwinsize(self.fd, rows, cols)\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.spawn","title":"<code>spawn(spawn_command: List[str], echo: bool = True, rows: int = 80, cols: int = 256) -&gt; PtyProcessType</code>  <code>classmethod</code>","text":"<p>Start the given command in a child process in a pseudo terminal.</p> <p>This does all the fork/exec type of stuff for a pty, and returns an instance of PtyProcess. For some devices setting terminal width strictly in the operating system (the actual network operating system) does not seem to be sufficient by itself for setting terminal length or width -- so we have optional values for rows/cols that can be passed here as well.</p> <p>Parameters:</p> Name Type Description Default <code>spawn_command</code> <code>List[str]</code> <p>command to execute with arguments (if applicable), as a list</p> required <code>echo</code> <code>bool</code> <p>enable/disable echo -- defaults to True, should be left as True for \"normal\" scrapli operations, optionally disable for scrapli_netconf operations.</p> <code>True</code> <code>rows</code> <code>int</code> <p>integer number of rows for ptyprocess \"window\"</p> <code>80</code> <code>cols</code> <code>int</code> <p>integer number of cols for ptyprocess \"window\"</p> <code>256</code> <p>Returns:</p> Name Type Description <code>PtyProcessType</code> <code>PtyProcessType</code> <p>instantiated PtyProcess object</p> <p>Raises:</p> Type Description <code>ScrapliValueError</code> <p>if no ssh binary found on PATH</p> <code>Exception</code> <p>IOError - if unable to set window size of child process</p> <code>Exception</code> <p>OSError - if unable to spawn command in child process</p> <code>IOError</code> <p>failing to reset window size</p> <code>exception</code> <p>if we get an exception decoding output</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>@classmethod\ndef spawn(\n    cls: Type[PtyProcessType],\n    spawn_command: List[str],\n    echo: bool = True,\n    rows: int = 80,\n    cols: int = 256,\n) -&gt; PtyProcessType:\n\"\"\"\n    Start the given command in a child process in a pseudo terminal.\n\n    This does all the fork/exec type of stuff for a pty, and returns an instance of PtyProcess.\n    For some devices setting terminal width strictly in the operating system (the actual network\n    operating system) does not seem to be sufficient by itself for setting terminal length or\n    width -- so we have optional values for rows/cols that can be passed here as well.\n\n    Args:\n        spawn_command: command to execute with arguments (if applicable), as a list\n        echo: enable/disable echo -- defaults to True, should be left as True for \"normal\"\n            scrapli operations, optionally disable for scrapli_netconf operations.\n        rows: integer number of rows for ptyprocess \"window\"\n        cols: integer number of cols for ptyprocess \"window\"\n\n    Returns:\n        PtyProcessType: instantiated PtyProcess object\n\n    Raises:\n        ScrapliValueError: if no ssh binary found on PATH\n        Exception: IOError - if unable to set window size of child process\n        Exception: OSError - if unable to spawn command in child process\n        IOError: failing to reset window size\n        exception: if we get an exception decoding output\n\n    \"\"\"\n    # Note that it is difficult for this method to fail.\n    # You cannot detect if the child process cannot start.\n    # So the only way you can tell if the child process started\n    # or not is to try to read from the file descriptor. If you get\n    # EOF immediately then it means that the child is already dead.\n    # That may not necessarily be bad because you may have spawned a child\n    # that performs some task; creates no stdout output; and then dies.\n\n    import fcntl\n    import pty\n    import resource\n    import termios\n    from pty import CHILD, STDIN_FILENO\n\n    spawn_executable = which(spawn_command[0])\n    if spawn_executable is None:\n        raise ScrapliValueError(\"ssh executable not found!\")\n    spawn_command[0] = spawn_executable\n\n    # [issue #119] To prevent the case where exec fails and the user is\n    # stuck interacting with a python child process instead of whatever\n    # was expected, we implement the solution from\n    # http://stackoverflow.com/a/3703179 to pass the exception to the\n    # parent process\n    # [issue #119] 1. Before forking, open a pipe in the parent process.\n    exec_err_pipe_read, exec_err_pipe_write = os.pipe()\n\n    pid, fd = pty.fork()\n\n    # Some platforms must call setwinsize() and setecho() from the\n    # child process, and others from the master process. We do both,\n    # allowing IOError for either.\n    if pid == CHILD:\n        try:\n            _setwinsize(fd=STDIN_FILENO, rows=rows, cols=cols)\n        except IOError as err:\n            if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                raise\n\n        # disable echo if requested\n        if echo is False:\n            try:\n                _setecho(STDIN_FILENO, False)\n            except (IOError, termios.error) as err:\n                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                    raise\n\n        # [issue #119] 3. The child closes the reading end and sets the\n        # close-on-exec flag for the writing end.\n        os.close(exec_err_pipe_read)\n        fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)\n\n        # Do not allow child to inherit open file descriptors from parent,\n        # with the exception of the exec_err_pipe_write of the pipe.\n        # Impose ceiling on max_fd: AIX bugfix for users with unlimited\n        # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()\n        # occasionally raises out of range error\n        max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])\n        pass_fds = sorted({exec_err_pipe_write})\n        for pair in zip([2] + pass_fds, pass_fds + [max_fd]):\n            os.closerange(pair[0] + 1, pair[1])\n\n        try:\n            os.execv(spawn_executable, spawn_command)\n        except OSError as err:\n            # [issue #119] 5. If exec fails, the child writes the error\n            # code back to the parent using the pipe, then exits.\n            tosend = f\"OSError:{err.errno}:{err}\".encode()\n            os.write(exec_err_pipe_write, tosend)\n            os.close(exec_err_pipe_write)\n            os._exit(os.EX_OSERR)\n\n    # Parent\n    inst = cls(pid, fd)\n\n    # [issue #119] 2. After forking, the parent closes the writing end\n    # of the pipe and reads from the reading end.\n    os.close(exec_err_pipe_write)\n    exec_err_data = os.read(exec_err_pipe_read, 4096)\n    os.close(exec_err_pipe_read)\n\n    # [issue #119] 6. The parent reads eof (a zero-length read) if the\n    # child successfully performed exec, since close-on-exec made\n    # successful exec close the writing end of the pipe. Or, if exec\n    # failed, the parent reads the error code and can proceed\n    # accordingly. Either way, the parent blocks until the child calls\n    # exec.\n    if len(exec_err_data) != 0:\n        try:\n            errclass, errno_s, errmsg = exec_err_data.split(b\":\", 2)\n            exctype = getattr(builtins, errclass.decode(\"ascii\"), Exception)\n\n            exception = exctype(errmsg.decode(\"utf-8\", \"replace\"))\n            if exctype is OSError:\n                exception.errno = int(errno_s)\n        except Exception:\n            raise Exception(\"Subprocess failed, got bad error data: %r\" % exec_err_data)\n        else:\n            raise exception\n\n    try:\n        inst.setwinsize(rows=rows, cols=cols)\n    except IOError as err:\n        if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):\n            raise\n\n    return inst\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.terminate","title":"<code>terminate(force: bool = False) -&gt; bool</code>","text":"<p>This forces a child process to terminate.</p> <p>It starts nicely with SIGHUP and SIGINT. If \"force\" is True then moves onto SIGKILL. This returns True if the child was terminated. This returns False if the child could not be terminated.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>bool; force termination</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>terminate succeeded or failed</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def terminate(self, force: bool = False) -&gt; bool:\n\"\"\"\n    This forces a child process to terminate.\n\n    It starts nicely with SIGHUP and SIGINT. If \"force\" is True then moves onto SIGKILL. This\n    returns True if the child was terminated. This returns False if the child could not be\n    terminated.\n\n    Args:\n        force: bool; force termination\n\n    Returns:\n        bool: terminate succeeded or failed\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if not self.isalive():\n        return True\n    try:\n        self.kill(signal.SIGHUP)\n        time.sleep(self.delayafterterminate)\n        if not self.isalive():\n            return True\n        self.kill(signal.SIGCONT)\n        time.sleep(self.delayafterterminate)\n        if not self.isalive():\n            return True\n        self.kill(signal.SIGINT)\n        time.sleep(self.delayafterterminate)\n        if not self.isalive():\n            return True\n        if force:\n            self.kill(signal.SIGKILL)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n    except OSError:\n        # I think there are kernel timing issues that sometimes cause\n        # this to happen. I think isalive() reports True, but the\n        # process is dead to the kernel.\n        # Make one last attempt to see if the kernel is up to date.\n        time.sleep(self.delayafterterminate)\n        if not self.isalive():\n            return True\n    return False\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcess.write","title":"<code>write(bytes_to_write: bytes, flush: bool = True) -&gt; int</code>","text":"<p>Write bytes to the pseudoterminal.</p> <p>Returns the number of bytes written.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_to_write</code> <code>bytes</code> <p>bytes to write to the terminal</p> required <code>flush</code> <code>bool</code> <p>flush the terminal or not</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of bytes written</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>def write(self, bytes_to_write: bytes, flush: bool = True) -&gt; int:\n\"\"\"\n    Write bytes to the pseudoterminal.\n\n    Returns the number of bytes written.\n\n    Args:\n        bytes_to_write: bytes to write to the terminal\n        flush: flush the terminal or not\n\n    Returns:\n        int: number of bytes written\n\n    Raises:\n        N/A\n\n    \"\"\"\n    n = self.fileobj.write(bytes_to_write)\n    if flush:\n        self.fileobj.flush()\n    return n\n</code></pre>"},{"location":"reference/transport/plugins/system/ptyprocess/#transport.plugins.system.ptyprocess.PtyProcessError","title":"<code>PtyProcessError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Generic error class for this package.</p> Source code in <code>transport/plugins/system/ptyprocess.py</code> <pre><code>class PtyProcessError(Exception):\n\"\"\"Generic error class for this package.\"\"\"\n</code></pre>"},{"location":"reference/transport/plugins/system/transport/","title":"transport","text":"<p>scrapli.transport.plugins.system.transport</p>"},{"location":"reference/transport/plugins/system/transport/#transport.plugins.system.transport.SystemTransport","title":"<code>SystemTransport</code>","text":"<p>         Bases: <code>Transport</code></p> Source code in <code>transport/plugins/system/transport.py</code> <pre><code>class SystemTransport(Transport):\n    def __init__(\n        self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n    ) -&gt; None:\n\"\"\"\n        System (i.e. /bin/ssh) transport plugin.\n\n        This transport supports some additional `transport_options` to control behavior --\n\n        `ptyprocess` is a dictionary that has the following options:\n            rows: integer number of rows for ptyprocess \"window\"\n            cols: integer number of cols for ptyprocess \"window\"\n            echo: defaults to `True`, passing `False` disables echo in the ptyprocess; should only\n                be used with scrapli-netconf, will break scrapli!\n\n        `netconf_force_pty` is a scrapli-netconf only argument. This setting defaults to `True` and\n            allows you to *not* force a pty. This setting seems to only be necessary when connecting\n            to juniper devices on port 830 as junos decides to not allocate a pty on that port for\n            some reason!\n\n        Args:\n            base_transport_args: scrapli base transport plugin arguments\n            plugin_transport_args: system ssh specific transport plugin arguments\n\n        Returns:\n            N/A\n\n        Raises:\n            ScrapliUnsupportedPlatform: if system is windows\n\n        \"\"\"\n        super().__init__(base_transport_args=base_transport_args)\n        self.plugin_transport_args = plugin_transport_args\n\n        if sys.platform.startswith(\"win\"):\n            raise ScrapliUnsupportedPlatform(\"system transport is not supported on windows devices\")\n\n        self.open_cmd: List[str] = []\n        self.session: Optional[PtyProcess] = None\n\n    def _build_open_cmd(self) -&gt; None:\n\"\"\"\n        Method to craft command to open ssh session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.open_cmd:\n            self.open_cmd = []\n\n        self.open_cmd.extend([\"ssh\", self._base_transport_args.host])\n        self.open_cmd.extend([\"-p\", str(self._base_transport_args.port)])\n\n        self.open_cmd.extend(\n            [\"-o\", f\"ConnectTimeout={int(self._base_transport_args.timeout_socket)}\"]\n        )\n        self.open_cmd.extend(\n            [\"-o\", f\"ServerAliveInterval={int(self._base_transport_args.timeout_transport)}\"]\n        )\n\n        if self.plugin_transport_args.auth_private_key:\n            self.open_cmd.extend([\"-i\", self.plugin_transport_args.auth_private_key])\n        if self.plugin_transport_args.auth_username:\n            self.open_cmd.extend([\"-l\", self.plugin_transport_args.auth_username])\n\n        if self.plugin_transport_args.auth_strict_key is False:\n            self.open_cmd.extend([\"-o\", \"StrictHostKeyChecking=no\"])\n            self.open_cmd.extend([\"-o\", \"UserKnownHostsFile=/dev/null\"])\n        else:\n            self.open_cmd.extend([\"-o\", \"StrictHostKeyChecking=yes\"])\n            if self.plugin_transport_args.ssh_known_hosts_file:\n                self.open_cmd.extend(\n                    [\"-o\", f\"UserKnownHostsFile={self.plugin_transport_args.ssh_known_hosts_file}\"]\n                )\n\n        if self.plugin_transport_args.ssh_config_file:\n            self.open_cmd.extend([\"-F\", self.plugin_transport_args.ssh_config_file])\n        else:\n            self.open_cmd.extend([\"-F\", \"/dev/null\"])\n\n        open_cmd_user_args = self._base_transport_args.transport_options.get(\"open_cmd\", [])\n        if isinstance(open_cmd_user_args, str):\n            open_cmd_user_args = [open_cmd_user_args]\n        self.open_cmd.extend(open_cmd_user_args)\n\n        self.logger.debug(f\"created transport 'open_cmd': '{self.open_cmd}'\")\n\n    def open(self) -&gt; None:\n        self._pre_open_closing_log(closing=False)\n\n        if not self.open_cmd:\n            self._build_open_cmd()\n\n        self.session = PtyProcess.spawn(\n            self.open_cmd,\n            echo=self._base_transport_args.transport_options.get(\"ptyprocess\", {}).get(\n                \"echo\", True\n            ),\n            rows=self._base_transport_args.transport_options.get(\"ptyprocess\", {}).get(\"rows\", 80),\n            cols=self._base_transport_args.transport_options.get(\"ptyprocess\", {}).get(\"cols\", 256),\n        )\n\n        self._post_open_closing_log(closing=False)\n\n    def close(self) -&gt; None:\n        self._pre_open_closing_log(closing=True)\n\n        if self.session:\n            self.session.close()\n\n        self.session = None\n\n        self._post_open_closing_log(closing=True)\n\n    def isalive(self) -&gt; bool:\n        if not self.session:\n            return False\n        if self.session.isalive() and not self.session.eof():\n            return True\n        return False\n\n    @timeout_wrapper\n    def read(self) -&gt; bytes:\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n        try:\n            buf = self.session.read(65535)\n        except EOFError as exc:\n            msg = (\n                \"encountered EOF reading from transport; typically means the device closed the \"\n                \"connection\"\n            )\n            self.logger.critical(msg)\n            raise ScrapliConnectionError(msg) from exc\n\n        return buf\n\n    def write(self, channel_input: bytes) -&gt; None:\n        if not self.session:\n            raise ScrapliConnectionNotOpened\n        self.session.write(channel_input)\n</code></pre>"},{"location":"reference/transport/plugins/system/transport/#transport.plugins.system.transport.SystemTransport.__init__","title":"<code>__init__(base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs) -&gt; None</code>","text":"<p>System (i.e. /bin/ssh) transport plugin.</p> <p>This transport supports some additional <code>transport_options</code> to control behavior --</p> <p><code>ptyprocess</code> is a dictionary that has the following options:     rows: integer number of rows for ptyprocess \"window\"     cols: integer number of cols for ptyprocess \"window\"     echo: defaults to <code>True</code>, passing <code>False</code> disables echo in the ptyprocess; should only         be used with scrapli-netconf, will break scrapli!</p> <p><code>netconf_force_pty</code> is a scrapli-netconf only argument. This setting defaults to <code>True</code> and     allows you to not force a pty. This setting seems to only be necessary when connecting     to juniper devices on port 830 as junos decides to not allocate a pty on that port for     some reason!</p> <p>Parameters:</p> Name Type Description Default <code>base_transport_args</code> <code>BaseTransportArgs</code> <p>scrapli base transport plugin arguments</p> required <code>plugin_transport_args</code> <code>PluginTransportArgs</code> <p>system ssh specific transport plugin arguments</p> required <p>Returns:</p> Type Description <code>None</code> <p>N/A</p> <p>Raises:</p> Type Description <code>ScrapliUnsupportedPlatform</code> <p>if system is windows</p> Source code in <code>transport/plugins/system/transport.py</code> <pre><code>def __init__(\n    self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n) -&gt; None:\n\"\"\"\n    System (i.e. /bin/ssh) transport plugin.\n\n    This transport supports some additional `transport_options` to control behavior --\n\n    `ptyprocess` is a dictionary that has the following options:\n        rows: integer number of rows for ptyprocess \"window\"\n        cols: integer number of cols for ptyprocess \"window\"\n        echo: defaults to `True`, passing `False` disables echo in the ptyprocess; should only\n            be used with scrapli-netconf, will break scrapli!\n\n    `netconf_force_pty` is a scrapli-netconf only argument. This setting defaults to `True` and\n        allows you to *not* force a pty. This setting seems to only be necessary when connecting\n        to juniper devices on port 830 as junos decides to not allocate a pty on that port for\n        some reason!\n\n    Args:\n        base_transport_args: scrapli base transport plugin arguments\n        plugin_transport_args: system ssh specific transport plugin arguments\n\n    Returns:\n        N/A\n\n    Raises:\n        ScrapliUnsupportedPlatform: if system is windows\n\n    \"\"\"\n    super().__init__(base_transport_args=base_transport_args)\n    self.plugin_transport_args = plugin_transport_args\n\n    if sys.platform.startswith(\"win\"):\n        raise ScrapliUnsupportedPlatform(\"system transport is not supported on windows devices\")\n\n    self.open_cmd: List[str] = []\n    self.session: Optional[PtyProcess] = None\n</code></pre>"},{"location":"reference/transport/plugins/telnet/","title":"telnet","text":"<p>scrapli.transport.plugins.telnet</p>"},{"location":"reference/transport/plugins/telnet/transport/","title":"transport","text":"<p>scrapli.transport.plugins.telnet.transport</p>"},{"location":"reference/transport/plugins/telnet/transport/#transport.plugins.telnet.transport.TelnetTransport","title":"<code>TelnetTransport</code>","text":"<p>         Bases: <code>Transport</code></p> Source code in <code>transport/plugins/telnet/transport.py</code> <pre><code>class TelnetTransport(Transport):\n    def __init__(\n        self, base_transport_args: BaseTransportArgs, plugin_transport_args: PluginTransportArgs\n    ) -&gt; None:\n        super().__init__(base_transport_args=base_transport_args)\n        self.plugin_transport_args = plugin_transport_args\n\n        self.socket: Optional[Socket] = None\n        self._eof = False\n        self._raw_buf = b\"\"\n        self._cooked_buf = b\"\"\n\n        self._control_char_sent_counter = 0\n        self._control_char_sent_limit = 10\n\n    def _set_socket_timeout(self, timeout: float) -&gt; None:\n\"\"\"\n        Set underlying socket timeout\n\n        Mostly this exists just to assert that socket and socket.sock are not None to appease mypy!\n\n        Args:\n            timeout: float value to set as the timeout\n\n        Returns:\n            N/A\n\n        Raises:\n            ScrapliConnectionNotOpened: if either socket or socket.sock are None\n        \"\"\"\n        if self.socket is None:\n            raise ScrapliConnectionNotOpened\n        if self.socket.sock is None:\n            raise ScrapliConnectionNotOpened\n        self.socket.sock.settimeout(timeout)\n\n    def _handle_control_chars_socket_timeout_update(self) -&gt; None:\n\"\"\"\n        Handle updating (if necessary) the socket timeout\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._control_char_sent_counter += 1\n\n        if self._control_char_sent_counter &gt; self._control_char_sent_limit:\n            # connection is opened, effectively ignore socket timeout at this point as we want\n            # the timeout socket to be \"just\" for opening the connection basically\n            # the number 8 is fairly arbitrary -- it looks like *most* platforms send around\n            # 8 - 12 control char/instructions on session opening, so we'll go with 8!\n            self._set_socket_timeout(600)\n\n    def _handle_control_chars_response(self, control_buf: bytes, c: bytes) -&gt; bytes:\n\"\"\"\n        Handle the actual response to control characters\n\n        Broken up to be easier to test as well as to appease mr. mccabe\n\n        NOTE: see the asynctelnet transport for additional comments inline about what is going on\n        here.\n\n        Args:\n            control_buf: current control_buf to work with\n            c: currently read control char to process\n\n        Returns:\n            bytes: updated control_buf\n\n        Raises:\n            ScrapliConnectionNotOpened: if connection is not opened for some reason\n\n        \"\"\"\n        if not self.socket:\n            raise ScrapliConnectionNotOpened\n\n        if not control_buf:\n            if c != IAC:\n                self._cooked_buf += c\n            else:\n                control_buf += c\n\n        elif len(control_buf) == 1 and c in (DO, DONT, WILL, WONT):\n            control_buf += c\n\n        elif len(control_buf) == 2:\n            cmd = control_buf[1:2]\n            control_buf = b\"\"\n\n            if (cmd == DO) and (c == SUPPRESS_GO_AHEAD):\n                self.write(IAC + WILL + c)\n            elif cmd in (DO, DONT):\n                self.write(IAC + WONT + c)\n            elif cmd == WILL:\n                self.write(IAC + DO + c)\n            elif cmd == WONT:\n                self.write(IAC + DONT + c)\n\n            self._handle_control_chars_socket_timeout_update()\n\n        return control_buf\n\n    def _handle_control_chars(self) -&gt; None:\n\"\"\"\n        Handle control characters -- nearly identical to CPython (removed in 3.11) telnetlib\n\n        Basically we want to read and \"decline\" any and all control options that the server proposes\n        to us -- so if they say \"DO\" XYZ directive, we say \"DONT\", if they say \"WILL\" we say \"WONT\".\n\n        NOTE: see the asynctelnet transport for additional comments inline about what is going on\n        here.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliConnectionNotOpened: if connection is not opened for some reason\n            ScrapliConnectionNotOpened: if we read an empty byte string from the reader -- this\n                indicates the server sent an EOF -- see #142\n\n        \"\"\"\n        if not self.socket:\n            raise ScrapliConnectionNotOpened\n\n        control_buf = b\"\"\n\n        while self._raw_buf:\n            c, self._raw_buf = self._raw_buf[:1], self._raw_buf[1:]\n            if not c:\n                raise ScrapliConnectionNotOpened(\"server returned EOF, connection not opened\")\n\n            control_buf = self._handle_control_chars_response(control_buf=control_buf, c=c)\n\n    def open(self) -&gt; None:\n        self._pre_open_closing_log(closing=False)\n\n        if not self.socket:\n            self.socket = Socket(\n                host=self._base_transport_args.host,\n                port=self._base_transport_args.port,\n                timeout=self._base_transport_args.timeout_socket,\n            )\n\n        if not self.socket.isalive():\n            self.socket.open()\n\n        self._post_open_closing_log(closing=False)\n\n    def close(self) -&gt; None:\n        self._pre_open_closing_log(closing=True)\n\n        if self.socket:\n            self.socket.close()\n\n        self.socket = None\n\n        self._post_open_closing_log(closing=True)\n\n    def isalive(self) -&gt; bool:\n        if not self.socket:\n            return False\n        if not self.socket.isalive():\n            return False\n        return True\n\n    def _read(self, n: int = 65535) -&gt; None:\n\"\"\"\n        Read n bytes from the socket and fill raw buffer\n\n        Mostly this exists just to assert that socket and socket.sock are not None to appease mypy!\n\n        Args:\n            n: optional amount of bytes to try to recv from the underlying socket\n\n        Returns:\n            N/A\n\n        Raises:\n            ScrapliConnectionNotOpened: if either socket or socket.sock are None\n            ScrapliConnectionError: if we fail to recv from the underlying socket\n\n        \"\"\"\n        if self.socket is None:\n            raise ScrapliConnectionNotOpened\n        if self.socket.sock is None:\n            raise ScrapliConnectionNotOpened\n        if not self._raw_buf:\n            try:\n                buf = self.socket.sock.recv(n)\n                self._eof = not buf\n                if self._control_char_sent_counter &lt; self._control_char_sent_limit:\n                    self._raw_buf += buf\n                else:\n                    self._cooked_buf += buf\n            except Exception as exc:\n                raise ScrapliConnectionError(\n                    \"encountered EOF reading from transport; typically means the device closed the \"\n                    \"connection\"\n                ) from exc\n\n    @timeout_wrapper\n    def read(self) -&gt; bytes:\n        if not self.socket:\n            raise ScrapliConnectionNotOpened\n\n        if self._control_char_sent_counter &lt; self._control_char_sent_limit:\n            self._handle_control_chars()\n\n        while not self._cooked_buf and not self._eof:\n            self._read()\n            if self._control_char_sent_counter &lt; self._control_char_sent_limit:\n                self._handle_control_chars()\n\n        buf = self._cooked_buf\n        self._cooked_buf = b\"\"\n\n        # possible to still have null bytes in the buf, replace them with nothing\n        return buf.replace(NULL, b\"\")\n\n    def write(self, channel_input: bytes) -&gt; None:\n        if self.socket is None:\n            raise ScrapliConnectionNotOpened\n        if self.socket.sock is None:\n            raise ScrapliConnectionNotOpened\n        self.socket.sock.send(channel_input)\n</code></pre>"},{"location":"user_guide/advanced_usage/","title":"Advanced Usage","text":""},{"location":"user_guide/advanced_usage/#all-driver-arguments","title":"All Driver Arguments","text":"<p>The basic usage section outlined the most commonly used driver arguments, please see the following page to see all  supported base driver arguments:</p> <ul> <li>Base <code>Driver</code> Arguments </li> </ul> <p>Most of these attributes actually get passed from the <code>Driver</code> (or sub-class such as <code>NXOSDriver</code>) into the  <code>Transport</code> and <code>Channel</code> classes, so if you need to modify any of these values after instantiation you should do so   on the appropriate object -- i.e. <code>conn.channel.comms_prompt_pattern</code>.</p>"},{"location":"user_guide/advanced_usage/#platform-regex","title":"Platform Regex","text":"<p>Due to the nature of Telnet/SSH there is no good way to know when a command has completed execution. Put another way , when sending any command, data is returned over a socket, that socket doesn't ever tell us when it is \"done \" sending the output from the command that was executed. In order to know when the session is \"back at the base  prompt/starting point\" scrapli uses a regular expression pattern to find that base prompt.</p> <p>This pattern is contained in the <code>comms_prompt_pattern</code> setting or is created by joining all possible prompt patterns  in the privilege levels for a \"core\" device type. In general, you should not change the patterns unless you have a   good reason to do so!</p> <p>The \"base\" <code>Driver</code> (default, but changeable) pattern is:</p> <p><code>\"^[a-z0-9.\\-@()/:]{1,48}[#&gt;$]\\s*$\"</code></p> <p>NOTE all <code>comms_prompt_pattern</code> \"should\" use the start and end of line anchors as all regex searches in scrapli are  multi-line (this is an important piece to making this all work!). While you don't need to use the line anchors its   probably a really good idea! Also note that most devices seem to leave at least one white space after the final    character of the prompt, so make sure to account for this! Last important note -- the core drivers all have reliable     patterns set for you, so you hopefully don't need to bother with this too much!</p> <p>The above pattern works on all \"core\" platforms listed above for at the very least basic usage. Custom prompts or  host names could in theory break this, so be careful!</p> <p>If you use a platform driver, the base prompt is set in the driver, so you don't really need to worry about this!</p> <p>The <code>comms_prompt_pattern</code> pattern can be changed at any time at or after instantiation of a scrapli object, and is  done so by modifying <code>conn.channel.comms_prompt_pattern</code> where <code>conn</code> is your scrapli connection object. Changing  this can break things though, so be careful! If using any <code>NetworkDriver</code> sub-classes you should modify the   privilege level(s) if necessary, and not the <code>comms_prompt_pattern</code>.</p>"},{"location":"user_guide/advanced_usage/#on-open","title":"On Open","text":"<p>Lots of times when connecting to a device there are \"things\" that need to happen immediately after getting connected . In the context of network devices the most obvious/common example would be disabling paging (i.e. sending <code>terminal  length 0</code> on a Cisco-type device). While scrapli <code>Driver</code> (the base driver) and <code>GenericDriver</code> do not know or care   about disabling paging or any other on connect type activities, scrapli of course provides a mechanism for allowing    users to handle these types of tasks. Even better yet, if you are using any of the core drivers (<code>IOSXEDriver</code>, <code>IOSXRDriver</code>, etc.), scrapli will automatically have some sane default \"on connect\" actions (namely disabling     paging).</p> <p>If you were so inclined to create some of your own \"on connect\" actions, you can simply pass those to the <code>on_open</code> argument of <code>Scrape</code> or any of its sub-classes (<code>NetworkDriver</code>, <code>IOSXEDriver</code>, etc.). The value of this argument  must be a callable that accepts the reference to the connection object. This allows for the user to send commands or   do really anything that needs to happen prior to \"normal\" operations. The core network drivers disable paging    functions all call directly into the channel object <code>send_input</code> method -- this is a good practice to follow as     this will avoid any of the <code>NetworkDriver</code> overhead such as trying to attain privilege levels -- things like this      may not be \"ready\" until after your <code>on_open</code> function is executed.</p> <p>Below is an example of creating an \"on connect\" function and passing it to scrapli. Immediately after authentication  is handled this function will be called and disable paging (in this example):</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\ndef iosxe_disable_paging(conn):\n    conn.channel.send_input(\"term length 0\")\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n    \"on_open\": iosxe_disable_paging\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n</code></pre> <p>Note that this section has talked almost exclusively about disabling paging, but any other \"things\" that need to  happen in the channel can be handled here. If there is a prompt/banner to accept you should be able to handle it   here. The goal of this \"on connect\" function is to allow for lots of flexibility for dealing with whatever needs to    happen for devices -- thus decoupling the challenge of addressing all of the possible options from scrapli itself     and allowing users to handle things specific for their environment.</p> <p>Lastly, while the <code>on_open</code> method should be synchronous or asyncio depending on the driver -- meaning that if using  an async driver, it will await the <code>on_open</code> callable, so it must be asynchronous!</p>"},{"location":"user_guide/advanced_usage/#on-close","title":"On Close","text":"<p>As you may have guessed, <code>on_close</code> is very similar to <code>on_open</code> with the obvious difference that it happens just  prior to disconnecting from the device. Just like <code>on_open</code>, <code>on_close</code> functions should accept a single argument   that is a reference to the object itself. As with most things scrapli, there are sane defaults for the <code>on_close</code> functions, but you are welcome to override them with your own function if you so chose! </p>"},{"location":"user_guide/advanced_usage/#timeouts","title":"Timeouts","text":"<p>scrapli supports several timeout options:</p> <ul> <li><code>timeout_socket</code></li> <li><code>timeout_transport</code></li> <li><code>timeout_ops</code></li> </ul> <p><code>timeout_socket</code> is exactly what it sounds where possible. For the ssh2 and paramiko transports we create our own  socket and pass this to the created object (paramiko or ssh2 object). The socket is created with the timeout value   set in the <code>timeout_socket</code> attribute. For telnet and system transports we do not create a socket ourselves so this    value is used slightly differently.</p> <p>For telnet, the <code>timeout_socket</code> is used as the timeout for telnet session creation. After the telnet session is  created the timeout is reset to the <code>timeout_transport</code> value (more on that in a second).</p> <p>For system transport, <code>timeout_socket</code> governs the <code>ConnectTimeout</code> ssh argument -- which seems to be very similar to  socket timeout in paramiko/ssh2.</p> <p><code>timeout_transport</code> is intended to govern the timeout for the actual transport mechanism itself. For paramiko and  ssh2, this is set to the respective libraries timeout attributes. For telnet, this is set to the telnetlib timeout   value after the initial telnet session is stood up. For system transport, this value is used as the timeout value    for read and write operations (handled by operation timeout decorator). </p> <p>Finally, <code>timeout_ops</code> sets a timeout value for individual operations -- or put another way, the timeout for each  send_input operation.</p>"},{"location":"user_guide/advanced_usage/#driver-privilege-levels","title":"Driver Privilege Levels","text":"<p>The \"core\" drivers understand the basic privilege levels of their respective device types. As mentioned previously , the drivers will automatically attain the \"privilege_exec\" (or equivalent) privilege level prior to executing \"show \" commands. If you don't want this \"auto-magic\" you can use the base driver (<code>Driver</code>) or the <code>GenericDriver</code>. The  privileges for each device are outlined in the platforms <code>driver.py</code> file - each privilege is an object of the base   <code>PrivilegeLevel</code> class which uses slots for the attributes. This used to be a named tuple, however as this was    immutable it was a bit of a pain for users to modify things on the fly. </p> <p>As an example, the following privilege levels are supported by the <code>IOSXEDriver</code>:</p> <ol> <li>\"exec\"</li> <li>\"privilege_exec\"</li> <li>\"configuration\"</li> </ol> <p>Each privilege level has the following attributes:</p> <ul> <li>pattern: regex pattern to associate prompt to privilege level with</li> <li>name: name of the priv level, i.e. \"exec\"</li> <li>previous_priv: name of the \"lower\"/\"previous\" privilege level</li> <li>deescalate: command used to deescalate from this privilege level (or an empty string if no lower privilege)</li> <li>escalate: command used to escalate to this privilege level (from the lower/previous privilege)</li> <li>escalate_auth: True/False there is auth required to escalate to this privilege level</li> <li>escalate_prompt: pattern to expect when escalating to this privilege level, i.e. \"Password:\" or any empty string</li> </ul> <p>If you wish to manually enter a privilege level you can use the <code>acquire_priv</code> method, passing in the name of the  privilege level you would like to enter. In general, you probably won't need this too often though as the driver   should handle much of this for you.</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\nwith IOSXEDriver(**my_device) as conn:\n    conn.acquire_priv(\"configuration\")\n</code></pre>"},{"location":"user_guide/advanced_usage/#configure-exclusive-and-configure-private-iosxrjunos","title":"Configure Exclusive and Configure Private (IOSXR/Junos)","text":"<p>IOSXR and Junos platforms have different configuration modes, such as \"configure exclusive\" or \"configure private \". These alternate configuration modes are represented as a privilege level just like the \"regular\" configuration  mode. You can acquire an \"exclusive\" configuration session on IOSXR as follows:</p> <pre><code>from scrapli.driver.core import IOSXRDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\nwith IOSXRDriver(**my_device) as conn:\n    conn.acquire_priv(\"configuration_exclusive\")\n</code></pre> <p>Of course you can also pass this privilege level name to the <code>send_configs</code> or <code>send_configs_from_file</code> methods as well:</p> <pre><code>from scrapli.driver.core import IOSXRDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\nwith IOSXRDriver(**my_device) as conn:\n    conn.send_configs(configs=[\"configure things\"], privilege_level=\"configuration_exclusive\")\n</code></pre> <p>Note that the name of the privilege level is \"configuration_exclusive\" -- don't forget to write the whole thing out!</p>"},{"location":"user_guide/advanced_usage/#configure-session-eosnxos","title":"Configure Session (EOS/NXOS)","text":"<p>EOS and NXOS devices support configuration \"sessions\", these sessions are a little bit of a special case for scrapli . In order to use a configuration session, the configuration session must first be \"registered\" with scrapli -- this  is so that scrapli can create a privilege level that is mapped to the given config session/config session name  . The <code>register_configuration_session</code> method that accepts a string name of the configuration session you would like   to create -- note that this method raises a <code>NotImplementedError</code> for platforms that do not support config sessions   . The<code>register_configuration_session</code> method creates a new privilege level for you and updates the transport class    with the appropriate information internally (see next section). An example of creating a session for an EOS device     called \"my-config-session\" can be seen here:</p> <pre><code>from scrapli.driver.core import EOSDriver\n\nmy_device = {\n    \"host\": \"172.18.0.14\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_secondary\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\nwith EOSDriver(**my_device) as conn:\n    conn.register_configuration_session(session_name=\"my-config-session\")\n    print(conn.privilege_levels[\"my-config-session\"])\n    print(conn.privilege_levels[\"my-config-session\"].name)\n    print(conn.privilege_levels[\"my-config-session\"].pattern)\n</code></pre> <pre><code>&lt;scrapli.driver.network_driver.PrivilegeLevel object at 0x7fca10070820&gt;\nmy-config-session\n^[a-z0-9.\\-@/:]{1,32}\\(config\\-s\\-my\\-con[a-z0-9_.\\-@/:]{0,32}\\)#\\s?$\n</code></pre>"},{"location":"user_guide/advanced_usage/#modifying-privilege-levels","title":"Modifying Privilege Levels","text":"<p>When creating a configuration session, or modifying a privilege level during runtime, scrapli needs to update some  internal arguments in order to always have a full \"map\" of how to escalate/deescalate, as well as to be able to   match prompts based on any/all of the patterns available in the privilege levels dictionary. The    <code>register_configuration_session</code> method will automatically handle updating these internal arguments, however if     you modify any of the privilege levels (or add a priv level on the fly without using the register method) then      you will need to manually call the <code>update_privilege_levels</code> method. </p>"},{"location":"user_guide/advanced_usage/#using-driver-directly","title":"Using <code>Driver</code> Directly","text":"<p>All examples in this readme have shown using the \"core\" network drivers such as <code>IOSXEDriver</code>. These core network  drivers are actually sub-classes of an ABC called <code>NetworkDriver</code> which itself is a sub-class of the <code>GenericDriver</code> which is a sub-class of the base <code>Scrape</code> class -- the namesake for this library. The <code>Driver</code> object can be used   directly if you prefer to have a much less opinionated or less \"auto-magic\" type experience. <code>Driver</code> does not    provide the same <code>send_command</code>/<code>send_commands</code>/<code>send_configs</code> methods, nor does it disable paging, or handle any     kind of privilege escalation/de-escalation. <code>Driver</code> is a much more basic \"paramiko\"-like experience. Below is a      brief example of using the <code>Driver</code> object directly:</p> <pre><code>from scrapli import Driver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith Driver(**my_device) as conn:\n    conn.channel.send_input(\"terminal length 0\")\n    response = conn.channel.send_input(\"show version\")\n</code></pre> <p>Without the <code>send_command</code> and similar methods, you must directly access the <code>Channel</code> object when sending inputs  with <code>Scrape</code>.</p>"},{"location":"user_guide/advanced_usage/#using-the-genericdriver","title":"Using the <code>GenericDriver</code>","text":"<p>Using the <code>Driver</code> driver directly is nice enough, however you may not want to have to change the prompt pattern, or  deal with accessing the channel to send commands to the device. In this case there is a <code>GenericDriver</code> available to   you. This driver has a very broad pattern that it matches for base prompts, has no concept of disabling paging or    privilege levels (like <code>Driver</code>), but does provide <code>send_command</code>, <code>send_commands</code>, <code>send_interactive</code>, and     <code>get_prompt</code> methods for a more NetworkDriver-like experience. </p> <p>Hopefully this <code>GenericDriver</code> can be used as a starting point for devices that don't fall under the core supported  platforms list.</p> <pre><code>from scrapli.driver import GenericDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith GenericDriver(**my_device) as conn:\n    conn.send_command(\"terminal length 0\")\n    response = conn.send_command(\"show version\")\n    responses = conn.send_commands([\"show version\", \"show run\"])\n</code></pre>"},{"location":"user_guide/advanced_usage/#using-a-different-transport","title":"Using a Different Transport","text":"<p>scrapli is built to be very flexible, including being flexible enough to use different libraries for \"transport \" -- or the actual Telnet/SSH communication. By default, scrapli uses the \"system\" transport which quite literally  uses the ssh binary on your system (<code>/usr/bin/ssh</code>). This \"system\" transport means that scrapli has no external   dependencies as it just relies on what is available on the machine running the scrapli script.</p> <p>In the spirit of being highly flexible, scrapli allows users to swap out this \"system\" transport with another  transport mechanism. The other supported transport plugins are <code>paramiko</code>, <code>ssh2-python</code>, <code>telnetlib</code>, <code>asyncssh</code>, and <code>asynctelnet</code>. The transport selection can be made  when instantiating the  scrapli connection object by passing in <code>paramiko</code>, <code>ssh2</code>, <code>telnet</code>, <code>asyncssh</code>, or <code>asynctelnet</code> to force  scrapli  to use the corresponding transport mechanism. If you are using one of the async transports you must use an async driver!</p> <p>While it will be a goal to ensure that these other transport mechanisms are supported and useful, the focus of  scrapli development will be on the \"system\" SSH transport.</p> <p>Example using <code>paramiko</code> as the transport:</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n    \"transport\": \"paramiko\"\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n</code></pre> <p>Currently, the only reason I can think of to use anything other than \"system\" as the transport would be to test  scrapli on a Windows host, to use telnet, to use ssh2 for super speed, or to use asyncio. If there are other good   reasons please do let me know!</p>"},{"location":"user_guide/advanced_usage/#auth-bypass","title":"Auth Bypass","text":"<p>NOTE only supported with system and telnet transports!</p> <p>Some devices, such as Cisco WLC, have no \"true\" SSH authentication, and instead prompt for credentials (or perhaps  not even that) after session establishment. In order to cope with this corner case, the <code>auth_bypass</code> flag can be   set to <code>True</code> which will cause scrapli to skip all authentication steps. Typically, this flag would be set and a    custom <code>on_open</code> function set to handle whatever prompts the device has upon SSH session establishment.</p> <p>See the non core device example to see this in action.</p>"},{"location":"user_guide/advanced_usage/#transport-options","title":"Transport Options","text":"<p>Because each transport has different options/features available, it doesn't make sense to try to put all possible  arguments in the <code>Driver</code> or <code>NetworkDriver</code> drivers, to address this an argument <code>transport_options</code> has been added  . This is exactly what it sounds like -- arguments that can be passed to the selected transport class. As these   arguments will be transport-specific, please check the docs/docstrings for your preferred transport to see what is    available.</p> <p>A simple example of passing additional SSH arguments to the <code>SystemSSHTransport</code> class is available  here.</p>"},{"location":"user_guide/advanced_usage/#raise-for-status","title":"Raise For Status","text":"<p>The scrapli <code>Response</code> and <code>MultiResponse</code> objects both contain a method called <code>raise_for_status</code>. This method's  purpose is to provide a very simple way to raise an exception if any of the commands or configs sent in a method   have failed. </p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    commands = [\"show run\", \"tacocat\", \"show version\"]\n    responses = conn.send_commands(commands=commands)\n</code></pre> <p>Inspecting the <code>responses</code> object from the above example, we can see that it indeed is marked as <code>Success: False</code>, even  though the first and last commands were successful:</p> <pre><code>&gt;&gt;&gt; responses\nMultiResponse &lt;Success: False; Response Elements: 3&gt;\n&gt;&gt;&gt; responses[0]\nResponse &lt;Success: True&gt;\n&gt;&gt;&gt; responses[1]\nResponse &lt;Success: False&gt;\n&gt;&gt;&gt; responses[2]\nResponse &lt;Success: True&gt;\n</code></pre> <p>Finally, we can all the <code>raise_for_status</code> method to have scrapli raise the <code>ScrapliCommandFailure</code> exception if any  of the configs/commands failed:</p> <pre><code>&gt;&gt;&gt; responses.raise_for_status()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/Users/carl/dev/github/scrapli/scrapli/response.py\", line 270, in raise_for_status\n    raise ScrapliCommandFailure()\nscrapli.exceptions.ScrapliCommandFailure\n</code></pre>"},{"location":"user_guide/basic_usage/","title":"Basic Usage","text":""},{"location":"user_guide/basic_usage/#picking-the-right-driver","title":"Picking the right Driver","text":"<p>Assuming you are using scrapli to connect to one of the five \"core\" platforms, you should almost always use the  provided corresponding \"core\" driver. For example if you are connecting to an Arista EOS device, you should use the   <code>EOSDriver</code>. You can select this driver \"manually\" or using the scrapli factory <code>Scrapli</code> (or the async scrapli    factory <code>AsyncScrapli</code>).</p> <p>Importing your driver manually looks like this:</p> <pre><code>from scrapli.driver.core import EOSDriver\n</code></pre> <p>If you are using asyncio, you can use the async variant of the driver:</p> <pre><code>from scrapli.driver.core import AsyncEOSDriver\n</code></pre> <p>The core drivers and associated platforms are outlined below:</p> Platform/OS Scrapli Driver Scrapli Async Driver Platform Name Cisco IOS-XE IOSXEDriver AsyncIOSXEDriver cisco_iosxe Cisco NX-OS NXOSDriver AsyncNXOSDriver cisco_nxos Cisco IOS-XR IOSXRDriver AsyncIOSXRDriver cisco_iosxr Arista EOS EOSDriver AsyncEOSDriver arista_eos Juniper JunOS JunosDriver AsyncJunosDriver juniper_junos <p>All drivers can be imported from <code>scrapli.driver.core</code>.</p> <p>If you would rather use the factory class to dynamically select the appropriate driver based on a platform string (as  seen in the above table), you can do so as follows:</p> <pre><code>from scrapli import Scrapli\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"scrapli\",\n   \"auth_password\": \"scrapli\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\n\nconn = Scrapli(**device)\nconn.open()\nprint(conn.get_prompt())\n</code></pre> <p>Note that the <code>Scrapli</code> and <code>AsyncScrapli</code> classes inherit from the <code>NetworkDriver</code> and <code>AsyncNetworkDriver</code> classes  respectively, so all editor code completion and type indicating behavior should work nicely! For non \"core  \" platforms please see the scrapli_community project.</p> <p>If you are working with a platform not listed above (and/or is not in the scrapli community project), you have three  options: </p> <ol> <li>You can use the (base)<code>Driver</code> driver directly, which you can read about here</li> <li>You can use the <code>GenericDriver</code> which you can read about here</li> <li>You can use the <code>NetworkDriver</code> which is similar to option 2 but you will need to understand/provide privilege /prompt information so scrapli can properly escalate/deescalate to/from configuration (or other) modes.</li> </ol> <p>In general you should probably simply create a scrapli community platform (read about adding a platform  here, but failing that the <code>GenericDriver</code> is   probably the simplest path forward.</p> <p>Note: if you are using async you must set the transport to <code>asyncssh</code> or <code>asynctelnet</code>!</p>"},{"location":"user_guide/basic_usage/#basic-driver-arguments","title":"Basic Driver Arguments","text":"<p>The drivers of course need some information about the device you are trying to connect to. The most common arguments  to provide to the driver are outlined below:</p> Argument Purpose/Value host name/ip of host to connect to port port of host to connect to (defaults to port 22) auth_username username for authentication auth_password password for authentication auth_secondary password for secondary authentication (enable password) auth_private_key private key for authentication auth_strict_key strict key checking -- TRUE by default! ssh_config_file True/False or path to ssh config file to use <p>These arguments may be passed as keyword arguments to the driver of your choice, or, commonly are passed via  dictionary unpacking as show below:</p> <pre><code>from scrapli.driver.core import IOSXRDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXRDriver(**my_device)\nconn.open()\n</code></pre> <p>NOTE that scrapli enables strict host key checking by default!</p>"},{"location":"user_guide/basic_usage/#opening-and-closing-a-connection","title":"Opening and Closing a Connection","text":"<p>scrapli does not open the connection for you when creating your scrapli connection object in normal operations, you  must manually call the <code>open</code> method prior to sending any commands to the device as shown below.</p> <pre><code>from scrapli.driver.core import IOSXRDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXRDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show version\")\n</code></pre> <p>Connections can be closed by calling the <code>close</code> method:</p> <pre><code>conn.close()\n</code></pre> <p>scrapli also supports using a context manager (<code>with</code> block), when using the context manager the connection will be  automatically opened and closed for you. </p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n</code></pre>"},{"location":"user_guide/basic_usage/#sending-commands","title":"Sending Commands","text":"<p>When using any of the core network drivers (<code>JunosDriver</code>, <code>EOSDriver</code>, etc.) or the <code>GenericDriver</code>, the <code>send_command</code> and <code>send_commands</code> methods will respectively send a single command or list of commands to the device.</p> <p>When using the core network drivers, the command(s) will be sent at the <code>default_desired_privilege_level</code> level which is  typically \"privilege exec\" (or equivalent) privilege level. Please see Driver Privilege Levels   in the advanced usage section for more details on privilege levels. As the <code>GenericDriver</code> doesn't know or   care about privilege levels you would need to manually handle acquiring the appropriate privilege level for you    command yourself if using that driver.</p> <p>Note the different methods for sending a single command versus a list of commands!</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXEDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show version\")\nresponses = conn.send_commands([\"show run\", \"show ip int brief\"])\n</code></pre> <p>Finally, if you prefer to have a file containing a list of commands to send, there is a <code>send_commands_from_file</code> method . This method excepts the provided file to have a single command to send per line in the file.</p>"},{"location":"user_guide/basic_usage/#response-object","title":"Response Object","text":"<p>All command/config operations that happen in the <code>GenericDriver</code> or any of the drivers inheriting from the  <code>NetworkDriver</code> result in a <code>Response</code> object being created. The <code>Response</code> object contains attributes for the   command sent (<code>channel_input</code>), start/end/elapsed time, and of course the result of the command sent.</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXEDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show version\")\nprint(response.elapsed_time)\nprint(response.result)\n</code></pre> <p>If using <code>send_commands</code> (plural!) then scrapli will return a <code>MultiResponse</code> object containing multiple <code>Response</code>  objects. The <code>MultiResponse</code> object is for all intents and purposes just a list of <code>Response</code> objects (with a few   very minor differences).</p> <p>In addition to containing the input and output of the command(s) that you sent, the <code>Response</code> object also contains a  method <code>textfsm_parse_output</code> (for more on TextFSM support see  Textfsm/NTC-Templates Integration) which will attempt to parse and return the   received output. If parsing fails, the value returned will be an empty list -- meaning you will always get    \"structured data\" returned, however it will just be an empty object if parsing fails.</p> <pre><code>&gt;&gt;&gt; structured_result = response.textfsm_parse_output()\n&gt;&gt;&gt; print(structured_result)\n[['16.4.1', 'IOS-XE', 'csr1000v', '2 days, 22 hours, 10 minutes', 'reload', 'packages.conf', ['CSR1000V'], ['9FKLJWM5EB0'], '0x2102', []]]\n</code></pre>"},{"location":"user_guide/basic_usage/#sending-configurations","title":"Sending Configurations","text":"<p>When using any of the core drivers, you can send configurations via the <code>send_config</code>, <code>send_configs</code> or  <code>send_configs_from_file</code> methods which will handle privilege escalation for you. <code>send_config</code> accepts a single   string, <code>send_configs</code> accepts a list of strings, and of course <code>send_configs_from_file</code> accepts a string path to a    file containing configurations to send. Note that <code>send_configs_from_file</code> -- just like with it's commands sibling     -- will treat each line in the file as a configuration element, in this way it behaves much like <code>send_configs</code>.</p> <p>Lastly, it is good to know that <code>send_config</code> (singular!) will parse the configuration string provided and split it  into lines -- this means that the underlying behavior is the same as <code>send_configs</code>, however this method returns a   single <code>Response</code> object. This <code>send_config</code> method can be used to send entire configurations to devices in a    reliable fashion.</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    conn.send_configs([\"interface loopback123\", \"description configured by scrapli\"])\n</code></pre> <p>If you need to get into any kind of \"special\" configuration mode, such as \"configure exclusive\", \"configure private \", or \"configure session XYZ\", you can pass the name of the corresponding privilege level via the <code>privilege_level</code> argument. Please see the Driver Privilege Levels section for more details!</p> <p>Lastly, note that scrapli does not exit configuration mode at completion of a \"configuration\" event -- this is  because scrapli (with the Network drivers) will automatically acquire <code>default_desired_privilege_level</code> before   sending a \"command\" -- so there is no need, from a scrapli perspective, to explicitly exit config mode at end of    the configuration session.</p>"},{"location":"user_guide/basic_usage/#textfsmntc-templates-integration","title":"Textfsm/NTC-Templates Integration","text":"<p>scrapli supports parsing output with TextFSM and ntc-templates. This of course requires installing TextFSM and having  ntc-templates somewhere on your system. When using a platform driver (i.e. <code>IOSXEDriver</code>) the textfsm-platform will be  set for you (based on the driver device type). If you wish to parse the output of your send commands, you can use the   <code>textfsm_parse_output</code> method of the response object. This method will attempt to find the template for you    -- based on the textfsm-platform and the channel-input (the command sent). If textfsm parsing succeeds, the     structured result is returned. If textfsm parsing fails, an empty list is returned.</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n    structured_result = response.textfsm_parse_output()\n    print(structured_result)\n</code></pre> <p>scrapli also supports passing in templates manually (meaning not using the pip installed ntc-templates directory to  find templates) if desired. The <code>textfsm_parse_output</code> method and <code>scrapli.helper.textfsm_parse</code> function both accepts a string or loaded (TextIOWrapper  ) template and output to parse. This can be useful if you have custom or one off templates or don't want to pip   install ntc-templates.</p> <pre><code>from scrapli.driver.core import IOSXEDriver\nfrom scrapli.helper import textfsm_parse\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n    structured_result = textfsm_parse(\"/path/to/my/template\", response.result)\n</code></pre> <p>NOTE: If a template does not return structured data an empty list will be returned!</p> <p>NOTE: Textfsm and ntc-templates is an optional extra for scrapli; you can install these modules manually or using  the optional extras install via pip:</p> <p><code>pip install scrapli[textfsm]</code></p>"},{"location":"user_guide/basic_usage/#cisco-genie-integration","title":"Cisco Genie Integration","text":"<p>Very much the same as the textfsm/ntc-templates integration, scrapli has optional integration with Cisco's PyATS /Genie parsing library for parsing show command output. While there are parsers for non-Cisco platforms, this is  currently just an option for Cisco platforms within scrapli.</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n    structured_result = response.genie_parse_output()\n    print(structured_result)\n</code></pre> <p>NOTE: If a parser does not return structured data an empty list will be returned!</p> <p>NOTE: PyATS and Genie is an optional extra for scrapli; you can install these modules manually or using  the optional extras install via pip:</p> <p><code>pip install scrapli[genie]</code></p>"},{"location":"user_guide/basic_usage/#ttp-integration","title":"TTP Integration","text":"<p>The scrapli response object also contains a <code>ttp_parse_output</code> method, that, as you may have guessed, uses the   ttp library to parse output received from the device. Other than the obvious   difference that this is in fact a different type of parser, the only difference from a usage perspective is that    the <code>ttp_parse_output</code> method requires a template string, string path to a template, or loaded (TextIOWrapper    ) template string to be passed. This is because there is no index or mapping of platform:command:template as there     is with TextFSM/ntc-templates and genie.</p> <p>An example ttp file (slightly modified from the great ttp quickstart guide) - in this case we'll pretend this file is  called \"my_template.ttp\":</p> <pre><code>interface {{ interface }}\n ip address {{ ip }} {{ mask }}\n description {{ description }}\n</code></pre> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show run interface GigabitEthernet1\")\n    structured_result = response.ttp_parse_output(template=\"my_template.ttp\")\n    print(structured_result)\n</code></pre> <p>NOTE: If a parser does parse data, ttp will return an empty list (as with the other parser methods)</p> <p>NOTE: ttp is an optional extra for scrapli; you can install these modules manually or using the optional extras  install via pip:</p> <p><code>pip install scrapli[ttp]</code></p>"},{"location":"user_guide/basic_usage/#handling-prompts","title":"Handling Prompts","text":"<p>In some cases you may need to run an \"interactive\" command on your device. The <code>send_interactive</code> method of the  <code>GenericDriver</code> or its sub-classes (<code>NetworkDriver</code> and \"core\" drivers) can be used to accomplish this. This method   accepts a list of \"interact_events\" -- or basically commands you would like to send, and their expected resulting    prompt. A third, optional, element is available for each \"interaction\", this last element is a bool that indicates     weather or not the input that you are sending to the device is \"hidden\" or obfuscated by the device. This is      typically used for password prompts where the input that is sent does not show up on the screen (if you as a       human are sitting on a terminal typing).</p> <p>This method can accept one or N \"events\" and thus can be used to deal with any number of subsequent prompts. </p> <p>One last important item about this method is that it accepts an argument <code>privilege_level</code> -- the value of this  argument should be the name of the privilege level that you would like to execute the interactive command at  . This is an optional argument, with a default of the <code>default_desired_privilege_level</code> attribute which is normally   \"privilege exec\" or similar depending on the platform. </p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    interactive = conn.send_interactive(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"somefile.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"scrapli\", \"Password:\", False),\n            (\"super_secure_password\", \"csr1000v#\", True),\n        ]\n    )\n</code></pre>"},{"location":"user_guide/basic_usage/#telnet","title":"Telnet","text":"<p>scrapli supports telnet as a transport driver via the standard library module <code>telnetlib</code> or with a custom-built  async telnet transport (creatively called \"asynctelnet\") built on the standard library <code>asycnio</code>.</p> <p>A few things worth noting:</p> <ul> <li> <p>You can set the username and password prompt expect string after your connection object instantiation  and before calling the <code>open</code> method -- this means if you have non-default prompts you cannot use scrapli with a   context manager and Telnet (because the context manager calls open for you). You can set the prompts using the    following attributes of the <code>Channel</code> (or <code>AsyncChannel</code>) object:</p> <ul> <li><code>telnet_username_prompt</code> which defaults to <code>^(.*username:)|(.*login:)\\s?$</code></li> <li><code>telnet_password_prompt</code> which defaults to <code>^password:\\s?$</code></li> </ul> <p>You can set these values by updating the appropriate attribute, for example: <code>conn.channel.telnet_username_prompt = \"somethingneat\"</code>. </p> </li> <li> <p>If you wish to provide custom prompt values you can provide a string to look for \"in\" the output from the device,    or a regular expression pattern that starts with <code>^</code> and ends with <code>$</code> -- if you don't use the line anchors the      pattern will be <code>re.escape</code>'d.</p> </li> <li>When using telnet you may need to set the <code>comms_return_char</code> to <code>\\r\\n</code> the tests against the core platforms pass  without this, however it seems that some console server type devices are looking for this <code>\\r\\n</code> pattern instead of   the default <code>\\n</code> pattern.</li> </ul>"},{"location":"user_guide/basic_usage/#ssh-config-support","title":"SSH Config Support","text":"<p>scrapli supports using OpenSSH configuration files in a few ways. For \"system\" SSH transport (default setting ), passing a path to a config file will simply make scrapli \"point\" to that file, and therefore use that  configuration files attributes (because it is just exec'ing system SSH!). You can also pass <code>True</code> to let  scrapli search in system default locations for a ssh config file (<code>~/.ssh/config</code> and <code>/etc/ssh/ssh_config</code>).</p> <p>SSH transports other than \"system\" transport may support some subset of the OpenSSH configuration files, but will  not provide full support. Asyncssh, for example, will automatically pick up and handle proxy-jumps, SSH keys, and  some other items -- this is a 100% asyncssh feature and has nothing to do with scrapli (other than the fact that  scrapli allows you to use asyncssh).</p> <p>NOTE -- scrapli does NOT disable strict host checking by default. Obviously this is the \"smart\" behavior, but it  can be overridden on a per host basis in your SSH config file, or by passing <code>False</code> to the \"auth_strict_key  \" argument on object instantiation.</p> <pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n    \"ssh_config_file\": \"~/my_ssh_config\",\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n</code></pre>"},{"location":"user_guide/faq/","title":"FAQ","text":"<ul> <li>Question: Why build this?<ul> <li>Answer: I built <code>ssh2net</code> to learn -- to have a goal/target for writing some code. scrapli is an evolution of the    lessons learned building ssh2net. About mid-way through building <code>ssh2net</code> I realized it may actually be kinda good at doing... stuff. So, sure there are other tools out there, but I think scrapli its pretty snazzy and fills in some  of the gaps in other tools. For example scrapli is 100% compliant with strict mypy type checking, very uniformly   documented/linted, contains a results object for every operation, is very very fast, is very flexible, and in    general pretty awesome! Finally, while I think in general that SSH \"screen scraping\" is not \"sexy\" or even     \"good\", it is the lowest common denominator for automation in the networking world. So I figured I could try      to make the fastest, most flexible library around for SSH network automation! </li> </ul> </li> <li>Question: Is this better than XYZ?<ul> <li>Answer: Nope! It is different though! The main focus is just to be stupid fast. It is very much that. It   should be   super reliable too as the timeouts are very easy/obvious to control, and it should also be very very very easy to    adapt to any other network-y type CLI by virtue of flexible prompt finding and easily modifiable on connect functions.</li> </ul> </li> <li>I wanna go fast!<ul> <li>Hmmm... not a question but I dig it. If you wanna go fast you gotta learn to drive with the fear... ok, enough    Talladega Nights quoting for now. In theory using the <code>ssh2</code> transport is the gateway to speed... being a very thin wrapper around libssh2 means that its basically all C and that means its probably about as fast as we're  reasonably going to get. All that said, scrapli by default uses the <code>system</code> transport which is really just   using your system ssh.... which is almost certainly libssh2/openssh which is also C. There is a thin layer of    abstraction between scrapli and your system ssh but really its just reading/writing to a file which Python     should be doing in C anyway I would think. In summary... while <code>ssh2</code> is probably the fastest you can go with      scrapli, the difference between <code>ssh2</code> and <code>system</code> transports in limited testing is very small, and the       benefits of using system transport (native ssh config file support!!) probably should outweigh the speed of        ssh2 -- especially if you have control persist and can take advantage of that with system transport!</li> </ul> </li> <li>Hey does this thing do SCP?<ul> <li>Nope! But the very cool @viktorkertesz has created scrapli_scp    which you should defo check out if you wanna do SCP things!</li> </ul> </li> <li>Other questions? Ask away!</li> </ul>"},{"location":"user_guide/installation/","title":"Installation","text":""},{"location":"user_guide/installation/#standard-installation","title":"Standard Installation","text":"<p>As outlined in the quick start, you should be able to pip install scrapli \"normally\":</p> <pre><code>pip install scrapli\n</code></pre>"},{"location":"user_guide/installation/#installing-current-main-branch","title":"Installing current main branch","text":"<p>To install from the source repositories master branch:</p> <pre><code>pip install git+https://github.com/carlmontanari/scrapli\n</code></pre>"},{"location":"user_guide/installation/#installing-a-different-branch","title":"Installing a different branch","text":"<p>To install from a different branch of the source repository, for example from a branch named <code>develop</code>:</p> <pre><code>pip install -e git+https://github.com/carlmontanari/scrapli.git@develop#egg=scrapli\n</code></pre>"},{"location":"user_guide/installation/#installation-from-source","title":"Installation from Source","text":"<p>To install from source:</p> <pre><code>git clone https://github.com/carlmontanari/scrapli\ncd scrapli\npython setup.py install\n</code></pre>"},{"location":"user_guide/installation/#optional-extras","title":"Optional Extras","text":"<p>scrapli has made an effort to have as few dependencies as possible -- in fact to have ZERO dependencies! The \"core\" of  scrapli can run with nothing other than standard library! If for any reason you wish to use paramiko, ssh2-python,  or asyncssh as a transport, however, you of course need to install those. These \"extras\" can be installed via pip:</p> <pre><code>pip install scrapli[paramiko]\n</code></pre> <p>The available optional installation extras options are:</p> <ul> <li>paramiko</li> <li>ssh2</li> <li>asyncssh  </li> <li>textfsm (textfsm and ntc-templates)</li> <li>ttp (ttp template parser)  </li> <li>genie (genie/pyats)</li> <li>netconf (scrapli_netconf)</li> <li>community (scrapli_community)</li> </ul> <p>If you would like to install all optional extras, you can do so with the <code>full</code> option:</p> <pre><code>pip install scrapli[full]\n</code></pre>"},{"location":"user_guide/installation/#supported-platforms","title":"Supported Platforms","text":"<p>As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any  POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no   longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or    ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks     to use WSL/Cygwin instead of Windows.</p>"},{"location":"user_guide/linting_testing/","title":"Linting and Testing","text":""},{"location":"user_guide/linting_testing/#linting","title":"Linting","text":"<p>This project uses black for auto-formatting. In addition to black, nox will execute  pylama, and pydocstyle for linting purposes  . Nox will also run  mypy, with strict type checking. Docstring linting is   handled by darglint which has been quite handy!</p> <p>All commits to this repository will trigger a GitHub action which runs nox, but of course its nicer to just run that  before making a commit to ensure that it will pass all tests!</p>"},{"location":"user_guide/linting_testing/#typing","title":"Typing","text":"<p>As stated, this project is 100% type checked and will remain that way. The value this adds for IDE auto-completion  and just general sanity checking/forcing writing of more type-check-able code is worth the small overhead in effort.</p>"},{"location":"user_guide/linting_testing/#testing","title":"Testing","text":"<p>Testing is broken into three main categories -- unit, integration, and functional.</p> <p>Unit is what you would expect -- unit testing the code. </p> <p>Integration tests run scrapli against auto generated ssh server that looks/feels like real network devices.</p> <p>Functional testing connects to virtual devices in order to more accurately test the code. </p> <p>Unit tests cover quite a bit of the code base due to lots of patching low level things to ensure code paths go where  they should go. This gives a pretty high level of confidence that at least object instantiation and channel  read/writes will generally work! </p> <p>Functional tests against virtual devices provide a much higher guarantee of things working as they should, and are  reproducible by end users to boot!</p>"},{"location":"user_guide/linting_testing/#unit-tests","title":"Unit Tests","text":"<p>Unit tests can be executed via pytest:</p> <pre><code>python -m pytest tests/unit/\n</code></pre> <p>Or using the following make command:</p> <pre><code>make test_unit\n</code></pre> <p>If you would like to see the coverage report and generate the html coverage report:</p> <pre><code>make cov_unit\n</code></pre>"},{"location":"user_guide/linting_testing/#setting-up-functional-test-environment","title":"Setting up Functional Test Environment","text":"<p>In order to try to be as consistent as possible when running functional testing, we rely on the very awesome  containerlab project. Containerlab allows us to have a reliable and  consistent testing environment and spin it up easily on any linux host (with nested virtualization capabilities).</p> <p>You can see the containerlab topology file in the <code>.clab</code> directory at the root of scrapli. The topology file in  this directory outlines the container images that containerlab requires in order to spin up the topology.  Unfortunately, networking vendors suck at giving us free and easy access to container images for testing (notable  exception of Nokia and SR-Linux, so shout out to them!), so you are going to need to bring your own images to use.</p> <p>For the Arista EOS platform, you can simply create an account on the Arista website and download the cEOS container  image and import it into docker. The other platforms all require you to obtain a Qcow2 disk image of the platform,  and to use the boxen project to convert the disk image into a container  image that containerlab can launch. The containerlab topology file indicates the version of the platforms the  testing suite expects -- other versions may be fine, but try to stick to the versions here if you can so tests run  exactly as expected! Once you have the Qcow files in hand, you can use boxen to build the container image -- please  check out the boxen docs for how to do this.</p> <p>If you elect to run tests with boxen only (in \"local\" mode -- not described here, but should be straight forward  enough) and not use containerlab - set the <code>SCRAPLI_HOST_FWD</code> environment variable to some non-empty string; this  will force scrapli to connect to localhost on the ports described below rather than the clab specified (bridged) IP  addresses:</p> Device Local Port iosxe 21022 iosxr 22022 nxos 23022 eos 24022 junos 25022"},{"location":"user_guide/linting_testing/#deployingdestroying-containerlab-test-environment","title":"Deploying/Destroying Containerlab Test Environment","text":"<p>Once you have created the images, you can start containerlab with a make command:</p> <pre><code>make deploy_clab\n</code></pre> <p>Conversely, you can terminate the containers:</p> <pre><code>make destroy_clab\n</code></pre>"},{"location":"user_guide/linting_testing/#ensuring-base-test-configs","title":"Ensuring Base Test Configs","text":"<p>To ensure that the base test configs are enforced, run the <code>prepare_dev_env</code> make directive, this uses scrapli-cfg  to load and replace the configurations running on these devices. This will do things like ensure telnet is enabled  (which is not the case by default for most platforms in clab/boxen), etc..</p>"},{"location":"user_guide/linting_testing/#running-functional-tests","title":"Running Functional Tests","text":"<p>To run functional tests you can simply use the make directive:</p> <p><code>make test_functional</code></p> <p>If you are adding tests and/or need to \"regenerate\" the expected output, you can use the <code>--update</code> flag like:</p> <p><code>python -m pytest tests/functional --update</code></p> <p>This flag causes the test suite to capture the output and write it into the expected directory. This expected output  is then compared to the \"real\" output we get from the device during subsequent tests.</p>"},{"location":"user_guide/linting_testing/#other-functional-test-info","title":"Other Functional Test Info","text":"<p>IOSXE is the only platform that is testing SSH key based authentication at the moment. The key is pushed via NAPALM in  the setup phase. This was mostly done out of laziness, and in the future the other platforms may be tested with key   based auth as well, but for now IOSXE is representative enough to provide some faith that key based auth works! </p>"},{"location":"user_guide/project_details/","title":"Project Details","text":""},{"location":"user_guide/project_details/#what-is-scrapli","title":"What is scrapli","text":"<p>scrapli is a python library focused on connecting to devices, specifically network devices via Telnet, SSH or NETCONF.</p> <p>scrapli is built primarily in three parts: transport, channel, and driver. The transport layer is responsible for  providing a file-like interface to the target server. The channel layer is responsible for reading and writing   to the provided file-like interface. Finally, the driver provides the user facing API/interface to scrapli.</p> <p>There are six available \"transports\" in scrapli \"core\" -- all of which inherit from a base transport classes  and provide the same file-like interface to the upstream channel.</p>"},{"location":"user_guide/project_details/#transports","title":"Transports","text":"<p>The available transport plugins are:</p> <ul> <li><code>system</code> -- wrapper around OpenSSH/System available SSH binary</li> <li><code>telnet</code> -- Python standard library telnetlib</li> <li><code>asynctelnet</code> -- Python standard library asyncio stream</li> <li><code>asyncssh</code> -- wrapper around asyncssh library</li> <li><code>ssh2</code> -- wrapper around ssh2-python library</li> <li><code>paramiko</code> -- wrapper around paramiko library</li> </ul> <p>A good question to ask at this point is probably \"why?\". Why multiple transport options? Why not just use paramiko  like most folks do? Historically the reason for moving away from paramiko was simply speed. ssh2-python is a wrapper   around the libssh2 C library, and as such is very, very fast. In a prior project    (ssh2net), of which scrapli is the successor/evolution, ssh2-python     was used with great success, however, it is a bit feature-limited, and development had stalled around the same      time scrapli was getting going.</p> <p>This led to moving back to paramiko, which of course is a fantastic project with tons and tons of feature support . Paramiko, however, does not provide \"direct\" OpenSSH support (as in -- auto-magically like when you ssh on your  normal shell), and I don't believe it provides 100% full OpenSSH support either (ex: ControlPersist). Fully   supporting an OpenSSH config file would be an ideal end goal for scrapli, something that may not be possible with    Paramiko - ControlPersist in particular is very interesting to me.</p> <p>With the goal of supporting all OpenSSH configuration options the primary transport driver option is simply  native system local SSH. The implementation of using system SSH is of course a little bit messy, however scrapli   takes care of that for you so you don't need to care about it! The payoff of using system SSH is of course that    OpenSSH config files simply \"work\" -- no passing it to scrapli, no selective support, no need to set username or     ports or any of the other config items that may reside in your SSH config file. This driver will likely be the      focus of most development for this project, though I will try to keep the other transport drivers -- in       particular asyncssh -- as close to parity as is possible/practical.</p> <p>Adding telnet support via telnetlib was trivial, as the interface is basically the same as SystemSSH, and it turns out  telnet is still actually useful for things like terminal servers and the like!</p> <p>Next, perhaps the most interesting scrapli transport plugin is the <code>asyncssh</code> transport. This transport option  represented a very big change for scrapli as the entire \"backend\" was basically re-worked in order to provide the  exact same API for both synchronous and asynchronous applications.</p> <p>Lastly, the <code>asynctelnet</code> transport is the latest (and perhaps last?!) transport plugin. This transport plugin was  built with only the python standard library (just like system/telnet) and as such it is part of scrapli \"core\".</p>"},{"location":"user_guide/project_details/#channel","title":"Channel","text":"<p>The \"channel\" sits between the transports and the drivers -- the channel is where much of the magic happens! The  channel is responsible for all prompt finding, sending commands or configs, and generally interacting with the  device. The channel essentially reads from and writes to the underlying transport for a given connection. The  Channel doesn't need to know or care about which transport you pick! (except of course to know if it is async or  synchronous)</p>"},{"location":"user_guide/project_details/#drivers","title":"Drivers","text":"<p>The final piece of scrapli is the actual \"driver\" -- or the component that binds the transport and channel together and  deals with instantiation of a scrapli object. There is a \"base\" driver object -- <code>Driver</code> -- which provides essentially   a \"raw\" SSH (or telnet) connection that is created by instantiating a Transport object, and a Channel object   . <code>Drive</code> provides (via Channel) read/write methods and not much else -- this should feel familiar if you have    used paramiko in the past. More specific \"drivers\" can inherit from this class to extend functionality of the     driver to make it more friendly for network devices. In fact, there is a <code>GenericDriver</code> class that inherits from      <code>Scrape</code> and provides a base driver to work with if you need to interact with a device not represented by one of       the \"core\" drivers. Next, the <code>NetworkDriver</code> class inherits from <code>GenericDriver</code>. The <code>NetworkDriver</code> isn't        really meant to be used directly though, but to be further extended and built upon instead. As this library is         focused on interacting with network devices, an example scrapli driver (built on the <code>NetworkDriver</code>) would          be the <code>IOSXEDriver</code> -- to, as you may have guessed , interact with devices running Cisco's IOS-XE operating           system.</p> <p>It should be noted that this is a bit of an oversimplification of the architecture of scrapli, but it is accurate . Scrapli has \"base\", \"sync\", and \"async\" versions of the core components. The \"base\" portion is made up of mixin  classes that get \"mixed in\" to the sync or async versions of the component. For example there is a   <code>NetworkDriverBase</code> class that is \"mixed in\" to the <code>NetworkDriver</code> and <code>AsyncNetworkDriver</code> classes. The mixin    provides consistent helper like functions (sync functions) that can be used by the two driver classes -- this     allows the sync/async components to have as little code as possible helping to keep the API consistent for both      synchronous and asynchronous users.</p>"},{"location":"user_guide/project_details/#supported-platforms","title":"Supported Platforms","text":"<p>scrapli \"core\" drivers cover basically the NAPALM platforms -- Cisco  IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS. These drivers provide an interface tailored to network device   \"screen-scraping\" rather than just a generic SSH connection/channel. It is important to note that there is a    synchronous and an asynchronous version of each of these drivers. Below are the core driver platforms and    regularly tested version.</p> <ul> <li>Cisco IOS-XE (tested on: 16.12.03)</li> <li>Cisco NX-OS (tested on: 9.2.4)</li> <li>Juniper JunOS (tested on: 17.3R2.10)</li> <li>Cisco IOS-XR (tested on: 6.5.3)</li> <li>Arista EOS (tested on: 4.22.1F)</li> </ul> <p>It is unlikely that any additional \"core\" platforms would be added, however the <code>scrapli_community</code> project is  available for users to contribute any other platforms they would like to see scrapli support! Please see the   scrapli_community project to check out what community platforms exist!</p> <p>The \"driver\" pattern is pretty much exactly like the implementation in NAPALM. The driver extends the base class  (<code>Scrape</code>) and the base networking driver class (<code>NetworkDriver</code>) with device specific functionality such as privilege   escalation/de-escalation, setting appropriate prompts to search for, and picking out appropriate   ntc templates for use with TextFSM, and so on.</p> <p>All of this is focused on network device type Telnet/SSH cli interfaces, but should work on pretty much any SSH  connection (though there are almost certainly better options for non-network type devices!). The \"base\" (<code>Driver</code>)   and <code>GenericDriver</code> connections do not handle any kind of device-specific operations such as privilege   escalation or saving configurations, they are simply intended to be a bare-bones connection that can interact with    nearly any device/platform if you are willing to send/parse inputs/outputs manually. In most cases it is assumed     that users will use one of the \"core\" drivers.</p> <p>The goal for all \"core\" devices will be to include functional tests that can run against vrnetlab containers to ensure that the \"core\" devices are as thoroughly tested  as is practical.</p>"},{"location":"user_guide/project_details/#related-scrapli-libraries","title":"Related Scrapli Libraries","text":"<p>This repo is the \"main\" or \"core\" scrapli project, however there are other libraries/repos in the scrapli family  -- here is a list/link to all of the other scrapli things!</p> <ul> <li>nornir_scrapli</li> <li>scrapli_community</li> <li>scrapli_cfg</li> <li>scrapli_replay</li> <li>scrapli_netconf</li> </ul>"},{"location":"user_guide/quickstart/","title":"Quick Start Guide","text":""},{"location":"user_guide/quickstart/#installation","title":"Installation","text":"<p>In most cases installation via pip is the simplest and best way to install scrapli. See here for advanced installation details.</p> <pre><code>pip install scrapli\n</code></pre>"},{"location":"user_guide/quickstart/#a-simple-example","title":"A Simple Example","text":"<pre><code>from scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"scrapli\",\n    \"auth_password\": \"scrapli\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXEDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show run\")\nprint(response.result)\n</code></pre> <pre><code>$ python my_scrapli_script.py\nBuilding configuration...\n\nCurrent configuration : 7584 bytes\n!\n! Last configuration change at 19:24:38 PST Sat Feb 29 2020 by carl\n! NVRAM config last updated at 19:00:28 PST Fri Feb 7 2020 by carl\n!\nversion 15.2\nservice nagle\nno service pad\nservice tcp-keepalives-in\nservice tcp-keepalives-out\nservice timestamps debug datetime msec\nno service password-encryption\n!\n&lt;SNIP&gt;\n!\nend\n</code></pre>"},{"location":"user_guide/quickstart/#more-examples","title":"More Examples","text":"<ul> <li>Basic \"native\" Scrape operations</li> <li>Basic \"GenericDriver\" operations</li> <li>Basic \"core\" Driver operations</li> <li>Basic async operations</li> <li>Async multiple connections</li> <li>Setting up basic logging</li> <li>Using SSH Key for authentication</li> <li>Using SSH config file</li> <li>Parse output with TextFSM/ntc-templates</li> <li>Parse output with Genie</li> <li>Transport Options</li> <li>Configuration Modes - IOSXR Configure Exclusive</li> <li>Configuration Modes - EOS Configure Session</li> <li>Banners, Macros, and other \"weird\" Things</li> </ul>"},{"location":"user_guide/quickstart/#other-stuff","title":"Other Stuff","text":"<p>Other scrapli related docs/blogs/videos/info:</p> <ul> <li>Scrapli on Dmitry Figol's Network Automation Channel</li> <li>Scrapli Intro on Wim Wauter's blog</li> <li>Scrapli on the Packet Pushers Heavy Networking Podcast</li> <li>IPvZero's Network Automation Course (including scrapli!) on CBT Nuggets (paid resource)</li> <li>Rick Donato's Scrapli Course (paid resource)</li> </ul>"},{"location":"user_guide/versioning/","title":"Versioning","text":"<p>scrapli, and all scrapli related projects use CalVer versioning standard. All release versions  follow the format <code>YYYY.MM.DD</code>, however PyPi will shorten/standardize this to remove leading zeros.</p> <p>The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are  clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the   concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has    been very stable -- there are only so many things you can/need to do over SSH after all!</p> <p>Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch  while updates are happening), and the \"public\" API is documented here, and includes the  date/version of each public method's creation as well as the latest updated/modified date and any relevant notes.</p> <p>A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very  stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs   -- you can \"watch\" this repository to ensure you are notified of any releases.</p>"}]}