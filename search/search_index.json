{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"scrapli \u00b6 scrapli -- scrap(e c)li -- is a python library focused on connecting to devices, specifically network devices (routers/switches/firewalls/etc.) via SSH or Telnet. The name scrapli -- is just \"scrape cli\" (as in screen scrape) squished together! scrapli's goal is to be as fast and flexible as possible, while providing a thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Feel free to join the very awesome networktocode slack workspace here , where you will find a scrapli channel where you can discuss anything about scrapli, as well as tons of other channels covering all sorts of network/network-automation topics!","title":"Scrapli"},{"location":"#scrapli","text":"scrapli -- scrap(e c)li -- is a python library focused on connecting to devices, specifically network devices (routers/switches/firewalls/etc.) via SSH or Telnet. The name scrapli -- is just \"scrape cli\" (as in screen scrape) squished together! scrapli's goal is to be as fast and flexible as possible, while providing a thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Feel free to join the very awesome networktocode slack workspace here , where you will find a scrapli channel where you can discuss anything about scrapli, as well as tons of other channels covering all sorts of network/network-automation topics!","title":"scrapli"},{"location":"changelog/","text":"Changelog \u00b6 2022.07.30.post1 \u00b6 Big thanks once again to @haccht (and to @egreenspan2 for raising an issue on this as well) for fixing up some broken telnet control character handling, and for porting that to async side of things as well! 2022.07.30 \u00b6 Added MANIFEST.in to make sure requirements files are in source distribution see #216 Move weekly build to develop branch so weekly build doesn't fail for \"stale\" main branch reasons textfsm_parse now supports passing in a file or URL to load as the template file -- thank you to @haccht for this one -- see #215 Fixed some mypy/typing challenges around the scrapli \"factory\" context manager -- thank you to @erwinkinn for working on this With lots of help from @netixx tracked down some silliness with timeout decorators not behaving how they should -- check out #233 for details on this Overhauled the functional testing to align more closely with scrapligo and to remove all the old unnecessary dockerfile bits, replacing that completely with containerlab 2022.01.30.post1 \u00b6 Remove newline anchor in in-channel auth password pattern. Felt like a good/smart idea but Cisco in their infinite wisdom have some awful banner on IOL (CML/VIRL) things that doesn't end with a newline and too many people will hit that. Move decorators back to function style -- fixes possible timeout issues as seen in #233 Modified escalate_priv methods to check for password prompt and desired prompt patterns and the current prompt pattern. There was an issue in scrapligo/containerlab where a cEOS device would not let you auth past enable until it is done \"booting\" up, and scrapli would just simply timeout as it didn't expect to see the exec prompt again. Thanks to @hellt for helping track this one down! Replaced standard library telnetlib transport with custom telnet transport (still no external requirements) in very early preparation for telnetlib's deprecation. 2022.01.30 \u00b6 Removed deprecated comms_ansi argument Improved error handling/error message for insufficient permissions when opening ssh config/known hosts file (system transport) Added support for hashed entries in known hosts file thanks to @kangtastic work in #174 Improved \"in channel\" SSH and Telnet authentication handling; better consistency between sync and async, patterns are now compiled only if/when needed Added option to enable echo in PTYProcess (was originally removed from vendor'd code) -- should only be useful/necessary with netconf #165 Allow users to build their own open_cmd for system transport -- users can override this to do things like kubectl exec -it args args args or docker exec -it args args args to connect to containers in k8s/docker #166 Updated/fixed(?) Juniper shell patterns for \"normal\" and root shells #170 Support transport options being passed to asyncssh transport thanks to @cuong-nguyenduy work in #178 and #183 A handful of nice readability/simplicity improvements throughout the codebase thanks to @yezz123 in #188 Fix (add) missing kwarg for channel_log_mode in the driver layers \"above\" base driver Update NXOS config pattern to include \"+\" to not break when entering TACACS config mode Added support for encrypted SSH keys with ssh2 transport in #192 thanks to @shnurty Fix/improve in channel SSH auth password prompt pattern to match scrapligo (which handles user @host password: strings) Update ssh2-python requirements now that 3.10/Darwin release is available Better exception/exception message for auth failures escalating privilege (network drivers) Added a global Settings object -- for now only has an attribute for \"SUPPRESS_USER_WARNINGS\" to... suppress user warnings Added read_callback method to GenericDriver / AsyncGenericDriver -- basically this is a fancier version of send interactive that lets you assign callbacks to things that scrapli reads rather than having to follow prompts in a linear fashion. Dropped Python3.6 support as it is now EOL! Of course, scrapli probably still works just fine with 3.6 (if you install the old 3.6 requirements), but we won't test/support it anymore. Added enable_rsa2 setting to paramiko transport options -- basically 2.9.0+ paramiko enables rsa2 support by default which causes key auth to fail on the test network devices, so we disable that by default, but exposet his flag so users can enable it if desired! 2021.07.30 \u00b6 Added \"% Unavailable command\" to EOS failed_when_contains Moved core platform failed_when_contains to base to not have to duplicate them in sync and async platforms Add file_mode to the enable_basic_logging function, can now choose \"append\" or \"write\" for logfile Add channel_log_mode to the base driver arguments; you can now choose \"append\" or \"write\" for this as well! Improve reading until prompt methods; no longer use re.search on the entire received byte string, now only checks for prompt on the last N chars where N is governed by the base channel args comms_prompt_search_depth attribute.. . this fixes an issue where scrapli could be wayyyyyy slow for very very large outputs (like full tables show bgp) Fix bug (or just terrible initial idea!?) in asynctelnet that reset a timer back to a very small value that was used for testing; most people shouldn't have noticed an issue here, but if you had slow devices this could cause issues that \"looked\" like an authentication issue due to scrapli not having responded to all telnet control characters before punting to auth Added commandeer to driver object; this is used to \"commandeer\" an existing connection but treat it like the new connection object (prompt patterns, methods, etc.) -- generally this would be used for using GenericDriver to connect to a console server, then \"commandeering\" that connection and turning it into an IOSXR/IOSXE/etc. connection object so you have all the \"normal\" behavior of scrapli Add missing timeout on the asynctelnet open method Add py.typed to hopefully do typing more correctly :P BUGFIX: network drivers aborted configuration sessions if responses were failed even if the stop_on_failed arg was set to False; this has been fixed now so that sessions are only aborted if the response is failed and Improved typing for send_interactive Remove napalm dev requirement -- switch to scrapli-cfg for dev environment config management; something something eating dog food or whatever. Deprecate comms_ansi -- if there is an ANSI escape sequence we will now just strip it out automagically; this is not currently a breaking change, but will be -- there is a deprecation warning now and comms_ansi will be fully removed in the 2022.01.30 release (and pre-releases). Removed a sleep that was in the default on_open for IOSXR devices... this has been there a while and I think it was just a hold over from early early versions of scrapli that perhaps had a less robust in channel authentication handler. 1 second faster IOSXR for free! Yay! Fixed an issue with system transport where the transport would get closed twice causing an unhandled exception -- thank you to Alex Lardschneider for finding this! Added an example for the enable_basic_logging function as well as the commandeer method Improved priv level handling -- if you try to acquire \"parallel\" privileges (ex. configuration and configuration exclusive in IOSXR) previously we would say things worked, but we would just stay in configuration mode. This has been fixed (hopefully)! Move ansi escape pattern to compile globally, so it only compiles once (why it was never like that before... who knows) Simplify the collect bits for integration tests... this is still not used heavily but hopefully will be soon! Replace vrnetlab creds in examples with scrapli (felt confusing to have vrnetlab creds everywhere, plus functional testing is moving away from (but still supporting) vrnetlab test environment) Crank up the rows/cols for system transport -> 80 rows, 256 cols -- this to align with scrapligo and to make it less common that users need to modify these values. BUGFIX: fixed blocking read in async channel telnet authentication (thank you Dmitry Figol!) Added not_contains field to privilege levels... this will help greatly simplify the necessary regex patterns, as well as allow us to ditch look arounds which go does not support... step one to a standardized community platform that works with python -or- go! Simplified (at least a little... more would be good) patterns for privilege levels for core platforms. Added _generic_driver_mode to the NetworkDriver classes -- this is a private mode as it should probably be used cautiously -- the idea here is that you can send any strings you want and scrapli will not care about privilege levels at all. See the discussion about this here . BUGFIX: fixed asynctelnet issue with control character handling, thank you to @davaeron -- see #147 BREAKING CHANGE removed the transport.username_prompt and transport.password_prompt attributes of the telnet transports. All authentication has been moved into the channel, so it made no sense to leave these attributes on the transports. This may cause an issue for users that had explicitly set their prompts to something non-standard. Finally added logic to auto set port to 23 for telnet :) BUGFIX: fixed a rare issue where decoding bytes received from the channel (in the response object) would raise a UnicodedecodEerror ; we now catch this exception and decode with ISO-8859-1 encoding which seems to be much less picky about what it decodes. Thanks to Alex Lardschneider for yet another good catch and fix! Added interaction_complete_patterns to all \"interactive\" methods -- this argument accepts a list of strings/patterns; will be re-escape'd if each string does not start with and end with \"^\" and \"$\" (line anchors), otherwise will be compiled with the standard scrapli case-insensitive and multiline flags. If the interactive event finds any of these pattenrs during the course of the interacting it will terminate the interactive session. Note that this is entirely optional and is a keyword only argument so no changes are necessary to any existing scrapli programs. 2021.01.30 \u00b6 BREAKING CHANGE PrivilegeLevel import location changed -- this will break things! timeout_exit deprecated; will always close connection on timeout now All exceptions rationalized/changed -- all exceptions now rooted in ScrapliException and scrapli should not raise any exception that is not rooted in this! It is of course possible that non-scrapli exceptions will get raised at some point, but all \"common\" exceptions will now follow this pattern. Added opinionated logging option -- should be used only for debugging/testing, otherwise use your own logging setup! Moved \"in channel\" auth into channel (for telnet/system ssh authentication) Added channel_lock option, defaults to false Added channel_log option Decorators got reswizzled a little, no more requires open as the transports handle this. There is now a dedicated ChannelTimeout and TransportTimeout to keep things simpler. All transport plugins are now in scrapli \"core\" All (ok, most...) channel and transport args are now properties of the driver class -- this should remove confusion about where to update what timeout/value Response._record_response is now public but only for linting reasons, people generally should ignore this anyway! Python 3.6 will now require dataclasses backport All driver methods now have only the \"main\" argument as an allowable positional argument, the rest of the arguments are keyword-only! For example, send_command you can pass a positional argument for command , but strip_prompt and any additional arguments must be keyword arguments! BREAKING CHANGE Scrape / AsyncScrape renamed --> Driver / AsyncDriver -- given most folks should not be using these directly there will be no alias for this, just a hard change! More improvements to IOSXE tclsh pattern handling; handles tclsh in exec or privilege exec mode now read_until_prompt_or_time now supports regex patterns in the channel_outputs list (pass as a string, will be compiled for you) Big improvements to Factory for users of IDEs -- factories now have proper typing data so you will have nice auto completion things there/typing will be much happier 2020.12.31 \u00b6 Make log messages for textfsm and genie parsers failing to parse consistent as log.warning Add factory example Add \"root\" priv level to junos driver -- probably should be considered experimental for now :) Fix issue where send_config unified result did not have finish time set POSSIBLY BREAKING CHANGE: logger names have changed to be easier to get/make more sense -- the logger for each instance used to look like: \"scrapli-channel-{{ HOST }}\" which kinda was not really smart :). Loggers now look like: \"scrapli.{{ HOST }}:{{ PORT }}.channel\" -- can be channel|driver|transport! Changes to test environment: ~~Support running devices on localhost w/ nat'd management ports -- in \"vrouter\" mode (poorly named) -- this is enabled with the SCRAPLI_VROUTER environment variable set to on/true/something~~ Update 2022.01.30 - renamed to SCRAPLI_BOXEN but does the same thing! Added bootvar into nxos base config -- when missing causes qemu nxosv to boot into loader prompt so thats no good Replace resource settings in vdc in nxos to account for nxos instances with differing resources (memory/cpu) Got rid of static license udi in iosxe config, replaced more certificate stuff so show run comparisons are easier on iosxe NEW TRANSPORT asynctelnet transport is built using standard library asyncio, as such it is part of scrapli core Should be considered beta for a while :) Added a bunch of tests mocking streamreader/writer to ensure that this driver is well tested Added asynctelnet support in nxos and juniper drivers (to change prompt for those platforms) Support asynctelnet in base driver auth_bypass for both telnet drivers completely bypasses not only auth (as it did previously) but also the auth validation where we confirm we got logged in successfully -- reason being is that for console servers and such you may not care about that, you may just want to log in and read data. Removed unnecessary re-checking/verifying of ssh config file in system transport (was basically duplicated from base transport, so was pointless!) Bumped all the default timeout values up as they were probably a bit on the aggressive side Added eager argument to send commands/commands from file and config/configs/configs from file methods -- basically this eager mode will not look for a prompt between lines of commands/configs. This means that things have a tiny potential to get out of whack because we will just send things as fast as possible. In order to not totally break things we will (whether you like it or not!) wait and find the prompt on the last command/config in the list though -- that way we dont get too out of whack. This now means we can use eager to configure banners and macros and things and we no longer need to do the dirty send interactive workaround. Added ScrapliConnectionLost exception and raise it if we get EOF in system transport -- with a message that is more clear than just \"EOF\" and some obscure line in ptyprocess! Added tclsh privilege level for IOSXE Fixed a bug that would prevent going to \"parallel\" privilege levels -- i.e. going from tclsh to configuration or visa versa in IOSXE or from configuration to configuration_exclusive in IOSXR If no failed_when_contains is passed to send_interactive network drivers will now use the network drivers failed_when_contains attribute to bring it inline with the normal command/config methods Added timeout_ops to send_interactive and wrap those methods with the TimeoutModifier decorator Add logic to properly fetch socket address family type so we can handle IPv6 hosts (w/ scrapli-ssh2/scrapli-paramiko) Added tclsh privilege level for NXOS, didn't even know that existed before! 2020.11.15 \u00b6 Fix a regex that sometimes caused a failed functional IOSXR test Add ptyprocess transport options for system transport -- sounds like this may be needed for huawei community platform to be able to set the pty process terminal size -- also added some basic testing for this Update scrapli-ssh2 pin to latest version -- now supports keyboard interactive auth; also un-skipped all related EOS tests now that this works Fix missing acquire priv in default on_open methods for nxos and eos async version Fix incorrect textfsm_platform for iosxr (was cisco_iosxr, now is cisco_xr) Remove unnecessary decorator on write operations for systemssh and telnet -- this operation shouldn't block so this was unnecessary; any issue here should raise some exception from the lower level library. Playing around w/ adding coverage reports with Codecov 2020.10.10 \u00b6 Improve logging in helper functions - especially around resolving ssh config/known hosts Add ttp_parse_output method to Response object; add ttp_parse function in helper Load requirements from requirements files and parse them for setup.py -- stop me from forgetting to update in one place or another! Slacken the IOSXE configuration prompt pattern -- hostname(ipsec-profile) was not being caught by the pattern as it was expecting the part in parenthesis to start with \"conf\" - thank you Talha Javaid for bringing this up on ntc slack, and Alex Lardschneider for confirming the \"fix\" should be good to go! Add community pip extra to install scrapli community Minor README house keeping! Made transport set_timeout saner -- I genuinely don't know what I was doing with that before... this included the base class as well as updating telnet and systemssh... in theory this could be a breaking change if you were just calling set_timeout for some reason without passing an argument... you probably weren't doing that... because why would you? There was some precedent for doing it like this before but it isn't worth caring about now :) Did smarter things with imports in helper, added tests to make sure the warnings are correct Dramatically simplified session locking... this had just gotten out of hand over time... now only the channel locks . This means that basically all inputs/outputs should go through the channel and/or you should acquire the lock yourself if you wish to read/write directly to the transport. Critically this means that all the external transport plugins AND scrapli-netconf need to be updated as well -- this means that you must update all of these if you are using this release! (requirements are of course pinned to make sure this is the case) BREAKING CHANGE: removed ALL keepalive stuff... for now. This will probably get added back, but AFAIK nobody uses it right now and the implementation of it is frankly not very good... keeping it around right now added complexity for little gain. Keepalives will be back and improved hopefully in the next release. If you need them, please just pin to 2020.09.26! 2020.09.26 \u00b6 Improved error handling/exceptions for scrapli Factory Fixed issue where system transport did not properly close/kill SSH connections Added 3.9-dev testing to GitHub Actions Added initial testing/support of on_init callable to base driver -- the idea for on_init is mostly to allow scrapli_community platform creators to be able to add an additional callable to be executed after initialization of the scrapli object, but before any open method is called Added initial testing/support of scrapli_community driver classes -- this would allow scrapli_community platform creators to create driver classes so that they can implement custom methods for each platform type if desired Minor improvements to telnet transport to improve logging as well as authentication validation (are we authenticated); this also makes telnet look/feel a lot more like system which is nice for consistency reasons Fix regression that caused scrapli to spam a bajillion log entries -- now a filter gets applied in both Channel and Transport base classes to snag the filter from the root scrapli logger and apply it to the base/channel loggers Fully give into the warm embrace of dependabot and pin all the dev requirements to specific versions... dependabot can keep us up to date and this lets us not worry about builds failing because of dev requirements getting changed around Fix ptyprocess file object closing issue 2020.08.28 \u00b6 Added Packet Pushers scrapli episode to the README!! Added NXOS and Junos mock ssh servers and created tests for open/close methods (silly tests but just ensures we send what we think we should be sending) Created a property timeout_ops on the driver class -- this property will also set the timeout_ops value of the channel as well, this is just to make it so users don't have to do conn.channel.timeout_ops to set the timeout value... that was not super intuitive! Update dev/test requirements to finally have pylama 2.6! This means that isort can be unpinned and free to update! Add send_and_read method to GenericDriver -- this method allows you to send an input (at the current priv level ) and wait for a prompt, an expected output, or a duration. Add eager flag to the channel send_input method -- this probably should not be used by many folks, but can be used to not read until the prompt pattern is seen. In other words, this will send an input, read the input off the channel and then return. All exceptions that are raised due to catching an internal exception should now be raising \"from\" the caught exception -- mostly this is to appease Pylama, but may end up being nicer on the eyes/easier to see whats going on in some scenarios. IOSXE now catches \"Enable password:\" for an escalation pattern from exec to privilege exec -- fixes #45 The \"requires open\" decorator has been updated/fixed to play nice with asyncio timeout_ops has been converted from an int to a float to allow for more granular timeout control (the other timeouts remain as integers) Few minor docstring fixes from copypasta issues :) Update black pin/re-run black 2020.07.26 \u00b6 Fixed the same get_prompt issue from the last release, but this time managed to actually fix it in async version! Better handling of read_until_input -- stripping some characters out that may get inserted (backspace char), and compares a normalized whitespace version of the read output to the a normalized whitespace version of the input , fixes #36 . Improved system transport ssh error handling -- catch cipher/kex errors better, catch bad configuration messages. Now raise an exception if trying to use an invalid transport class for the base driver type -- i.e. if using asyncssh transport plugin with the \"normal\" sync driver class. Added links to the other projects in the scrapli \"family\" to the readme. Created first draft of the scrapli \"factory\" -- this will allow users to provide the platform name as a string to a single Scrapli or AsyncScrapli class and it will automagically get the right platform driver selected and such . This is also the first support for scrapli_community , which will allow users to contribute non \"core\" platforms and have them be usable in scrapli just like \"normal\". Overhaul decorators for timeouts into a single class (for sync and async), prefer to use signals timeout method where possible, fall back to multiprocessing timeout where required (multiprocessing is slower/more cpu intensive so dont use it if we dont have to). 2020.07.12 \u00b6 Fixed a silly issue where get_prompt was setting the transport timeout to 10s causing user defined timeouts to be effectively ignored. Improved telnet authentication handling -- previously if a return character was needed to get the auth prompts to kick into gear this could break auth. Added \"auth_bypass\" to telnet transport. Probably BUGFIX -- async functions were being decorated by the \"normal\" operation_timeout decorator -- created a mostly duplicated async version of the timeout decorator to wrap the AsyncChannel methods. Fixed a maybe regression that caused drivers to try to authenticate (via interactive methods) even if a auth_secondary is not set. Added tests to make sure that we raise a warning if there is no secondary password set , but try to increase privilege without authentication, and of course if there is an auth secondary set, we obviously try to auth in the normal fashion. Started thinning down the PtyProcess stuff to simplify and and remove all unnecessary parts, as well as add typing and docstrings... not done yet, but some progress! Added additional asyncio example Added blurb about versioning in README Fixed a few README issues (incorrect methods/typos) Updated notes about auth_bypass to include telnet support Added SSHNotFound exception for system SSH/PtyProcess if ssh binary can't be found 2020.07.04 \u00b6 Updated IOSXE base config to include netconf setup for consistency w/ scrapli_netconf Removed \"pipes\" authentication for system ssh -- this is mostly an internal change that simplifies the way that system transport authenticates. We lose the ability to very easily read out of stderr what is going on so even if we auth with a key now we have to \"confirm\" that we are authenticated, but this removes a fair bit of code and unifies things as well as allows for the next line item... Added support for auth_private_key_passphrase to system transport -- allows for entering ssh key passphrase to decrypt ssh keys Added an example on how to deal with \"weird\" things like banners and macros -- these types of things change how the ssh channel works in that they are pseudo \"interactive\" -- meaning the prompt is modified/removed so scrapli can't ever \"know\" when a command is done inserting. It would be possible to support these types of config items more \"natively\" but doing so would lose some of the smarts about how scrapli enters/confirms inputs sent, so for now (and probably for forever) these will need to be configured in a \"special\" fashion Updated IOSXE for functional tests to use 16.12.03 -- this includes updates to the base config/expected configs ... AFAIK there is some better netconf/restconf support in this version which may be handy for tests for scrapli-netconf Update channel/drivers to never decode bytes -- this now only happens in the response object; primary motivation for this is to not have to decode/re-encode in general, and in scrapli-netconf in particular 2020.06.06 \u00b6 Converted all priv levels to be kwargs instead of just args for setup -- simple thing but makes it more readable IMO. Added to the Juniper prompt pattern to include matching the RE prompt that is on the line \"above\" the \"normal \" prompt as this was getting included in command output instead of being seen as part of the prompt by scrapli. Convert driver privilege escalation prompts to use regex to match upper and lower case \"P\" in password prompt Fix core drivers to actually allow for users to pass failed_when_contains , textfsm_platform , genie_platform , and default_desired_privilege_level Add better exception/message for attempting to send command/config to a connection object that has not been opened Add testing for on open/close methods of core drivers Add send_config method to send a single configuration string -- this will automagically handle sending a full configuration, breaking it into a list of configs, sending that list with send_configs and then joining the responses into a single Response object... or of course you can just send a single config line with it too! Add better handling/logging for SystemSSH transport when key exchange cannot be negotiated Convert the _failed() method of MultiResponse to be a property so users can check .failed on a MultiResponse object more intuitively/sanely ASYNC ALL THE THINGS... basically only an internal change, but hugely modified the guts of scrapli to try to be able to best support asyncio while still having the same api for sync and async. Again, if you dont care about aysncio this probably doesnt matter at all as all the \"public\" stuff has not changed for sync versions of things. Completely overhaul unit tests -- unit tests now spin up an SSH server using asyncssh, this server is a very basic implementation of an IOSXE device. This fake IOSXE device allows for connecting/sending commands/handling log on stuff like disabling paging all in as close to the real thing as possible while being completely self contained and completely in python. Additionally since there was a lot of changes to break things out to be more granular with the async implementation the testing has evolved to support this. Increased all hostname patterns to match up to 63 characters -- this is the hostname length limit for Cisco IOSXE at least and should be a reasonable value that hopefully doesnt really ever need to be changed/expanded now Changing logging to create a logger associated with each object instance and include the name/ip of the host in the log name -- should make things a lot nicer with threads/asyncio/etc. Moved from tox to using nox for handling tests/linting; originally this was because of some of the unit testing failing when ran via tox (now I believe this was because there was no TERM env var set in tox), but at this point nox is quite nice so we'll stick with it! Added exception to be raised when users try to use system transport on Windows BUGFIX: Added underscores to hostname patterns for IOSXE, IOSXR, NXOS, and Junos (not valid in EOS at least in my testing) No more Windows testing, not worth the effort BUGFIX: Added functionality to merge less specific (but matching) host entry data for ssh config file hosts -- meaning that we can now merge attributes from a \"*\" entry into a more specific host entry (see #21 ) Add dependabot to see how we like having that friend around... 2020.05.09 \u00b6 Add underscores to EOS config prompt matching Actually fixed on_close methods that I could have sworn were fixed.... gremlins ! (was sending prompt pattern instead of a return char... for copypasta reasons probably) No longer \"exit\" config mode... given that send_command like methods already check to ensure they are in the right priv level there is no reason to exit config mode... just leave it when you need to. Should be a minor speed up if using send_configs more than once in a row, and otherwise should be basically exactly the same. For NetworkDrivers we no longer set the channel prompt pattern depending on the priv level -- it is now *always the combined pattern that matches all priv levels... this should make doing manual things where you change privileges and don't use scrapli's built in methods a little easier. Scrapli still checks that the current prompt matches where it thinks it should be (i.e. config mode vs privileged exec) though, so nothing should change from a user perspective. Improve (fix?) the abort config setup for IOSXR/Junos Add more helpful exception if ssh key permissions are too open Convert PrivilegeLevel from a namedtuple to a class with slots... better for typing and is also mutable so users can more easily update the pattern for a given privilege level if so desired Minor clean up stuff for all the core platforms and network driver, all internal, mostly just about organization! Add \"configuration_exclusive\" privilege level for IOSXRDriver, add \"configuration_private\" and \"configuration_exclusive\" for JunosDriver, modify some of the privilege handling to support these modes -- these can be accessed by simply passing privilege_level=\"configuration_exclusive\" when using send_configs method Add support for configuration sessions for EOS/NXOS. At this time sessions need to be \"registered\" as a privilege level, and then are requestable like any other privilege level, and can be used when sending configs by passing the name of your session as the privilege level argument for send config methods Add a space to EOS prompts -- it seems its very easy to add one to the prompts and scrapli did not enjoy that previously! Give users the option to pass in their own privilege levels for network drivers, and also throw a warning if users try to pass comms_prompt_pattern when using network drivers (as this should all be handled by priv levels) Created MultiResponse object to use instead of a generic list for grouping multiple Response objects Added raise_for_status methods to Response and MultiResponse -- copying the requests style method here to raise an exception if any elements were failed BUGFIX: fixed an issue with IOSXEDriver not matching the config mode pattern for ssh pub key entries. 2020.04.30 \u00b6 Continued improvement around SystemSSHTransport connection/auth failure logging Fix for very intermittent issue where pty fd is not available for reading on SystemSSH/Telnet connections, now we loop over the select statement checking the fd instead of failing if it isn't immediately readable Implement atexit function if keepalives are enabled -- this originally just lived in the ssh2 transport, but needs to be here in the base Transport class as the issue affected all transport types Added send_commands_from_file method... does what it sounds like it does... Added send_configs_from_file method ( NetworkDriver and sub-classes)... also does what it sounds like it does Simplified privilege levels and overhauled how auth escalation/deescalation works. Its still probably a bit more complex than it should be, but its a bit more efficient and at least a little simpler/more flexible. Removed comms_prompt_pattern from Network drivers and now build this as a big pattern matching all of the priv levels for that device type. This is used only for initial connection/finding prompt then scrapli still sets the explicit prompt for the particular privilege level. Implemented lru_cache on some places where we have repetitive tasks... probably unmeasurable difference, but in theory its a little faster now in some places Moved some Network driver things into the base NetworkDriver class to clean things up a bit. Added an _abort_config method to abort configurations for IOSXR/Juniper, this is ignored on the other core platforms BREAKING CHANGE : (minor) Removed now unneeded exception CouldNotAcquirePrivLevel Made the get_prompt_pattern helper a little worse... should revisit to improve/make its use more clear Fixed a screw up that had ridiculous transport timeouts -- at one point timeouts were in seconds, then milliseconds ... went back to seconds, but left things setting millisecond values... fixed :D Added transport_options to base Scrape class -- this is a dict of arguments that can be passed down to your selected transport class... for now this is very limited and is just for passing additional \"open_cmd\" arguments to SystemSSHTransport . The current use case is adding args such as ciphers/kex to your ssh command so you don't need to rely on having this in an ssh config file. 2020.04.19 \u00b6 Increase character count for base prompt pattern for Scrape , GenericDriver , and core drivers. Example: r\"^[a-z0-9.\\-@()/:]{1,32}[#>$]$\" for the base IOSXEDriver comms_prompt_pattern has been increased to: r\"^[a-z0-9.\\-@()/:]{1,48}[#>$]$\" Improve the logging for SystemSSHTransport authentication Fixed an issue where SystemSSHTransport auth would fail due to a login banner having the word password in the banner/text Significantly increase the base timeout_ops value -- as this is not a timer that is going to cause things to block, it may as well be much higher for the default value to help prevent issues Fixed an issue w/ ssh config file not parsing the last host entry Added super basic tests for most of the examples -- just making sure they don't blow up... in general that should keep them in decent shape! Removed cssh2 and miko transports from scrapli core. These have been migrated to their own repositories. From a users perspective nothing really should change -- you can still pip install scrapli[paramiko] to install the paramiko transport and the requirements (paramiko), and the actual usage (setting \"transport\" = \"paramiko \" ) remains the same! This is mostly about keeping the core of scrapli as simple as possible, and also will hopefully help to illustrate that SystemSSH is the development priority for scrapli. Convert many function calls to use keyword args for better readability throughout Add a comms_auto_expand argument to the Channel ; for now this is mostly not used, but may be useful in the future. The purpose of this is to handle devices that auto expand input commands to their full canonical name. Hopefully(?) fixed a bit of an idiosyncrasy where the timeout_transport was being used to decorate read/write operations for telnet/system transports. This is no longer the case, the read/write methods are NOT decorated now , instead we rely on the timeout_ops to time these operations out OR the timeout_transport being set to the timeout value (telnet) or ServerAliveInterval value for system ssh. 2020.04.11 \u00b6 BREAKING CHANGE : modify send_interact to just make more sense in general... now it supports 1->N \"events\" to interact with -- see the \"handling prompts\" section of README for updated example Moved record_response of Response object to be a private method, shouldn't really be needed publicly Moved authenticate and isauthenticated methods of ssh2/paramiko transports to private methods Add auth_bypass option to ignore ssh auth for weird devices such as Cisco WLC -- currently only supported on system transport. Bump timeout_transport up to 10 seconds after finding some issues for some users. Add example for \"non-standard\" device type (Cisco WLC) demo-ing the auth_bypass, custom on_open method, custom comms_prompt_pattern and just general non-standard device stuff. Add option (and make it the default) to have textfsm data returned in list of dict form with the headers being the keys and of course the row values as the values, should be much nicer on the eyes this way! Added terminal width settings for the core drivers to set things as wide as possible so long commands don't have issues Teeny tiny improvements that may make things a tick faster in Channel by using str methods instead of re Create a draft of public api status doc -- this should be useful on a quick glance to see if/when any public methods change, obviously as development simmers down things should be stable but inevitably stuff will change , so the goal here is to just document when methods were introduced and the last time they were changed Move some imports around so that scrapli works on windows (with paramiko/ssh2 transports) 2020.03.29 \u00b6 Add support for parse_genie to Response object; obviously really only for Cisco devices at this point unless there are parsers floating around out there for other platforms I don't know about! Add an atexit function for the ssh2 transport which forcibly closes the connection. This fixes a bug where if a user did not manually close the connection (or use a context manager for the connection) the script would hang open until an interrupt. Added a GenericDriver for those with non-core platforms. The GenericDriver has a really broad prompt pattern match, doesn't know about privilege levels or any other device specific stuff, but does provide the send_command , send_commands , send_interact , and get_prompt methods just like the \"core\" drivers do. This should be a decent starting point for anyone working on non-core platforms! Minor unit test improvement to cover send_commands (plural) and to cover the new GenericDriver Improved auth failure handling for systemssh using pty auth (username/pass auth) Add \"failed_when\" strings to the core drivers; these are used in the response object to help indicate if the channel input failed or succeeded. For scrapli not super super helpful, but nornir_scrapli will benefit from this as well! Modify NetworkDriver to inherit from GenericDriver -- this allowed for some clean up of how/where Response objects get created/returned from. Channel now is much more de-coupled from whatever sits on top of it (this will be important for some netconf testing happening soon!). Minor test de-duplication around ssh config/known hosts file gathering. Added a few simple examples for structured data (textfsm/genie) and updated existing examples a bit.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#20220730post1","text":"Big thanks once again to @haccht (and to @egreenspan2 for raising an issue on this as well) for fixing up some broken telnet control character handling, and for porting that to async side of things as well!","title":"2022.07.30.post1"},{"location":"changelog/#20220730","text":"Added MANIFEST.in to make sure requirements files are in source distribution see #216 Move weekly build to develop branch so weekly build doesn't fail for \"stale\" main branch reasons textfsm_parse now supports passing in a file or URL to load as the template file -- thank you to @haccht for this one -- see #215 Fixed some mypy/typing challenges around the scrapli \"factory\" context manager -- thank you to @erwinkinn for working on this With lots of help from @netixx tracked down some silliness with timeout decorators not behaving how they should -- check out #233 for details on this Overhauled the functional testing to align more closely with scrapligo and to remove all the old unnecessary dockerfile bits, replacing that completely with containerlab","title":"2022.07.30"},{"location":"changelog/#20220130post1","text":"Remove newline anchor in in-channel auth password pattern. Felt like a good/smart idea but Cisco in their infinite wisdom have some awful banner on IOL (CML/VIRL) things that doesn't end with a newline and too many people will hit that. Move decorators back to function style -- fixes possible timeout issues as seen in #233 Modified escalate_priv methods to check for password prompt and desired prompt patterns and the current prompt pattern. There was an issue in scrapligo/containerlab where a cEOS device would not let you auth past enable until it is done \"booting\" up, and scrapli would just simply timeout as it didn't expect to see the exec prompt again. Thanks to @hellt for helping track this one down! Replaced standard library telnetlib transport with custom telnet transport (still no external requirements) in very early preparation for telnetlib's deprecation.","title":"2022.01.30.post1"},{"location":"changelog/#20220130","text":"Removed deprecated comms_ansi argument Improved error handling/error message for insufficient permissions when opening ssh config/known hosts file (system transport) Added support for hashed entries in known hosts file thanks to @kangtastic work in #174 Improved \"in channel\" SSH and Telnet authentication handling; better consistency between sync and async, patterns are now compiled only if/when needed Added option to enable echo in PTYProcess (was originally removed from vendor'd code) -- should only be useful/necessary with netconf #165 Allow users to build their own open_cmd for system transport -- users can override this to do things like kubectl exec -it args args args or docker exec -it args args args to connect to containers in k8s/docker #166 Updated/fixed(?) Juniper shell patterns for \"normal\" and root shells #170 Support transport options being passed to asyncssh transport thanks to @cuong-nguyenduy work in #178 and #183 A handful of nice readability/simplicity improvements throughout the codebase thanks to @yezz123 in #188 Fix (add) missing kwarg for channel_log_mode in the driver layers \"above\" base driver Update NXOS config pattern to include \"+\" to not break when entering TACACS config mode Added support for encrypted SSH keys with ssh2 transport in #192 thanks to @shnurty Fix/improve in channel SSH auth password prompt pattern to match scrapligo (which handles user @host password: strings) Update ssh2-python requirements now that 3.10/Darwin release is available Better exception/exception message for auth failures escalating privilege (network drivers) Added a global Settings object -- for now only has an attribute for \"SUPPRESS_USER_WARNINGS\" to... suppress user warnings Added read_callback method to GenericDriver / AsyncGenericDriver -- basically this is a fancier version of send interactive that lets you assign callbacks to things that scrapli reads rather than having to follow prompts in a linear fashion. Dropped Python3.6 support as it is now EOL! Of course, scrapli probably still works just fine with 3.6 (if you install the old 3.6 requirements), but we won't test/support it anymore. Added enable_rsa2 setting to paramiko transport options -- basically 2.9.0+ paramiko enables rsa2 support by default which causes key auth to fail on the test network devices, so we disable that by default, but exposet his flag so users can enable it if desired!","title":"2022.01.30"},{"location":"changelog/#20210730","text":"Added \"% Unavailable command\" to EOS failed_when_contains Moved core platform failed_when_contains to base to not have to duplicate them in sync and async platforms Add file_mode to the enable_basic_logging function, can now choose \"append\" or \"write\" for logfile Add channel_log_mode to the base driver arguments; you can now choose \"append\" or \"write\" for this as well! Improve reading until prompt methods; no longer use re.search on the entire received byte string, now only checks for prompt on the last N chars where N is governed by the base channel args comms_prompt_search_depth attribute.. . this fixes an issue where scrapli could be wayyyyyy slow for very very large outputs (like full tables show bgp) Fix bug (or just terrible initial idea!?) in asynctelnet that reset a timer back to a very small value that was used for testing; most people shouldn't have noticed an issue here, but if you had slow devices this could cause issues that \"looked\" like an authentication issue due to scrapli not having responded to all telnet control characters before punting to auth Added commandeer to driver object; this is used to \"commandeer\" an existing connection but treat it like the new connection object (prompt patterns, methods, etc.) -- generally this would be used for using GenericDriver to connect to a console server, then \"commandeering\" that connection and turning it into an IOSXR/IOSXE/etc. connection object so you have all the \"normal\" behavior of scrapli Add missing timeout on the asynctelnet open method Add py.typed to hopefully do typing more correctly :P BUGFIX: network drivers aborted configuration sessions if responses were failed even if the stop_on_failed arg was set to False; this has been fixed now so that sessions are only aborted if the response is failed and Improved typing for send_interactive Remove napalm dev requirement -- switch to scrapli-cfg for dev environment config management; something something eating dog food or whatever. Deprecate comms_ansi -- if there is an ANSI escape sequence we will now just strip it out automagically; this is not currently a breaking change, but will be -- there is a deprecation warning now and comms_ansi will be fully removed in the 2022.01.30 release (and pre-releases). Removed a sleep that was in the default on_open for IOSXR devices... this has been there a while and I think it was just a hold over from early early versions of scrapli that perhaps had a less robust in channel authentication handler. 1 second faster IOSXR for free! Yay! Fixed an issue with system transport where the transport would get closed twice causing an unhandled exception -- thank you to Alex Lardschneider for finding this! Added an example for the enable_basic_logging function as well as the commandeer method Improved priv level handling -- if you try to acquire \"parallel\" privileges (ex. configuration and configuration exclusive in IOSXR) previously we would say things worked, but we would just stay in configuration mode. This has been fixed (hopefully)! Move ansi escape pattern to compile globally, so it only compiles once (why it was never like that before... who knows) Simplify the collect bits for integration tests... this is still not used heavily but hopefully will be soon! Replace vrnetlab creds in examples with scrapli (felt confusing to have vrnetlab creds everywhere, plus functional testing is moving away from (but still supporting) vrnetlab test environment) Crank up the rows/cols for system transport -> 80 rows, 256 cols -- this to align with scrapligo and to make it less common that users need to modify these values. BUGFIX: fixed blocking read in async channel telnet authentication (thank you Dmitry Figol!) Added not_contains field to privilege levels... this will help greatly simplify the necessary regex patterns, as well as allow us to ditch look arounds which go does not support... step one to a standardized community platform that works with python -or- go! Simplified (at least a little... more would be good) patterns for privilege levels for core platforms. Added _generic_driver_mode to the NetworkDriver classes -- this is a private mode as it should probably be used cautiously -- the idea here is that you can send any strings you want and scrapli will not care about privilege levels at all. See the discussion about this here . BUGFIX: fixed asynctelnet issue with control character handling, thank you to @davaeron -- see #147 BREAKING CHANGE removed the transport.username_prompt and transport.password_prompt attributes of the telnet transports. All authentication has been moved into the channel, so it made no sense to leave these attributes on the transports. This may cause an issue for users that had explicitly set their prompts to something non-standard. Finally added logic to auto set port to 23 for telnet :) BUGFIX: fixed a rare issue where decoding bytes received from the channel (in the response object) would raise a UnicodedecodEerror ; we now catch this exception and decode with ISO-8859-1 encoding which seems to be much less picky about what it decodes. Thanks to Alex Lardschneider for yet another good catch and fix! Added interaction_complete_patterns to all \"interactive\" methods -- this argument accepts a list of strings/patterns; will be re-escape'd if each string does not start with and end with \"^\" and \"$\" (line anchors), otherwise will be compiled with the standard scrapli case-insensitive and multiline flags. If the interactive event finds any of these pattenrs during the course of the interacting it will terminate the interactive session. Note that this is entirely optional and is a keyword only argument so no changes are necessary to any existing scrapli programs.","title":"2021.07.30"},{"location":"changelog/#20210130","text":"BREAKING CHANGE PrivilegeLevel import location changed -- this will break things! timeout_exit deprecated; will always close connection on timeout now All exceptions rationalized/changed -- all exceptions now rooted in ScrapliException and scrapli should not raise any exception that is not rooted in this! It is of course possible that non-scrapli exceptions will get raised at some point, but all \"common\" exceptions will now follow this pattern. Added opinionated logging option -- should be used only for debugging/testing, otherwise use your own logging setup! Moved \"in channel\" auth into channel (for telnet/system ssh authentication) Added channel_lock option, defaults to false Added channel_log option Decorators got reswizzled a little, no more requires open as the transports handle this. There is now a dedicated ChannelTimeout and TransportTimeout to keep things simpler. All transport plugins are now in scrapli \"core\" All (ok, most...) channel and transport args are now properties of the driver class -- this should remove confusion about where to update what timeout/value Response._record_response is now public but only for linting reasons, people generally should ignore this anyway! Python 3.6 will now require dataclasses backport All driver methods now have only the \"main\" argument as an allowable positional argument, the rest of the arguments are keyword-only! For example, send_command you can pass a positional argument for command , but strip_prompt and any additional arguments must be keyword arguments! BREAKING CHANGE Scrape / AsyncScrape renamed --> Driver / AsyncDriver -- given most folks should not be using these directly there will be no alias for this, just a hard change! More improvements to IOSXE tclsh pattern handling; handles tclsh in exec or privilege exec mode now read_until_prompt_or_time now supports regex patterns in the channel_outputs list (pass as a string, will be compiled for you) Big improvements to Factory for users of IDEs -- factories now have proper typing data so you will have nice auto completion things there/typing will be much happier","title":"2021.01.30"},{"location":"changelog/#20201231","text":"Make log messages for textfsm and genie parsers failing to parse consistent as log.warning Add factory example Add \"root\" priv level to junos driver -- probably should be considered experimental for now :) Fix issue where send_config unified result did not have finish time set POSSIBLY BREAKING CHANGE: logger names have changed to be easier to get/make more sense -- the logger for each instance used to look like: \"scrapli-channel-{{ HOST }}\" which kinda was not really smart :). Loggers now look like: \"scrapli.{{ HOST }}:{{ PORT }}.channel\" -- can be channel|driver|transport! Changes to test environment: ~~Support running devices on localhost w/ nat'd management ports -- in \"vrouter\" mode (poorly named) -- this is enabled with the SCRAPLI_VROUTER environment variable set to on/true/something~~ Update 2022.01.30 - renamed to SCRAPLI_BOXEN but does the same thing! Added bootvar into nxos base config -- when missing causes qemu nxosv to boot into loader prompt so thats no good Replace resource settings in vdc in nxos to account for nxos instances with differing resources (memory/cpu) Got rid of static license udi in iosxe config, replaced more certificate stuff so show run comparisons are easier on iosxe NEW TRANSPORT asynctelnet transport is built using standard library asyncio, as such it is part of scrapli core Should be considered beta for a while :) Added a bunch of tests mocking streamreader/writer to ensure that this driver is well tested Added asynctelnet support in nxos and juniper drivers (to change prompt for those platforms) Support asynctelnet in base driver auth_bypass for both telnet drivers completely bypasses not only auth (as it did previously) but also the auth validation where we confirm we got logged in successfully -- reason being is that for console servers and such you may not care about that, you may just want to log in and read data. Removed unnecessary re-checking/verifying of ssh config file in system transport (was basically duplicated from base transport, so was pointless!) Bumped all the default timeout values up as they were probably a bit on the aggressive side Added eager argument to send commands/commands from file and config/configs/configs from file methods -- basically this eager mode will not look for a prompt between lines of commands/configs. This means that things have a tiny potential to get out of whack because we will just send things as fast as possible. In order to not totally break things we will (whether you like it or not!) wait and find the prompt on the last command/config in the list though -- that way we dont get too out of whack. This now means we can use eager to configure banners and macros and things and we no longer need to do the dirty send interactive workaround. Added ScrapliConnectionLost exception and raise it if we get EOF in system transport -- with a message that is more clear than just \"EOF\" and some obscure line in ptyprocess! Added tclsh privilege level for IOSXE Fixed a bug that would prevent going to \"parallel\" privilege levels -- i.e. going from tclsh to configuration or visa versa in IOSXE or from configuration to configuration_exclusive in IOSXR If no failed_when_contains is passed to send_interactive network drivers will now use the network drivers failed_when_contains attribute to bring it inline with the normal command/config methods Added timeout_ops to send_interactive and wrap those methods with the TimeoutModifier decorator Add logic to properly fetch socket address family type so we can handle IPv6 hosts (w/ scrapli-ssh2/scrapli-paramiko) Added tclsh privilege level for NXOS, didn't even know that existed before!","title":"2020.12.31"},{"location":"changelog/#20201115","text":"Fix a regex that sometimes caused a failed functional IOSXR test Add ptyprocess transport options for system transport -- sounds like this may be needed for huawei community platform to be able to set the pty process terminal size -- also added some basic testing for this Update scrapli-ssh2 pin to latest version -- now supports keyboard interactive auth; also un-skipped all related EOS tests now that this works Fix missing acquire priv in default on_open methods for nxos and eos async version Fix incorrect textfsm_platform for iosxr (was cisco_iosxr, now is cisco_xr) Remove unnecessary decorator on write operations for systemssh and telnet -- this operation shouldn't block so this was unnecessary; any issue here should raise some exception from the lower level library. Playing around w/ adding coverage reports with Codecov","title":"2020.11.15"},{"location":"changelog/#20201010","text":"Improve logging in helper functions - especially around resolving ssh config/known hosts Add ttp_parse_output method to Response object; add ttp_parse function in helper Load requirements from requirements files and parse them for setup.py -- stop me from forgetting to update in one place or another! Slacken the IOSXE configuration prompt pattern -- hostname(ipsec-profile) was not being caught by the pattern as it was expecting the part in parenthesis to start with \"conf\" - thank you Talha Javaid for bringing this up on ntc slack, and Alex Lardschneider for confirming the \"fix\" should be good to go! Add community pip extra to install scrapli community Minor README house keeping! Made transport set_timeout saner -- I genuinely don't know what I was doing with that before... this included the base class as well as updating telnet and systemssh... in theory this could be a breaking change if you were just calling set_timeout for some reason without passing an argument... you probably weren't doing that... because why would you? There was some precedent for doing it like this before but it isn't worth caring about now :) Did smarter things with imports in helper, added tests to make sure the warnings are correct Dramatically simplified session locking... this had just gotten out of hand over time... now only the channel locks . This means that basically all inputs/outputs should go through the channel and/or you should acquire the lock yourself if you wish to read/write directly to the transport. Critically this means that all the external transport plugins AND scrapli-netconf need to be updated as well -- this means that you must update all of these if you are using this release! (requirements are of course pinned to make sure this is the case) BREAKING CHANGE: removed ALL keepalive stuff... for now. This will probably get added back, but AFAIK nobody uses it right now and the implementation of it is frankly not very good... keeping it around right now added complexity for little gain. Keepalives will be back and improved hopefully in the next release. If you need them, please just pin to 2020.09.26!","title":"2020.10.10"},{"location":"changelog/#20200926","text":"Improved error handling/exceptions for scrapli Factory Fixed issue where system transport did not properly close/kill SSH connections Added 3.9-dev testing to GitHub Actions Added initial testing/support of on_init callable to base driver -- the idea for on_init is mostly to allow scrapli_community platform creators to be able to add an additional callable to be executed after initialization of the scrapli object, but before any open method is called Added initial testing/support of scrapli_community driver classes -- this would allow scrapli_community platform creators to create driver classes so that they can implement custom methods for each platform type if desired Minor improvements to telnet transport to improve logging as well as authentication validation (are we authenticated); this also makes telnet look/feel a lot more like system which is nice for consistency reasons Fix regression that caused scrapli to spam a bajillion log entries -- now a filter gets applied in both Channel and Transport base classes to snag the filter from the root scrapli logger and apply it to the base/channel loggers Fully give into the warm embrace of dependabot and pin all the dev requirements to specific versions... dependabot can keep us up to date and this lets us not worry about builds failing because of dev requirements getting changed around Fix ptyprocess file object closing issue","title":"2020.09.26"},{"location":"changelog/#20200828","text":"Added Packet Pushers scrapli episode to the README!! Added NXOS and Junos mock ssh servers and created tests for open/close methods (silly tests but just ensures we send what we think we should be sending) Created a property timeout_ops on the driver class -- this property will also set the timeout_ops value of the channel as well, this is just to make it so users don't have to do conn.channel.timeout_ops to set the timeout value... that was not super intuitive! Update dev/test requirements to finally have pylama 2.6! This means that isort can be unpinned and free to update! Add send_and_read method to GenericDriver -- this method allows you to send an input (at the current priv level ) and wait for a prompt, an expected output, or a duration. Add eager flag to the channel send_input method -- this probably should not be used by many folks, but can be used to not read until the prompt pattern is seen. In other words, this will send an input, read the input off the channel and then return. All exceptions that are raised due to catching an internal exception should now be raising \"from\" the caught exception -- mostly this is to appease Pylama, but may end up being nicer on the eyes/easier to see whats going on in some scenarios. IOSXE now catches \"Enable password:\" for an escalation pattern from exec to privilege exec -- fixes #45 The \"requires open\" decorator has been updated/fixed to play nice with asyncio timeout_ops has been converted from an int to a float to allow for more granular timeout control (the other timeouts remain as integers) Few minor docstring fixes from copypasta issues :) Update black pin/re-run black","title":"2020.08.28"},{"location":"changelog/#20200726","text":"Fixed the same get_prompt issue from the last release, but this time managed to actually fix it in async version! Better handling of read_until_input -- stripping some characters out that may get inserted (backspace char), and compares a normalized whitespace version of the read output to the a normalized whitespace version of the input , fixes #36 . Improved system transport ssh error handling -- catch cipher/kex errors better, catch bad configuration messages. Now raise an exception if trying to use an invalid transport class for the base driver type -- i.e. if using asyncssh transport plugin with the \"normal\" sync driver class. Added links to the other projects in the scrapli \"family\" to the readme. Created first draft of the scrapli \"factory\" -- this will allow users to provide the platform name as a string to a single Scrapli or AsyncScrapli class and it will automagically get the right platform driver selected and such . This is also the first support for scrapli_community , which will allow users to contribute non \"core\" platforms and have them be usable in scrapli just like \"normal\". Overhaul decorators for timeouts into a single class (for sync and async), prefer to use signals timeout method where possible, fall back to multiprocessing timeout where required (multiprocessing is slower/more cpu intensive so dont use it if we dont have to).","title":"2020.07.26"},{"location":"changelog/#20200712","text":"Fixed a silly issue where get_prompt was setting the transport timeout to 10s causing user defined timeouts to be effectively ignored. Improved telnet authentication handling -- previously if a return character was needed to get the auth prompts to kick into gear this could break auth. Added \"auth_bypass\" to telnet transport. Probably BUGFIX -- async functions were being decorated by the \"normal\" operation_timeout decorator -- created a mostly duplicated async version of the timeout decorator to wrap the AsyncChannel methods. Fixed a maybe regression that caused drivers to try to authenticate (via interactive methods) even if a auth_secondary is not set. Added tests to make sure that we raise a warning if there is no secondary password set , but try to increase privilege without authentication, and of course if there is an auth secondary set, we obviously try to auth in the normal fashion. Started thinning down the PtyProcess stuff to simplify and and remove all unnecessary parts, as well as add typing and docstrings... not done yet, but some progress! Added additional asyncio example Added blurb about versioning in README Fixed a few README issues (incorrect methods/typos) Updated notes about auth_bypass to include telnet support Added SSHNotFound exception for system SSH/PtyProcess if ssh binary can't be found","title":"2020.07.12"},{"location":"changelog/#20200704","text":"Updated IOSXE base config to include netconf setup for consistency w/ scrapli_netconf Removed \"pipes\" authentication for system ssh -- this is mostly an internal change that simplifies the way that system transport authenticates. We lose the ability to very easily read out of stderr what is going on so even if we auth with a key now we have to \"confirm\" that we are authenticated, but this removes a fair bit of code and unifies things as well as allows for the next line item... Added support for auth_private_key_passphrase to system transport -- allows for entering ssh key passphrase to decrypt ssh keys Added an example on how to deal with \"weird\" things like banners and macros -- these types of things change how the ssh channel works in that they are pseudo \"interactive\" -- meaning the prompt is modified/removed so scrapli can't ever \"know\" when a command is done inserting. It would be possible to support these types of config items more \"natively\" but doing so would lose some of the smarts about how scrapli enters/confirms inputs sent, so for now (and probably for forever) these will need to be configured in a \"special\" fashion Updated IOSXE for functional tests to use 16.12.03 -- this includes updates to the base config/expected configs ... AFAIK there is some better netconf/restconf support in this version which may be handy for tests for scrapli-netconf Update channel/drivers to never decode bytes -- this now only happens in the response object; primary motivation for this is to not have to decode/re-encode in general, and in scrapli-netconf in particular","title":"2020.07.04"},{"location":"changelog/#20200606","text":"Converted all priv levels to be kwargs instead of just args for setup -- simple thing but makes it more readable IMO. Added to the Juniper prompt pattern to include matching the RE prompt that is on the line \"above\" the \"normal \" prompt as this was getting included in command output instead of being seen as part of the prompt by scrapli. Convert driver privilege escalation prompts to use regex to match upper and lower case \"P\" in password prompt Fix core drivers to actually allow for users to pass failed_when_contains , textfsm_platform , genie_platform , and default_desired_privilege_level Add better exception/message for attempting to send command/config to a connection object that has not been opened Add testing for on open/close methods of core drivers Add send_config method to send a single configuration string -- this will automagically handle sending a full configuration, breaking it into a list of configs, sending that list with send_configs and then joining the responses into a single Response object... or of course you can just send a single config line with it too! Add better handling/logging for SystemSSH transport when key exchange cannot be negotiated Convert the _failed() method of MultiResponse to be a property so users can check .failed on a MultiResponse object more intuitively/sanely ASYNC ALL THE THINGS... basically only an internal change, but hugely modified the guts of scrapli to try to be able to best support asyncio while still having the same api for sync and async. Again, if you dont care about aysncio this probably doesnt matter at all as all the \"public\" stuff has not changed for sync versions of things. Completely overhaul unit tests -- unit tests now spin up an SSH server using asyncssh, this server is a very basic implementation of an IOSXE device. This fake IOSXE device allows for connecting/sending commands/handling log on stuff like disabling paging all in as close to the real thing as possible while being completely self contained and completely in python. Additionally since there was a lot of changes to break things out to be more granular with the async implementation the testing has evolved to support this. Increased all hostname patterns to match up to 63 characters -- this is the hostname length limit for Cisco IOSXE at least and should be a reasonable value that hopefully doesnt really ever need to be changed/expanded now Changing logging to create a logger associated with each object instance and include the name/ip of the host in the log name -- should make things a lot nicer with threads/asyncio/etc. Moved from tox to using nox for handling tests/linting; originally this was because of some of the unit testing failing when ran via tox (now I believe this was because there was no TERM env var set in tox), but at this point nox is quite nice so we'll stick with it! Added exception to be raised when users try to use system transport on Windows BUGFIX: Added underscores to hostname patterns for IOSXE, IOSXR, NXOS, and Junos (not valid in EOS at least in my testing) No more Windows testing, not worth the effort BUGFIX: Added functionality to merge less specific (but matching) host entry data for ssh config file hosts -- meaning that we can now merge attributes from a \"*\" entry into a more specific host entry (see #21 ) Add dependabot to see how we like having that friend around...","title":"2020.06.06"},{"location":"changelog/#20200509","text":"Add underscores to EOS config prompt matching Actually fixed on_close methods that I could have sworn were fixed.... gremlins ! (was sending prompt pattern instead of a return char... for copypasta reasons probably) No longer \"exit\" config mode... given that send_command like methods already check to ensure they are in the right priv level there is no reason to exit config mode... just leave it when you need to. Should be a minor speed up if using send_configs more than once in a row, and otherwise should be basically exactly the same. For NetworkDrivers we no longer set the channel prompt pattern depending on the priv level -- it is now *always the combined pattern that matches all priv levels... this should make doing manual things where you change privileges and don't use scrapli's built in methods a little easier. Scrapli still checks that the current prompt matches where it thinks it should be (i.e. config mode vs privileged exec) though, so nothing should change from a user perspective. Improve (fix?) the abort config setup for IOSXR/Junos Add more helpful exception if ssh key permissions are too open Convert PrivilegeLevel from a namedtuple to a class with slots... better for typing and is also mutable so users can more easily update the pattern for a given privilege level if so desired Minor clean up stuff for all the core platforms and network driver, all internal, mostly just about organization! Add \"configuration_exclusive\" privilege level for IOSXRDriver, add \"configuration_private\" and \"configuration_exclusive\" for JunosDriver, modify some of the privilege handling to support these modes -- these can be accessed by simply passing privilege_level=\"configuration_exclusive\" when using send_configs method Add support for configuration sessions for EOS/NXOS. At this time sessions need to be \"registered\" as a privilege level, and then are requestable like any other privilege level, and can be used when sending configs by passing the name of your session as the privilege level argument for send config methods Add a space to EOS prompts -- it seems its very easy to add one to the prompts and scrapli did not enjoy that previously! Give users the option to pass in their own privilege levels for network drivers, and also throw a warning if users try to pass comms_prompt_pattern when using network drivers (as this should all be handled by priv levels) Created MultiResponse object to use instead of a generic list for grouping multiple Response objects Added raise_for_status methods to Response and MultiResponse -- copying the requests style method here to raise an exception if any elements were failed BUGFIX: fixed an issue with IOSXEDriver not matching the config mode pattern for ssh pub key entries.","title":"2020.05.09"},{"location":"changelog/#20200430","text":"Continued improvement around SystemSSHTransport connection/auth failure logging Fix for very intermittent issue where pty fd is not available for reading on SystemSSH/Telnet connections, now we loop over the select statement checking the fd instead of failing if it isn't immediately readable Implement atexit function if keepalives are enabled -- this originally just lived in the ssh2 transport, but needs to be here in the base Transport class as the issue affected all transport types Added send_commands_from_file method... does what it sounds like it does... Added send_configs_from_file method ( NetworkDriver and sub-classes)... also does what it sounds like it does Simplified privilege levels and overhauled how auth escalation/deescalation works. Its still probably a bit more complex than it should be, but its a bit more efficient and at least a little simpler/more flexible. Removed comms_prompt_pattern from Network drivers and now build this as a big pattern matching all of the priv levels for that device type. This is used only for initial connection/finding prompt then scrapli still sets the explicit prompt for the particular privilege level. Implemented lru_cache on some places where we have repetitive tasks... probably unmeasurable difference, but in theory its a little faster now in some places Moved some Network driver things into the base NetworkDriver class to clean things up a bit. Added an _abort_config method to abort configurations for IOSXR/Juniper, this is ignored on the other core platforms BREAKING CHANGE : (minor) Removed now unneeded exception CouldNotAcquirePrivLevel Made the get_prompt_pattern helper a little worse... should revisit to improve/make its use more clear Fixed a screw up that had ridiculous transport timeouts -- at one point timeouts were in seconds, then milliseconds ... went back to seconds, but left things setting millisecond values... fixed :D Added transport_options to base Scrape class -- this is a dict of arguments that can be passed down to your selected transport class... for now this is very limited and is just for passing additional \"open_cmd\" arguments to SystemSSHTransport . The current use case is adding args such as ciphers/kex to your ssh command so you don't need to rely on having this in an ssh config file.","title":"2020.04.30"},{"location":"changelog/#20200419","text":"Increase character count for base prompt pattern for Scrape , GenericDriver , and core drivers. Example: r\"^[a-z0-9.\\-@()/:]{1,32}[#>$]$\" for the base IOSXEDriver comms_prompt_pattern has been increased to: r\"^[a-z0-9.\\-@()/:]{1,48}[#>$]$\" Improve the logging for SystemSSHTransport authentication Fixed an issue where SystemSSHTransport auth would fail due to a login banner having the word password in the banner/text Significantly increase the base timeout_ops value -- as this is not a timer that is going to cause things to block, it may as well be much higher for the default value to help prevent issues Fixed an issue w/ ssh config file not parsing the last host entry Added super basic tests for most of the examples -- just making sure they don't blow up... in general that should keep them in decent shape! Removed cssh2 and miko transports from scrapli core. These have been migrated to their own repositories. From a users perspective nothing really should change -- you can still pip install scrapli[paramiko] to install the paramiko transport and the requirements (paramiko), and the actual usage (setting \"transport\" = \"paramiko \" ) remains the same! This is mostly about keeping the core of scrapli as simple as possible, and also will hopefully help to illustrate that SystemSSH is the development priority for scrapli. Convert many function calls to use keyword args for better readability throughout Add a comms_auto_expand argument to the Channel ; for now this is mostly not used, but may be useful in the future. The purpose of this is to handle devices that auto expand input commands to their full canonical name. Hopefully(?) fixed a bit of an idiosyncrasy where the timeout_transport was being used to decorate read/write operations for telnet/system transports. This is no longer the case, the read/write methods are NOT decorated now , instead we rely on the timeout_ops to time these operations out OR the timeout_transport being set to the timeout value (telnet) or ServerAliveInterval value for system ssh.","title":"2020.04.19"},{"location":"changelog/#20200411","text":"BREAKING CHANGE : modify send_interact to just make more sense in general... now it supports 1->N \"events\" to interact with -- see the \"handling prompts\" section of README for updated example Moved record_response of Response object to be a private method, shouldn't really be needed publicly Moved authenticate and isauthenticated methods of ssh2/paramiko transports to private methods Add auth_bypass option to ignore ssh auth for weird devices such as Cisco WLC -- currently only supported on system transport. Bump timeout_transport up to 10 seconds after finding some issues for some users. Add example for \"non-standard\" device type (Cisco WLC) demo-ing the auth_bypass, custom on_open method, custom comms_prompt_pattern and just general non-standard device stuff. Add option (and make it the default) to have textfsm data returned in list of dict form with the headers being the keys and of course the row values as the values, should be much nicer on the eyes this way! Added terminal width settings for the core drivers to set things as wide as possible so long commands don't have issues Teeny tiny improvements that may make things a tick faster in Channel by using str methods instead of re Create a draft of public api status doc -- this should be useful on a quick glance to see if/when any public methods change, obviously as development simmers down things should be stable but inevitably stuff will change , so the goal here is to just document when methods were introduced and the last time they were changed Move some imports around so that scrapli works on windows (with paramiko/ssh2 transports)","title":"2020.04.11"},{"location":"changelog/#20200329","text":"Add support for parse_genie to Response object; obviously really only for Cisco devices at this point unless there are parsers floating around out there for other platforms I don't know about! Add an atexit function for the ssh2 transport which forcibly closes the connection. This fixes a bug where if a user did not manually close the connection (or use a context manager for the connection) the script would hang open until an interrupt. Added a GenericDriver for those with non-core platforms. The GenericDriver has a really broad prompt pattern match, doesn't know about privilege levels or any other device specific stuff, but does provide the send_command , send_commands , send_interact , and get_prompt methods just like the \"core\" drivers do. This should be a decent starting point for anyone working on non-core platforms! Minor unit test improvement to cover send_commands (plural) and to cover the new GenericDriver Improved auth failure handling for systemssh using pty auth (username/pass auth) Add \"failed_when\" strings to the core drivers; these are used in the response object to help indicate if the channel input failed or succeeded. For scrapli not super super helpful, but nornir_scrapli will benefit from this as well! Modify NetworkDriver to inherit from GenericDriver -- this allowed for some clean up of how/where Response objects get created/returned from. Channel now is much more de-coupled from whatever sits on top of it (this will be important for some netconf testing happening soon!). Minor test de-duplication around ssh config/known hosts file gathering. Added a few simple examples for structured data (textfsm/genie) and updated existing examples a bit.","title":"2020.03.29"},{"location":"public_api_status/","text":"Public API Status \u00b6 Note that all public methods, unless otherwise noted, are available in sync and async form depending on the driver you have selected. Drivers \u00b6 Driver \u00b6 Method Implemented Last Change Notes open 2020.03.29 close 2020.03.29 isalive 2020.03.29 AsyncDriver \u00b6 Method Implemented Last Change Notes open 2020.06.06 close 2020.06.06 isalive 2020.06.06 GenericDriver (and NetworkDriver sub-classes unless overridden) \u00b6 Method Implemented Last Change Notes get_prompt 2020.03.29 send_command 2020.03.29 2020.08.09 added timeout_ops keyword argument to modify timeout send_commands 2020.03.29 2020.12.31 added eager keyword argument send_commands_from_file 2020.04.30 2020.12.31 added eager keyword argument send_interactive 2020.03.29 2021.01.30 added interaction_complete_patterns keyword argument send_and_read 2020.08.28 send_callback 2022.01.30 AsyncGenericDriver (and NetworkDriver sub-classes unless overridden) \u00b6 Method Implemented Last Change Notes get_prompt 2020.06.06 send_command 2020.06.06 2020.08.09 added timeout_ops keyword argument to modify timeout send_commands 2020.06.06 2020.12.31 added eager keyword argument send_commands_from_file 2020.06.06 2020.12.31 added eager keyword argument send_interactive 2020.06.06 2021.01.30 added interaction_complete_patterns keyword argument send_and_read 2020.08.28 send_callback 2022.01.30 NetworkDriver (and Platform driver sub-classes unless overridden) \u00b6 Method Implemented Last Change Notes update_privilege_levels 2020.05.09 update priv map/all prompt pattern if adding/modifying privs acquire_priv 2020.03.29 register_configuration_session 2020.05.09 register a config session so the priv level can be tracked send_config 2020.05.09 2020.12.31 added eager keyword argument send_configs 2020.03.29 2020.12.31 added eager keyword argument send_configs_from_file 2020.04.30 2020.12.31 added eager keyword argument send_interactive 2020.03.29 2021.01.30 added interaction_complete_patterns keyword argument AsyncNetworkDriver (and Platform driver sub-classes unless overridden) \u00b6 Method Implemented Last Change Notes update_privilege_levels 2020.06.06 acquire_priv 2020.06.06 register_configuration_session 2020.06.06 send_config 2020.06.06 2020.12.31 added eager keyword argument send_configs 2020.06.06 2020.12.31 added eager keyword argument send_configs_from_file 2020.06.06 2020.12.31 added eager keyword argument send_interactive 2020.06.06 2021.01.30 added interaction_complete_patterns keyword argument Channel \u00b6 Method Implemented Last Change Notes get_prompt 2020.03.29 send_input 2020.03.29 2020.12.31 added eager keyword argument send_inputs_interact 2020.03.29 2020.04.11 changed to support list of \"events\" to interact with send_input_and_read 2020.08.28 AsyncChannel \u00b6 Method Implemented Last Change Notes get_prompt 2020.06.06 send_input 2020.06.06 2020.12.31 added eager keyword argument send_inputs_interact 2020.06.06 send_input_and_read 2020.08.28 Transport \u00b6 Transport ABC (and Transport sub-classes unless overridden) \u00b6 Method Implemented Last Change Notes open 2020.03.29 close 2020.03.29 isalive 2020.03.29 read 2020.03.29 write 2020.03.29 set_timeout 2020.03.29 AsyncTransport ABC (and Transport sub-classes unless overridden) \u00b6 Method Implemented Last Change Notes open 2020.06.06 close 2020.06.06 isalive 2020.06.06 read 2020.06.06 write 2020.06.06 set_timeout 2020.06.06 Response \u00b6 Method Implemented Last Change Notes genie_parse_output 2020.03.29 textfsm_parse_output 2020.03.29 ttp_parse_output 2020.10.10 Unlike other parse methods, requires a template argument raise_for_status 2020.05.09 MultiResponse \u00b6 Method Implemented Last Change Notes raise_for_status 2020.05.09 SSHConfig \u00b6 Method Implemented Last Change Notes lookup 2020.03.29","title":"Public API Status"},{"location":"public_api_status/#public-api-status","text":"Note that all public methods, unless otherwise noted, are available in sync and async form depending on the driver you have selected.","title":"Public API Status"},{"location":"public_api_status/#drivers","text":"","title":"Drivers"},{"location":"public_api_status/#driver","text":"Method Implemented Last Change Notes open 2020.03.29 close 2020.03.29 isalive 2020.03.29","title":"Driver"},{"location":"public_api_status/#asyncdriver","text":"Method Implemented Last Change Notes open 2020.06.06 close 2020.06.06 isalive 2020.06.06","title":"AsyncDriver"},{"location":"public_api_status/#genericdriver-and-networkdriver-sub-classes-unless-overridden","text":"Method Implemented Last Change Notes get_prompt 2020.03.29 send_command 2020.03.29 2020.08.09 added timeout_ops keyword argument to modify timeout send_commands 2020.03.29 2020.12.31 added eager keyword argument send_commands_from_file 2020.04.30 2020.12.31 added eager keyword argument send_interactive 2020.03.29 2021.01.30 added interaction_complete_patterns keyword argument send_and_read 2020.08.28 send_callback 2022.01.30","title":"GenericDriver (and NetworkDriver sub-classes unless overridden)"},{"location":"public_api_status/#asyncgenericdriver-and-networkdriver-sub-classes-unless-overridden","text":"Method Implemented Last Change Notes get_prompt 2020.06.06 send_command 2020.06.06 2020.08.09 added timeout_ops keyword argument to modify timeout send_commands 2020.06.06 2020.12.31 added eager keyword argument send_commands_from_file 2020.06.06 2020.12.31 added eager keyword argument send_interactive 2020.06.06 2021.01.30 added interaction_complete_patterns keyword argument send_and_read 2020.08.28 send_callback 2022.01.30","title":"AsyncGenericDriver (and NetworkDriver sub-classes unless overridden)"},{"location":"public_api_status/#networkdriver-and-platform-driver-sub-classes-unless-overridden","text":"Method Implemented Last Change Notes update_privilege_levels 2020.05.09 update priv map/all prompt pattern if adding/modifying privs acquire_priv 2020.03.29 register_configuration_session 2020.05.09 register a config session so the priv level can be tracked send_config 2020.05.09 2020.12.31 added eager keyword argument send_configs 2020.03.29 2020.12.31 added eager keyword argument send_configs_from_file 2020.04.30 2020.12.31 added eager keyword argument send_interactive 2020.03.29 2021.01.30 added interaction_complete_patterns keyword argument","title":"NetworkDriver (and Platform driver sub-classes unless overridden)"},{"location":"public_api_status/#asyncnetworkdriver-and-platform-driver-sub-classes-unless-overridden","text":"Method Implemented Last Change Notes update_privilege_levels 2020.06.06 acquire_priv 2020.06.06 register_configuration_session 2020.06.06 send_config 2020.06.06 2020.12.31 added eager keyword argument send_configs 2020.06.06 2020.12.31 added eager keyword argument send_configs_from_file 2020.06.06 2020.12.31 added eager keyword argument send_interactive 2020.06.06 2021.01.30 added interaction_complete_patterns keyword argument","title":"AsyncNetworkDriver (and Platform driver sub-classes unless overridden)"},{"location":"public_api_status/#channel","text":"Method Implemented Last Change Notes get_prompt 2020.03.29 send_input 2020.03.29 2020.12.31 added eager keyword argument send_inputs_interact 2020.03.29 2020.04.11 changed to support list of \"events\" to interact with send_input_and_read 2020.08.28","title":"Channel"},{"location":"public_api_status/#asyncchannel","text":"Method Implemented Last Change Notes get_prompt 2020.06.06 send_input 2020.06.06 2020.12.31 added eager keyword argument send_inputs_interact 2020.06.06 send_input_and_read 2020.08.28","title":"AsyncChannel"},{"location":"public_api_status/#transport","text":"","title":"Transport"},{"location":"public_api_status/#transport-abc-and-transport-sub-classes-unless-overridden","text":"Method Implemented Last Change Notes open 2020.03.29 close 2020.03.29 isalive 2020.03.29 read 2020.03.29 write 2020.03.29 set_timeout 2020.03.29","title":"Transport ABC (and Transport sub-classes unless overridden)"},{"location":"public_api_status/#asynctransport-abc-and-transport-sub-classes-unless-overridden","text":"Method Implemented Last Change Notes open 2020.06.06 close 2020.06.06 isalive 2020.06.06 read 2020.06.06 write 2020.06.06 set_timeout 2020.06.06","title":"AsyncTransport ABC (and Transport sub-classes unless overridden)"},{"location":"public_api_status/#response","text":"Method Implemented Last Change Notes genie_parse_output 2020.03.29 textfsm_parse_output 2020.03.29 ttp_parse_output 2020.10.10 Unlike other parse methods, requires a template argument raise_for_status 2020.05.09","title":"Response"},{"location":"public_api_status/#multiresponse","text":"Method Implemented Last Change Notes raise_for_status 2020.05.09","title":"MultiResponse"},{"location":"public_api_status/#sshconfig","text":"Method Implemented Last Change Notes lookup 2020.03.29","title":"SSHConfig"},{"location":"about/code_of_conduct/","text":"Code of Conduct \u00b6 Be excellent to each other!","title":"Code of Conduct"},{"location":"about/code_of_conduct/#code-of-conduct","text":"Be excellent to each other!","title":"Code of Conduct"},{"location":"about/contributing/","text":"Contributing \u00b6 Thanks for thinking about contributing! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR, this way everyone has a chance to chime in and make sure we're all on the same page! Please open an issue to discuss any bugs/bug fixes prior to opening a PR. Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated! All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"about/contributing/#contributing","text":"Thanks for thinking about contributing! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR, this way everyone has a chance to chime in and make sure we're all on the same page! Please open an issue to discuss any bugs/bug fixes prior to opening a PR. Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated! All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"about/thank_you/","text":"Thank You! \u00b6 Thank you to the following people who have made contributions other than (and maybe in addition to) code that have helped make scrapli what it is! Kevin Landreth for helping with the vision for the system transport driver , and putting up with lots of annoying Slack messages while troubleshooting things Dmitry Figol for really helpful guidance on how best to build the API/overall structure of things very early on, and continued support/guidance Javin Craig for very early testing help and extra eyes on loads of readme/docs John (IPvZero) McGovern for loads of testing, encouraging the nornir plugin along, and lots of great discussions Ryan Bradshaw for early testing and discussions on disabling paging, dealing with interactive inputs, and making the paramiko/ssh2-python transports plugins Eric Tedor for some interesting and challenging use cases that helped to improve some of the prompt matching decisions Ron Frederick for building the very awesome asyncssh library! Brett Canter for building the very first scrapli_community platform! (ruckus_fastiron) Alex Lardschneider for great conversation, many contributions to scrapli_community , and helping to improve various pieces of scrapli with great testing and troubleshooting! Marion for loads of testing hard to track down issues with the async transports! Roman Dodin for inspiration to make the docs much better and for adding the doc testing to keep them looking good! netixx for helping unravel some particularly fun decorator timeout shenanigans! The following people have helped identify and report bugs in scrapli, thank you all! Kirill Pletnev IOSXEDriver configuration mode prompt pattern missed pub key config mode Michal D SSH Config not Merging Attributes artyomovs Prompt patterns not matching \"tacacs+\" get_prompt Resetting timeout_ops inadvertently telnet authentication when requiring a return char/telnet auth bypass Dave P Additional enable password prompt format IOSXE Natasha Samoylenko Missing open timeout on asynctelnet transport This list has not been kept up as well as it should, apologies for that! Thank you to everyone else who has contributed in any way to scrapli! Last, but very much not least, a huge shoutout to JetBrains for building awesome tools and providing licenses for their pro tools to open source developers (like me)! If you would like to use JetBrains awesome products, check out their open source support page here for me info.","title":"Thank Yous"},{"location":"about/thank_you/#thank-you","text":"Thank you to the following people who have made contributions other than (and maybe in addition to) code that have helped make scrapli what it is! Kevin Landreth for helping with the vision for the system transport driver , and putting up with lots of annoying Slack messages while troubleshooting things Dmitry Figol for really helpful guidance on how best to build the API/overall structure of things very early on, and continued support/guidance Javin Craig for very early testing help and extra eyes on loads of readme/docs John (IPvZero) McGovern for loads of testing, encouraging the nornir plugin along, and lots of great discussions Ryan Bradshaw for early testing and discussions on disabling paging, dealing with interactive inputs, and making the paramiko/ssh2-python transports plugins Eric Tedor for some interesting and challenging use cases that helped to improve some of the prompt matching decisions Ron Frederick for building the very awesome asyncssh library! Brett Canter for building the very first scrapli_community platform! (ruckus_fastiron) Alex Lardschneider for great conversation, many contributions to scrapli_community , and helping to improve various pieces of scrapli with great testing and troubleshooting! Marion for loads of testing hard to track down issues with the async transports! Roman Dodin for inspiration to make the docs much better and for adding the doc testing to keep them looking good! netixx for helping unravel some particularly fun decorator timeout shenanigans! The following people have helped identify and report bugs in scrapli, thank you all! Kirill Pletnev IOSXEDriver configuration mode prompt pattern missed pub key config mode Michal D SSH Config not Merging Attributes artyomovs Prompt patterns not matching \"tacacs+\" get_prompt Resetting timeout_ops inadvertently telnet authentication when requiring a return char/telnet auth bypass Dave P Additional enable password prompt format IOSXE Natasha Samoylenko Missing open timeout on asynctelnet transport This list has not been kept up as well as it should, apologies for that! Thank you to everyone else who has contributed in any way to scrapli! Last, but very much not least, a huge shoutout to JetBrains for building awesome tools and providing licenses for their pro tools to open source developers (like me)! If you would like to use JetBrains awesome products, check out their open source support page here for me info.","title":"Thank You!"},{"location":"more_scrapli/nornir_scrapli/","text":"Nornir scrapli \u00b6 If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The nornir_scrapli plugin allows you to use scrapli (and scrapli netconf and scrapli cfg) within the Nornir framework!","title":"Nornir Scrapli"},{"location":"more_scrapli/nornir_scrapli/#nornir-scrapli","text":"If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The nornir_scrapli plugin allows you to use scrapli (and scrapli netconf and scrapli cfg) within the Nornir framework!","title":"Nornir scrapli"},{"location":"more_scrapli/scrapli_cfg/","text":"Scrapli Cfg \u00b6 scrapli_cfg ( docs ) is utility that accepts a scrapli Telnet or SSH connection and provides configuration management capabilities. scrapli_cfg allows you to load candidate configurations for merge or replace operations, generate diffs of the current vs candidate, and of course commit or abort the candidate configuration.","title":"Scrapli Cfg"},{"location":"more_scrapli/scrapli_cfg/#scrapli-cfg","text":"scrapli_cfg ( docs ) is utility that accepts a scrapli Telnet or SSH connection and provides configuration management capabilities. scrapli_cfg allows you to load candidate configurations for merge or replace operations, generate diffs of the current vs candidate, and of course commit or abort the candidate configuration.","title":"Scrapli Cfg"},{"location":"more_scrapli/scrapli_community/","text":"Scrapli Community \u00b6 If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_community/#scrapli-community","text":"If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_netconf/","text":"Scrapli Netconf \u00b6 scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_netconf/#scrapli-netconf","text":"scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_replay/","text":"Scrapli Replay \u00b6 scrapli_replay ( docs ) is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that patches and records and replays session data (like vcr.py ) for scrapli connections.","title":"Scrapli Replay"},{"location":"more_scrapli/scrapli_replay/#scrapli-replay","text":"scrapli_replay ( docs ) is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that patches and records and replays session data (like vcr.py ) for scrapli connections.","title":"Scrapli Replay"},{"location":"reference/SUMMARY/","text":"channel async_channel base_channel sync_channel decorators driver base async_driver base_driver sync_driver core arista_eos async_driver base_driver sync_driver cisco_iosxe async_driver base_driver sync_driver cisco_iosxr async_driver base_driver sync_driver cisco_nxos async_driver base_driver sync_driver juniper_junos async_driver base_driver sync_driver generic async_driver base_driver sync_driver network async_driver base_driver sync_driver exceptions factory helper logging response settings ssh_config transport base async_transport base_socket base_transport sync_transport telnet_common plugins asyncssh transport asynctelnet transport paramiko transport ssh2 transport system ptyprocess transport telnet transport","title":"SUMMARY"},{"location":"reference/decorators/","text":"::: decorators","title":"Decorators"},{"location":"reference/exceptions/","text":"::: exceptions","title":"Exceptions"},{"location":"reference/factory/","text":"::: factory","title":"Factory"},{"location":"reference/helper/","text":"::: helper","title":"Helper"},{"location":"reference/logging/","text":"::: logging","title":"Logging"},{"location":"reference/response/","text":"::: response","title":"Response"},{"location":"reference/settings/","text":"::: settings","title":"Settings"},{"location":"reference/ssh_config/","text":"::: ssh_config","title":"Ssh config"},{"location":"reference/channel/","text":"::: channel","title":"Index"},{"location":"reference/channel/async_channel/","text":"::: channel.async_channel","title":"Async channel"},{"location":"reference/channel/base_channel/","text":"::: channel.base_channel","title":"Base channel"},{"location":"reference/channel/sync_channel/","text":"::: channel.sync_channel","title":"Sync channel"},{"location":"reference/driver/","text":"::: driver","title":"Index"},{"location":"reference/driver/base/","text":"::: driver.base","title":"Index"},{"location":"reference/driver/base/async_driver/","text":"::: driver.base.async_driver","title":"Async driver"},{"location":"reference/driver/base/base_driver/","text":"::: driver.base.base_driver","title":"Base driver"},{"location":"reference/driver/base/sync_driver/","text":"::: driver.base.sync_driver","title":"Sync driver"},{"location":"reference/driver/core/","text":"::: driver.core","title":"Index"},{"location":"reference/driver/core/arista_eos/","text":"::: driver.core.arista_eos","title":"Index"},{"location":"reference/driver/core/arista_eos/async_driver/","text":"::: driver.core.arista_eos.async_driver","title":"Async driver"},{"location":"reference/driver/core/arista_eos/base_driver/","text":"::: driver.core.arista_eos.base_driver","title":"Base driver"},{"location":"reference/driver/core/arista_eos/sync_driver/","text":"::: driver.core.arista_eos.sync_driver","title":"Sync driver"},{"location":"reference/driver/core/cisco_iosxe/","text":"::: driver.core.cisco_iosxe","title":"Index"},{"location":"reference/driver/core/cisco_iosxe/async_driver/","text":"::: driver.core.cisco_iosxe.async_driver","title":"Async driver"},{"location":"reference/driver/core/cisco_iosxe/base_driver/","text":"::: driver.core.cisco_iosxe.base_driver","title":"Base driver"},{"location":"reference/driver/core/cisco_iosxe/sync_driver/","text":"::: driver.core.cisco_iosxe.sync_driver","title":"Sync driver"},{"location":"reference/driver/core/cisco_iosxr/","text":"::: driver.core.cisco_iosxr","title":"Index"},{"location":"reference/driver/core/cisco_iosxr/async_driver/","text":"::: driver.core.cisco_iosxr.async_driver","title":"Async driver"},{"location":"reference/driver/core/cisco_iosxr/base_driver/","text":"::: driver.core.cisco_iosxr.base_driver","title":"Base driver"},{"location":"reference/driver/core/cisco_iosxr/sync_driver/","text":"::: driver.core.cisco_iosxr.sync_driver","title":"Sync driver"},{"location":"reference/driver/core/cisco_nxos/","text":"::: driver.core.cisco_nxos","title":"Index"},{"location":"reference/driver/core/cisco_nxos/async_driver/","text":"::: driver.core.cisco_nxos.async_driver","title":"Async driver"},{"location":"reference/driver/core/cisco_nxos/base_driver/","text":"::: driver.core.cisco_nxos.base_driver","title":"Base driver"},{"location":"reference/driver/core/cisco_nxos/sync_driver/","text":"::: driver.core.cisco_nxos.sync_driver","title":"Sync driver"},{"location":"reference/driver/core/juniper_junos/","text":"::: driver.core.juniper_junos","title":"Index"},{"location":"reference/driver/core/juniper_junos/async_driver/","text":"::: driver.core.juniper_junos.async_driver","title":"Async driver"},{"location":"reference/driver/core/juniper_junos/base_driver/","text":"::: driver.core.juniper_junos.base_driver","title":"Base driver"},{"location":"reference/driver/core/juniper_junos/sync_driver/","text":"::: driver.core.juniper_junos.sync_driver","title":"Sync driver"},{"location":"reference/driver/generic/","text":"::: driver.generic","title":"Index"},{"location":"reference/driver/generic/async_driver/","text":"::: driver.generic.async_driver","title":"Async driver"},{"location":"reference/driver/generic/base_driver/","text":"::: driver.generic.base_driver","title":"Base driver"},{"location":"reference/driver/generic/sync_driver/","text":"::: driver.generic.sync_driver","title":"Sync driver"},{"location":"reference/driver/network/","text":"::: driver.network","title":"Index"},{"location":"reference/driver/network/async_driver/","text":"::: driver.network.async_driver","title":"Async driver"},{"location":"reference/driver/network/base_driver/","text":"::: driver.network.base_driver","title":"Base driver"},{"location":"reference/driver/network/sync_driver/","text":"::: driver.network.sync_driver","title":"Sync driver"},{"location":"reference/transport/","text":"::: transport","title":"Index"},{"location":"reference/transport/base/","text":"::: transport.base","title":"Index"},{"location":"reference/transport/base/async_transport/","text":"::: transport.base.async_transport","title":"Async transport"},{"location":"reference/transport/base/base_socket/","text":"::: transport.base.base_socket","title":"Base socket"},{"location":"reference/transport/base/base_transport/","text":"::: transport.base.base_transport","title":"Base transport"},{"location":"reference/transport/base/sync_transport/","text":"::: transport.base.sync_transport","title":"Sync transport"},{"location":"reference/transport/base/telnet_common/","text":"::: transport.base.telnet_common","title":"Telnet common"},{"location":"reference/transport/plugins/","text":"::: transport.plugins","title":"Index"},{"location":"reference/transport/plugins/asyncssh/","text":"::: transport.plugins.asyncssh","title":"Index"},{"location":"reference/transport/plugins/asyncssh/transport/","text":"::: transport.plugins.asyncssh.transport","title":"Transport"},{"location":"reference/transport/plugins/asynctelnet/","text":"::: transport.plugins.asynctelnet","title":"Index"},{"location":"reference/transport/plugins/asynctelnet/transport/","text":"::: transport.plugins.asynctelnet.transport","title":"Transport"},{"location":"reference/transport/plugins/paramiko/","text":"::: transport.plugins.paramiko","title":"Index"},{"location":"reference/transport/plugins/paramiko/transport/","text":"::: transport.plugins.paramiko.transport","title":"Transport"},{"location":"reference/transport/plugins/ssh2/","text":"::: transport.plugins.ssh2","title":"Index"},{"location":"reference/transport/plugins/ssh2/transport/","text":"::: transport.plugins.ssh2.transport","title":"Transport"},{"location":"reference/transport/plugins/system/","text":"::: transport.plugins.system","title":"Index"},{"location":"reference/transport/plugins/system/ptyprocess/","text":"::: transport.plugins.system.ptyprocess","title":"Ptyprocess"},{"location":"reference/transport/plugins/system/transport/","text":"::: transport.plugins.system.transport","title":"Transport"},{"location":"reference/transport/plugins/telnet/","text":"::: transport.plugins.telnet","title":"Index"},{"location":"reference/transport/plugins/telnet/transport/","text":"::: transport.plugins.telnet.transport","title":"Transport"},{"location":"user_guide/advanced_usage/","text":"Advanced Usage \u00b6 All Driver Arguments \u00b6 The basic usage section outlined the most commonly used driver arguments, please see the following pages to see all supported driver arguments: Base Driver Arguments GenericDriver Arguments NetworkDriver Arguments Most of these attributes actually get passed from the Driver (or sub-class such as NXOSDriver ) into the Transport and Channel classes, so if you need to modify any of these values after instantiation you should do so on the appropriate object -- i.e. conn.channel.comms_prompt_pattern . Platform Regex \u00b6 Due to the nature of Telnet/SSH there is no good way to know when a command has completed execution. Put another way , when sending any command, data is returned over a socket, that socket doesn't ever tell us when it is \"done \" sending the output from the command that was executed. In order to know when the session is \"back at the base prompt/starting point\" scrapli uses a regular expression pattern to find that base prompt. This pattern is contained in the comms_prompt_pattern setting or is created by joining all possible prompt patterns in the privilege levels for a \"core\" device type. In general, you should not change the patterns unless you have a good reason to do so! The \"base\" Driver (default, but changeable) pattern is: \"^[a-z0-9.\\-@()/:]{1,48}[#>$]\\s*$\" NOTE all comms_prompt_pattern \"should\" use the start and end of line anchors as all regex searches in scrapli are multi-line (this is an important piece to making this all work!). While you don't need to use the line anchors its probably a really good idea! Also note that most devices seem to leave at least one white space after the final character of the prompt, so make sure to account for this! Last important note -- the core drivers all have reliable patterns set for you, so you hopefully don't need to bother with this too much! The above pattern works on all \"core\" platforms listed above for at the very least basic usage. Custom prompts or host names could in theory break this, so be careful! If you use a platform driver, the base prompt is set in the driver, so you don't really need to worry about this! The comms_prompt_pattern pattern can be changed at any time at or after instantiation of a scrapli object, and is done so by modifying conn.channel.comms_prompt_pattern where conn is your scrapli connection object. Changing this can break things though, so be careful! If using any NetworkDriver sub-classes you should modify the privilege level(s) if necessary, and not the comms_prompt_pattern . On Open \u00b6 Lots of times when connecting to a device there are \"things\" that need to happen immediately after getting connected . In the context of network devices the most obvious/common example would be disabling paging (i.e. sending terminal length 0 on a Cisco-type device). While scrapli Driver (the base driver) and GenericDriver do not know or care about disabling paging or any other on connect type activities, scrapli of course provides a mechanism for allowing users to handle these types of tasks. Even better yet, if you are using any of the core drivers ( IOSXEDriver , IOSXRDriver , etc.), scrapli will automatically have some sane default \"on connect\" actions (namely disabling paging). If you were so inclined to create some of your own \"on connect\" actions, you can simply pass those to the on_open argument of Scrape or any of its sub-classes ( NetworkDriver , IOSXEDriver , etc.). The value of this argument must be a callable that accepts the reference to the connection object. This allows for the user to send commands or do really anything that needs to happen prior to \"normal\" operations. The core network drivers disable paging functions all call directly into the channel object send_input method -- this is a good practice to follow as this will avoid any of the NetworkDriver overhead such as trying to attain privilege levels -- things like this may not be \"ready\" until after your on_open function is executed. Below is an example of creating an \"on connect\" function and passing it to scrapli. Immediately after authentication is handled this function will be called and disable paging (in this example): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli.driver.core import IOSXEDriver def iosxe_disable_paging ( conn ): conn . channel . send_input ( \"term length 0\" ) my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"on_open\" : iosxe_disable_paging } with IOSXEDriver ( ** my_device ) as conn : print ( conn . get_prompt ()) Note that this section has talked almost exclusively about disabling paging, but any other \"things\" that need to happen in the channel can be handled here. If there is a prompt/banner to accept you should be able to handle it here. The goal of this \"on connect\" function is to allow for lots of flexibility for dealing with whatever needs to happen for devices -- thus decoupling the challenge of addressing all of the possible options from scrapli itself and allowing users to handle things specific for their environment. Lastly, while the on_open method should be synchronous or asyncio depending on the driver -- meaning that if using an async driver, it will await the on_open callable, so it must be asynchronous! On Close \u00b6 As you may have guessed, on_close is very similar to on_open with the obvious difference that it happens just prior to disconnecting from the device. Just like on_open , on_close functions should accept a single argument that is a reference to the object itself. As with most things scrapli, there are sane defaults for the on_close functions, but you are welcome to override them with your own function if you so chose! Timeouts \u00b6 scrapli supports several timeout options: timeout_socket timeout_transport timeout_ops timeout_socket is exactly what it sounds where possible. For the ssh2 and paramiko transports we create our own socket and pass this to the created object (paramiko or ssh2 object). The socket is created with the timeout value set in the timeout_socket attribute. For telnet and system transports we do not create a socket ourselves so this value is used slightly differently. For telnet, the timeout_socket is used as the timeout for telnet session creation. After the telnet session is created the timeout is reset to the timeout_transport value (more on that in a second). For system transport, timeout_socket governs the ConnectTimeout ssh argument -- which seems to be very similar to socket timeout in paramiko/ssh2. timeout_transport is intended to govern the timeout for the actual transport mechanism itself. For paramiko and ssh2, this is set to the respective libraries timeout attributes. For telnet, this is set to the telnetlib timeout value after the initial telnet session is stood up. For system transport, this value is used as the timeout value for read and write operations (handled by operation timeout decorator). Finally, timeout_ops sets a timeout value for individual operations -- or put another way, the timeout for each send_input operation. Driver Privilege Levels \u00b6 The \"core\" drivers understand the basic privilege levels of their respective device types. As mentioned previously , the drivers will automatically attain the \"privilege_exec\" (or equivalent) privilege level prior to executing \"show \" commands. If you don't want this \"auto-magic\" you can use the base driver ( Driver ) or the GenericDriver . The privileges for each device are outlined in the platforms driver.py file - each privilege is an object of the base PrivilegeLevel class which uses slots for the attributes. This used to be a named tuple, however as this was immutable it was a bit of a pain for users to modify things on the fly. As an example, the following privilege levels are supported by the IOSXEDriver : \"exec\" \"privilege_exec\" \"configuration\" Each privilege level has the following attributes: pattern: regex pattern to associate prompt to privilege level with name: name of the priv level, i.e. \"exec\" previous_priv: name of the \"lower\"/\"previous\" privilege level deescalate: command used to deescalate from this privilege level (or an empty string if no lower privilege) escalate: command used to escalate to this privilege level (from the lower/previous privilege) escalate_auth: True/False there is auth required to escalate to this privilege level escalate_prompt: pattern to expect when escalating to this privilege level, i.e. \"Password:\" or any empty string If you wish to manually enter a privilege level you can use the acquire_priv method, passing in the name of the privilege level you would like to enter. In general, you probably won't need this too often though as the driver should handle much of this for you. 1 2 3 4 5 6 7 8 9 10 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : conn . acquire_priv ( \"configuration\" ) Configure Exclusive and Configure Private (IOSXR/Junos) \u00b6 IOSXR and Junos platforms have different configuration modes, such as \"configure exclusive\" or \"configure private \". These alternate configuration modes are represented as a privilege level just like the \"regular\" configuration mode. You can acquire an \"exclusive\" configuration session on IOSXR as follows: 1 2 3 4 5 6 7 8 9 10 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXRDriver ( ** my_device ) as conn : conn . acquire_priv ( \"configuration_exclusive\" ) Of course you can also pass this privilege level name to the send_configs or send_configs_from_file methods as well: 1 2 3 4 5 6 7 8 9 10 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXRDriver ( ** my_device ) as conn : conn . send_configs ( configs = [ \"configure things\" ], privilege_level = \"configuration_exclusive\" ) Note that the name of the privilege level is \"configuration_exclusive\" -- don't forget to write the whole thing out! Configure Session (EOS/NXOS) \u00b6 EOS and NXOS devices support configuration \"sessions\", these sessions are a little bit of a special case for scrapli . In order to use a configuration session, the configuration session must first be \"registered\" with scrapli -- this is so that scrapli can create a privilege level that is mapped to the given config session/config session name . The register_configuration_session method that accepts a string name of the configuration session you would like to create -- note that this method raises a NotImplementedError for platforms that do not support config sessions . The register_configuration_session method creates a new privilege level for you and updates the transport class with the appropriate information internally (see next section). An example of creating a session for an EOS device called \"my-config-session\" can be seen here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from scrapli.driver.core import EOSDriver my_device = { \"host\" : \"172.18.0.14\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_secondary\" : \"VR-netlab9\" , \"auth_strict_key\" : False , } with EOSDriver ( ** my_device ) as conn : conn . register_configuration_session ( session_name = \"my-config-session\" ) print ( conn . privilege_levels [ \"my-config-session\" ]) print ( conn . privilege_levels [ \"my-config-session\" ] . name ) print ( conn . privilege_levels [ \"my-config-session\" ] . pattern ) 1 2 3 <scrapli.driver.network_driver.PrivilegeLevel object at 0x7fca10070820> my-config-session ^[a-z0-9.\\-@/:]{1,32}\\(config\\-s\\-my\\-con[a-z0-9_.\\-@/:]{0,32}\\)#\\s?$ Modifying Privilege Levels \u00b6 When creating a configuration session, or modifying a privilege level during runtime, scrapli needs to update some internal arguments in order to always have a full \"map\" of how to escalate/deescalate, as well as to be able to match prompts based on any/all of the patterns available in the privilege levels dictionary. The register_configuration_session method will automatically handle updating these internal arguments, however if you modify any of the privilege levels (or add a priv level on the fly without using the register method) then you will need to manually call the update_privilege_levels method. Using Driver Directly \u00b6 All examples in this readme have shown using the \"core\" network drivers such as IOSXEDriver . These core network drivers are actually sub-classes of an ABC called NetworkDriver which itself is a sub-class of the GenericDriver which is a sub-class of the base Scrape class -- the namesake for this library. The Driver object can be used directly if you prefer to have a much less opinionated or less \"auto-magic\" type experience. Driver does not provide the same send_command / send_commands / send_configs methods, nor does it disable paging, or handle any kind of privilege escalation/de-escalation. Driver is a much more basic \"paramiko\"-like experience. Below is a brief example of using the Driver object directly: 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli import Driver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with Driver ( ** my_device ) as conn : conn . channel . send_input ( \"terminal length 0\" ) response = conn . channel . send_input ( \"show version\" ) Without the send_command and similar methods, you must directly access the Channel object when sending inputs with Scrape . Using the GenericDriver \u00b6 Using the Driver driver directly is nice enough, however you may not want to have to change the prompt pattern, or deal with accessing the channel to send commands to the device. In this case there is a GenericDriver available to you. This driver has a very broad pattern that it matches for base prompts, has no concept of disabling paging or privilege levels (like Driver ), but does provide send_command , send_commands , send_interactive , and get_prompt methods for a more NetworkDriver-like experience. Hopefully this GenericDriver can be used as a starting point for devices that don't fall under the core supported platforms list. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver import GenericDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with GenericDriver ( ** my_device ) as conn : conn . send_command ( \"terminal length 0\" ) response = conn . send_command ( \"show version\" ) responses = conn . send_commands ([ \"show version\" , \"show run\" ]) Using a Different Transport \u00b6 scrapli is built to be very flexible, including being flexible enough to use different libraries for \"transport \" -- or the actual Telnet/SSH communication. By default, scrapli uses the \"system\" transport which quite literally uses the ssh binary on your system ( /usr/bin/ssh ). This \"system\" transport means that scrapli has no external dependencies as it just relies on what is available on the machine running the scrapli script. In the spirit of being highly flexible, scrapli allows users to swap out this \"system\" transport with another transport mechanism. The other supported transport plugins are paramiko , ssh2-python , telnetlib , asyncssh , and asynctelnet . The transport selection can be made when instantiating the scrapli connection object by passing in paramiko , ssh2 , telnet , asyncssh , or asynctelnet to force scrapli to use the corresponding transport mechanism. If you are using one of the async transports you must use an async driver! While it will be a goal to ensure that these other transport mechanisms are supported and useful, the focus of scrapli development will be on the \"system\" SSH transport. Example using paramiko as the transport: 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"transport\" : \"paramiko\" } with IOSXEDriver ( ** my_device ) as conn : print ( conn . get_prompt ()) Currently, the only reason I can think of to use anything other than \"system\" as the transport would be to test scrapli on a Windows host, to use telnet, to use ssh2 for super speed, or to use asyncio. If there are other good reasons please do let me know! Auth Bypass \u00b6 NOTE only supported with system and telnet transports! Some devices, such as Cisco WLC, have no \"true\" SSH authentication, and instead prompt for credentials (or perhaps not even that) after session establishment. In order to cope with this corner case, the auth_bypass flag can be set to True which will cause scrapli to skip all authentication steps. Typically, this flag would be set and a custom on_open function set to handle whatever prompts the device has upon SSH session establishment. See the non core device example to see this in action. Transport Options \u00b6 Because each transport has different options/features available, it doesn't make sense to try to put all possible arguments in the Driver or NetworkDriver drivers, to address this an argument transport_options has been added . This is exactly what it sounds like -- arguments that can be passed to the selected transport class. As these arguments will be transport-specific, please check the docs/docstrings for your preferred transport to see what is available. A simple example of passing additional SSH arguments to the SystemSSHTransport class is available here . Raise For Status \u00b6 The scrapli Response and MultiResponse objects both contain a method called raise_for_status . This method's purpose is to provide a very simple way to raise an exception if any of the commands or configs sent in a method have failed. 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : commands = [ \"show run\" , \"tacocat\" , \"show version\" ] responses = conn . send_commands ( commands = commands ) Inspecting the responses object from the above example, we can see that it indeed is marked as Success: False , even though the first and last commands were successful: 1 2 3 4 5 6 7 8 >>> responses MultiResponse < Success : False ; Response Elements : 3 > >>> responses [ 0 ] Response < Success : True > >>> responses [ 1 ] Response < Success : False > >>> responses [ 2 ] Response < Success : True > Finally, we can all the raise_for_status method to have scrapli raise the ScrapliCommandFailure exception if any of the configs/commands failed: 1 2 3 4 5 6 >>> responses . raise_for_status () Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/Users/carl/dev/github/scrapli/scrapli/response.py\" , line 270 , in raise_for_status raise ScrapliCommandFailure () scrapli . exceptions . ScrapliCommandFailure","title":"Advanced Usage"},{"location":"user_guide/advanced_usage/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"user_guide/advanced_usage/#all-driver-arguments","text":"The basic usage section outlined the most commonly used driver arguments, please see the following pages to see all supported driver arguments: Base Driver Arguments GenericDriver Arguments NetworkDriver Arguments Most of these attributes actually get passed from the Driver (or sub-class such as NXOSDriver ) into the Transport and Channel classes, so if you need to modify any of these values after instantiation you should do so on the appropriate object -- i.e. conn.channel.comms_prompt_pattern .","title":"All Driver Arguments"},{"location":"user_guide/advanced_usage/#platform-regex","text":"Due to the nature of Telnet/SSH there is no good way to know when a command has completed execution. Put another way , when sending any command, data is returned over a socket, that socket doesn't ever tell us when it is \"done \" sending the output from the command that was executed. In order to know when the session is \"back at the base prompt/starting point\" scrapli uses a regular expression pattern to find that base prompt. This pattern is contained in the comms_prompt_pattern setting or is created by joining all possible prompt patterns in the privilege levels for a \"core\" device type. In general, you should not change the patterns unless you have a good reason to do so! The \"base\" Driver (default, but changeable) pattern is: \"^[a-z0-9.\\-@()/:]{1,48}[#>$]\\s*$\" NOTE all comms_prompt_pattern \"should\" use the start and end of line anchors as all regex searches in scrapli are multi-line (this is an important piece to making this all work!). While you don't need to use the line anchors its probably a really good idea! Also note that most devices seem to leave at least one white space after the final character of the prompt, so make sure to account for this! Last important note -- the core drivers all have reliable patterns set for you, so you hopefully don't need to bother with this too much! The above pattern works on all \"core\" platforms listed above for at the very least basic usage. Custom prompts or host names could in theory break this, so be careful! If you use a platform driver, the base prompt is set in the driver, so you don't really need to worry about this! The comms_prompt_pattern pattern can be changed at any time at or after instantiation of a scrapli object, and is done so by modifying conn.channel.comms_prompt_pattern where conn is your scrapli connection object. Changing this can break things though, so be careful! If using any NetworkDriver sub-classes you should modify the privilege level(s) if necessary, and not the comms_prompt_pattern .","title":"Platform Regex"},{"location":"user_guide/advanced_usage/#on-open","text":"Lots of times when connecting to a device there are \"things\" that need to happen immediately after getting connected . In the context of network devices the most obvious/common example would be disabling paging (i.e. sending terminal length 0 on a Cisco-type device). While scrapli Driver (the base driver) and GenericDriver do not know or care about disabling paging or any other on connect type activities, scrapli of course provides a mechanism for allowing users to handle these types of tasks. Even better yet, if you are using any of the core drivers ( IOSXEDriver , IOSXRDriver , etc.), scrapli will automatically have some sane default \"on connect\" actions (namely disabling paging). If you were so inclined to create some of your own \"on connect\" actions, you can simply pass those to the on_open argument of Scrape or any of its sub-classes ( NetworkDriver , IOSXEDriver , etc.). The value of this argument must be a callable that accepts the reference to the connection object. This allows for the user to send commands or do really anything that needs to happen prior to \"normal\" operations. The core network drivers disable paging functions all call directly into the channel object send_input method -- this is a good practice to follow as this will avoid any of the NetworkDriver overhead such as trying to attain privilege levels -- things like this may not be \"ready\" until after your on_open function is executed. Below is an example of creating an \"on connect\" function and passing it to scrapli. Immediately after authentication is handled this function will be called and disable paging (in this example): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli.driver.core import IOSXEDriver def iosxe_disable_paging ( conn ): conn . channel . send_input ( \"term length 0\" ) my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"on_open\" : iosxe_disable_paging } with IOSXEDriver ( ** my_device ) as conn : print ( conn . get_prompt ()) Note that this section has talked almost exclusively about disabling paging, but any other \"things\" that need to happen in the channel can be handled here. If there is a prompt/banner to accept you should be able to handle it here. The goal of this \"on connect\" function is to allow for lots of flexibility for dealing with whatever needs to happen for devices -- thus decoupling the challenge of addressing all of the possible options from scrapli itself and allowing users to handle things specific for their environment. Lastly, while the on_open method should be synchronous or asyncio depending on the driver -- meaning that if using an async driver, it will await the on_open callable, so it must be asynchronous!","title":"On Open"},{"location":"user_guide/advanced_usage/#on-close","text":"As you may have guessed, on_close is very similar to on_open with the obvious difference that it happens just prior to disconnecting from the device. Just like on_open , on_close functions should accept a single argument that is a reference to the object itself. As with most things scrapli, there are sane defaults for the on_close functions, but you are welcome to override them with your own function if you so chose!","title":"On Close"},{"location":"user_guide/advanced_usage/#timeouts","text":"scrapli supports several timeout options: timeout_socket timeout_transport timeout_ops timeout_socket is exactly what it sounds where possible. For the ssh2 and paramiko transports we create our own socket and pass this to the created object (paramiko or ssh2 object). The socket is created with the timeout value set in the timeout_socket attribute. For telnet and system transports we do not create a socket ourselves so this value is used slightly differently. For telnet, the timeout_socket is used as the timeout for telnet session creation. After the telnet session is created the timeout is reset to the timeout_transport value (more on that in a second). For system transport, timeout_socket governs the ConnectTimeout ssh argument -- which seems to be very similar to socket timeout in paramiko/ssh2. timeout_transport is intended to govern the timeout for the actual transport mechanism itself. For paramiko and ssh2, this is set to the respective libraries timeout attributes. For telnet, this is set to the telnetlib timeout value after the initial telnet session is stood up. For system transport, this value is used as the timeout value for read and write operations (handled by operation timeout decorator). Finally, timeout_ops sets a timeout value for individual operations -- or put another way, the timeout for each send_input operation.","title":"Timeouts"},{"location":"user_guide/advanced_usage/#driver-privilege-levels","text":"The \"core\" drivers understand the basic privilege levels of their respective device types. As mentioned previously , the drivers will automatically attain the \"privilege_exec\" (or equivalent) privilege level prior to executing \"show \" commands. If you don't want this \"auto-magic\" you can use the base driver ( Driver ) or the GenericDriver . The privileges for each device are outlined in the platforms driver.py file - each privilege is an object of the base PrivilegeLevel class which uses slots for the attributes. This used to be a named tuple, however as this was immutable it was a bit of a pain for users to modify things on the fly. As an example, the following privilege levels are supported by the IOSXEDriver : \"exec\" \"privilege_exec\" \"configuration\" Each privilege level has the following attributes: pattern: regex pattern to associate prompt to privilege level with name: name of the priv level, i.e. \"exec\" previous_priv: name of the \"lower\"/\"previous\" privilege level deescalate: command used to deescalate from this privilege level (or an empty string if no lower privilege) escalate: command used to escalate to this privilege level (from the lower/previous privilege) escalate_auth: True/False there is auth required to escalate to this privilege level escalate_prompt: pattern to expect when escalating to this privilege level, i.e. \"Password:\" or any empty string If you wish to manually enter a privilege level you can use the acquire_priv method, passing in the name of the privilege level you would like to enter. In general, you probably won't need this too often though as the driver should handle much of this for you. 1 2 3 4 5 6 7 8 9 10 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : conn . acquire_priv ( \"configuration\" )","title":"Driver Privilege Levels"},{"location":"user_guide/advanced_usage/#configure-exclusive-and-configure-private-iosxrjunos","text":"IOSXR and Junos platforms have different configuration modes, such as \"configure exclusive\" or \"configure private \". These alternate configuration modes are represented as a privilege level just like the \"regular\" configuration mode. You can acquire an \"exclusive\" configuration session on IOSXR as follows: 1 2 3 4 5 6 7 8 9 10 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXRDriver ( ** my_device ) as conn : conn . acquire_priv ( \"configuration_exclusive\" ) Of course you can also pass this privilege level name to the send_configs or send_configs_from_file methods as well: 1 2 3 4 5 6 7 8 9 10 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXRDriver ( ** my_device ) as conn : conn . send_configs ( configs = [ \"configure things\" ], privilege_level = \"configuration_exclusive\" ) Note that the name of the privilege level is \"configuration_exclusive\" -- don't forget to write the whole thing out!","title":"Configure Exclusive and Configure Private (IOSXR/Junos)"},{"location":"user_guide/advanced_usage/#configure-session-eosnxos","text":"EOS and NXOS devices support configuration \"sessions\", these sessions are a little bit of a special case for scrapli . In order to use a configuration session, the configuration session must first be \"registered\" with scrapli -- this is so that scrapli can create a privilege level that is mapped to the given config session/config session name . The register_configuration_session method that accepts a string name of the configuration session you would like to create -- note that this method raises a NotImplementedError for platforms that do not support config sessions . The register_configuration_session method creates a new privilege level for you and updates the transport class with the appropriate information internally (see next section). An example of creating a session for an EOS device called \"my-config-session\" can be seen here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from scrapli.driver.core import EOSDriver my_device = { \"host\" : \"172.18.0.14\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_secondary\" : \"VR-netlab9\" , \"auth_strict_key\" : False , } with EOSDriver ( ** my_device ) as conn : conn . register_configuration_session ( session_name = \"my-config-session\" ) print ( conn . privilege_levels [ \"my-config-session\" ]) print ( conn . privilege_levels [ \"my-config-session\" ] . name ) print ( conn . privilege_levels [ \"my-config-session\" ] . pattern ) 1 2 3 <scrapli.driver.network_driver.PrivilegeLevel object at 0x7fca10070820> my-config-session ^[a-z0-9.\\-@/:]{1,32}\\(config\\-s\\-my\\-con[a-z0-9_.\\-@/:]{0,32}\\)#\\s?$","title":"Configure Session (EOS/NXOS)"},{"location":"user_guide/advanced_usage/#modifying-privilege-levels","text":"When creating a configuration session, or modifying a privilege level during runtime, scrapli needs to update some internal arguments in order to always have a full \"map\" of how to escalate/deescalate, as well as to be able to match prompts based on any/all of the patterns available in the privilege levels dictionary. The register_configuration_session method will automatically handle updating these internal arguments, however if you modify any of the privilege levels (or add a priv level on the fly without using the register method) then you will need to manually call the update_privilege_levels method.","title":"Modifying Privilege Levels"},{"location":"user_guide/advanced_usage/#using-driver-directly","text":"All examples in this readme have shown using the \"core\" network drivers such as IOSXEDriver . These core network drivers are actually sub-classes of an ABC called NetworkDriver which itself is a sub-class of the GenericDriver which is a sub-class of the base Scrape class -- the namesake for this library. The Driver object can be used directly if you prefer to have a much less opinionated or less \"auto-magic\" type experience. Driver does not provide the same send_command / send_commands / send_configs methods, nor does it disable paging, or handle any kind of privilege escalation/de-escalation. Driver is a much more basic \"paramiko\"-like experience. Below is a brief example of using the Driver object directly: 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli import Driver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with Driver ( ** my_device ) as conn : conn . channel . send_input ( \"terminal length 0\" ) response = conn . channel . send_input ( \"show version\" ) Without the send_command and similar methods, you must directly access the Channel object when sending inputs with Scrape .","title":"Using Driver Directly"},{"location":"user_guide/advanced_usage/#using-the-genericdriver","text":"Using the Driver driver directly is nice enough, however you may not want to have to change the prompt pattern, or deal with accessing the channel to send commands to the device. In this case there is a GenericDriver available to you. This driver has a very broad pattern that it matches for base prompts, has no concept of disabling paging or privilege levels (like Driver ), but does provide send_command , send_commands , send_interactive , and get_prompt methods for a more NetworkDriver-like experience. Hopefully this GenericDriver can be used as a starting point for devices that don't fall under the core supported platforms list. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver import GenericDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with GenericDriver ( ** my_device ) as conn : conn . send_command ( \"terminal length 0\" ) response = conn . send_command ( \"show version\" ) responses = conn . send_commands ([ \"show version\" , \"show run\" ])","title":"Using the GenericDriver"},{"location":"user_guide/advanced_usage/#using-a-different-transport","text":"scrapli is built to be very flexible, including being flexible enough to use different libraries for \"transport \" -- or the actual Telnet/SSH communication. By default, scrapli uses the \"system\" transport which quite literally uses the ssh binary on your system ( /usr/bin/ssh ). This \"system\" transport means that scrapli has no external dependencies as it just relies on what is available on the machine running the scrapli script. In the spirit of being highly flexible, scrapli allows users to swap out this \"system\" transport with another transport mechanism. The other supported transport plugins are paramiko , ssh2-python , telnetlib , asyncssh , and asynctelnet . The transport selection can be made when instantiating the scrapli connection object by passing in paramiko , ssh2 , telnet , asyncssh , or asynctelnet to force scrapli to use the corresponding transport mechanism. If you are using one of the async transports you must use an async driver! While it will be a goal to ensure that these other transport mechanisms are supported and useful, the focus of scrapli development will be on the \"system\" SSH transport. Example using paramiko as the transport: 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"transport\" : \"paramiko\" } with IOSXEDriver ( ** my_device ) as conn : print ( conn . get_prompt ()) Currently, the only reason I can think of to use anything other than \"system\" as the transport would be to test scrapli on a Windows host, to use telnet, to use ssh2 for super speed, or to use asyncio. If there are other good reasons please do let me know!","title":"Using a Different Transport"},{"location":"user_guide/advanced_usage/#auth-bypass","text":"NOTE only supported with system and telnet transports! Some devices, such as Cisco WLC, have no \"true\" SSH authentication, and instead prompt for credentials (or perhaps not even that) after session establishment. In order to cope with this corner case, the auth_bypass flag can be set to True which will cause scrapli to skip all authentication steps. Typically, this flag would be set and a custom on_open function set to handle whatever prompts the device has upon SSH session establishment. See the non core device example to see this in action.","title":"Auth Bypass"},{"location":"user_guide/advanced_usage/#transport-options","text":"Because each transport has different options/features available, it doesn't make sense to try to put all possible arguments in the Driver or NetworkDriver drivers, to address this an argument transport_options has been added . This is exactly what it sounds like -- arguments that can be passed to the selected transport class. As these arguments will be transport-specific, please check the docs/docstrings for your preferred transport to see what is available. A simple example of passing additional SSH arguments to the SystemSSHTransport class is available here .","title":"Transport Options"},{"location":"user_guide/advanced_usage/#raise-for-status","text":"The scrapli Response and MultiResponse objects both contain a method called raise_for_status . This method's purpose is to provide a very simple way to raise an exception if any of the commands or configs sent in a method have failed. 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : commands = [ \"show run\" , \"tacocat\" , \"show version\" ] responses = conn . send_commands ( commands = commands ) Inspecting the responses object from the above example, we can see that it indeed is marked as Success: False , even though the first and last commands were successful: 1 2 3 4 5 6 7 8 >>> responses MultiResponse < Success : False ; Response Elements : 3 > >>> responses [ 0 ] Response < Success : True > >>> responses [ 1 ] Response < Success : False > >>> responses [ 2 ] Response < Success : True > Finally, we can all the raise_for_status method to have scrapli raise the ScrapliCommandFailure exception if any of the configs/commands failed: 1 2 3 4 5 6 >>> responses . raise_for_status () Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/Users/carl/dev/github/scrapli/scrapli/response.py\" , line 270 , in raise_for_status raise ScrapliCommandFailure () scrapli . exceptions . ScrapliCommandFailure","title":"Raise For Status"},{"location":"user_guide/basic_usage/","text":"Basic Usage \u00b6 Picking the right Driver \u00b6 Assuming you are using scrapli to connect to one of the five \"core\" platforms, you should almost always use the provided corresponding \"core\" driver. For example if you are connecting to an Arista EOS device, you should use the EOSDriver . You can select this driver \"manually\" or using the scrapli factory Scrapli (or the async scrapli factory AsyncScrapli ). Importing your driver manually looks like this: 1 from scrapli.driver.core import EOSDriver If you are using asyncio, you can use the async variant of the driver: 1 from scrapli.driver.core import AsyncEOSDriver The core drivers and associated platforms are outlined below: Platform/OS Scrapli Driver Scrapli Async Driver Platform Name Cisco IOS-XE IOSXEDriver AsyncIOSXEDriver cisco_iosxe Cisco NX-OS NXOSDriver AsyncNXOSDriver cisco_nxos Cisco IOS-XR IOSXRDriver AsyncIOSXRDriver cisco_iosxr Arista EOS EOSDriver AsyncEOSDriver arista_eos Juniper JunOS JunosDriver AsyncJunosDriver juniper_junos All drivers can be imported from scrapli.driver.core . If you would rather use the factory class to dynamically select the appropriate driver based on a platform string (as seen in the above table), you can do so as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli import Scrapli device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) conn . open () print ( conn . get_prompt ()) Note that the Scrapli and AsyncScrapli classes inherit from the NetworkDriver and AsyncNetworkDriver classes respectively, so all editor code completion and type indicating behavior should work nicely! For non \"core \" platforms please see the scrapli_community project . If you are working with a platform not listed above (and/or is not in the scrapli community project), you have three options: You can use the (base) Driver driver directly, which you can read about here You can use the GenericDriver which you can read about here You can use the NetworkDriver which is similar to option 2 but you will need to understand/provide privilege /prompt information so scrapli can properly escalate/deescalate to/from configuration (or other) modes. In general you should probably simply create a scrapli community platform (read about adding a platform here , but failing that the GenericDriver is probably the simplest path forward. Note: if you are using async you must set the transport to asyncssh or asynctelnet ! Basic Driver Arguments \u00b6 The drivers of course need some information about the device you are trying to connect to. The most common arguments to provide to the driver are outlined below: Argument Purpose/Value host name/ip of host to connect to port port of host to connect to (defaults to port 22) auth_username username for authentication auth_password password for authentication auth_secondary password for secondary authentication (enable password) auth_private_key private key for authentication auth_strict_key strict key checking -- TRUE by default! ssh_config_file True/False or path to ssh config file to use These arguments may be passed as keyword arguments to the driver of your choice, or, commonly are passed via dictionary unpacking as show below: 1 2 3 4 5 6 7 8 9 10 11 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXRDriver ( ** my_device ) conn . open () NOTE that scrapli enables strict host key checking by default! Opening and Closing a Connection \u00b6 scrapli does not open the connection for you when creating your scrapli connection object in normal operations, you must manually call the open method prior to sending any commands to the device as shown below. 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXRDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show version\" ) Connections can be closed by calling the close method: 1 conn . close () scrapli also supports using a context manager ( with block), when using the context manager the connection will be automatically opened and closed for you. 1 2 3 4 5 6 7 8 9 10 11 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" ) Sending Commands \u00b6 When using any of the core network drivers ( JunosDriver , EOSDriver , etc.) or the GenericDriver , the send_command and send_commands methods will respectively send a single command or list of commands to the device. When using the core network drivers, the command(s) will be sent at the default_desired_privilege_level level which is typically \"privilege exec\" (or equivalent) privilege level. Please see Driver Privilege Levels in the advanced usage section for more details on privilege levels. As the GenericDriver doesn't know or care about privilege levels you would need to manually handle acquiring the appropriate privilege level for you command yourself if using that driver. Note the different methods for sending a single command versus a list of commands! 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXEDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show version\" ) responses = conn . send_commands ([ \"show run\" , \"show ip int brief\" ]) Finally, if you prefer to have a file containing a list of commands to send, there is a send_commands_from_file method . This method excepts the provided file to have a single command to send per line in the file. Response Object \u00b6 All command/config operations that happen in the GenericDriver or any of the drivers inheriting from the NetworkDriver result in a Response object being created. The Response object contains attributes for the command sent ( channel_input ), start/end/elapsed time, and of course the result of the command sent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXEDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show version\" ) print ( response . elapsed_time ) print ( response . result ) If using send_commands (plural!) then scrapli will return a MultiResponse object containing multiple Response objects. The MultiResponse object is for all intents and purposes just a list of Response objects (with a few very minor differences). In addition to containing the input and output of the command(s) that you sent, the Response object also contains a method textfsm_parse_output (for more on TextFSM support see Textfsm/NTC-Templates Integration ) which will attempt to parse and return the received output. If parsing fails, the value returned will be an empty list -- meaning you will always get \"structured data\" returned, however it will just be an empty object if parsing fails. 1 2 3 >>> structured_result = response . textfsm_parse_output () >>> print ( structured_result ) [[ '16.4.1' , 'IOS-XE' , 'csr1000v' , '2 days, 22 hours, 10 minutes' , 'reload' , 'packages.conf' , [ 'CSR1000V' ], [ '9FKLJWM5EB0' ], '0x2102' , []]] Sending Configurations \u00b6 When using any of the core drivers, you can send configurations via the send_config , send_configs or send_configs_from_file methods which will handle privilege escalation for you. send_config accepts a single string, send_configs accepts a list of strings, and of course send_configs_from_file accepts a string path to a file containing configurations to send. Note that send_configs_from_file -- just like with it's commands sibling -- will treat each line in the file as a configuration element, in this way it behaves much like send_configs . Lastly, it is good to know that send_config (singular!) will parse the configuration string provided and split it into lines -- this means that the underlying behavior is the same as send_configs , however this method returns a single Response object. This send_config method can be used to send entire configurations to devices in a reliable fashion. 1 2 3 4 5 6 7 8 9 10 11 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : conn . send_configs ([ \"interface loopback123\" , \"description configured by scrapli\" ]) If you need to get into any kind of \"special\" configuration mode, such as \"configure exclusive\", \"configure private \", or \"configure session XYZ\", you can pass the name of the corresponding privilege level via the privilege_level argument. Please see the Driver Privilege Levels section for more details! Lastly, note that scrapli does not exit configuration mode at completion of a \"configuration\" event -- this is because scrapli (with the Network drivers) will automatically acquire default_desired_privilege_level before sending a \"command\" -- so there is no need, from a scrapli perspective, to explicitly exit config mode at end of the configuration session. Textfsm/NTC-Templates Integration \u00b6 scrapli supports parsing output with TextFSM and ntc-templates. This of course requires installing TextFSM and having ntc-templates somewhere on your system. When using a platform driver (i.e. IOSXEDriver ) the textfsm-platform will be set for you (based on the driver device type). If you wish to parse the output of your send commands, you can use the textfsm_parse_output method of the response object. This method will attempt to find the template for you -- based on the textfsm-platform and the channel-input (the command sent). If textfsm parsing succeeds, the structured result is returned. If textfsm parsing fails, an empty list is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" ) structured_result = response . textfsm_parse_output () print ( structured_result ) scrapli also supports passing in templates manually (meaning not using the pip installed ntc-templates directory to find templates) if desired. The textfsm_parse_output method and scrapli.helper.textfsm_parse function both accepts a string or loaded (TextIOWrapper ) template and output to parse. This can be useful if you have custom or one off templates or don't want to pip install ntc-templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver from scrapli.helper import textfsm_parse my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" ) structured_result = textfsm_parse ( \"/path/to/my/template\" , response . result ) NOTE : If a template does not return structured data an empty list will be returned! NOTE : Textfsm and ntc-templates is an optional extra for scrapli; you can install these modules manually or using the optional extras install via pip: pip install scrapli[textfsm] Cisco Genie Integration \u00b6 Very much the same as the textfsm/ntc-templates integration, scrapli has optional integration with Cisco's PyATS /Genie parsing library for parsing show command output. While there are parsers for non-Cisco platforms, this is currently just an option for Cisco platforms within scrapli. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" ) structured_result = response . genie_parse_output () print ( structured_result ) NOTE : If a parser does not return structured data an empty list will be returned! NOTE : PyATS and Genie is an optional extra for scrapli; you can install these modules manually or using the optional extras install via pip: pip install scrapli[genie] TTP Integration \u00b6 The scrapli response object also contains a ttp_parse_output method, that, as you may have guessed, uses the ttp library to parse output received from the device. Other than the obvious difference that this is in fact a different type of parser, the only difference from a usage perspective is that the ttp_parse_output method requires a template string, string path to a template, or loaded (TextIOWrapper ) template string to be passed. This is because there is no index or mapping of platform:command:template as there is with TextFSM/ntc-templates and genie. An example ttp file (slightly modified from the great ttp quickstart guide) - in this case we'll pretend this file is called \"my_template.ttp\": 1 2 3 interface {{ interface }} ip address {{ ip }} {{ mask }} description {{ description }} 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show run interface GigabitEthernet1\" ) structured_result = response . ttp_parse_output ( template = \"my_template.ttp\" ) print ( structured_result ) NOTE : If a parser does parse data, ttp will return an empty list (as with the other parser methods) NOTE : ttp is an optional extra for scrapli; you can install these modules manually or using the optional extras install via pip: pip install scrapli[ttp] Handling Prompts \u00b6 In some cases you may need to run an \"interactive\" command on your device. The send_interactive method of the GenericDriver or its sub-classes ( NetworkDriver and \"core\" drivers) can be used to accomplish this. This method accepts a list of \"interact_events\" -- or basically commands you would like to send, and their expected resulting prompt. A third, optional, element is available for each \"interaction\", this last element is a bool that indicates weather or not the input that you are sending to the device is \"hidden\" or obfuscated by the device. This is typically used for password prompts where the input that is sent does not show up on the screen (if you as a human are sitting on a terminal typing). This method can accept one or N \"events\" and thus can be used to deal with any number of subsequent prompts. One last important item about this method is that it accepts an argument privilege_level -- the value of this argument should be the name of the privilege level that you would like to execute the interactive command at . This is an optional argument, with a default of the default_desired_privilege_level attribute which is normally \"privilege exec\" or similar depending on the platform. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : interactive = conn . send_interactive ( [ ( \"copy flash: scp:\" , \"Source filename []?\" , False ), ( \"somefile.txt\" , \"Address or name of remote host []?\" , False ), ( \"172.31.254.100\" , \"Destination username [carl]?\" , False ), ( \"scrapli\" , \"Password:\" , False ), ( \"super_secure_password\" , \"csr1000v#\" , True ), ] ) Telnet \u00b6 scrapli supports telnet as a transport driver via the standard library module telnetlib or with a custom-built async telnet transport (creatively called \"asynctelnet\") built on the standard library asycnio . A few things worth noting: You can set the username and password prompt expect string after your connection object instantiation and before calling the open method -- this means if you have non-default prompts you cannot use scrapli with a context manager and Telnet (because the context manager calls open for you). You can set the prompts using the following attributes of the Channel (or AsyncChannel ) object: telnet_username_prompt which defaults to ^(.*username:)|(.*login:)\\s?$ telnet_password_prompt which defaults to ^password:\\s?$ You can set these values by updating the appropriate attribute, for example: conn.channel.telnet_username_prompt = \"somethingneat\" . If you wish to provide custom prompt values you can provide a string to look for \"in\" the output from the device, or a regular expression pattern that starts with ^ and ends with $ -- if you don't use the line anchors the pattern will be re.escape 'd. When using telnet you may need to set the comms_return_char to \\r\\n the tests against the core platforms pass without this, however it seems that some console server type devices are looking for this \\r\\n pattern instead of the default \\n pattern. SSH Config Support \u00b6 scrapli supports using OpenSSH configuration files in a few ways. For \"system\" SSH transport (default setting ), passing a path to a config file will simply make scrapli \"point\" to that file, and therefore use that configuration files attributes (because it is just exec'ing system SSH!). You can also pass True to let scrapli search in system default locations for a ssh config file ( ~/.ssh/config and /etc/ssh/ssh_config ). SSH transports other than \"system\" transport may support some subset of the OpenSSH configuration files, but will not provide full support. Asyncssh, for example, will automatically pick up and handle proxy-jumps, SSH keys, and some other items -- this is a 100% asyncssh feature and has nothing to do with scrapli (other than the fact that scrapli allows you to use asyncssh). NOTE -- scrapli does NOT disable strict host checking by default. Obviously this is the \"smart\" behavior, but it can be overridden on a per host basis in your SSH config file, or by passing False to the \"auth_strict_key \" argument on object instantiation. 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"ssh_config_file\" : \"~/my_ssh_config\" , } with IOSXEDriver ( ** my_device ) as conn : print ( conn . get_prompt ())","title":"Basic Usage"},{"location":"user_guide/basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"user_guide/basic_usage/#picking-the-right-driver","text":"Assuming you are using scrapli to connect to one of the five \"core\" platforms, you should almost always use the provided corresponding \"core\" driver. For example if you are connecting to an Arista EOS device, you should use the EOSDriver . You can select this driver \"manually\" or using the scrapli factory Scrapli (or the async scrapli factory AsyncScrapli ). Importing your driver manually looks like this: 1 from scrapli.driver.core import EOSDriver If you are using asyncio, you can use the async variant of the driver: 1 from scrapli.driver.core import AsyncEOSDriver The core drivers and associated platforms are outlined below: Platform/OS Scrapli Driver Scrapli Async Driver Platform Name Cisco IOS-XE IOSXEDriver AsyncIOSXEDriver cisco_iosxe Cisco NX-OS NXOSDriver AsyncNXOSDriver cisco_nxos Cisco IOS-XR IOSXRDriver AsyncIOSXRDriver cisco_iosxr Arista EOS EOSDriver AsyncEOSDriver arista_eos Juniper JunOS JunosDriver AsyncJunosDriver juniper_junos All drivers can be imported from scrapli.driver.core . If you would rather use the factory class to dynamically select the appropriate driver based on a platform string (as seen in the above table), you can do so as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli import Scrapli device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) conn . open () print ( conn . get_prompt ()) Note that the Scrapli and AsyncScrapli classes inherit from the NetworkDriver and AsyncNetworkDriver classes respectively, so all editor code completion and type indicating behavior should work nicely! For non \"core \" platforms please see the scrapli_community project . If you are working with a platform not listed above (and/or is not in the scrapli community project), you have three options: You can use the (base) Driver driver directly, which you can read about here You can use the GenericDriver which you can read about here You can use the NetworkDriver which is similar to option 2 but you will need to understand/provide privilege /prompt information so scrapli can properly escalate/deescalate to/from configuration (or other) modes. In general you should probably simply create a scrapli community platform (read about adding a platform here , but failing that the GenericDriver is probably the simplest path forward. Note: if you are using async you must set the transport to asyncssh or asynctelnet !","title":"Picking the right Driver"},{"location":"user_guide/basic_usage/#basic-driver-arguments","text":"The drivers of course need some information about the device you are trying to connect to. The most common arguments to provide to the driver are outlined below: Argument Purpose/Value host name/ip of host to connect to port port of host to connect to (defaults to port 22) auth_username username for authentication auth_password password for authentication auth_secondary password for secondary authentication (enable password) auth_private_key private key for authentication auth_strict_key strict key checking -- TRUE by default! ssh_config_file True/False or path to ssh config file to use These arguments may be passed as keyword arguments to the driver of your choice, or, commonly are passed via dictionary unpacking as show below: 1 2 3 4 5 6 7 8 9 10 11 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXRDriver ( ** my_device ) conn . open () NOTE that scrapli enables strict host key checking by default!","title":"Basic Driver Arguments"},{"location":"user_guide/basic_usage/#opening-and-closing-a-connection","text":"scrapli does not open the connection for you when creating your scrapli connection object in normal operations, you must manually call the open method prior to sending any commands to the device as shown below. 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXRDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXRDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show version\" ) Connections can be closed by calling the close method: 1 conn . close () scrapli also supports using a context manager ( with block), when using the context manager the connection will be automatically opened and closed for you. 1 2 3 4 5 6 7 8 9 10 11 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" )","title":"Opening and Closing a Connection"},{"location":"user_guide/basic_usage/#sending-commands","text":"When using any of the core network drivers ( JunosDriver , EOSDriver , etc.) or the GenericDriver , the send_command and send_commands methods will respectively send a single command or list of commands to the device. When using the core network drivers, the command(s) will be sent at the default_desired_privilege_level level which is typically \"privilege exec\" (or equivalent) privilege level. Please see Driver Privilege Levels in the advanced usage section for more details on privilege levels. As the GenericDriver doesn't know or care about privilege levels you would need to manually handle acquiring the appropriate privilege level for you command yourself if using that driver. Note the different methods for sending a single command versus a list of commands! 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXEDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show version\" ) responses = conn . send_commands ([ \"show run\" , \"show ip int brief\" ]) Finally, if you prefer to have a file containing a list of commands to send, there is a send_commands_from_file method . This method excepts the provided file to have a single command to send per line in the file.","title":"Sending Commands"},{"location":"user_guide/basic_usage/#response-object","text":"All command/config operations that happen in the GenericDriver or any of the drivers inheriting from the NetworkDriver result in a Response object being created. The Response object contains attributes for the command sent ( channel_input ), start/end/elapsed time, and of course the result of the command sent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXEDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show version\" ) print ( response . elapsed_time ) print ( response . result ) If using send_commands (plural!) then scrapli will return a MultiResponse object containing multiple Response objects. The MultiResponse object is for all intents and purposes just a list of Response objects (with a few very minor differences). In addition to containing the input and output of the command(s) that you sent, the Response object also contains a method textfsm_parse_output (for more on TextFSM support see Textfsm/NTC-Templates Integration ) which will attempt to parse and return the received output. If parsing fails, the value returned will be an empty list -- meaning you will always get \"structured data\" returned, however it will just be an empty object if parsing fails. 1 2 3 >>> structured_result = response . textfsm_parse_output () >>> print ( structured_result ) [[ '16.4.1' , 'IOS-XE' , 'csr1000v' , '2 days, 22 hours, 10 minutes' , 'reload' , 'packages.conf' , [ 'CSR1000V' ], [ '9FKLJWM5EB0' ], '0x2102' , []]]","title":"Response Object"},{"location":"user_guide/basic_usage/#sending-configurations","text":"When using any of the core drivers, you can send configurations via the send_config , send_configs or send_configs_from_file methods which will handle privilege escalation for you. send_config accepts a single string, send_configs accepts a list of strings, and of course send_configs_from_file accepts a string path to a file containing configurations to send. Note that send_configs_from_file -- just like with it's commands sibling -- will treat each line in the file as a configuration element, in this way it behaves much like send_configs . Lastly, it is good to know that send_config (singular!) will parse the configuration string provided and split it into lines -- this means that the underlying behavior is the same as send_configs , however this method returns a single Response object. This send_config method can be used to send entire configurations to devices in a reliable fashion. 1 2 3 4 5 6 7 8 9 10 11 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : conn . send_configs ([ \"interface loopback123\" , \"description configured by scrapli\" ]) If you need to get into any kind of \"special\" configuration mode, such as \"configure exclusive\", \"configure private \", or \"configure session XYZ\", you can pass the name of the corresponding privilege level via the privilege_level argument. Please see the Driver Privilege Levels section for more details! Lastly, note that scrapli does not exit configuration mode at completion of a \"configuration\" event -- this is because scrapli (with the Network drivers) will automatically acquire default_desired_privilege_level before sending a \"command\" -- so there is no need, from a scrapli perspective, to explicitly exit config mode at end of the configuration session.","title":"Sending Configurations"},{"location":"user_guide/basic_usage/#textfsmntc-templates-integration","text":"scrapli supports parsing output with TextFSM and ntc-templates. This of course requires installing TextFSM and having ntc-templates somewhere on your system. When using a platform driver (i.e. IOSXEDriver ) the textfsm-platform will be set for you (based on the driver device type). If you wish to parse the output of your send commands, you can use the textfsm_parse_output method of the response object. This method will attempt to find the template for you -- based on the textfsm-platform and the channel-input (the command sent). If textfsm parsing succeeds, the structured result is returned. If textfsm parsing fails, an empty list is returned. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" ) structured_result = response . textfsm_parse_output () print ( structured_result ) scrapli also supports passing in templates manually (meaning not using the pip installed ntc-templates directory to find templates) if desired. The textfsm_parse_output method and scrapli.helper.textfsm_parse function both accepts a string or loaded (TextIOWrapper ) template and output to parse. This can be useful if you have custom or one off templates or don't want to pip install ntc-templates. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver from scrapli.helper import textfsm_parse my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" ) structured_result = textfsm_parse ( \"/path/to/my/template\" , response . result ) NOTE : If a template does not return structured data an empty list will be returned! NOTE : Textfsm and ntc-templates is an optional extra for scrapli; you can install these modules manually or using the optional extras install via pip: pip install scrapli[textfsm]","title":"Textfsm/NTC-Templates Integration"},{"location":"user_guide/basic_usage/#cisco-genie-integration","text":"Very much the same as the textfsm/ntc-templates integration, scrapli has optional integration with Cisco's PyATS /Genie parsing library for parsing show command output. While there are parsers for non-Cisco platforms, this is currently just an option for Cisco platforms within scrapli. 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show version\" ) structured_result = response . genie_parse_output () print ( structured_result ) NOTE : If a parser does not return structured data an empty list will be returned! NOTE : PyATS and Genie is an optional extra for scrapli; you can install these modules manually or using the optional extras install via pip: pip install scrapli[genie]","title":"Cisco Genie Integration"},{"location":"user_guide/basic_usage/#ttp-integration","text":"The scrapli response object also contains a ttp_parse_output method, that, as you may have guessed, uses the ttp library to parse output received from the device. Other than the obvious difference that this is in fact a different type of parser, the only difference from a usage perspective is that the ttp_parse_output method requires a template string, string path to a template, or loaded (TextIOWrapper ) template string to be passed. This is because there is no index or mapping of platform:command:template as there is with TextFSM/ntc-templates and genie. An example ttp file (slightly modified from the great ttp quickstart guide) - in this case we'll pretend this file is called \"my_template.ttp\": 1 2 3 interface {{ interface }} ip address {{ ip }} {{ mask }} description {{ description }} 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : response = conn . send_command ( \"show run interface GigabitEthernet1\" ) structured_result = response . ttp_parse_output ( template = \"my_template.ttp\" ) print ( structured_result ) NOTE : If a parser does parse data, ttp will return an empty list (as with the other parser methods) NOTE : ttp is an optional extra for scrapli; you can install these modules manually or using the optional extras install via pip: pip install scrapli[ttp]","title":"TTP Integration"},{"location":"user_guide/basic_usage/#handling-prompts","text":"In some cases you may need to run an \"interactive\" command on your device. The send_interactive method of the GenericDriver or its sub-classes ( NetworkDriver and \"core\" drivers) can be used to accomplish this. This method accepts a list of \"interact_events\" -- or basically commands you would like to send, and their expected resulting prompt. A third, optional, element is available for each \"interaction\", this last element is a bool that indicates weather or not the input that you are sending to the device is \"hidden\" or obfuscated by the device. This is typically used for password prompts where the input that is sent does not show up on the screen (if you as a human are sitting on a terminal typing). This method can accept one or N \"events\" and thus can be used to deal with any number of subsequent prompts. One last important item about this method is that it accepts an argument privilege_level -- the value of this argument should be the name of the privilege level that you would like to execute the interactive command at . This is an optional argument, with a default of the default_desired_privilege_level attribute which is normally \"privilege exec\" or similar depending on the platform. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } with IOSXEDriver ( ** my_device ) as conn : interactive = conn . send_interactive ( [ ( \"copy flash: scp:\" , \"Source filename []?\" , False ), ( \"somefile.txt\" , \"Address or name of remote host []?\" , False ), ( \"172.31.254.100\" , \"Destination username [carl]?\" , False ), ( \"scrapli\" , \"Password:\" , False ), ( \"super_secure_password\" , \"csr1000v#\" , True ), ] )","title":"Handling Prompts"},{"location":"user_guide/basic_usage/#telnet","text":"scrapli supports telnet as a transport driver via the standard library module telnetlib or with a custom-built async telnet transport (creatively called \"asynctelnet\") built on the standard library asycnio . A few things worth noting: You can set the username and password prompt expect string after your connection object instantiation and before calling the open method -- this means if you have non-default prompts you cannot use scrapli with a context manager and Telnet (because the context manager calls open for you). You can set the prompts using the following attributes of the Channel (or AsyncChannel ) object: telnet_username_prompt which defaults to ^(.*username:)|(.*login:)\\s?$ telnet_password_prompt which defaults to ^password:\\s?$ You can set these values by updating the appropriate attribute, for example: conn.channel.telnet_username_prompt = \"somethingneat\" . If you wish to provide custom prompt values you can provide a string to look for \"in\" the output from the device, or a regular expression pattern that starts with ^ and ends with $ -- if you don't use the line anchors the pattern will be re.escape 'd. When using telnet you may need to set the comms_return_char to \\r\\n the tests against the core platforms pass without this, however it seems that some console server type devices are looking for this \\r\\n pattern instead of the default \\n pattern.","title":"Telnet"},{"location":"user_guide/basic_usage/#ssh-config-support","text":"scrapli supports using OpenSSH configuration files in a few ways. For \"system\" SSH transport (default setting ), passing a path to a config file will simply make scrapli \"point\" to that file, and therefore use that configuration files attributes (because it is just exec'ing system SSH!). You can also pass True to let scrapli search in system default locations for a ssh config file ( ~/.ssh/config and /etc/ssh/ssh_config ). SSH transports other than \"system\" transport may support some subset of the OpenSSH configuration files, but will not provide full support. Asyncssh, for example, will automatically pick up and handle proxy-jumps, SSH keys, and some other items -- this is a 100% asyncssh feature and has nothing to do with scrapli (other than the fact that scrapli allows you to use asyncssh). NOTE -- scrapli does NOT disable strict host checking by default. Obviously this is the \"smart\" behavior, but it can be overridden on a per host basis in your SSH config file, or by passing False to the \"auth_strict_key \" argument on object instantiation. 1 2 3 4 5 6 7 8 9 10 11 12 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , \"ssh_config_file\" : \"~/my_ssh_config\" , } with IOSXEDriver ( ** my_device ) as conn : print ( conn . get_prompt ())","title":"SSH Config Support"},{"location":"user_guide/faq/","text":"FAQ \u00b6 Question: Why build this? Answer: I built ssh2net to learn -- to have a goal/target for writing some code. scrapli is an evolution of the lessons learned building ssh2net. About mid-way through building ssh2net I realized it may actually be kinda good at doing... stuff. So, sure there are other tools out there, but I think scrapli its pretty snazzy and fills in some of the gaps in other tools. For example scrapli is 100% compliant with strict mypy type checking, very uniformly documented/linted, contains a results object for every operation, is very very fast, is very flexible, and in general pretty awesome! Finally, while I think in general that SSH \"screen scraping\" is not \"sexy\" or even \"good\", it is the lowest common denominator for automation in the networking world. So I figured I could try to make the fastest, most flexible library around for SSH network automation! Question: Is this better than XYZ? Answer: Nope! It is different though! The main focus is just to be stupid fast. It is very much that. It should be super reliable too as the timeouts are very easy/obvious to control, and it should also be very very very easy to adapt to any other network-y type CLI by virtue of flexible prompt finding and easily modifiable on connect functions. I wanna go fast! Hmmm... not a question but I dig it. If you wanna go fast you gotta learn to drive with the fear... ok, enough Talladega Nights quoting for now. In theory using the ssh2 transport is the gateway to speed... being a very thin wrapper around libssh2 means that its basically all C and that means its probably about as fast as we're reasonably going to get. All that said, scrapli by default uses the system transport which is really just using your system ssh.... which is almost certainly libssh2/openssh which is also C. There is a thin layer of abstraction between scrapli and your system ssh but really its just reading/writing to a file which Python should be doing in C anyway I would think. In summary... while ssh2 is probably the fastest you can go with scrapli, the difference between ssh2 and system transports in limited testing is very small, and the benefits of using system transport (native ssh config file support!!) probably should outweigh the speed of ssh2 -- especially if you have control persist and can take advantage of that with system transport! Hey does this thing do SCP? Nope! But the very cool @viktorkertesz has created scrapli_scp which you should defo check out if you wanna do SCP things! Other questions? Ask away!","title":"FAQ"},{"location":"user_guide/faq/#faq","text":"Question: Why build this? Answer: I built ssh2net to learn -- to have a goal/target for writing some code. scrapli is an evolution of the lessons learned building ssh2net. About mid-way through building ssh2net I realized it may actually be kinda good at doing... stuff. So, sure there are other tools out there, but I think scrapli its pretty snazzy and fills in some of the gaps in other tools. For example scrapli is 100% compliant with strict mypy type checking, very uniformly documented/linted, contains a results object for every operation, is very very fast, is very flexible, and in general pretty awesome! Finally, while I think in general that SSH \"screen scraping\" is not \"sexy\" or even \"good\", it is the lowest common denominator for automation in the networking world. So I figured I could try to make the fastest, most flexible library around for SSH network automation! Question: Is this better than XYZ? Answer: Nope! It is different though! The main focus is just to be stupid fast. It is very much that. It should be super reliable too as the timeouts are very easy/obvious to control, and it should also be very very very easy to adapt to any other network-y type CLI by virtue of flexible prompt finding and easily modifiable on connect functions. I wanna go fast! Hmmm... not a question but I dig it. If you wanna go fast you gotta learn to drive with the fear... ok, enough Talladega Nights quoting for now. In theory using the ssh2 transport is the gateway to speed... being a very thin wrapper around libssh2 means that its basically all C and that means its probably about as fast as we're reasonably going to get. All that said, scrapli by default uses the system transport which is really just using your system ssh.... which is almost certainly libssh2/openssh which is also C. There is a thin layer of abstraction between scrapli and your system ssh but really its just reading/writing to a file which Python should be doing in C anyway I would think. In summary... while ssh2 is probably the fastest you can go with scrapli, the difference between ssh2 and system transports in limited testing is very small, and the benefits of using system transport (native ssh config file support!!) probably should outweigh the speed of ssh2 -- especially if you have control persist and can take advantage of that with system transport! Hey does this thing do SCP? Nope! But the very cool @viktorkertesz has created scrapli_scp which you should defo check out if you wanna do SCP things! Other questions? Ask away!","title":"FAQ"},{"location":"user_guide/installation/","text":"Installation \u00b6 Standard Installation \u00b6 As outlined in the quick start, you should be able to pip install scrapli \"normally\": 1 pip install scrapli Installing current main branch \u00b6 To install from the source repositories master branch: 1 pip install git+https://github.com/carlmontanari/scrapli Installing a different branch \u00b6 To install from a different branch of the source repository, for example from a branch named develop : 1 pip install -e git+https://github.com/carlmontanari/scrapli.git@develop#egg=scrapli Installation from Source \u00b6 To install from source: 1 2 3 git clone https://github.com/carlmontanari/scrapli cd scrapli python setup.py install Optional Extras \u00b6 scrapli has made an effort to have as few dependencies as possible -- in fact to have ZERO dependencies! The \"core\" of scrapli can run with nothing other than standard library! If for any reason you wish to use paramiko, ssh2-python, or asyncssh as a transport, however, you of course need to install those. These \"extras\" can be installed via pip: 1 pip install scrapli[paramiko] The available optional installation extras options are: paramiko ssh2 asyncssh textfsm (textfsm and ntc-templates) ttp (ttp template parser) genie (genie/pyats) netconf (scrapli_netconf) community (scrapli_community) If you would like to install all optional extras, you can do so with the full option: 1 pip install scrapli[full] Supported Platforms \u00b6 As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Installation"},{"location":"user_guide/installation/#installation","text":"","title":"Installation"},{"location":"user_guide/installation/#standard-installation","text":"As outlined in the quick start, you should be able to pip install scrapli \"normally\": 1 pip install scrapli","title":"Standard Installation"},{"location":"user_guide/installation/#installing-current-main-branch","text":"To install from the source repositories master branch: 1 pip install git+https://github.com/carlmontanari/scrapli","title":"Installing current main branch"},{"location":"user_guide/installation/#installing-a-different-branch","text":"To install from a different branch of the source repository, for example from a branch named develop : 1 pip install -e git+https://github.com/carlmontanari/scrapli.git@develop#egg=scrapli","title":"Installing a different branch"},{"location":"user_guide/installation/#installation-from-source","text":"To install from source: 1 2 3 git clone https://github.com/carlmontanari/scrapli cd scrapli python setup.py install","title":"Installation from Source"},{"location":"user_guide/installation/#optional-extras","text":"scrapli has made an effort to have as few dependencies as possible -- in fact to have ZERO dependencies! The \"core\" of scrapli can run with nothing other than standard library! If for any reason you wish to use paramiko, ssh2-python, or asyncssh as a transport, however, you of course need to install those. These \"extras\" can be installed via pip: 1 pip install scrapli[paramiko] The available optional installation extras options are: paramiko ssh2 asyncssh textfsm (textfsm and ntc-templates) ttp (ttp template parser) genie (genie/pyats) netconf (scrapli_netconf) community (scrapli_community) If you would like to install all optional extras, you can do so with the full option: 1 pip install scrapli[full]","title":"Optional Extras"},{"location":"user_guide/installation/#supported-platforms","text":"As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Supported Platforms"},{"location":"user_guide/linting_testing/","text":"Linting and Testing \u00b6 Linting \u00b6 This project uses black for auto-formatting. In addition to black, nox will execute pylama , and pydocstyle for linting purposes . Nox will also run mypy , with strict type checking. Docstring linting is handled by darglint which has been quite handy! All commits to this repository will trigger a GitHub action which runs nox, but of course its nicer to just run that before making a commit to ensure that it will pass all tests! Typing \u00b6 As stated, this project is 100% type checked and will remain that way. The value this adds for IDE auto-completion and just general sanity checking/forcing writing of more type-check-able code is worth the small overhead in effort. Testing \u00b6 Testing is broken into three main categories -- unit, integration, and functional. Unit is what you would expect -- unit testing the code. Integration tests run scrapli against auto generated ssh server that looks/feels like real network devices. Functional testing connects to virtual devices in order to more accurately test the code. Unit tests cover quite a bit of the code base due to lots of patching low level things to ensure code paths go where they should go. This gives a pretty high level of confidence that at least object instantiation and channel read/writes will generally work! Functional tests against virtual devices provide a much higher guarantee of things working as they should, and are reproducible by end users to boot! Unit Tests \u00b6 Unit tests can be executed via pytest: 1 python -m pytest tests/unit/ Or using the following make command: 1 make test_unit If you would like to see the coverage report and generate the html coverage report: 1 make cov_unit Setting up Functional Test Environment \u00b6 In order to try to be as consistent as possible when running functional testing, we rely on the very awesome containerlab project. Containerlab allows us to have a reliable and consistent testing environment and spin it up easily on any linux host (with nested virtualization capabilities). You can see the containerlab topology file in the .clab directory at the root of scrapli. The topology file in this directory outlines the container images that containerlab requires in order to spin up the topology. Unfortunately, networking vendors suck at giving us free and easy access to container images for testing (notable exception of Nokia and SR-Linux, so shout out to them!), so you are going to need to bring your own images to use. For the Arista EOS platform, you can simply create an account on the Arista website and download the cEOS container image and import it into docker. The other platforms all require you to obtain a Qcow2 disk image of the platform, and to use the boxen project to convert the disk image into a container image that containerlab can launch. The containerlab topology file indicates the version of the platforms the testing suite expects -- other versions may be fine, but try to stick to the versions here if you can so tests run exactly as expected! Once you have the Qcow files in hand, you can use boxen to build the container image -- please check out the boxen docs for how to do this. If you elect to run tests with boxen only (in \"local\" mode -- not described here, but should be straight forward enough) and not use containerlab - set the SCRAPLI_HOST_FWD environment variable to some non-empty string; this will force scrapli to connect to localhost on the ports described below rather than the clab specified (bridged) IP addresses: Device Local Port iosxe 21022 iosxr 22022 nxos 23022 eos 24022 junos 25022 Deploying/Destroying Containerlab Test Environment \u00b6 Once you have created the images, you can start containerlab with a make command: 1 make deploy_clab Conversely, you can terminate the containers: 1 make destroy_clab Ensuring Base Test Configs \u00b6 To ensure that the base test configs are enforced, run the prepare_dev_env make directive, this uses scrapli-cfg to load and replace the configurations running on these devices. This will do things like ensure telnet is enabled (which is not the case by default for most platforms in clab/boxen), etc.. Running Functional Tests \u00b6 To run functional tests you can simply use the make directive: make test_functional If you are adding tests and/or need to \"regenerate\" the expected output, you can use the --update flag like: python -m pytest tests/functional --update This flag causes the test suite to capture the output and write it into the expected directory. This expected output is then compared to the \"real\" output we get from the device during subsequent tests. Other Functional Test Info \u00b6 IOSXE is the only platform that is testing SSH key based authentication at the moment. The key is pushed via NAPALM in the setup phase. This was mostly done out of laziness, and in the future the other platforms may be tested with key based auth as well, but for now IOSXE is representative enough to provide some faith that key based auth works!","title":"Linting and Testing"},{"location":"user_guide/linting_testing/#linting-and-testing","text":"","title":"Linting and Testing"},{"location":"user_guide/linting_testing/#linting","text":"This project uses black for auto-formatting. In addition to black, nox will execute pylama , and pydocstyle for linting purposes . Nox will also run mypy , with strict type checking. Docstring linting is handled by darglint which has been quite handy! All commits to this repository will trigger a GitHub action which runs nox, but of course its nicer to just run that before making a commit to ensure that it will pass all tests!","title":"Linting"},{"location":"user_guide/linting_testing/#typing","text":"As stated, this project is 100% type checked and will remain that way. The value this adds for IDE auto-completion and just general sanity checking/forcing writing of more type-check-able code is worth the small overhead in effort.","title":"Typing"},{"location":"user_guide/linting_testing/#testing","text":"Testing is broken into three main categories -- unit, integration, and functional. Unit is what you would expect -- unit testing the code. Integration tests run scrapli against auto generated ssh server that looks/feels like real network devices. Functional testing connects to virtual devices in order to more accurately test the code. Unit tests cover quite a bit of the code base due to lots of patching low level things to ensure code paths go where they should go. This gives a pretty high level of confidence that at least object instantiation and channel read/writes will generally work! Functional tests against virtual devices provide a much higher guarantee of things working as they should, and are reproducible by end users to boot!","title":"Testing"},{"location":"user_guide/linting_testing/#unit-tests","text":"Unit tests can be executed via pytest: 1 python -m pytest tests/unit/ Or using the following make command: 1 make test_unit If you would like to see the coverage report and generate the html coverage report: 1 make cov_unit","title":"Unit Tests"},{"location":"user_guide/linting_testing/#setting-up-functional-test-environment","text":"In order to try to be as consistent as possible when running functional testing, we rely on the very awesome containerlab project. Containerlab allows us to have a reliable and consistent testing environment and spin it up easily on any linux host (with nested virtualization capabilities). You can see the containerlab topology file in the .clab directory at the root of scrapli. The topology file in this directory outlines the container images that containerlab requires in order to spin up the topology. Unfortunately, networking vendors suck at giving us free and easy access to container images for testing (notable exception of Nokia and SR-Linux, so shout out to them!), so you are going to need to bring your own images to use. For the Arista EOS platform, you can simply create an account on the Arista website and download the cEOS container image and import it into docker. The other platforms all require you to obtain a Qcow2 disk image of the platform, and to use the boxen project to convert the disk image into a container image that containerlab can launch. The containerlab topology file indicates the version of the platforms the testing suite expects -- other versions may be fine, but try to stick to the versions here if you can so tests run exactly as expected! Once you have the Qcow files in hand, you can use boxen to build the container image -- please check out the boxen docs for how to do this. If you elect to run tests with boxen only (in \"local\" mode -- not described here, but should be straight forward enough) and not use containerlab - set the SCRAPLI_HOST_FWD environment variable to some non-empty string; this will force scrapli to connect to localhost on the ports described below rather than the clab specified (bridged) IP addresses: Device Local Port iosxe 21022 iosxr 22022 nxos 23022 eos 24022 junos 25022","title":"Setting up Functional Test Environment"},{"location":"user_guide/linting_testing/#deployingdestroying-containerlab-test-environment","text":"Once you have created the images, you can start containerlab with a make command: 1 make deploy_clab Conversely, you can terminate the containers: 1 make destroy_clab","title":"Deploying/Destroying Containerlab Test Environment"},{"location":"user_guide/linting_testing/#ensuring-base-test-configs","text":"To ensure that the base test configs are enforced, run the prepare_dev_env make directive, this uses scrapli-cfg to load and replace the configurations running on these devices. This will do things like ensure telnet is enabled (which is not the case by default for most platforms in clab/boxen), etc..","title":"Ensuring Base Test Configs"},{"location":"user_guide/linting_testing/#running-functional-tests","text":"To run functional tests you can simply use the make directive: make test_functional If you are adding tests and/or need to \"regenerate\" the expected output, you can use the --update flag like: python -m pytest tests/functional --update This flag causes the test suite to capture the output and write it into the expected directory. This expected output is then compared to the \"real\" output we get from the device during subsequent tests.","title":"Running Functional Tests"},{"location":"user_guide/linting_testing/#other-functional-test-info","text":"IOSXE is the only platform that is testing SSH key based authentication at the moment. The key is pushed via NAPALM in the setup phase. This was mostly done out of laziness, and in the future the other platforms may be tested with key based auth as well, but for now IOSXE is representative enough to provide some faith that key based auth works!","title":"Other Functional Test Info"},{"location":"user_guide/project_details/","text":"Project Details \u00b6 What is scrapli \u00b6 scrapli is a python library focused on connecting to devices, specifically network devices via Telnet, SSH or NETCONF. scrapli is built primarily in three parts: transport, channel, and driver. The transport layer is responsible for providing a file-like interface to the target server. The channel layer is responsible for reading and writing to the provided file-like interface. Finally, the driver provides the user facing API/interface to scrapli. There are six available \"transports\" in scrapli \"core\" -- all of which inherit from a base transport classes and provide the same file-like interface to the upstream channel. Transports \u00b6 The available transport plugins are: system -- wrapper around OpenSSH/System available SSH binary telnet -- Python standard library telnetlib asynctelnet -- Python standard library asyncio stream asyncssh -- wrapper around asyncssh library ssh2 -- wrapper around ssh2-python library paramiko -- wrapper around paramiko library A good question to ask at this point is probably \"why?\". Why multiple transport options? Why not just use paramiko like most folks do? Historically the reason for moving away from paramiko was simply speed. ssh2-python is a wrapper around the libssh2 C library, and as such is very, very fast. In a prior project ( ssh2net ), of which scrapli is the successor/evolution, ssh2-python was used with great success, however, it is a bit feature-limited, and development had stalled around the same time scrapli was getting going. This led to moving back to paramiko, which of course is a fantastic project with tons and tons of feature support . Paramiko, however, does not provide \"direct\" OpenSSH support (as in -- auto-magically like when you ssh on your normal shell), and I don't believe it provides 100% full OpenSSH support either (ex: ControlPersist). Fully supporting an OpenSSH config file would be an ideal end goal for scrapli, something that may not be possible with Paramiko - ControlPersist in particular is very interesting to me. With the goal of supporting all OpenSSH configuration options the primary transport driver option is simply native system local SSH. The implementation of using system SSH is of course a little bit messy, however scrapli takes care of that for you so you don't need to care about it! The payoff of using system SSH is of course that OpenSSH config files simply \"work\" -- no passing it to scrapli, no selective support, no need to set username or ports or any of the other config items that may reside in your SSH config file. This driver will likely be the focus of most development for this project, though I will try to keep the other transport drivers -- in particular asyncssh -- as close to parity as is possible/practical. Adding telnet support via telnetlib was trivial, as the interface is basically the same as SystemSSH, and it turns out telnet is still actually useful for things like terminal servers and the like! Next, perhaps the most interesting scrapli transport plugin is the asyncssh transport. This transport option represented a very big change for scrapli as the entire \"backend\" was basically re-worked in order to provide the exact same API for both synchronous and asynchronous applications. Lastly, the asynctelnet transport is the latest (and perhaps last?!) transport plugin. This transport plugin was built with only the python standard library (just like system/telnet) and as such it is part of scrapli \"core\". Channel \u00b6 The \"channel\" sits between the transports and the drivers -- the channel is where much of the magic happens! The channel is responsible for all prompt finding, sending commands or configs, and generally interacting with the device. The channel essentially reads from and writes to the underlying transport for a given connection. The Channel doesn't need to know or care about which transport you pick! (except of course to know if it is async or synchronous) Drivers \u00b6 The final piece of scrapli is the actual \"driver\" -- or the component that binds the transport and channel together and deals with instantiation of a scrapli object. There is a \"base\" driver object -- Driver -- which provides essentially a \"raw\" SSH (or telnet) connection that is created by instantiating a Transport object, and a Channel object . Drive provides (via Channel) read/write methods and not much else -- this should feel familiar if you have used paramiko in the past. More specific \"drivers\" can inherit from this class to extend functionality of the driver to make it more friendly for network devices. In fact, there is a GenericDriver class that inherits from Scrape and provides a base driver to work with if you need to interact with a device not represented by one of the \"core\" drivers. Next, the NetworkDriver class inherits from GenericDriver . The NetworkDriver isn't really meant to be used directly though, but to be further extended and built upon instead. As this library is focused on interacting with network devices, an example scrapli driver (built on the NetworkDriver ) would be the IOSXEDriver -- to, as you may have guessed , interact with devices running Cisco's IOS-XE operating system. It should be noted that this is a bit of an oversimplification of the architecture of scrapli, but it is accurate . Scrapli has \"base\", \"sync\", and \"async\" versions of the core components. The \"base\" portion is made up of mixin classes that get \"mixed in\" to the sync or async versions of the component. For example there is a NetworkDriverBase class that is \"mixed in\" to the NetworkDriver and AsyncNetworkDriver classes. The mixin provides consistent helper like functions (sync functions) that can be used by the two driver classes -- this allows the sync/async components to have as little code as possible helping to keep the API consistent for both synchronous and asynchronous users. Supported Platforms \u00b6 scrapli \"core\" drivers cover basically the NAPALM platforms -- Cisco IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS. These drivers provide an interface tailored to network device \"screen-scraping\" rather than just a generic SSH connection/channel. It is important to note that there is a synchronous and an asynchronous version of each of these drivers. Below are the core driver platforms and regularly tested version. Cisco IOS-XE (tested on: 16.12.03) Cisco NX-OS (tested on: 9.2.4) Juniper JunOS (tested on: 17.3R2.10) Cisco IOS-XR (tested on: 6.5.3) Arista EOS (tested on: 4.22.1F) It is unlikely that any additional \"core\" platforms would be added, however the scrapli_community project is available for users to contribute any other platforms they would like to see scrapli support! Please see the scrapli_community project to check out what community platforms exist! The \"driver\" pattern is pretty much exactly like the implementation in NAPALM. The driver extends the base class ( Scrape ) and the base networking driver class ( NetworkDriver ) with device specific functionality such as privilege escalation/de-escalation, setting appropriate prompts to search for, and picking out appropriate ntc templates for use with TextFSM, and so on. All of this is focused on network device type Telnet/SSH cli interfaces, but should work on pretty much any SSH connection (though there are almost certainly better options for non-network type devices!). The \"base\" ( Driver ) and GenericDriver connections do not handle any kind of device-specific operations such as privilege escalation or saving configurations, they are simply intended to be a bare-bones connection that can interact with nearly any device/platform if you are willing to send/parse inputs/outputs manually. In most cases it is assumed that users will use one of the \"core\" drivers. The goal for all \"core\" devices will be to include functional tests that can run against vrnetlab containers to ensure that the \"core\" devices are as thoroughly tested as is practical. Related Scrapli Libraries \u00b6 This repo is the \"main\" or \"core\" scrapli project, however there are other libraries/repos in the scrapli family -- here is a list/link to all of the other scrapli things! nornir_scrapli scrapli_community scrapli_cfg scrapli_replay scrapli_netconf","title":"Project Details"},{"location":"user_guide/project_details/#project-details","text":"","title":"Project Details"},{"location":"user_guide/project_details/#what-is-scrapli","text":"scrapli is a python library focused on connecting to devices, specifically network devices via Telnet, SSH or NETCONF. scrapli is built primarily in three parts: transport, channel, and driver. The transport layer is responsible for providing a file-like interface to the target server. The channel layer is responsible for reading and writing to the provided file-like interface. Finally, the driver provides the user facing API/interface to scrapli. There are six available \"transports\" in scrapli \"core\" -- all of which inherit from a base transport classes and provide the same file-like interface to the upstream channel.","title":"What is scrapli"},{"location":"user_guide/project_details/#transports","text":"The available transport plugins are: system -- wrapper around OpenSSH/System available SSH binary telnet -- Python standard library telnetlib asynctelnet -- Python standard library asyncio stream asyncssh -- wrapper around asyncssh library ssh2 -- wrapper around ssh2-python library paramiko -- wrapper around paramiko library A good question to ask at this point is probably \"why?\". Why multiple transport options? Why not just use paramiko like most folks do? Historically the reason for moving away from paramiko was simply speed. ssh2-python is a wrapper around the libssh2 C library, and as such is very, very fast. In a prior project ( ssh2net ), of which scrapli is the successor/evolution, ssh2-python was used with great success, however, it is a bit feature-limited, and development had stalled around the same time scrapli was getting going. This led to moving back to paramiko, which of course is a fantastic project with tons and tons of feature support . Paramiko, however, does not provide \"direct\" OpenSSH support (as in -- auto-magically like when you ssh on your normal shell), and I don't believe it provides 100% full OpenSSH support either (ex: ControlPersist). Fully supporting an OpenSSH config file would be an ideal end goal for scrapli, something that may not be possible with Paramiko - ControlPersist in particular is very interesting to me. With the goal of supporting all OpenSSH configuration options the primary transport driver option is simply native system local SSH. The implementation of using system SSH is of course a little bit messy, however scrapli takes care of that for you so you don't need to care about it! The payoff of using system SSH is of course that OpenSSH config files simply \"work\" -- no passing it to scrapli, no selective support, no need to set username or ports or any of the other config items that may reside in your SSH config file. This driver will likely be the focus of most development for this project, though I will try to keep the other transport drivers -- in particular asyncssh -- as close to parity as is possible/practical. Adding telnet support via telnetlib was trivial, as the interface is basically the same as SystemSSH, and it turns out telnet is still actually useful for things like terminal servers and the like! Next, perhaps the most interesting scrapli transport plugin is the asyncssh transport. This transport option represented a very big change for scrapli as the entire \"backend\" was basically re-worked in order to provide the exact same API for both synchronous and asynchronous applications. Lastly, the asynctelnet transport is the latest (and perhaps last?!) transport plugin. This transport plugin was built with only the python standard library (just like system/telnet) and as such it is part of scrapli \"core\".","title":"Transports"},{"location":"user_guide/project_details/#channel","text":"The \"channel\" sits between the transports and the drivers -- the channel is where much of the magic happens! The channel is responsible for all prompt finding, sending commands or configs, and generally interacting with the device. The channel essentially reads from and writes to the underlying transport for a given connection. The Channel doesn't need to know or care about which transport you pick! (except of course to know if it is async or synchronous)","title":"Channel"},{"location":"user_guide/project_details/#drivers","text":"The final piece of scrapli is the actual \"driver\" -- or the component that binds the transport and channel together and deals with instantiation of a scrapli object. There is a \"base\" driver object -- Driver -- which provides essentially a \"raw\" SSH (or telnet) connection that is created by instantiating a Transport object, and a Channel object . Drive provides (via Channel) read/write methods and not much else -- this should feel familiar if you have used paramiko in the past. More specific \"drivers\" can inherit from this class to extend functionality of the driver to make it more friendly for network devices. In fact, there is a GenericDriver class that inherits from Scrape and provides a base driver to work with if you need to interact with a device not represented by one of the \"core\" drivers. Next, the NetworkDriver class inherits from GenericDriver . The NetworkDriver isn't really meant to be used directly though, but to be further extended and built upon instead. As this library is focused on interacting with network devices, an example scrapli driver (built on the NetworkDriver ) would be the IOSXEDriver -- to, as you may have guessed , interact with devices running Cisco's IOS-XE operating system. It should be noted that this is a bit of an oversimplification of the architecture of scrapli, but it is accurate . Scrapli has \"base\", \"sync\", and \"async\" versions of the core components. The \"base\" portion is made up of mixin classes that get \"mixed in\" to the sync or async versions of the component. For example there is a NetworkDriverBase class that is \"mixed in\" to the NetworkDriver and AsyncNetworkDriver classes. The mixin provides consistent helper like functions (sync functions) that can be used by the two driver classes -- this allows the sync/async components to have as little code as possible helping to keep the API consistent for both synchronous and asynchronous users.","title":"Drivers"},{"location":"user_guide/project_details/#supported-platforms","text":"scrapli \"core\" drivers cover basically the NAPALM platforms -- Cisco IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS. These drivers provide an interface tailored to network device \"screen-scraping\" rather than just a generic SSH connection/channel. It is important to note that there is a synchronous and an asynchronous version of each of these drivers. Below are the core driver platforms and regularly tested version. Cisco IOS-XE (tested on: 16.12.03) Cisco NX-OS (tested on: 9.2.4) Juniper JunOS (tested on: 17.3R2.10) Cisco IOS-XR (tested on: 6.5.3) Arista EOS (tested on: 4.22.1F) It is unlikely that any additional \"core\" platforms would be added, however the scrapli_community project is available for users to contribute any other platforms they would like to see scrapli support! Please see the scrapli_community project to check out what community platforms exist! The \"driver\" pattern is pretty much exactly like the implementation in NAPALM. The driver extends the base class ( Scrape ) and the base networking driver class ( NetworkDriver ) with device specific functionality such as privilege escalation/de-escalation, setting appropriate prompts to search for, and picking out appropriate ntc templates for use with TextFSM, and so on. All of this is focused on network device type Telnet/SSH cli interfaces, but should work on pretty much any SSH connection (though there are almost certainly better options for non-network type devices!). The \"base\" ( Driver ) and GenericDriver connections do not handle any kind of device-specific operations such as privilege escalation or saving configurations, they are simply intended to be a bare-bones connection that can interact with nearly any device/platform if you are willing to send/parse inputs/outputs manually. In most cases it is assumed that users will use one of the \"core\" drivers. The goal for all \"core\" devices will be to include functional tests that can run against vrnetlab containers to ensure that the \"core\" devices are as thoroughly tested as is practical.","title":"Supported Platforms"},{"location":"user_guide/project_details/#related-scrapli-libraries","text":"This repo is the \"main\" or \"core\" scrapli project, however there are other libraries/repos in the scrapli family -- here is a list/link to all of the other scrapli things! nornir_scrapli scrapli_community scrapli_cfg scrapli_replay scrapli_netconf","title":"Related Scrapli Libraries"},{"location":"user_guide/quickstart/","text":"Quick Start Guide \u00b6 Installation \u00b6 In most cases installation via pip is the simplest and best way to install scrapli. See here for advanced installation details. 1 pip install scrapli A Simple Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXEDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show run\" ) print ( response . result ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ python my_scrapli_script.py Building configuration... Current configuration : 7584 bytes ! ! Last configuration change at 19:24:38 PST Sat Feb 29 2020 by carl ! NVRAM config last updated at 19:00:28 PST Fri Feb 7 2020 by carl ! version 15.2 service nagle no service pad service tcp-keepalives-in service tcp-keepalives-out service timestamps debug datetime msec no service password-encryption ! <SNIP> ! end More Examples \u00b6 Basic \"native\" Scrape operations Basic \"GenericDriver\" operations Basic \"core\" Driver operations Basic async operations Async multiple connections Setting up basic logging Using SSH Key for authentication Using SSH config file Parse output with TextFSM/ntc-templates Parse output with Genie Transport Options Configuration Modes - IOSXR Configure Exclusive Configuration Modes - EOS Configure Session Banners, Macros, and other \"weird\" Things Other Stuff \u00b6 Other scrapli related docs/blogs/videos/info: Scrapli on Dmitry Figol's Network Automation Channel Scrapli Intro on Wim Wauter's blog Scrapli on the Packet Pushers Heavy Networking Podcast IPvZero's Network Automation Course (including scrapli!) on CBT Nuggets (paid resource) Rick Donato's Scrapli Course (paid resource)","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#installation","text":"In most cases installation via pip is the simplest and best way to install scrapli. See here for advanced installation details. 1 pip install scrapli","title":"Installation"},{"location":"user_guide/quickstart/#a-simple-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 from scrapli.driver.core import IOSXEDriver my_device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"scrapli\" , \"auth_password\" : \"scrapli\" , \"auth_strict_key\" : False , } conn = IOSXEDriver ( ** my_device ) conn . open () response = conn . send_command ( \"show run\" ) print ( response . result ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ python my_scrapli_script.py Building configuration... Current configuration : 7584 bytes ! ! Last configuration change at 19:24:38 PST Sat Feb 29 2020 by carl ! NVRAM config last updated at 19:00:28 PST Fri Feb 7 2020 by carl ! version 15.2 service nagle no service pad service tcp-keepalives-in service tcp-keepalives-out service timestamps debug datetime msec no service password-encryption ! <SNIP> ! end","title":"A Simple Example"},{"location":"user_guide/quickstart/#more-examples","text":"Basic \"native\" Scrape operations Basic \"GenericDriver\" operations Basic \"core\" Driver operations Basic async operations Async multiple connections Setting up basic logging Using SSH Key for authentication Using SSH config file Parse output with TextFSM/ntc-templates Parse output with Genie Transport Options Configuration Modes - IOSXR Configure Exclusive Configuration Modes - EOS Configure Session Banners, Macros, and other \"weird\" Things","title":"More Examples"},{"location":"user_guide/quickstart/#other-stuff","text":"Other scrapli related docs/blogs/videos/info: Scrapli on Dmitry Figol's Network Automation Channel Scrapli Intro on Wim Wauter's blog Scrapli on the Packet Pushers Heavy Networking Podcast IPvZero's Network Automation Course (including scrapli!) on CBT Nuggets (paid resource) Rick Donato's Scrapli Course (paid resource)","title":"Other Stuff"},{"location":"user_guide/versioning/","text":"Versioning \u00b6 scrapli, and all scrapli related projects use CalVer versioning standard. All release versions follow the format YYYY.MM.DD , however PyPi will shorten/standardize this to remove leading zeros. The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has been very stable -- there are only so many things you can/need to do over SSH after all! Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch while updates are happening), and the \"public\" API is documented here , and includes the date/version of each public method's creation as well as the latest updated/modified date and any relevant notes. A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs -- you can \"watch\" this repository to ensure you are notified of any releases.","title":"Versioning"},{"location":"user_guide/versioning/#versioning","text":"scrapli, and all scrapli related projects use CalVer versioning standard. All release versions follow the format YYYY.MM.DD , however PyPi will shorten/standardize this to remove leading zeros. The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has been very stable -- there are only so many things you can/need to do over SSH after all! Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch while updates are happening), and the \"public\" API is documented here , and includes the date/version of each public method's creation as well as the latest updated/modified date and any relevant notes. A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs -- you can \"watch\" this repository to ensure you are notified of any releases.","title":"Versioning"}]}